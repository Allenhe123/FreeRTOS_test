
c1200_soc_r5.elf:     file format elf32-littlearm


Disassembly of section .privileged_functions:

05100000 <__FLASH_segment_start__>:
/*.extern FreeRTOS_SWI_Handler*/
.extern AbortRarry

.section .freertos_vectors, "a"
__vector_table:
	LDR	pc,=ResetHandler
 5100000:	e59ff018 	ldr	pc, [pc, #24]	; 5100020 <__FLASH_segment_start__+0x20>
	LDR	pc,=FreeRTOS_Undefined
 5100004:	e59ff018 	ldr	pc, [pc, #24]	; 5100024 <__FLASH_segment_start__+0x24>
	LDR pc,=FreeRTOS_SVC_Handler
 5100008:	e59ff018 	ldr	pc, [pc, #24]	; 5100028 <__FLASH_segment_start__+0x28>
	/*LDR pc,=FreeRTOS_SWI_Handler*/
	LDR	pc,=FreeRTOS_PrefetchAbortHandler
 510000c:	e59ff018 	ldr	pc, [pc, #24]	; 510002c <__FLASH_segment_start__+0x2c>
	LDR	pc,=FreeRTOS_DataAbortHandler
 5100010:	e59ff018 	ldr	pc, [pc, #24]	; 5100030 <__FLASH_segment_start__+0x30>
	NOP	/* Placeholder for address exception vector*/
 5100014:	e320f000 	nop	{0}
	LDR pc,=FreeRTOS_IRQ_Handler
 5100018:	e59ff014 	ldr	pc, [pc, #20]	; 5100034 <__FLASH_segment_start__+0x34>
	LDR	pc,=FreeRTOS_FIQHandler
 510001c:	e59ff014 	ldr	pc, [pc, #20]	; 5100038 <__FLASH_segment_start__+0x38>
	LDR	pc,=ResetHandler
 5100020:	05110000 	.word	0x05110000
	LDR	pc,=FreeRTOS_Undefined
 5100024:	05110288 	.word	0x05110288
	LDR pc,=FreeRTOS_SVC_Handler
 5100028:	051000a0 	.word	0x051000a0
	LDR	pc,=FreeRTOS_PrefetchAbortHandler
 510002c:	051102e8 	.word	0x051102e8
	LDR	pc,=FreeRTOS_DataAbortHandler
 5100030:	051102b8 	.word	0x051102b8
	LDR pc,=FreeRTOS_IRQ_Handler
 5100034:	051002d0 	.word	0x051002d0
	LDR	pc,=FreeRTOS_FIQHandler
 5100038:	0511025c 	.word	0x0511025c
 510003c:	00000000 	.word	0x00000000

05100040 <vPortStartFirstTask>:
 5100040:	f1020013 	cps	#19
 5100044:	e59fe3c0 	ldr	lr, [pc, #960]	; 510040c <vTaskSwitchContextConst+0x4>
 5100048:	e59ee000 	ldr	lr, [lr]
 510004c:	e28e1004 	add	r1, lr, #4
 5100050:	e59ee000 	ldr	lr, [lr]
 5100054:	e3a05000 	mov	r5, #0
 5100058:	e8b1001c 	ldm	r1!, {r2, r3, r4}
 510005c:	ee065f12 	mcr	15, 0, r5, cr6, cr2, {0}
 5100060:	ee064f11 	mcr	15, 0, r4, cr6, cr1, {0}
 5100064:	ee063f91 	mcr	15, 0, r3, cr6, cr1, {4}
 5100068:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
 510006c:	e2855001 	add	r5, r5, #1
 5100070:	e3550008 	cmp	r5, #8
 5100074:	dafffff7 	ble	5100058 <vPortStartFirstTask+0x18>
 5100078:	e59f1390 	ldr	r1, [pc, #912]	; 5100410 <vTaskSwitchContextConst+0x8>
 510007c:	e8be0004 	ldm	lr!, {r2}
 5100080:	e5812000 	str	r2, [r1]
 5100084:	e8be0002 	ldm	lr!, {r1}
 5100088:	eee11a10 	vmsr	fpscr, r1
 510008c:	ecbe0b20 	vldmia	lr!, {d0-d15}
 5100090:	e8de7fff 	ldm	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 5100094:	e28ee03c 	add	lr, lr, #60	; 0x3c
 5100098:	f89e0a00 	rfeia	lr
 510009c:	00000000 	.word	0x00000000

051000a0 <FreeRTOS_SVC_Handler>:
 51000a0:	e92d1800 	push	{fp, ip}
 51000a4:	e59fb368 	ldr	fp, [pc, #872]	; 5100414 <vTaskSwitchContextConst+0xc>
 51000a8:	e59fc368 	ldr	ip, [pc, #872]	; 5100418 <vTaskSwitchContextConst+0x10>
 51000ac:	e15e000b 	cmp	lr, fp
 51000b0:	ba00000d 	blt	51000ec <svcHandlerExit>
 51000b4:	e15e000c 	cmp	lr, ip
 51000b8:	ca00000b 	bgt	51000ec <svcHandlerExit>
 51000bc:	e14fb000 	mrs	fp, SPSR
 51000c0:	e31b0020 	tst	fp, #32
 51000c4:	115eb0b2 	ldrhne	fp, [lr, #-2]
 51000c8:	13cbbcff 	bicne	fp, fp, #65280	; 0xff00
 51000cc:	051eb004 	ldreq	fp, [lr, #-4]
 51000d0:	03cbb4ff 	biceq	fp, fp, #-16777216	; 0xff000000
 51000d4:	e35b0046 	cmp	fp, #70	; 0x46
 51000d8:	ba00003d 	blt	51001d4 <svcSystemCallEnter>
 51000dc:	e35b0f41 	cmp	fp, #260	; 0x104
 51000e0:	0a00002d 	beq	510019c <svcSystemCallExit>
 51000e4:	e35b0c01 	cmp	fp, #256	; 0x100
 51000e8:	0a000001 	beq	51000f4 <svcPortYield>

051000ec <svcHandlerExit>:
 51000ec:	e8bd1800 	pop	{fp, ip}
 51000f0:	e1b0f00e 	movs	pc, lr

051000f4 <svcPortYield>:
 51000f4:	e8bd1800 	pop	{fp, ip}
 51000f8:	f57ff04f 	dsb	sy
 51000fc:	f57ff06f 	isb	sy
 5100100:	e92d4001 	push	{r0, lr}
 5100104:	e59fe300 	ldr	lr, [pc, #768]	; 510040c <vTaskSwitchContextConst+0x4>
 5100108:	e59ee000 	ldr	lr, [lr]
 510010c:	e59ee000 	ldr	lr, [lr]
 5100110:	e59f02f8 	ldr	r0, [pc, #760]	; 5100410 <vTaskSwitchContextConst+0x8>
 5100114:	e5900000 	ldr	r0, [r0]
 5100118:	e8ae0001 	stmia	lr!, {r0}
 510011c:	eef10a10 	vmrs	r0, fpscr
 5100120:	e8ae0001 	stmia	lr!, {r0}
 5100124:	ecae0b20 	vstmia	lr!, {d0-d15}
 5100128:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 510012c:	e8ce7fff 	stmia	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 5100130:	e28ee03c 	add	lr, lr, #60	; 0x3c
 5100134:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 5100138:	e14f1000 	mrs	r1, SPSR
 510013c:	e8ae0003 	stmia	lr!, {r0, r1}
 5100140:	eb001a87 	bl	5106b64 <vTaskSwitchContext>
 5100144:	e59fe2c0 	ldr	lr, [pc, #704]	; 510040c <vTaskSwitchContextConst+0x4>
 5100148:	e59ee000 	ldr	lr, [lr]
 510014c:	e28e1004 	add	r1, lr, #4
 5100150:	e59ee000 	ldr	lr, [lr]
 5100154:	e3a05000 	mov	r5, #0
 5100158:	e8b1001c 	ldm	r1!, {r2, r3, r4}
 510015c:	ee065f12 	mcr	15, 0, r5, cr6, cr2, {0}
 5100160:	ee064f11 	mcr	15, 0, r4, cr6, cr1, {0}
 5100164:	ee063f91 	mcr	15, 0, r3, cr6, cr1, {4}
 5100168:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
 510016c:	e2855001 	add	r5, r5, #1
 5100170:	e3550008 	cmp	r5, #8
 5100174:	dafffff7 	ble	5100158 <svcPortYield+0x64>
 5100178:	e59f1290 	ldr	r1, [pc, #656]	; 5100410 <vTaskSwitchContextConst+0x8>
 510017c:	e8be0004 	ldm	lr!, {r2}
 5100180:	e5812000 	str	r2, [r1]
 5100184:	e8be0002 	ldm	lr!, {r1}
 5100188:	eee11a10 	vmsr	fpscr, r1
 510018c:	ecbe0b20 	vldmia	lr!, {d0-d15}
 5100190:	e8de7fff 	ldm	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 5100194:	e28ee03c 	add	lr, lr, #60	; 0x3c
 5100198:	f89e0a00 	rfeia	lr

0510019c <svcSystemCallExit>:
 510019c:	e59fb268 	ldr	fp, [pc, #616]	; 510040c <vTaskSwitchContextConst+0x4>
 51001a0:	e59bb000 	ldr	fp, [fp]
 51001a4:	e28bb074 	add	fp, fp, #116	; 0x74
 51001a8:	e8db6000 	ldm	fp, {sp, lr}^
 51001ac:	e20cc000 	and	ip, ip, #0
 51001b0:	e58bc000 	str	ip, [fp]
 51001b4:	e58bc004 	str	ip, [fp, #4]
 51001b8:	e91b1000 	ldmdb	fp, {ip}
 51001bc:	e31c0002 	tst	ip, #2
 51001c0:	1affffc9 	bne	51000ec <svcHandlerExit>
 51001c4:	e14fc000 	mrs	ip, SPSR
 51001c8:	e3ccc00f 	bic	ip, ip, #15
 51001cc:	e16ff00c 	msr	SPSR_fsxc, ip
 51001d0:	eaffffc5 	b	51000ec <svcHandlerExit>

051001d4 <svcSystemCallEnter>:
 51001d4:	e59fc240 	ldr	ip, [pc, #576]	; 510041c <vTaskSwitchContextConst+0x14>
 51001d8:	e79cc10b 	ldr	ip, [ip, fp, lsl #2]
 51001dc:	e35c0000 	cmp	ip, #0
 51001e0:	0affffc1 	beq	51000ec <svcHandlerExit>
 51001e4:	e1a0e00c 	mov	lr, ip
 51001e8:	e59fb21c 	ldr	fp, [pc, #540]	; 510040c <vTaskSwitchContextConst+0x4>
 51001ec:	e59bb000 	ldr	fp, [fp]
 51001f0:	e28bb074 	add	fp, fp, #116	; 0x74
 51001f4:	e8cb6000 	stmia	fp, {sp, lr}^
 51001f8:	e28bb008 	add	fp, fp, #8
 51001fc:	e8db6000 	ldm	fp, {sp, lr}^
 5100200:	e14fc000 	mrs	ip, SPSR
 5100204:	e38cc01f 	orr	ip, ip, #31
 5100208:	e16ff00c 	msr	SPSR_fsxc, ip
 510020c:	eaffffb6 	b	51000ec <svcHandlerExit>

05100210 <vPortDisableInterrupts>:
 5100210:	f10c0080 	cpsid	i
 5100214:	e12fff1e 	bx	lr
	...

05100220 <vPortEnableInterrupts>:
 5100220:	f1080080 	cpsie	i
 5100224:	e12fff1e 	bx	lr
	...

05100230 <vMPUSetRegion>:
 5100230:	e200000f 	and	r0, r0, #15
 5100234:	ee060f12 	mcr	15, 0, r0, cr6, cr2, {0}
 5100238:	ee061f11 	mcr	15, 0, r1, cr6, cr1, {0}
 510023c:	ee063f91 	mcr	15, 0, r3, cr6, cr1, {4}
 5100240:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
 5100244:	e12fff1e 	bx	lr
	...

05100250 <vMPUEnable>:
 5100250:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 5100254:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
 5100258:	e3800001 	orr	r0, r0, #1
 510025c:	f57ff04f 	dsb	sy
 5100260:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
 5100264:	f57ff06f 	isb	sy
 5100268:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 510026c:	e12fff1e 	bx	lr

05100270 <vMPUDisable>:
 5100270:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 5100274:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
 5100278:	e3c00001 	bic	r0, r0, #1
 510027c:	f57ff04f 	dsb	sy
 5100280:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
 5100284:	f57ff06f 	isb	sy
 5100288:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 510028c:	e12fff1e 	bx	lr

05100290 <vMPUEnableBackgroundRegion>:
 5100290:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 5100294:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
 5100298:	e3800802 	orr	r0, r0, #131072	; 0x20000
 510029c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
 51002a0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 51002a4:	e12fff1e 	bx	lr
	...

051002b0 <vMPUDisableBackgroundRegion>:
 51002b0:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
 51002b4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
 51002b8:	e3c00802 	bic	r0, r0, #131072	; 0x20000
 51002bc:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
 51002c0:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 51002c4:	e12fff1e 	bx	lr
	...

051002d0 <FreeRTOS_IRQ_Handler>:
 51002d0:	e24ee004 	sub	lr, lr, #4
 51002d4:	f96d0512 	srsdb	sp!, #18
 51002d8:	f1020013 	cps	#19
 51002dc:	e92d100f 	push	{r0, r1, r2, r3, ip}
 51002e0:	e59f0138 	ldr	r0, [pc, #312]	; 5100420 <vTaskSwitchContextConst+0x18>
 51002e4:	e5901000 	ldr	r1, [r0]
 51002e8:	e2812001 	add	r2, r1, #1
 51002ec:	e5802000 	str	r2, [r0]
 51002f0:	e59f7108 	ldr	r7, [pc, #264]	; 5100400 <ulICCIARConst>
 51002f4:	e5977000 	ldr	r7, [r7]
 51002f8:	e5976000 	ldr	r6, [r7]
 51002fc:	e92d400f 	push	{r0, r1, r2, r3, lr}
 5100300:	eb004498 	bl	5111568 <vApplicationIRQHandler>
 5100304:	e8bd400f 	pop	{r0, r1, r2, r3, lr}
 5100308:	f10c0080 	cpsid	i
 510030c:	f57ff04f 	dsb	sy
 5100310:	f57ff06f 	isb	sy
 5100314:	e5801000 	str	r1, [r0]
 5100318:	e3510000 	cmp	r1, #0
 510031c:	1a000003 	bne	5100330 <exit_without_switch>
 5100320:	e59f10fc 	ldr	r1, [pc, #252]	; 5100424 <vTaskSwitchContextConst+0x1c>
 5100324:	e5910000 	ldr	r0, [r1]
 5100328:	e3500000 	cmp	r0, #0
 510032c:	1a000002 	bne	510033c <switch_before_exit>

05100330 <exit_without_switch>:
 5100330:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
 5100334:	f1020012 	cps	#18
 5100338:	f8bd0a00 	rfeia	sp!

0510033c <switch_before_exit>:
 510033c:	e3a00000 	mov	r0, #0
 5100340:	e5810000 	str	r0, [r1]
 5100344:	e8bd100f 	pop	{r0, r1, r2, r3, ip}
 5100348:	f1020012 	cps	#18
 510034c:	e9bd4000 	ldmib	sp!, {lr}
 5100350:	e16ff00e 	msr	SPSR_fsxc, lr
 5100354:	e91d4000 	ldmdb	sp, {lr}
 5100358:	e28dd004 	add	sp, sp, #4
 510035c:	f57ff04f 	dsb	sy
 5100360:	f57ff06f 	isb	sy
 5100364:	e92d4001 	push	{r0, lr}
 5100368:	e59fe09c 	ldr	lr, [pc, #156]	; 510040c <vTaskSwitchContextConst+0x4>
 510036c:	e59ee000 	ldr	lr, [lr]
 5100370:	e59ee000 	ldr	lr, [lr]
 5100374:	e59f0094 	ldr	r0, [pc, #148]	; 5100410 <vTaskSwitchContextConst+0x8>
 5100378:	e5900000 	ldr	r0, [r0]
 510037c:	e8ae0001 	stmia	lr!, {r0}
 5100380:	eef10a10 	vmrs	r0, fpscr
 5100384:	e8ae0001 	stmia	lr!, {r0}
 5100388:	ecae0b20 	vstmia	lr!, {d0-d15}
 510038c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 5100390:	e8ce7fff 	stmia	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 5100394:	e28ee03c 	add	lr, lr, #60	; 0x3c
 5100398:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
 510039c:	e14f1000 	mrs	r1, SPSR
 51003a0:	e8ae0003 	stmia	lr!, {r0, r1}
 51003a4:	eb0019ee 	bl	5106b64 <vTaskSwitchContext>
 51003a8:	e59fe05c 	ldr	lr, [pc, #92]	; 510040c <vTaskSwitchContextConst+0x4>
 51003ac:	e59ee000 	ldr	lr, [lr]
 51003b0:	e28e1004 	add	r1, lr, #4
 51003b4:	e59ee000 	ldr	lr, [lr]
 51003b8:	e3a05000 	mov	r5, #0
 51003bc:	e8b1001c 	ldm	r1!, {r2, r3, r4}
 51003c0:	ee065f12 	mcr	15, 0, r5, cr6, cr2, {0}
 51003c4:	ee064f11 	mcr	15, 0, r4, cr6, cr1, {0}
 51003c8:	ee063f91 	mcr	15, 0, r3, cr6, cr1, {4}
 51003cc:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
 51003d0:	e2855001 	add	r5, r5, #1
 51003d4:	e3550008 	cmp	r5, #8
 51003d8:	dafffff7 	ble	51003bc <switch_before_exit+0x80>
 51003dc:	e59f102c 	ldr	r1, [pc, #44]	; 5100410 <vTaskSwitchContextConst+0x8>
 51003e0:	e8be0004 	ldm	lr!, {r2}
 51003e4:	e5812000 	str	r2, [r1]
 51003e8:	e8be0002 	ldm	lr!, {r1}
 51003ec:	eee11a10 	vmsr	fpscr, r1
 51003f0:	ecbe0b20 	vldmia	lr!, {d0-d15}
 51003f4:	e8de7fff 	ldm	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 51003f8:	e28ee03c 	add	lr, lr, #60	; 0x3c
 51003fc:	f89e0a00 	rfeia	lr

05100400 <ulICCIARConst>:
 5100400:	0512dbb8 	.word	0x0512dbb8

05100404 <ulICCEOIRConst>:
 5100404:	0512dbb4 	.word	0x0512dbb4

05100408 <vTaskSwitchContextConst>:
 5100408:	05106b64 	.word	0x05106b64
 510040c:	0511cdc4 	.word	0x0511cdc4
 5100410:	051276c8 	.word	0x051276c8
 5100414:	05110000 	.word	0x05110000
 5100418:	0511064c 	.word	0x0511064c
 510041c:	051275a8 	.word	0x051275a8
 5100420:	051276cc 	.word	0x051276cc
 5100424:	051276c0 	.word	0x051276c0

05100428 <xEventGroupCreate>:
            traceENTER_xEventGroupCreate();

            /* MISRA Ref 11.5.1 [Malloc memory assignment] */
            /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-115 */
            /* coverity[misra_c_2012_rule_11_5_violation] */
            pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 5100428:	e3073f74 	movw	r3, #32628	; 0x7f74
 510042c:	e3a0001c 	mov	r0, #28
        {
 5100430:	e92d4070 	push	{r4, r5, r6, lr}
            pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 5100434:	e3403510 	movt	r3, #1296	; 0x510
 5100438:	e12fff33 	blx	r3

            if( pxEventBits != NULL )
 510043c:	e2504000 	subs	r4, r0, #0
 5100440:	0a000006 	beq	5100460 <xEventGroupCreate+0x38>
            {
                pxEventBits->uxEventBits = 0;
 5100444:	e3a05000 	mov	r5, #0
 5100448:	e1a00004 	mov	r0, r4
                vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 510044c:	e3003c28 	movw	r3, #3112	; 0xc28
                pxEventBits->uxEventBits = 0;
 5100450:	e4805004 	str	r5, [r0], #4
                vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 5100454:	e3403510 	movt	r3, #1296	; 0x510
 5100458:	e12fff33 	blx	r3
                #if ( configSUPPORT_STATIC_ALLOCATION == 1 )
                {
                    /* Both static and dynamic allocation can be used, so note this
                     * event group was allocated statically in case the event group is
                     * later deleted. */
                    pxEventBits->ucStaticallyAllocated = pdFALSE;
 510045c:	e5c45018 	strb	r5, [r4, #24]
            }

            traceRETURN_xEventGroupCreate( pxEventBits );

            return pxEventBits;
        }
 5100460:	e1a00004 	mov	r0, r4
 5100464:	e8bd8070 	pop	{r4, r5, r6, pc}

05100468 <xEventGroupCreateStatic>:
        {
 5100468:	e92d4030 	push	{r4, r5, lr}
            configASSERT( pxEventGroupBuffer );
 510046c:	e2504000 	subs	r4, r0, #0
        {
 5100470:	e24dd00c 	sub	sp, sp, #12
            configASSERT( pxEventGroupBuffer );
 5100474:	0a000016 	beq	51004d4 <xEventGroupCreateStatic+0x6c>
                volatile size_t xSize = sizeof( StaticEventGroup_t );
 5100478:	e3a0301c 	mov	r3, #28
 510047c:	e58d3004 	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( EventGroup_t ) );
 5100480:	e59d3004 	ldr	r3, [sp, #4]
 5100484:	e353001c 	cmp	r3, #28
 5100488:	1a00000a 	bne	51004b8 <xEventGroupCreateStatic+0x50>
                pxEventBits->uxEventBits = 0;
 510048c:	e1a00004 	mov	r0, r4
 5100490:	e3a02000 	mov	r2, #0
                vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 5100494:	e3003c28 	movw	r3, #3112	; 0xc28
                pxEventBits->uxEventBits = 0;
 5100498:	e4802004 	str	r2, [r0], #4
                vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 510049c:	e3403510 	movt	r3, #1296	; 0x510
 51004a0:	e12fff33 	blx	r3
                    pxEventBits->ucStaticallyAllocated = pdTRUE;
 51004a4:	e3a03001 	mov	r3, #1
 51004a8:	e5c43018 	strb	r3, [r4, #24]
        }
 51004ac:	e1a00004 	mov	r0, r4
 51004b0:	e28dd00c 	add	sp, sp, #12
 51004b4:	e8bd8030 	pop	{r4, r5, pc}
                configASSERT( xSize == sizeof( EventGroup_t ) );
 51004b8:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 51004bc:	e3003900 	movw	r3, #2304	; 0x900
 51004c0:	e3a01065 	mov	r1, #101	; 0x65
 51004c4:	e3403511 	movt	r3, #1297	; 0x511
 51004c8:	e3400512 	movt	r0, #1298	; 0x512
 51004cc:	e12fff33 	blx	r3
            if( pxEventBits != NULL )
 51004d0:	eaffffed 	b	510048c <xEventGroupCreateStatic+0x24>
            configASSERT( pxEventGroupBuffer );
 51004d4:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 51004d8:	e3005900 	movw	r5, #2304	; 0x900
 51004dc:	e3a0105d 	mov	r1, #93	; 0x5d
 51004e0:	e3400512 	movt	r0, #1298	; 0x512
 51004e4:	e3405511 	movt	r5, #1297	; 0x511
 51004e8:	e12fff35 	blx	r5
                volatile size_t xSize = sizeof( StaticEventGroup_t );
 51004ec:	e3a0301c 	mov	r3, #28
 51004f0:	e58d3004 	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( EventGroup_t ) );
 51004f4:	e59d3004 	ldr	r3, [sp, #4]
 51004f8:	e353001c 	cmp	r3, #28
 51004fc:	0affffea 	beq	51004ac <xEventGroupCreateStatic+0x44>
 5100500:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100504:	e3a01065 	mov	r1, #101	; 0x65
 5100508:	e3400512 	movt	r0, #1298	; 0x512
 510050c:	e12fff35 	blx	r5
            return pxEventBits;
 5100510:	eaffffe5 	b	51004ac <xEventGroupCreateStatic+0x44>

05100514 <xEventGroupWaitBits>:
    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                     const EventBits_t uxBitsToWaitFor,
                                     const BaseType_t xClearOnExit,
                                     const BaseType_t xWaitForAllBits,
                                     TickType_t xTicksToWait )
    {
 5100514:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5100518:	e59d9020 	ldr	r9, [sp, #32]

        traceENTER_xEventGroupWaitBits( xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait );

        /* Check the user is not attempting to wait on the bits used by the kernel
         * itself, and that at least one bit is being requested. */
        configASSERT( xEventGroup );
 510051c:	e2506000 	subs	r6, r0, #0
    {
 5100520:	e1a04001 	mov	r4, r1
 5100524:	e1a08002 	mov	r8, r2
 5100528:	e1a07003 	mov	r7, r3
        configASSERT( xEventGroup );
 510052c:	0a000051 	beq	5100678 <xEventGroupWaitBits+0x164>
        configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100530:	e31404ff 	tst	r4, #-16777216	; 0xff000000
 5100534:	1a000044 	bne	510064c <xEventGroupWaitBits+0x138>
        configASSERT( uxBitsToWaitFor != 0 );
 5100538:	e3540000 	cmp	r4, #0
 510053c:	0a000022 	beq	51005cc <xEventGroupWaitBits+0xb8>
        #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5100540:	e3063e28 	movw	r3, #28200	; 0x6e28
 5100544:	e3403510 	movt	r3, #1296	; 0x510
 5100548:	e12fff33 	blx	r3
 510054c:	e16f1f19 	clz	r1, r9
 5100550:	e1a012a1 	lsr	r1, r1, #5
 5100554:	e3500000 	cmp	r0, #0
 5100558:	13811001 	orrne	r1, r1, #1
 510055c:	e3510000 	cmp	r1, #0
 5100560:	0a00004b 	beq	5100694 <xEventGroupWaitBits+0x180>
        }
        #endif

        vTaskSuspendAll();
 5100564:	e30532a0 	movw	r3, #21152	; 0x52a0
 5100568:	e3403510 	movt	r3, #1296	; 0x510
 510056c:	e12fff33 	blx	r3
        {
            const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 5100570:	e5965000 	ldr	r5, [r6]
                                            const EventBits_t uxBitsToWaitFor,
                                            const BaseType_t xWaitForAllBits )
    {
        BaseType_t xWaitConditionMet = pdFALSE;

        if( xWaitForAllBits == pdFALSE )
 5100574:	e3570000 	cmp	r7, #0
 5100578:	1a00000a 	bne	51005a8 <xEventGroupWaitBits+0x94>
        {
            /* Task only has to wait for one bit within uxBitsToWaitFor to be
             * set.  Is one already set? */
            if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 510057c:	e1140005 	tst	r4, r5
 5100580:	0a00000a 	beq	51005b0 <xEventGroupWaitBits+0x9c>
                if( xClearOnExit != pdFALSE )
 5100584:	e3580000 	cmp	r8, #0
 5100588:	0a00000a 	beq	51005b8 <xEventGroupWaitBits+0xa4>
        xAlreadyYielded = xTaskResumeAll();
 510058c:	e3053efc 	movw	r3, #24316	; 0x5efc
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 5100590:	e1c54004 	bic	r4, r5, r4
        xAlreadyYielded = xTaskResumeAll();
 5100594:	e3403510 	movt	r3, #1296	; 0x510
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 5100598:	e5864000 	str	r4, [r6]
        xAlreadyYielded = xTaskResumeAll();
 510059c:	e12fff33 	blx	r3
    }
 51005a0:	e1a00005 	mov	r0, r5
 51005a4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        }
        else
        {
            /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
             * Are they set already? */
            if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 51005a8:	e1d43005 	bics	r3, r4, r5
 51005ac:	0afffff4 	beq	5100584 <xEventGroupWaitBits+0x70>
            else if( xTicksToWait == ( TickType_t ) 0 )
 51005b0:	e3590000 	cmp	r9, #0
 51005b4:	1a00000b 	bne	51005e8 <xEventGroupWaitBits+0xd4>
        xAlreadyYielded = xTaskResumeAll();
 51005b8:	e3053efc 	movw	r3, #24316	; 0x5efc
 51005bc:	e3403510 	movt	r3, #1296	; 0x510
 51005c0:	e12fff33 	blx	r3
    }
 51005c4:	e1a00005 	mov	r0, r5
 51005c8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        configASSERT( uxBitsToWaitFor != 0 );
 51005cc:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 51005d0:	e3003900 	movw	r3, #2304	; 0x900
 51005d4:	e3001149 	movw	r1, #329	; 0x149
 51005d8:	e3403511 	movt	r3, #1297	; 0x511
 51005dc:	e3400512 	movt	r0, #1298	; 0x512
 51005e0:	e12fff33 	blx	r3
 51005e4:	eaffffd5 	b	5100540 <xEventGroupWaitBits+0x2c>
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 51005e8:	e3063774 	movw	r3, #26484	; 0x6774
                    uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 51005ec:	e3580000 	cmp	r8, #0
 51005f0:	13a01401 	movne	r1, #16777216	; 0x1000000
 51005f4:	03a01000 	moveq	r1, #0
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 51005f8:	e1a02009 	mov	r2, r9
                if( xWaitForAllBits != pdFALSE )
 51005fc:	e3570000 	cmp	r7, #0
                    uxControlBits |= eventWAIT_FOR_ALL_BITS;
 5100600:	13811301 	orrne	r1, r1, #67108864	; 0x4000000
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 5100604:	e1811004 	orr	r1, r1, r4
 5100608:	e3403510 	movt	r3, #1296	; 0x510
 510060c:	e2860004 	add	r0, r6, #4
 5100610:	e12fff33 	blx	r3
        xAlreadyYielded = xTaskResumeAll();
 5100614:	e3053efc 	movw	r3, #24316	; 0x5efc
 5100618:	e3403510 	movt	r3, #1296	; 0x510
 510061c:	e12fff33 	blx	r3
            if( xAlreadyYielded == pdFALSE )
 5100620:	e3500000 	cmp	r0, #0
 5100624:	0a00000f 	beq	5100668 <xEventGroupWaitBits+0x154>
            uxReturn = uxTaskResetEventItemValue();
 5100628:	e3063dc4 	movw	r3, #28100	; 0x6dc4
 510062c:	e3403510 	movt	r3, #1296	; 0x510
 5100630:	e12fff33 	blx	r3
 5100634:	e1a05000 	mov	r5, r0
            if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 5100638:	e3100402 	tst	r0, #33554432	; 0x2000000
 510063c:	0a00001b 	beq	51006b0 <xEventGroupWaitBits+0x19c>
            uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 5100640:	e3c554ff 	bic	r5, r5, #-16777216	; 0xff000000
    }
 5100644:	e1a00005 	mov	r0, r5
 5100648:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 510064c:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100650:	e3003900 	movw	r3, #2304	; 0x900
 5100654:	e3a01f52 	mov	r1, #328	; 0x148
 5100658:	e3403511 	movt	r3, #1297	; 0x511
 510065c:	e3400512 	movt	r0, #1298	; 0x512
 5100660:	e12fff33 	blx	r3
        configASSERT( uxBitsToWaitFor != 0 );
 5100664:	eaffffb5 	b	5100540 <xEventGroupWaitBits+0x2c>
                taskYIELD_WITHIN_API();
 5100668:	e3003000 	movw	r3, #0
 510066c:	e3403511 	movt	r3, #1297	; 0x511
 5100670:	e12fff33 	blx	r3
 5100674:	eaffffeb 	b	5100628 <xEventGroupWaitBits+0x114>
        configASSERT( xEventGroup );
 5100678:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 510067c:	e3003900 	movw	r3, #2304	; 0x900
 5100680:	e3001147 	movw	r1, #327	; 0x147
 5100684:	e3403511 	movt	r3, #1297	; 0x511
 5100688:	e3400512 	movt	r0, #1298	; 0x512
 510068c:	e12fff33 	blx	r3
 5100690:	eaffffa6 	b	5100530 <xEventGroupWaitBits+0x1c>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5100694:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100698:	e3003900 	movw	r3, #2304	; 0x900
 510069c:	e3a01f53 	mov	r1, #332	; 0x14c
 51006a0:	e3403511 	movt	r3, #1297	; 0x511
 51006a4:	e3400512 	movt	r0, #1298	; 0x512
 51006a8:	e12fff33 	blx	r3
 51006ac:	eaffffac 	b	5100564 <xEventGroupWaitBits+0x50>
                taskENTER_CRITICAL();
 51006b0:	e30c3930 	movw	r3, #51504	; 0xc930
 51006b4:	e3403510 	movt	r3, #1296	; 0x510
 51006b8:	e12fff33 	blx	r3
                    uxReturn = pxEventBits->uxEventBits;
 51006bc:	e5965000 	ldr	r5, [r6]
        if( xWaitForAllBits == pdFALSE )
 51006c0:	e3570000 	cmp	r7, #0
 51006c4:	1a000008 	bne	51006ec <xEventGroupWaitBits+0x1d8>
            if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 51006c8:	e1140005 	tst	r4, r5
 51006cc:	0a000002 	beq	51006dc <xEventGroupWaitBits+0x1c8>
                        if( xClearOnExit != pdFALSE )
 51006d0:	e3580000 	cmp	r8, #0
                            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 51006d4:	11c54004 	bicne	r4, r5, r4
 51006d8:	15864000 	strne	r4, [r6]
                taskEXIT_CRITICAL();
 51006dc:	e30c3988 	movw	r3, #51592	; 0xc988
 51006e0:	e3403510 	movt	r3, #1296	; 0x510
 51006e4:	e12fff33 	blx	r3
 51006e8:	eaffffd4 	b	5100640 <xEventGroupWaitBits+0x12c>
            if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 51006ec:	e1d43005 	bics	r3, r4, r5
 51006f0:	1afffff9 	bne	51006dc <xEventGroupWaitBits+0x1c8>
 51006f4:	eafffff5 	b	51006d0 <xEventGroupWaitBits+0x1bc>

051006f8 <xEventGroupClearBits>:
    {
 51006f8:	e92d4070 	push	{r4, r5, r6, lr}
 51006fc:	e1a04001 	mov	r4, r1
        configASSERT( xEventGroup );
 5100700:	e2505000 	subs	r5, r0, #0
 5100704:	0a000013 	beq	5100758 <xEventGroupClearBits+0x60>
        configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100708:	e31404ff 	tst	r4, #-16777216	; 0xff000000
 510070c:	1a00000a 	bne	510073c <xEventGroupClearBits+0x44>
        taskENTER_CRITICAL();
 5100710:	e30c3930 	movw	r3, #51504	; 0xc930
 5100714:	e3403510 	movt	r3, #1296	; 0x510
 5100718:	e12fff33 	blx	r3
            uxReturn = pxEventBits->uxEventBits;
 510071c:	e5956000 	ldr	r6, [r5]
        taskEXIT_CRITICAL();
 5100720:	e30c3988 	movw	r3, #51592	; 0xc988
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 5100724:	e1c64004 	bic	r4, r6, r4
        taskEXIT_CRITICAL();
 5100728:	e3403510 	movt	r3, #1296	; 0x510
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 510072c:	e5854000 	str	r4, [r5]
        taskEXIT_CRITICAL();
 5100730:	e12fff33 	blx	r3
    }
 5100734:	e1a00006 	mov	r0, r6
 5100738:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 510073c:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100740:	e3003900 	movw	r3, #2304	; 0x900
 5100744:	e30011e3 	movw	r1, #483	; 0x1e3
 5100748:	e3403511 	movt	r3, #1297	; 0x511
 510074c:	e3400512 	movt	r0, #1298	; 0x512
 5100750:	e12fff33 	blx	r3
 5100754:	eaffffed 	b	5100710 <xEventGroupClearBits+0x18>
        configASSERT( xEventGroup );
 5100758:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 510075c:	e3003900 	movw	r3, #2304	; 0x900
 5100760:	e30011e2 	movw	r1, #482	; 0x1e2
 5100764:	e3403511 	movt	r3, #1297	; 0x511
 5100768:	e3400512 	movt	r0, #1298	; 0x512
 510076c:	e12fff33 	blx	r3
 5100770:	eaffffe4 	b	5100708 <xEventGroupClearBits+0x10>

05100774 <xEventGroupSetBits>:
    {
 5100774:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5100778:	e1a05001 	mov	r5, r1
        configASSERT( xEventGroup );
 510077c:	e2506000 	subs	r6, r0, #0
 5100780:	0a000030 	beq	5100848 <xEventGroupSetBits+0xd4>
        configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100784:	e31504ff 	tst	r5, #-16777216	; 0xff000000
 5100788:	1a000027 	bne	510082c <xEventGroupSetBits+0xb8>
        vTaskSuspendAll();
 510078c:	e30532a0 	movw	r3, #21152	; 0x52a0
        pxListEnd = listGET_END_MARKER( pxList );
 5100790:	e286800c 	add	r8, r6, #12
        vTaskSuspendAll();
 5100794:	e3403510 	movt	r3, #1296	; 0x510
 5100798:	e12fff33 	blx	r3
            pxEventBits->uxEventBits |= uxBitsToSet;
 510079c:	e5963000 	ldr	r3, [r6]
            pxListItem = listGET_HEAD_ENTRY( pxList );
 51007a0:	e5964010 	ldr	r4, [r6, #16]
            pxEventBits->uxEventBits |= uxBitsToSet;
 51007a4:	e1853003 	orr	r3, r5, r3
            while( pxListItem != pxListEnd )
 51007a8:	e1580004 	cmp	r8, r4
            pxEventBits->uxEventBits |= uxBitsToSet;
 51007ac:	e5863000 	str	r3, [r6]
            while( pxListItem != pxListEnd )
 51007b0:	0a000017 	beq	5100814 <xEventGroupSetBits+0xa0>
                    vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 51007b4:	e3065a2c 	movw	r5, #27180	; 0x6a2c
        EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 51007b8:	e3a07000 	mov	r7, #0
                    vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 51007bc:	e3405510 	movt	r5, #1296	; 0x510
 51007c0:	ea000007 	b	51007e4 <xEventGroupSetBits+0x70>
                    if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 51007c4:	e11c0003 	tst	ip, r3
 51007c8:	0a000003 	beq	51007dc <xEventGroupSetBits+0x68>
                    if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 51007cc:	e3120401 	tst	r2, #16777216	; 0x1000000
                        uxBitsToClear |= uxBitsWaitedFor;
 51007d0:	1187700c 	orrne	r7, r7, ip
                    vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 51007d4:	e12fff35 	blx	r5
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 51007d8:	e5963000 	ldr	r3, [r6]
            while( pxListItem != pxListEnd )
 51007dc:	e1580004 	cmp	r8, r4
 51007e0:	0a00000a 	beq	5100810 <xEventGroupSetBits+0x9c>
                    if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 51007e4:	e1a00004 	mov	r0, r4
                    vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 51007e8:	e3831402 	orr	r1, r3, #33554432	; 0x2000000
                pxNext = listGET_NEXT( pxListItem );
 51007ec:	e5944004 	ldr	r4, [r4, #4]
                uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 51007f0:	e5902000 	ldr	r2, [r0]
                if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 51007f4:	e3120301 	tst	r2, #67108864	; 0x4000000
                uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 51007f8:	e3c2c4ff 	bic	ip, r2, #-16777216	; 0xff000000
                if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 51007fc:	0afffff0 	beq	51007c4 <xEventGroupSetBits+0x50>
                else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 5100800:	e1dce003 	bics	lr, ip, r3
 5100804:	0afffff0 	beq	51007cc <xEventGroupSetBits+0x58>
            while( pxListItem != pxListEnd )
 5100808:	e1580004 	cmp	r8, r4
 510080c:	1afffff4 	bne	51007e4 <xEventGroupSetBits+0x70>
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 5100810:	e1c33007 	bic	r3, r3, r7
 5100814:	e5863000 	str	r3, [r6]
        ( void ) xTaskResumeAll();
 5100818:	e3052efc 	movw	r2, #24316	; 0x5efc
 510081c:	e3402510 	movt	r2, #1296	; 0x510
 5100820:	e12fff32 	blx	r2
    }
 5100824:	e5960000 	ldr	r0, [r6]
 5100828:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 510082c:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100830:	e3003900 	movw	r3, #2304	; 0x900
 5100834:	e3001233 	movw	r1, #563	; 0x233
 5100838:	e3403511 	movt	r3, #1297	; 0x511
 510083c:	e3400512 	movt	r0, #1298	; 0x512
 5100840:	e12fff33 	blx	r3
 5100844:	eaffffd0 	b	510078c <xEventGroupSetBits+0x18>
        configASSERT( xEventGroup );
 5100848:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 510084c:	e3003900 	movw	r3, #2304	; 0x900
 5100850:	e3001232 	movw	r1, #562	; 0x232
 5100854:	e3403511 	movt	r3, #1297	; 0x511
 5100858:	e3400512 	movt	r0, #1298	; 0x512
 510085c:	e12fff33 	blx	r3
 5100860:	eaffffc7 	b	5100784 <xEventGroupSetBits+0x10>

05100864 <xEventGroupSync>:
        configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100864:	e31204ff 	tst	r2, #-16777216	; 0xff000000
    {
 5100868:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 510086c:	e1a06002 	mov	r6, r2
 5100870:	e1a05000 	mov	r5, r0
 5100874:	e1a07001 	mov	r7, r1
 5100878:	e1a08003 	mov	r8, r3
        configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 510087c:	1a000055 	bne	51009d8 <xEventGroupSync+0x174>
        configASSERT( uxBitsToWaitFor != 0 );
 5100880:	e3520000 	cmp	r2, #0
 5100884:	0a000038 	beq	510096c <xEventGroupSync+0x108>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5100888:	e3063e28 	movw	r3, #28200	; 0x6e28
 510088c:	e3403510 	movt	r3, #1296	; 0x510
 5100890:	e12fff33 	blx	r3
 5100894:	e3500000 	cmp	r0, #0
 5100898:	1a000013 	bne	51008ec <xEventGroupSync+0x88>
 510089c:	e3580000 	cmp	r8, #0
 51008a0:	13004900 	movwne	r4, #2304	; 0x900
 51008a4:	13404511 	movtne	r4, #1297	; 0x511
 51008a8:	1a000053 	bne	51009fc <xEventGroupSync+0x198>
        vTaskSuspendAll();
 51008ac:	e30532a0 	movw	r3, #21152	; 0x52a0
 51008b0:	e3403510 	movt	r3, #1296	; 0x510
 51008b4:	e12fff33 	blx	r3
            uxOriginalBitValue = pxEventBits->uxEventBits;
 51008b8:	e5954000 	ldr	r4, [r5]
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 51008bc:	e1a01007 	mov	r1, r7
 51008c0:	e1a00005 	mov	r0, r5
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 51008c4:	e1874004 	orr	r4, r7, r4
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 51008c8:	ebffffa9 	bl	5100774 <xEventGroupSetBits>
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 51008cc:	e1d63004 	bics	r3, r6, r4
 51008d0:	0a000038 	beq	51009b8 <xEventGroupSync+0x154>
                    uxReturn = pxEventBits->uxEventBits;
 51008d4:	e5954000 	ldr	r4, [r5]
        xAlreadyYielded = xTaskResumeAll();
 51008d8:	e3053efc 	movw	r3, #24316	; 0x5efc
 51008dc:	e3403510 	movt	r3, #1296	; 0x510
 51008e0:	e12fff33 	blx	r3
    }
 51008e4:	e1a00004 	mov	r0, r4
 51008e8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        vTaskSuspendAll();
 51008ec:	e30532a0 	movw	r3, #21152	; 0x52a0
 51008f0:	e3403510 	movt	r3, #1296	; 0x510
 51008f4:	e12fff33 	blx	r3
            uxOriginalBitValue = pxEventBits->uxEventBits;
 51008f8:	e5954000 	ldr	r4, [r5]
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 51008fc:	e1a01007 	mov	r1, r7
 5100900:	e1a00005 	mov	r0, r5
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 5100904:	e1844007 	orr	r4, r4, r7
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 5100908:	ebffff99 	bl	5100774 <xEventGroupSetBits>
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 510090c:	e1d63004 	bics	r3, r6, r4
 5100910:	0a000028 	beq	51009b8 <xEventGroupSync+0x154>
                if( xTicksToWait != ( TickType_t ) 0 )
 5100914:	e3580000 	cmp	r8, #0
 5100918:	0affffed 	beq	51008d4 <xEventGroupSync+0x70>
                    vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
 510091c:	e3063774 	movw	r3, #26484	; 0x6774
 5100920:	e1a02008 	mov	r2, r8
 5100924:	e3861405 	orr	r1, r6, #83886080	; 0x5000000
 5100928:	e2850004 	add	r0, r5, #4
 510092c:	e3403510 	movt	r3, #1296	; 0x510
 5100930:	e12fff33 	blx	r3
        xAlreadyYielded = xTaskResumeAll();
 5100934:	e3053efc 	movw	r3, #24316	; 0x5efc
 5100938:	e3403510 	movt	r3, #1296	; 0x510
 510093c:	e12fff33 	blx	r3
            if( xAlreadyYielded == pdFALSE )
 5100940:	e3500000 	cmp	r0, #0
 5100944:	0a000046 	beq	5100a64 <xEventGroupSync+0x200>
            uxReturn = uxTaskResetEventItemValue();
 5100948:	e3063dc4 	movw	r3, #28100	; 0x6dc4
 510094c:	e3403510 	movt	r3, #1296	; 0x510
 5100950:	e12fff33 	blx	r3
 5100954:	e1a04000 	mov	r4, r0
            if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 5100958:	e3100402 	tst	r0, #33554432	; 0x2000000
 510095c:	0a000035 	beq	5100a38 <xEventGroupSync+0x1d4>
            uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 5100960:	e3c444ff 	bic	r4, r4, #-16777216	; 0xff000000
    }
 5100964:	e1a00004 	mov	r0, r4
 5100968:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( uxBitsToWaitFor != 0 );
 510096c:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100970:	e3004900 	movw	r4, #2304	; 0x900
 5100974:	e3a010c6 	mov	r1, #198	; 0xc6
 5100978:	e3400512 	movt	r0, #1298	; 0x512
 510097c:	e3404511 	movt	r4, #1297	; 0x511
 5100980:	e12fff34 	blx	r4
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5100984:	e3063e28 	movw	r3, #28200	; 0x6e28
 5100988:	e3403510 	movt	r3, #1296	; 0x510
 510098c:	e12fff33 	blx	r3
 5100990:	e3500000 	cmp	r0, #0
 5100994:	0a000016 	beq	51009f4 <xEventGroupSync+0x190>
        vTaskSuspendAll();
 5100998:	e30532a0 	movw	r3, #21152	; 0x52a0
 510099c:	e3403510 	movt	r3, #1296	; 0x510
 51009a0:	e12fff33 	blx	r3
            uxOriginalBitValue = pxEventBits->uxEventBits;
 51009a4:	e5954000 	ldr	r4, [r5]
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 51009a8:	e1a01007 	mov	r1, r7
 51009ac:	e1a00005 	mov	r0, r5
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 51009b0:	e1874004 	orr	r4, r7, r4
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 51009b4:	ebffff6e 	bl	5100774 <xEventGroupSetBits>
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 51009b8:	e5952000 	ldr	r2, [r5]
        xAlreadyYielded = xTaskResumeAll();
 51009bc:	e3053efc 	movw	r3, #24316	; 0x5efc
 51009c0:	e3403510 	movt	r3, #1296	; 0x510
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 51009c4:	e1c26006 	bic	r6, r2, r6
 51009c8:	e5856000 	str	r6, [r5]
        xAlreadyYielded = xTaskResumeAll();
 51009cc:	e12fff33 	blx	r3
    }
 51009d0:	e1a00004 	mov	r0, r4
 51009d4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 51009d8:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 51009dc:	e3004900 	movw	r4, #2304	; 0x900
 51009e0:	e3a010c5 	mov	r1, #197	; 0xc5
 51009e4:	e3404511 	movt	r4, #1297	; 0x511
 51009e8:	e3400512 	movt	r0, #1298	; 0x512
 51009ec:	e12fff34 	blx	r4
        configASSERT( uxBitsToWaitFor != 0 );
 51009f0:	eaffffa4 	b	5100888 <xEventGroupSync+0x24>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 51009f4:	e3580000 	cmp	r8, #0
 51009f8:	0affffe6 	beq	5100998 <xEventGroupSync+0x134>
 51009fc:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100a00:	e3a010c9 	mov	r1, #201	; 0xc9
 5100a04:	e3400512 	movt	r0, #1298	; 0x512
 5100a08:	e12fff34 	blx	r4
        vTaskSuspendAll();
 5100a0c:	e30532a0 	movw	r3, #21152	; 0x52a0
 5100a10:	e3403510 	movt	r3, #1296	; 0x510
 5100a14:	e12fff33 	blx	r3
            uxOriginalBitValue = pxEventBits->uxEventBits;
 5100a18:	e5954000 	ldr	r4, [r5]
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 5100a1c:	e1a01007 	mov	r1, r7
 5100a20:	e1a00005 	mov	r0, r5
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 5100a24:	e1874004 	orr	r4, r7, r4
            ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
 5100a28:	ebffff51 	bl	5100774 <xEventGroupSetBits>
            if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
 5100a2c:	e1d63004 	bics	r3, r6, r4
 5100a30:	1affffb9 	bne	510091c <xEventGroupSync+0xb8>
 5100a34:	eaffffdf 	b	51009b8 <xEventGroupSync+0x154>
                taskENTER_CRITICAL();
 5100a38:	e30c3930 	movw	r3, #51504	; 0xc930
 5100a3c:	e3403510 	movt	r3, #1296	; 0x510
 5100a40:	e12fff33 	blx	r3
                    uxReturn = pxEventBits->uxEventBits;
 5100a44:	e5954000 	ldr	r4, [r5]
                    if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
 5100a48:	e1d63004 	bics	r3, r6, r4
                taskEXIT_CRITICAL();
 5100a4c:	e30c3988 	movw	r3, #51592	; 0xc988
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 5100a50:	01c46006 	biceq	r6, r4, r6
                taskEXIT_CRITICAL();
 5100a54:	e3403510 	movt	r3, #1296	; 0x510
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 5100a58:	05856000 	streq	r6, [r5]
                taskEXIT_CRITICAL();
 5100a5c:	e12fff33 	blx	r3
                xTimeoutOccurred = pdTRUE;
 5100a60:	eaffffbe 	b	5100960 <xEventGroupSync+0xfc>
                taskYIELD_WITHIN_API();
 5100a64:	e3003000 	movw	r3, #0
 5100a68:	e3403511 	movt	r3, #1297	; 0x511
 5100a6c:	e12fff33 	blx	r3
 5100a70:	eaffffb4 	b	5100948 <xEventGroupSync+0xe4>

05100a74 <xEventGroupGetBitsFromISR>:
    }
 5100a74:	e5900000 	ldr	r0, [r0]
 5100a78:	e12fff1e 	bx	lr

05100a7c <vEventGroupDelete>:
    {
 5100a7c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        configASSERT( pxEventBits );
 5100a80:	e2504000 	subs	r4, r0, #0
 5100a84:	0a000025 	beq	5100b20 <vEventGroupDelete+0xa4>
        vTaskSuspendAll();
 5100a88:	e30532a0 	movw	r3, #21152	; 0x52a0
 5100a8c:	e3403510 	movt	r3, #1296	; 0x510
 5100a90:	e12fff33 	blx	r3
            while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 5100a94:	e5943004 	ldr	r3, [r4, #4]
 5100a98:	e3530000 	cmp	r3, #0
 5100a9c:	0a000014 	beq	5100af4 <vEventGroupDelete+0x78>
 5100aa0:	e3065a2c 	movw	r5, #27180	; 0x6a2c
                configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 5100aa4:	e30d8a4c 	movw	r8, #55884	; 0xda4c
 5100aa8:	e3007900 	movw	r7, #2304	; 0x900
 5100aac:	e284600c 	add	r6, r4, #12
 5100ab0:	e3405510 	movt	r5, #1296	; 0x510
 5100ab4:	e3408512 	movt	r8, #1298	; 0x512
 5100ab8:	e3407511 	movt	r7, #1297	; 0x511
 5100abc:	ea000004 	b	5100ad4 <vEventGroupDelete+0x58>
                vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 5100ac0:	e3a01402 	mov	r1, #33554432	; 0x2000000
 5100ac4:	e12fff35 	blx	r5
            while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 5100ac8:	e5943004 	ldr	r3, [r4, #4]
 5100acc:	e3530000 	cmp	r3, #0
 5100ad0:	0a000007 	beq	5100af4 <vEventGroupDelete+0x78>
                configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 5100ad4:	e5940010 	ldr	r0, [r4, #16]
 5100ad8:	e1500006 	cmp	r0, r6
 5100adc:	1afffff7 	bne	5100ac0 <vEventGroupDelete+0x44>
 5100ae0:	e300129a 	movw	r1, #666	; 0x29a
 5100ae4:	e1a00008 	mov	r0, r8
 5100ae8:	e12fff37 	blx	r7
                vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 5100aec:	e5940010 	ldr	r0, [r4, #16]
 5100af0:	eafffff2 	b	5100ac0 <vEventGroupDelete+0x44>
        ( void ) xTaskResumeAll();
 5100af4:	e3053efc 	movw	r3, #24316	; 0x5efc
 5100af8:	e3403510 	movt	r3, #1296	; 0x510
 5100afc:	e12fff33 	blx	r3
            if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 5100b00:	e5d43018 	ldrb	r3, [r4, #24]
 5100b04:	e3530000 	cmp	r3, #0
 5100b08:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                vPortFree( pxEventBits );
 5100b0c:	e308333c 	movw	r3, #33596	; 0x833c
 5100b10:	e1a00004 	mov	r0, r4
 5100b14:	e3403510 	movt	r3, #1296	; 0x510
 5100b18:	e12fff33 	blx	r3
    }
 5100b1c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( pxEventBits );
 5100b20:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100b24:	e3003900 	movw	r3, #2304	; 0x900
 5100b28:	e300128e 	movw	r1, #654	; 0x28e
 5100b2c:	e3403511 	movt	r3, #1297	; 0x511
 5100b30:	e3400512 	movt	r0, #1298	; 0x512
 5100b34:	e12fff33 	blx	r3
 5100b38:	eaffffd2 	b	5100a88 <vEventGroupDelete+0xc>

05100b3c <xEventGroupGetStaticBuffer>:
        {
 5100b3c:	e92d4070 	push	{r4, r5, r6, lr}
 5100b40:	e1a05001 	mov	r5, r1
            configASSERT( pxEventBits );
 5100b44:	e2504000 	subs	r4, r0, #0
 5100b48:	0a000006 	beq	5100b68 <xEventGroupGetStaticBuffer+0x2c>
            configASSERT( ppxEventGroupBuffer );
 5100b4c:	e3550000 	cmp	r5, #0
 5100b50:	0a00000c 	beq	5100b88 <xEventGroupGetStaticBuffer+0x4c>
                if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdTRUE )
 5100b54:	e5d40018 	ldrb	r0, [r4, #24]
 5100b58:	e3500001 	cmp	r0, #1
                    xReturn = pdFALSE;
 5100b5c:	13a00000 	movne	r0, #0
                    *ppxEventGroupBuffer = ( StaticEventGroup_t * ) pxEventBits;
 5100b60:	05854000 	streq	r4, [r5]
        }
 5100b64:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( pxEventBits );
 5100b68:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100b6c:	e3003900 	movw	r3, #2304	; 0x900
 5100b70:	e30012c2 	movw	r1, #706	; 0x2c2
 5100b74:	e3400512 	movt	r0, #1298	; 0x512
 5100b78:	e3403511 	movt	r3, #1297	; 0x511
 5100b7c:	e12fff33 	blx	r3
            configASSERT( ppxEventGroupBuffer );
 5100b80:	e3550000 	cmp	r5, #0
 5100b84:	1afffff2 	bne	5100b54 <xEventGroupGetStaticBuffer+0x18>
 5100b88:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100b8c:	e3003900 	movw	r3, #2304	; 0x900
 5100b90:	e30012c3 	movw	r1, #707	; 0x2c3
 5100b94:	e3403511 	movt	r3, #1297	; 0x511
 5100b98:	e3400512 	movt	r0, #1298	; 0x512
 5100b9c:	e12fff33 	blx	r3
 5100ba0:	eaffffeb 	b	5100b54 <xEventGroupGetStaticBuffer+0x18>

05100ba4 <vEventGroupSetBitsCallback>:
    {
 5100ba4:	e92d4010 	push	{r4, lr}
        ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
 5100ba8:	ebfffef1 	bl	5100774 <xEventGroupSetBits>
    }
 5100bac:	e8bd8010 	pop	{r4, pc}

05100bb0 <vEventGroupClearBitsCallback>:
    {
 5100bb0:	e92d4070 	push	{r4, r5, r6, lr}
 5100bb4:	e1a05001 	mov	r5, r1
        configASSERT( xEventGroup );
 5100bb8:	e2504000 	subs	r4, r0, #0
 5100bbc:	0a000012 	beq	5100c0c <vEventGroupClearBitsCallback+0x5c>
        configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100bc0:	e31504ff 	tst	r5, #-16777216	; 0xff000000
 5100bc4:	1a000009 	bne	5100bf0 <vEventGroupClearBitsCallback+0x40>
        taskENTER_CRITICAL();
 5100bc8:	e30c3930 	movw	r3, #51504	; 0xc930
 5100bcc:	e3403510 	movt	r3, #1296	; 0x510
 5100bd0:	e12fff33 	blx	r3
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 5100bd4:	e5941000 	ldr	r1, [r4]
        taskEXIT_CRITICAL();
 5100bd8:	e30c3988 	movw	r3, #51592	; 0xc988
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 5100bdc:	e1c15005 	bic	r5, r1, r5
        taskEXIT_CRITICAL();
 5100be0:	e3403510 	movt	r3, #1296	; 0x510
            pxEventBits->uxEventBits &= ~uxBitsToClear;
 5100be4:	e5845000 	str	r5, [r4]
        taskEXIT_CRITICAL();
 5100be8:	e12fff33 	blx	r3
    }
 5100bec:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 5100bf0:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100bf4:	e3003900 	movw	r3, #2304	; 0x900
 5100bf8:	e30011e3 	movw	r1, #483	; 0x1e3
 5100bfc:	e3403511 	movt	r3, #1297	; 0x511
 5100c00:	e3400512 	movt	r0, #1298	; 0x512
 5100c04:	e12fff33 	blx	r3
 5100c08:	eaffffee 	b	5100bc8 <vEventGroupClearBitsCallback+0x18>
        configASSERT( xEventGroup );
 5100c0c:	e30d0a4c 	movw	r0, #55884	; 0xda4c
 5100c10:	e3003900 	movw	r3, #2304	; 0x900
 5100c14:	e30011e2 	movw	r1, #482	; 0x1e2
 5100c18:	e3403511 	movt	r3, #1297	; 0x511
 5100c1c:	e3400512 	movt	r0, #1298	; 0x512
 5100c20:	e12fff33 	blx	r3
 5100c24:	eaffffe5 	b	5100bc0 <vEventGroupClearBitsCallback+0x10>

05100c28 <vListInitialise>:
    traceENTER_vListInitialise( pxList );

    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
 5100c28:	e2803008 	add	r3, r0, #8
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 5100c2c:	e3a02000 	mov	r2, #0
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 5100c30:	e3e01000 	mvn	r1, #0
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );
 5100c34:	e580300c 	str	r3, [r0, #12]
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 5100c38:	e5801008 	str	r1, [r0, #8]
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );
 5100c3c:	e1c020f0 	strd	r2, [r0]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );
 5100c40:	e5803010 	str	r3, [r0, #16]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );

    traceRETURN_vListInitialise();
}
 5100c44:	e12fff1e 	bx	lr

05100c48 <vListInitialiseItem>:
void vListInitialiseItem( ListItem_t * const pxItem )
{
    traceENTER_vListInitialiseItem( pxItem );

    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 5100c48:	e3a03000 	mov	r3, #0
 5100c4c:	e5803010 	str	r3, [r0, #16]
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );

    traceRETURN_vListInitialiseItem();
}
 5100c50:	e12fff1e 	bx	lr

05100c54 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 5100c54:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 5100c58:	e591e000 	ldr	lr, [r1]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 5100c5c:	e37e0001 	cmn	lr, #1
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 5100c60:	12803008 	addne	r3, r0, #8
    if( xValueOfInsertion == portMAX_DELAY )
 5100c64:	0a00000d 	beq	5100ca0 <vListInsert+0x4c>
        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 5100c68:	e1a0c003 	mov	ip, r3
 5100c6c:	e5933004 	ldr	r3, [r3, #4]
 5100c70:	e5932000 	ldr	r2, [r3]
 5100c74:	e152000e 	cmp	r2, lr
 5100c78:	9afffffa 	bls	5100c68 <vListInsert+0x14>

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;

    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100c7c:	e5902000 	ldr	r2, [r0]
    pxNewListItem->pxNext = pxIterator->pxNext;
 5100c80:	e5813004 	str	r3, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 5100c84:	e5831008 	str	r1, [r3, #8]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100c88:	e2823001 	add	r3, r2, #1
    pxNewListItem->pxPrevious = pxIterator;
 5100c8c:	e581c008 	str	ip, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 5100c90:	e58c1004 	str	r1, [ip, #4]
    pxNewListItem->pxContainer = pxList;
 5100c94:	e5810010 	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100c98:	e5803000 	str	r3, [r0]

    traceRETURN_vListInsert();
}
 5100c9c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
        pxIterator = pxList->xListEnd.pxPrevious;
 5100ca0:	e590c010 	ldr	ip, [r0, #16]
    pxNewListItem->pxNext = pxIterator->pxNext;
 5100ca4:	e59c3004 	ldr	r3, [ip, #4]
 5100ca8:	eafffff3 	b	5100c7c <vListInsert+0x28>

05100cac <vListInsertEnd>:
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100cac:	e1c020d0 	ldrd	r2, [r0]
    pxNewListItem->pxNext = pxIndex;
 5100cb0:	e5813004 	str	r3, [r1, #4]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100cb4:	e2822001 	add	r2, r2, #1
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 5100cb8:	e593c008 	ldr	ip, [r3, #8]
 5100cbc:	e581c008 	str	ip, [r1, #8]
    pxIndex->pxPrevious->pxNext = pxNewListItem;
 5100cc0:	e593c008 	ldr	ip, [r3, #8]
 5100cc4:	e58c1004 	str	r1, [ip, #4]
    pxIndex->pxPrevious = pxNewListItem;
 5100cc8:	e5831008 	str	r1, [r3, #8]
    pxNewListItem->pxContainer = pxList;
 5100ccc:	e5810010 	str	r0, [r1, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems + 1U );
 5100cd0:	e5802000 	str	r2, [r0]
}
 5100cd4:	e12fff1e 	bx	lr

05100cd8 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    /* The list item knows which list it is in.  Obtain the list from the list
     * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 5100cd8:	e5902010 	ldr	r2, [r0, #16]

    traceENTER_uxListRemove( pxItemToRemove );

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 5100cdc:	e990000a 	ldmib	r0, {r1, r3}
 5100ce0:	e5813008 	str	r3, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 5100ce4:	e5831004 	str	r1, [r3, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 5100ce8:	e5921004 	ldr	r1, [r2, #4]
 5100cec:	e1510000 	cmp	r1, r0
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 5100cf0:	e3a01000 	mov	r1, #0
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 5100cf4:	05823004 	streq	r3, [r2, #4]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
 5100cf8:	e5923000 	ldr	r3, [r2]
    pxItemToRemove->pxContainer = NULL;
 5100cfc:	e5801010 	str	r1, [r0, #16]
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
 5100d00:	e2433001 	sub	r3, r3, #1

    traceRETURN_uxListRemove( pxList->uxNumberOfItems );

    return pxList->uxNumberOfItems;
}
 5100d04:	e1a00003 	mov	r0, r3
    ( pxList->uxNumberOfItems ) = ( UBaseType_t ) ( pxList->uxNumberOfItems - 1U );
 5100d08:	e5823000 	str	r3, [r2]
}
 5100d0c:	e12fff1e 	bx	lr

05100d10 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
 5100d10:	e92d4070 	push	{r4, r5, r6, lr}
 5100d14:	e1a06002 	mov	r6, r2
 5100d18:	e1a04000 	mov	r4, r0

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 5100d1c:	e5902040 	ldr	r2, [r0, #64]	; 0x40
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5100d20:	e5905038 	ldr	r5, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 5100d24:	e3520000 	cmp	r2, #0
 5100d28:	1a000006 	bne	5100d48 <prvCopyDataToQueue+0x38>
    {
        #if ( configUSE_MUTEXES == 1 )
        {
            if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 5100d2c:	e5906000 	ldr	r6, [r0]
 5100d30:	e3560000 	cmp	r6, #0
 5100d34:	0a000028 	beq	5100ddc <prvCopyDataToQueue+0xcc>
    BaseType_t xReturn = pdFALSE;
 5100d38:	e3a00000 	mov	r0, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5100d3c:	e2855001 	add	r5, r5, #1
 5100d40:	e5845038 	str	r5, [r4, #56]	; 0x38

    return xReturn;
}
 5100d44:	e8bd8070 	pop	{r4, r5, r6, pc}
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
 5100d48:	e3093ca1 	movw	r3, #40097	; 0x9ca1
    else if( xPosition == queueSEND_TO_BACK )
 5100d4c:	e3560000 	cmp	r6, #0
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
 5100d50:	e3403511 	movt	r3, #1297	; 0x511
    else if( xPosition == queueSEND_TO_BACK )
 5100d54:	1a00000e 	bne	5100d94 <prvCopyDataToQueue+0x84>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
 5100d58:	e5900004 	ldr	r0, [r0, #4]
 5100d5c:	e12fff33 	blx	r3
        pxQueue->pcWriteTo += pxQueue->uxItemSize;
 5100d60:	e5943004 	ldr	r3, [r4, #4]
 5100d64:	e5942040 	ldr	r2, [r4, #64]	; 0x40
 5100d68:	e0833002 	add	r3, r3, r2
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )
 5100d6c:	e5942008 	ldr	r2, [r4, #8]
        pxQueue->pcWriteTo += pxQueue->uxItemSize;
 5100d70:	e5843004 	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )
 5100d74:	e1530002 	cmp	r3, r2
 5100d78:	3affffee 	bcc	5100d38 <prvCopyDataToQueue+0x28>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 5100d7c:	e5943000 	ldr	r3, [r4]
    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5100d80:	e2855001 	add	r5, r5, #1
            pxQueue->pcWriteTo = pxQueue->pcHead;
 5100d84:	e5843004 	str	r3, [r4, #4]
    BaseType_t xReturn = pdFALSE;
 5100d88:	e1a00006 	mov	r0, r6
    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5100d8c:	e5845038 	str	r5, [r4, #56]	; 0x38
}
 5100d90:	e8bd8070 	pop	{r4, r5, r6, pc}
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize );
 5100d94:	e590000c 	ldr	r0, [r0, #12]
 5100d98:	e12fff33 	blx	r3
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 5100d9c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
 5100da0:	e594300c 	ldr	r3, [r4, #12]
 5100da4:	e2621000 	rsb	r1, r2, #0
 5100da8:	e0433002 	sub	r3, r3, r2
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )
 5100dac:	e5942000 	ldr	r2, [r4]
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 5100db0:	e584300c 	str	r3, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead )
 5100db4:	e1530002 	cmp	r3, r2
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 5100db8:	35943008 	ldrcc	r3, [r4, #8]
 5100dbc:	30833001 	addcc	r3, r3, r1
 5100dc0:	3584300c 	strcc	r3, [r4, #12]
        if( xPosition == queueOVERWRITE )
 5100dc4:	e3560002 	cmp	r6, #2
 5100dc8:	1affffda 	bne	5100d38 <prvCopyDataToQueue+0x28>
    BaseType_t xReturn = pdFALSE;
 5100dcc:	e3a00000 	mov	r0, #0
 5100dd0:	e3550001 	cmp	r5, #1
 5100dd4:	33a05001 	movcc	r5, #1
 5100dd8:	eaffffd8 	b	5100d40 <prvCopyDataToQueue+0x30>
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 5100ddc:	e3063f70 	movw	r3, #28528	; 0x6f70
    pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5100de0:	e2855001 	add	r5, r5, #1
                xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 5100de4:	e5900008 	ldr	r0, [r0, #8]
 5100de8:	e3403510 	movt	r3, #1296	; 0x510
 5100dec:	e12fff33 	blx	r3
                pxQueue->u.xSemaphore.xMutexHolder = NULL;
 5100df0:	e5846008 	str	r6, [r4, #8]
 5100df4:	eaffffd1 	b	5100d40 <prvCopyDataToQueue+0x30>

05100df8 <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
 5100df8:	e92d4070 	push	{r4, r5, r6, lr}
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
 5100dfc:	e5904048 	ldr	r4, [r0, #72]	; 0x48
    {
 5100e00:	e24dd008 	sub	sp, sp, #8
 5100e04:	e58d0004 	str	r0, [sp, #4]
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
 5100e08:	e3540000 	cmp	r4, #0
 5100e0c:	0a000033 	beq	5100ee0 <prvNotifyQueueSetContainer+0xe8>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 5100e10:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5100e14:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5100e18:	e1520003 	cmp	r2, r3
 5100e1c:	2a000006 	bcs	5100e3c <prvNotifyQueueSetContainer+0x44>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5100e20:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5100e24:	e1520003 	cmp	r2, r3
        BaseType_t xReturn = pdFALSE;
 5100e28:	23a05000 	movcs	r5, #0
        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5100e2c:	3a00000d 	bcc	5100e68 <prvNotifyQueueSetContainer+0x70>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
 5100e30:	e1a00005 	mov	r0, r5
 5100e34:	e28dd008 	add	sp, sp, #8
 5100e38:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 5100e3c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5100e40:	e3003900 	movw	r3, #2304	; 0x900
 5100e44:	e3001cf9 	movw	r1, #3321	; 0xcf9
 5100e48:	e3403511 	movt	r3, #1297	; 0x511
 5100e4c:	e3400512 	movt	r0, #1298	; 0x512
 5100e50:	e12fff33 	blx	r3
        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5100e54:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5100e58:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5100e5c:	e1520003 	cmp	r2, r3
        BaseType_t xReturn = pdFALSE;
 5100e60:	23a05000 	movcs	r5, #0
        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 5100e64:	2afffff1 	bcs	5100e30 <prvNotifyQueueSetContainer+0x38>
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
 5100e68:	e3a02000 	mov	r2, #0
 5100e6c:	e28d1004 	add	r1, sp, #4
 5100e70:	e1a00004 	mov	r0, r4
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 5100e74:	e5d46045 	ldrb	r6, [r4, #69]	; 0x45
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
 5100e78:	ebffffa4 	bl	5100d10 <prvCopyDataToQueue>
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 5100e7c:	e6af6076 	sxtb	r6, r6
            if( cTxLock == queueUNLOCKED )
 5100e80:	e3760001 	cmn	r6, #1
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
 5100e84:	e1a05000 	mov	r5, r0
            if( cTxLock == queueUNLOCKED )
 5100e88:	1a000009 	bne	5100eb4 <prvNotifyQueueSetContainer+0xbc>
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
 5100e8c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
 5100e90:	e3530000 	cmp	r3, #0
 5100e94:	0affffe5 	beq	5100e30 <prvNotifyQueueSetContainer+0x38>
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
 5100e98:	e30638d0 	movw	r3, #26832	; 0x68d0
 5100e9c:	e2840024 	add	r0, r4, #36	; 0x24
 5100ea0:	e3403510 	movt	r3, #1296	; 0x510
 5100ea4:	e12fff33 	blx	r3
                        xReturn = pdTRUE;
 5100ea8:	e3500000 	cmp	r0, #0
 5100eac:	13a05001 	movne	r5, #1
 5100eb0:	eaffffde 	b	5100e30 <prvNotifyQueueSetContainer+0x38>
                prvIncrementQueueTxLock( pxQueueSetContainer, cTxLock );
 5100eb4:	e30532d8 	movw	r3, #21208	; 0x52d8
 5100eb8:	e3403510 	movt	r3, #1296	; 0x510
 5100ebc:	e12fff33 	blx	r3
 5100ec0:	e1560000 	cmp	r6, r0
 5100ec4:	2affffd9 	bcs	5100e30 <prvNotifyQueueSetContainer+0x38>
 5100ec8:	e356007f 	cmp	r6, #127	; 0x7f
 5100ecc:	0a00000a 	beq	5100efc <prvNotifyQueueSetContainer+0x104>
 5100ed0:	e2866001 	add	r6, r6, #1
 5100ed4:	e6af6076 	sxtb	r6, r6
 5100ed8:	e5c46045 	strb	r6, [r4, #69]	; 0x45
 5100edc:	eaffffd3 	b	5100e30 <prvNotifyQueueSetContainer+0x38>
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
 5100ee0:	e30d0a74 	movw	r0, #55924	; 0xda74
 5100ee4:	e3003900 	movw	r3, #2304	; 0x900
 5100ee8:	e3001cf8 	movw	r1, #3320	; 0xcf8
 5100eec:	e3403511 	movt	r3, #1297	; 0x511
 5100ef0:	e3400512 	movt	r0, #1298	; 0x512
 5100ef4:	e12fff33 	blx	r3
 5100ef8:	eaffffc4 	b	5100e10 <prvNotifyQueueSetContainer+0x18>
                prvIncrementQueueTxLock( pxQueueSetContainer, cTxLock );
 5100efc:	e30d0a74 	movw	r0, #55924	; 0xda74
 5100f00:	e3003900 	movw	r3, #2304	; 0x900
 5100f04:	e3001d19 	movw	r1, #3353	; 0xd19
 5100f08:	e3403511 	movt	r3, #1297	; 0x511
 5100f0c:	e3400512 	movt	r0, #1298	; 0x512
 5100f10:	e12fff33 	blx	r3
 5100f14:	eaffffed 	b	5100ed0 <prvNotifyQueueSetContainer+0xd8>

05100f18 <prvUnlockQueue>:
{
 5100f18:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    taskENTER_CRITICAL();
 5100f1c:	e30c9930 	movw	r9, #51504	; 0xc930
{
 5100f20:	e1a05000 	mov	r5, r0
    taskENTER_CRITICAL();
 5100f24:	e3409510 	movt	r9, #1296	; 0x510
 5100f28:	e12fff39 	blx	r9
        int8_t cTxLock = pxQueue->cTxLock;
 5100f2c:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
 5100f30:	e6af4073 	sxtb	r4, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 5100f34:	e3540000 	cmp	r4, #0
 5100f38:	da00001a 	ble	5100fa8 <prvUnlockQueue+0x90>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5100f3c:	e30668d0 	movw	r6, #26832	; 0x68d0
                        vTaskMissedYield();
 5100f40:	e3067e14 	movw	r7, #28180	; 0x6e14
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5100f44:	e2858024 	add	r8, r5, #36	; 0x24
 5100f48:	e3406510 	movt	r6, #1296	; 0x510
                        vTaskMissedYield();
 5100f4c:	e3407510 	movt	r7, #1296	; 0x510
 5100f50:	ea000007 	b	5100f74 <prvUnlockQueue+0x5c>
                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 5100f54:	ebffffa7 	bl	5100df8 <prvNotifyQueueSetContainer>
 5100f58:	e3500000 	cmp	r0, #0
 5100f5c:	1a00000f 	bne	5100fa0 <prvUnlockQueue+0x88>
            --cTxLock;
 5100f60:	e2443001 	sub	r3, r4, #1
 5100f64:	e6ef2073 	uxtb	r2, r3
        while( cTxLock > queueLOCKED_UNMODIFIED )
 5100f68:	e3520000 	cmp	r2, #0
 5100f6c:	e6af4073 	sxtb	r4, r3
 5100f70:	0a00000c 	beq	5100fa8 <prvUnlockQueue+0x90>
                if( pxQueue->pxQueueSetContainer != NULL )
 5100f74:	e5953048 	ldr	r3, [r5, #72]	; 0x48
                    if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 5100f78:	e1a00005 	mov	r0, r5
                if( pxQueue->pxQueueSetContainer != NULL )
 5100f7c:	e3530000 	cmp	r3, #0
 5100f80:	1afffff3 	bne	5100f54 <prvUnlockQueue+0x3c>
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5100f84:	e5953024 	ldr	r3, [r5, #36]	; 0x24
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5100f88:	e1a00008 	mov	r0, r8
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5100f8c:	e3530000 	cmp	r3, #0
 5100f90:	0a000004 	beq	5100fa8 <prvUnlockQueue+0x90>
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5100f94:	e12fff36 	blx	r6
 5100f98:	e3500000 	cmp	r0, #0
 5100f9c:	0affffef 	beq	5100f60 <prvUnlockQueue+0x48>
                        vTaskMissedYield();
 5100fa0:	e12fff37 	blx	r7
 5100fa4:	eaffffed 	b	5100f60 <prvUnlockQueue+0x48>
    taskEXIT_CRITICAL();
 5100fa8:	e30c8988 	movw	r8, #51592	; 0xc988
        pxQueue->cTxLock = queueUNLOCKED;
 5100fac:	e3e03000 	mvn	r3, #0
    taskEXIT_CRITICAL();
 5100fb0:	e3408510 	movt	r8, #1296	; 0x510
        pxQueue->cTxLock = queueUNLOCKED;
 5100fb4:	e5c53045 	strb	r3, [r5, #69]	; 0x45
    taskEXIT_CRITICAL();
 5100fb8:	e12fff38 	blx	r8
    taskENTER_CRITICAL();
 5100fbc:	e12fff39 	blx	r9
        int8_t cRxLock = pxQueue->cRxLock;
 5100fc0:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
 5100fc4:	e6af4073 	sxtb	r4, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 5100fc8:	e3540000 	cmp	r4, #0
 5100fcc:	da000013 	ble	5101020 <prvUnlockQueue+0x108>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5100fd0:	e30668d0 	movw	r6, #26832	; 0x68d0
                    vTaskMissedYield();
 5100fd4:	e3069e14 	movw	r9, #28180	; 0x6e14
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5100fd8:	e2857010 	add	r7, r5, #16
 5100fdc:	e3406510 	movt	r6, #1296	; 0x510
                    vTaskMissedYield();
 5100fe0:	e3409510 	movt	r9, #1296	; 0x510
 5100fe4:	ea000004 	b	5100ffc <prvUnlockQueue+0xe4>
                --cRxLock;
 5100fe8:	e2443001 	sub	r3, r4, #1
 5100fec:	e6ef2073 	uxtb	r2, r3
        while( cRxLock > queueLOCKED_UNMODIFIED )
 5100ff0:	e3520000 	cmp	r2, #0
 5100ff4:	e6af4073 	sxtb	r4, r3
 5100ff8:	0a000008 	beq	5101020 <prvUnlockQueue+0x108>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5100ffc:	e5953010 	ldr	r3, [r5, #16]
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5101000:	e1a00007 	mov	r0, r7
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5101004:	e3530000 	cmp	r3, #0
 5101008:	0a000004 	beq	5101020 <prvUnlockQueue+0x108>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 510100c:	e12fff36 	blx	r6
 5101010:	e3500000 	cmp	r0, #0
 5101014:	0afffff3 	beq	5100fe8 <prvUnlockQueue+0xd0>
                    vTaskMissedYield();
 5101018:	e12fff39 	blx	r9
 510101c:	eafffff1 	b	5100fe8 <prvUnlockQueue+0xd0>
        pxQueue->cRxLock = queueUNLOCKED;
 5101020:	e3e03000 	mvn	r3, #0
 5101024:	e5c53044 	strb	r3, [r5, #68]	; 0x44
    taskEXIT_CRITICAL();
 5101028:	e12fff38 	blx	r8
}
 510102c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

05101030 <xQueueGenericSend>:
{
 5101030:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    configASSERT( pxQueue );
 5101034:	e2504000 	subs	r4, r0, #0
{
 5101038:	e24dd01c 	sub	sp, sp, #28
 510103c:	e58d1008 	str	r1, [sp, #8]
 5101040:	e58d3004 	str	r3, [sp, #4]
 5101044:	e58d200c 	str	r2, [sp, #12]
    configASSERT( pxQueue );
 5101048:	0a00009e 	beq	51012c8 <xQueueGenericSend+0x298>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 510104c:	e59d3008 	ldr	r3, [sp, #8]
 5101050:	e3530000 	cmp	r3, #0
 5101054:	0a000074 	beq	510122c <xQueueGenericSend+0x1fc>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 5101058:	e59d3004 	ldr	r3, [sp, #4]
 510105c:	e3530002 	cmp	r3, #2
 5101060:	0a000067 	beq	5101204 <xQueueGenericSend+0x1d4>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101064:	e3063e28 	movw	r3, #28200	; 0x6e28
 5101068:	e3403510 	movt	r3, #1296	; 0x510
 510106c:	e12fff33 	blx	r3
 5101070:	e3500000 	cmp	r0, #0
 5101074:	1a000002 	bne	5101084 <xQueueGenericSend+0x54>
 5101078:	e59d300c 	ldr	r3, [sp, #12]
 510107c:	e3530000 	cmp	r3, #0
 5101080:	1a000080 	bne	5101288 <xQueueGenericSend+0x258>
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5101084:	e59d3004 	ldr	r3, [sp, #4]
 5101088:	e30c5930 	movw	r5, #51504	; 0xc930
 510108c:	e30c6988 	movw	r6, #51592	; 0xc988
                    vTaskInternalSetTimeOutState( &xTimeOut );
 5101090:	e307b1ec 	movw	fp, #29164	; 0x71ec
        vTaskSuspendAll();
 5101094:	e30592a0 	movw	r9, #21152	; 0x52a0
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5101098:	e243a002 	sub	sl, r3, #2
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 510109c:	e3058b8c 	movw	r8, #23436	; 0x5b8c
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 51010a0:	e16faf1a 	clz	sl, sl
 51010a4:	e3a07000 	mov	r7, #0
 51010a8:	e3405510 	movt	r5, #1296	; 0x510
 51010ac:	e1a0a2aa 	lsr	sl, sl, #5
 51010b0:	e3406510 	movt	r6, #1296	; 0x510
                    vTaskInternalSetTimeOutState( &xTimeOut );
 51010b4:	e340b510 	movt	fp, #1296	; 0x510
        vTaskSuspendAll();
 51010b8:	e3409510 	movt	r9, #1296	; 0x510
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 51010bc:	e3408510 	movt	r8, #1296	; 0x510
 51010c0:	ea000006 	b	51010e0 <xQueueGenericSend+0xb0>
    taskEXIT_CRITICAL();
 51010c4:	e12fff36 	blx	r6
                prvUnlockQueue( pxQueue );
 51010c8:	e1a00004 	mov	r0, r4
 51010cc:	ebffff91 	bl	5100f18 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 51010d0:	e3053efc 	movw	r3, #24316	; 0x5efc
 51010d4:	e3403510 	movt	r3, #1296	; 0x510
 51010d8:	e12fff33 	blx	r3
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 51010dc:	e3a07001 	mov	r7, #1
        taskENTER_CRITICAL();
 51010e0:	e12fff35 	blx	r5
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 51010e4:	e5941038 	ldr	r1, [r4, #56]	; 0x38
 51010e8:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
 51010ec:	e1510002 	cmp	r1, r2
 51010f0:	21a0300a 	movcs	r3, sl
 51010f4:	338a3001 	orrcc	r3, sl, #1
 51010f8:	e3530000 	cmp	r3, #0
 51010fc:	1a00002f 	bne	51011c0 <xQueueGenericSend+0x190>
                if( xTicksToWait == ( TickType_t ) 0 )
 5101100:	e59d000c 	ldr	r0, [sp, #12]
 5101104:	e3500000 	cmp	r0, #0
 5101108:	0a000051 	beq	5101254 <xQueueGenericSend+0x224>
                else if( xEntryTimeSet == pdFALSE )
 510110c:	e3570000 	cmp	r7, #0
                    vTaskInternalSetTimeOutState( &xTimeOut );
 5101110:	e28d7010 	add	r7, sp, #16
                else if( xEntryTimeSet == pdFALSE )
 5101114:	0a000026 	beq	51011b4 <xQueueGenericSend+0x184>
        taskEXIT_CRITICAL();
 5101118:	e12fff36 	blx	r6
        vTaskSuspendAll();
 510111c:	e12fff39 	blx	r9
        prvLockQueue( pxQueue );
 5101120:	e12fff35 	blx	r5
 5101124:	e5d43044 	ldrb	r3, [r4, #68]	; 0x44
 5101128:	e35300ff 	cmp	r3, #255	; 0xff
 510112c:	03a03000 	moveq	r3, #0
 5101130:	05c43044 	strbeq	r3, [r4, #68]	; 0x44
 5101134:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
 5101138:	e35300ff 	cmp	r3, #255	; 0xff
 510113c:	03a03000 	moveq	r3, #0
 5101140:	05c43045 	strbeq	r3, [r4, #69]	; 0x45
 5101144:	e12fff36 	blx	r6
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 5101148:	e1a00007 	mov	r0, r7
 510114c:	e28d100c 	add	r1, sp, #12
 5101150:	e12fff38 	blx	r8
 5101154:	e3500000 	cmp	r0, #0
 5101158:	1a000042 	bne	5101268 <xQueueGenericSend+0x238>
    taskENTER_CRITICAL();
 510115c:	e12fff35 	blx	r5
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 5101160:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5101164:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5101168:	e1520003 	cmp	r2, r3
 510116c:	1affffd4 	bne	51010c4 <xQueueGenericSend+0x94>
    taskEXIT_CRITICAL();
 5101170:	e12fff36 	blx	r6
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 5101174:	e3063718 	movw	r3, #26392	; 0x6718
 5101178:	e59d100c 	ldr	r1, [sp, #12]
 510117c:	e3403510 	movt	r3, #1296	; 0x510
 5101180:	e2840010 	add	r0, r4, #16
 5101184:	e12fff33 	blx	r3
                prvUnlockQueue( pxQueue );
 5101188:	e1a00004 	mov	r0, r4
 510118c:	ebffff61 	bl	5100f18 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 5101190:	e3053efc 	movw	r3, #24316	; 0x5efc
 5101194:	e3403510 	movt	r3, #1296	; 0x510
 5101198:	e12fff33 	blx	r3
 510119c:	e3500000 	cmp	r0, #0
 51011a0:	1affffcd 	bne	51010dc <xQueueGenericSend+0xac>
                    taskYIELD_WITHIN_API();
 51011a4:	e3003000 	movw	r3, #0
 51011a8:	e3403511 	movt	r3, #1297	; 0x511
 51011ac:	e12fff33 	blx	r3
 51011b0:	eaffffc9 	b	51010dc <xQueueGenericSend+0xac>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 51011b4:	e1a00007 	mov	r0, r7
 51011b8:	e12fff3b 	blx	fp
                    xEntryTimeSet = pdTRUE;
 51011bc:	eaffffd5 	b	5101118 <xQueueGenericSend+0xe8>
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 51011c0:	e59d2004 	ldr	r2, [sp, #4]
 51011c4:	e1a00004 	mov	r0, r4
 51011c8:	e59d1008 	ldr	r1, [sp, #8]
                    const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 51011cc:	e5945038 	ldr	r5, [r4, #56]	; 0x38
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 51011d0:	ebfffece 	bl	5100d10 <prvCopyDataToQueue>
                    if( pxQueue->pxQueueSetContainer != NULL )
 51011d4:	e5943048 	ldr	r3, [r4, #72]	; 0x48
 51011d8:	e3530000 	cmp	r3, #0
 51011dc:	0a000030 	beq	51012a4 <xQueueGenericSend+0x274>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
 51011e0:	e3550000 	cmp	r5, #0
 51011e4:	03a0a000 	moveq	sl, #0
 51011e8:	120aa001 	andne	sl, sl, #1
 51011ec:	e35a0000 	cmp	sl, #0
 51011f0:	0a00003b 	beq	51012e4 <xQueueGenericSend+0x2b4>
                taskEXIT_CRITICAL();
 51011f4:	e12fff36 	blx	r6
                return pdPASS;
 51011f8:	e3a00001 	mov	r0, #1
}
 51011fc:	e28dd01c 	add	sp, sp, #28
 5101200:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 5101204:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5101208:	e3530001 	cmp	r3, #1
 510120c:	0affff94 	beq	5101064 <xQueueGenericSend+0x34>
 5101210:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101214:	e3003900 	movw	r3, #2304	; 0x900
 5101218:	e3a01fee 	mov	r1, #952	; 0x3b8
 510121c:	e3403511 	movt	r3, #1297	; 0x511
 5101220:	e3400512 	movt	r0, #1298	; 0x512
 5101224:	e12fff33 	blx	r3
 5101228:	eaffff8d 	b	5101064 <xQueueGenericSend+0x34>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 510122c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 5101230:	e3530000 	cmp	r3, #0
 5101234:	0affff87 	beq	5101058 <xQueueGenericSend+0x28>
 5101238:	e30d0a74 	movw	r0, #55924	; 0xda74
 510123c:	e3003900 	movw	r3, #2304	; 0x900
 5101240:	e30013b7 	movw	r1, #951	; 0x3b7
 5101244:	e3403511 	movt	r3, #1297	; 0x511
 5101248:	e3400512 	movt	r0, #1298	; 0x512
 510124c:	e12fff33 	blx	r3
 5101250:	eaffff80 	b	5101058 <xQueueGenericSend+0x28>
 5101254:	e58d0004 	str	r0, [sp, #4]
                    taskEXIT_CRITICAL();
 5101258:	e12fff36 	blx	r6
                    return errQUEUE_FULL;
 510125c:	e59d0004 	ldr	r0, [sp, #4]
}
 5101260:	e28dd01c 	add	sp, sp, #28
 5101264:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            prvUnlockQueue( pxQueue );
 5101268:	e1a00004 	mov	r0, r4
 510126c:	ebffff29 	bl	5100f18 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 5101270:	e3053efc 	movw	r3, #24316	; 0x5efc
 5101274:	e3403510 	movt	r3, #1296	; 0x510
 5101278:	e12fff33 	blx	r3
            return errQUEUE_FULL;
 510127c:	e3a00000 	mov	r0, #0
}
 5101280:	e28dd01c 	add	sp, sp, #28
 5101284:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101288:	e30d0a74 	movw	r0, #55924	; 0xda74
 510128c:	e3003900 	movw	r3, #2304	; 0x900
 5101290:	e30013bb 	movw	r1, #955	; 0x3bb
 5101294:	e3403511 	movt	r3, #1297	; 0x511
 5101298:	e3400512 	movt	r0, #1298	; 0x512
 510129c:	e12fff33 	blx	r3
 51012a0:	eaffff77 	b	5101084 <xQueueGenericSend+0x54>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 51012a4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
 51012a8:	e3530000 	cmp	r3, #0
 51012ac:	1a00000f 	bne	51012f0 <xQueueGenericSend+0x2c0>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 51012b0:	e3500000 	cmp	r0, #0
 51012b4:	0affffce 	beq	51011f4 <xQueueGenericSend+0x1c4>
                            queueYIELD_IF_USING_PREEMPTION();
 51012b8:	e3003000 	movw	r3, #0
 51012bc:	e3403511 	movt	r3, #1297	; 0x511
 51012c0:	e12fff33 	blx	r3
 51012c4:	eaffffca 	b	51011f4 <xQueueGenericSend+0x1c4>
    configASSERT( pxQueue );
 51012c8:	e30d0a74 	movw	r0, #55924	; 0xda74
 51012cc:	e3003900 	movw	r3, #2304	; 0x900
 51012d0:	e30013b6 	movw	r1, #950	; 0x3b6
 51012d4:	e3403511 	movt	r3, #1297	; 0x511
 51012d8:	e3400512 	movt	r0, #1298	; 0x512
 51012dc:	e12fff33 	blx	r3
 51012e0:	eaffff59 	b	510104c <xQueueGenericSend+0x1c>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 51012e4:	e1a00004 	mov	r0, r4
 51012e8:	ebfffec2 	bl	5100df8 <prvNotifyQueueSetContainer>
 51012ec:	eaffffef 	b	51012b0 <xQueueGenericSend+0x280>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 51012f0:	e30638d0 	movw	r3, #26832	; 0x68d0
 51012f4:	e2840024 	add	r0, r4, #36	; 0x24
 51012f8:	e3403510 	movt	r3, #1296	; 0x510
 51012fc:	e12fff33 	blx	r3
 5101300:	e3500000 	cmp	r0, #0
 5101304:	0affffba 	beq	51011f4 <xQueueGenericSend+0x1c4>
 5101308:	eaffffea 	b	51012b8 <xQueueGenericSend+0x288>

0510130c <xQueuePeek>:
{
 510130c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    configASSERT( ( pxQueue ) );
 5101310:	e2504000 	subs	r4, r0, #0
{
 5101314:	e24dd01c 	sub	sp, sp, #28
 5101318:	e58d1004 	str	r1, [sp, #4]
 510131c:	e58d200c 	str	r2, [sp, #12]
    configASSERT( ( pxQueue ) );
 5101320:	0a00006e 	beq	51014e0 <xQueuePeek+0x1d4>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101324:	e59d3004 	ldr	r3, [sp, #4]
 5101328:	e3530000 	cmp	r3, #0
 510132c:	0a00005a 	beq	510149c <xQueuePeek+0x190>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101330:	e3063e28 	movw	r3, #28200	; 0x6e28
 5101334:	e3403510 	movt	r3, #1296	; 0x510
 5101338:	e12fff33 	blx	r3
 510133c:	e3500000 	cmp	r0, #0
 5101340:	1a000002 	bne	5101350 <xQueuePeek+0x44>
 5101344:	e59d300c 	ldr	r3, [sp, #12]
 5101348:	e3530000 	cmp	r3, #0
 510134c:	1a00005c 	bne	51014c4 <xQueuePeek+0x1b8>
        taskENTER_CRITICAL();
 5101350:	e30c6930 	movw	r6, #51504	; 0xc930
 5101354:	e3406510 	movt	r6, #1296	; 0x510
 5101358:	e12fff36 	blx	r6
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 510135c:	e594a038 	ldr	sl, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 5101360:	e35a0000 	cmp	sl, #0
 5101364:	130c5988 	movwne	r5, #51592	; 0xc988
 5101368:	13405510 	movtne	r5, #1296	; 0x510
 510136c:	1a000062 	bne	51014fc <xQueuePeek+0x1f0>
                if( xTicksToWait == ( TickType_t ) 0 )
 5101370:	e59d300c 	ldr	r3, [sp, #12]
 5101374:	e3530000 	cmp	r3, #0
 5101378:	0a00007f 	beq	510157c <xQueuePeek+0x270>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 510137c:	e30731ec 	movw	r3, #29164	; 0x71ec
 5101380:	e28d0010 	add	r0, sp, #16
 5101384:	e30c5988 	movw	r5, #51592	; 0xc988
 5101388:	e3403510 	movt	r3, #1296	; 0x510
 510138c:	e12fff33 	blx	r3
                    xEntryTimeSet = pdTRUE;
 5101390:	e30592a0 	movw	r9, #21152	; 0x52a0
 5101394:	e3058b8c 	movw	r8, #23436	; 0x5b8c
 5101398:	e3057efc 	movw	r7, #24316	; 0x5efc
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 510139c:	e306b718 	movw	fp, #26392	; 0x6718
                    taskYIELD_WITHIN_API();
 51013a0:	e3003000 	movw	r3, #0
 51013a4:	e3403511 	movt	r3, #1297	; 0x511
 51013a8:	e3405510 	movt	r5, #1296	; 0x510
 51013ac:	e3409510 	movt	r9, #1296	; 0x510
 51013b0:	e3408510 	movt	r8, #1296	; 0x510
 51013b4:	e3407510 	movt	r7, #1296	; 0x510
 51013b8:	e58d3008 	str	r3, [sp, #8]
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 51013bc:	e340b510 	movt	fp, #1296	; 0x510
        taskEXIT_CRITICAL();
 51013c0:	e12fff35 	blx	r5
        vTaskSuspendAll();
 51013c4:	e12fff39 	blx	r9
        prvLockQueue( pxQueue );
 51013c8:	e12fff36 	blx	r6
 51013cc:	e5d43044 	ldrb	r3, [r4, #68]	; 0x44
 51013d0:	e35300ff 	cmp	r3, #255	; 0xff
 51013d4:	05c4a044 	strbeq	sl, [r4, #68]	; 0x44
 51013d8:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
 51013dc:	e35300ff 	cmp	r3, #255	; 0xff
 51013e0:	05c4a045 	strbeq	sl, [r4, #69]	; 0x45
 51013e4:	e12fff35 	blx	r5
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 51013e8:	e28d100c 	add	r1, sp, #12
 51013ec:	e28d0010 	add	r0, sp, #16
 51013f0:	e12fff38 	blx	r8
 51013f4:	e3500000 	cmp	r0, #0
 51013f8:	1a000012 	bne	5101448 <xQueuePeek+0x13c>
    taskENTER_CRITICAL();
 51013fc:	e12fff36 	blx	r6
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 5101400:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5101404:	e3530000 	cmp	r3, #0
 5101408:	0a000017 	beq	510146c <xQueuePeek+0x160>
    taskEXIT_CRITICAL();
 510140c:	e12fff35 	blx	r5
                prvUnlockQueue( pxQueue );
 5101410:	e1a00004 	mov	r0, r4
 5101414:	ebfffebf 	bl	5100f18 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 5101418:	e12fff37 	blx	r7
        taskENTER_CRITICAL();
 510141c:	e12fff36 	blx	r6
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101420:	e5943038 	ldr	r3, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 5101424:	e3530000 	cmp	r3, #0
 5101428:	1a000033 	bne	51014fc <xQueuePeek+0x1f0>
                if( xTicksToWait == ( TickType_t ) 0 )
 510142c:	e59d300c 	ldr	r3, [sp, #12]
 5101430:	e3530000 	cmp	r3, #0
 5101434:	1affffe1 	bne	51013c0 <xQueuePeek+0xb4>
                    taskEXIT_CRITICAL();
 5101438:	e12fff35 	blx	r5
                    return errQUEUE_EMPTY;
 510143c:	e3a00000 	mov	r0, #0
}
 5101440:	e28dd01c 	add	sp, sp, #28
 5101444:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            prvUnlockQueue( pxQueue );
 5101448:	e1a00004 	mov	r0, r4
 510144c:	ebfffeb1 	bl	5100f18 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 5101450:	e12fff37 	blx	r7
    taskENTER_CRITICAL();
 5101454:	e12fff36 	blx	r6
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 5101458:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 510145c:	e3530000 	cmp	r3, #0
 5101460:	0afffff4 	beq	5101438 <xQueuePeek+0x12c>
    taskEXIT_CRITICAL();
 5101464:	e12fff35 	blx	r5
 5101468:	eaffffeb 	b	510141c <xQueuePeek+0x110>
 510146c:	e12fff35 	blx	r5
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 5101470:	e59d100c 	ldr	r1, [sp, #12]
 5101474:	e2840024 	add	r0, r4, #36	; 0x24
 5101478:	e12fff3b 	blx	fp
                prvUnlockQueue( pxQueue );
 510147c:	e1a00004 	mov	r0, r4
 5101480:	ebfffea4 	bl	5100f18 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 5101484:	e12fff37 	blx	r7
 5101488:	e3500000 	cmp	r0, #0
 510148c:	1affffe2 	bne	510141c <xQueuePeek+0x110>
                    taskYIELD_WITHIN_API();
 5101490:	e59d3008 	ldr	r3, [sp, #8]
 5101494:	e12fff33 	blx	r3
        taskENTER_CRITICAL();
 5101498:	eaffffdf 	b	510141c <xQueuePeek+0x110>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 510149c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 51014a0:	e3530000 	cmp	r3, #0
 51014a4:	0affffa1 	beq	5101330 <xQueuePeek+0x24>
 51014a8:	e30d0a74 	movw	r0, #55924	; 0xda74
 51014ac:	e3003900 	movw	r3, #2304	; 0x900
 51014b0:	e3001765 	movw	r1, #1893	; 0x765
 51014b4:	e3403511 	movt	r3, #1297	; 0x511
 51014b8:	e3400512 	movt	r0, #1298	; 0x512
 51014bc:	e12fff33 	blx	r3
 51014c0:	eaffff9a 	b	5101330 <xQueuePeek+0x24>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 51014c4:	e30d0a74 	movw	r0, #55924	; 0xda74
 51014c8:	e3003900 	movw	r3, #2304	; 0x900
 51014cc:	e300176a 	movw	r1, #1898	; 0x76a
 51014d0:	e3403511 	movt	r3, #1297	; 0x511
 51014d4:	e3400512 	movt	r0, #1298	; 0x512
 51014d8:	e12fff33 	blx	r3
 51014dc:	eaffff9b 	b	5101350 <xQueuePeek+0x44>
    configASSERT( ( pxQueue ) );
 51014e0:	e30d0a74 	movw	r0, #55924	; 0xda74
 51014e4:	e3003900 	movw	r3, #2304	; 0x900
 51014e8:	e3001761 	movw	r1, #1889	; 0x761
 51014ec:	e3403511 	movt	r3, #1297	; 0x511
 51014f0:	e3400512 	movt	r0, #1298	; 0x512
 51014f4:	e12fff33 	blx	r3
 51014f8:	eaffff89 	b	5101324 <xQueuePeek+0x18>
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 51014fc:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 5101500:	e594600c 	ldr	r6, [r4, #12]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 5101504:	e3520000 	cmp	r2, #0
 5101508:	0a000009 	beq	5101534 <xQueuePeek+0x228>
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 510150c:	e5943008 	ldr	r3, [r4, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101510:	e0861002 	add	r1, r6, r2
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101514:	e59d0004 	ldr	r0, [sp, #4]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101518:	e584100c 	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 510151c:	e1510003 	cmp	r1, r3
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101520:	e3093ca1 	movw	r3, #40097	; 0x9ca1
 5101524:	e3403511 	movt	r3, #1297	; 0x511
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 5101528:	25941000 	ldrcs	r1, [r4]
 510152c:	2584100c 	strcs	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101530:	e12fff33 	blx	r3
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5101534:	e5943024 	ldr	r3, [r4, #36]	; 0x24
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 5101538:	e584600c 	str	r6, [r4, #12]
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 510153c:	e3530000 	cmp	r3, #0
 5101540:	1a000003 	bne	5101554 <xQueuePeek+0x248>
                taskEXIT_CRITICAL();
 5101544:	e12fff35 	blx	r5
                return pdPASS;
 5101548:	e3a00001 	mov	r0, #1
}
 510154c:	e28dd01c 	add	sp, sp, #28
 5101550:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5101554:	e30638d0 	movw	r3, #26832	; 0x68d0
 5101558:	e2840024 	add	r0, r4, #36	; 0x24
 510155c:	e3403510 	movt	r3, #1296	; 0x510
 5101560:	e12fff33 	blx	r3
 5101564:	e3500000 	cmp	r0, #0
 5101568:	0afffff5 	beq	5101544 <xQueuePeek+0x238>
                        queueYIELD_IF_USING_PREEMPTION();
 510156c:	e3003000 	movw	r3, #0
 5101570:	e3403511 	movt	r3, #1297	; 0x511
 5101574:	e12fff33 	blx	r3
 5101578:	eafffff1 	b	5101544 <xQueuePeek+0x238>
 510157c:	e30c5988 	movw	r5, #51592	; 0xc988
 5101580:	e3405510 	movt	r5, #1296	; 0x510
 5101584:	eaffffab 	b	5101438 <xQueuePeek+0x12c>

05101588 <xQueuePeekFromISR>:
{
 5101588:	e92d4070 	push	{r4, r5, r6, lr}
 510158c:	e1a05001 	mov	r5, r1
    configASSERT( pxQueue );
 5101590:	e2504000 	subs	r4, r0, #0
 5101594:	0a000023 	beq	5101628 <xQueuePeekFromISR+0xa0>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101598:	e3550000 	cmp	r5, #0
 510159c:	0a000007 	beq	51015c0 <xQueuePeekFromISR+0x38>
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 51015a0:	e5942040 	ldr	r2, [r4, #64]	; 0x40
 51015a4:	e3520000 	cmp	r2, #0
 51015a8:	0a000007 	beq	51015cc <xQueuePeekFromISR+0x44>
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 51015ac:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 51015b0:	e3530000 	cmp	r3, #0
 51015b4:	1a000022 	bne	5101644 <xQueuePeekFromISR+0xbc>
            xReturn = pdFAIL;
 51015b8:	e3a00000 	mov	r0, #0
 51015bc:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 51015c0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 51015c4:	e3530000 	cmp	r3, #0
 51015c8:	1a00000f 	bne	510160c <xQueuePeekFromISR+0x84>
    configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
 51015cc:	e30d0a74 	movw	r0, #55924	; 0xda74
 51015d0:	e3003900 	movw	r3, #2304	; 0x900
 51015d4:	e3001863 	movw	r1, #2147	; 0x863
 51015d8:	e3403511 	movt	r3, #1297	; 0x511
 51015dc:	e3400512 	movt	r0, #1298	; 0x512
 51015e0:	e12fff33 	blx	r3
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
 51015e4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 51015e8:	e3530000 	cmp	r3, #0
 51015ec:	0afffff1 	beq	51015b8 <xQueuePeekFromISR+0x30>
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 51015f0:	e5942040 	ldr	r2, [r4, #64]	; 0x40
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 51015f4:	e594600c 	ldr	r6, [r4, #12]
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 51015f8:	e3520000 	cmp	r2, #0
 51015fc:	1a000011 	bne	5101648 <xQueuePeekFromISR+0xc0>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
 5101600:	e584600c 	str	r6, [r4, #12]
            xReturn = pdPASS;
 5101604:	e3a00001 	mov	r0, #1
}
 5101608:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 510160c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101610:	e3003900 	movw	r3, #2304	; 0x900
 5101614:	e3001862 	movw	r1, #2146	; 0x862
 5101618:	e3403511 	movt	r3, #1297	; 0x511
 510161c:	e3400512 	movt	r0, #1298	; 0x512
 5101620:	e12fff33 	blx	r3
 5101624:	eaffffdd 	b	51015a0 <xQueuePeekFromISR+0x18>
    configASSERT( pxQueue );
 5101628:	e30d0a74 	movw	r0, #55924	; 0xda74
 510162c:	e3003900 	movw	r3, #2304	; 0x900
 5101630:	e3001861 	movw	r1, #2145	; 0x861
 5101634:	e3403511 	movt	r3, #1297	; 0x511
 5101638:	e3400512 	movt	r0, #1298	; 0x512
 510163c:	e12fff33 	blx	r3
 5101640:	eaffffd4 	b	5101598 <xQueuePeekFromISR+0x10>
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
 5101644:	e594600c 	ldr	r6, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 5101648:	e5943008 	ldr	r3, [r4, #8]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 510164c:	e0861002 	add	r1, r6, r2
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101650:	e1a00005 	mov	r0, r5
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101654:	e584100c 	str	r1, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 5101658:	e1510003 	cmp	r1, r3
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 510165c:	e3093ca1 	movw	r3, #40097	; 0x9ca1
 5101660:	e3403511 	movt	r3, #1297	; 0x511
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 5101664:	25941000 	ldrcs	r1, [r4]
 5101668:	2584100c 	strcs	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 510166c:	e12fff33 	blx	r3
 5101670:	eaffffe2 	b	5101600 <xQueuePeekFromISR+0x78>

05101674 <xQueueReceive>:
{
 5101674:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    configASSERT( ( pxQueue ) );
 5101678:	e2504000 	subs	r4, r0, #0
{
 510167c:	e24dd01c 	sub	sp, sp, #28
 5101680:	e58d1008 	str	r1, [sp, #8]
 5101684:	e58d200c 	str	r2, [sp, #12]
    configASSERT( ( pxQueue ) );
 5101688:	0a00006f 	beq	510184c <xQueueReceive+0x1d8>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 510168c:	e59d3008 	ldr	r3, [sp, #8]
 5101690:	e3530000 	cmp	r3, #0
 5101694:	0a00005b 	beq	5101808 <xQueueReceive+0x194>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101698:	e3063e28 	movw	r3, #28200	; 0x6e28
 510169c:	e3403510 	movt	r3, #1296	; 0x510
 51016a0:	e12fff33 	blx	r3
 51016a4:	e3500000 	cmp	r0, #0
 51016a8:	1a000002 	bne	51016b8 <xQueueReceive+0x44>
 51016ac:	e59d300c 	ldr	r3, [sp, #12]
 51016b0:	e3530000 	cmp	r3, #0
 51016b4:	1a00005d 	bne	5101830 <xQueueReceive+0x1bc>
        taskENTER_CRITICAL();
 51016b8:	e30c6930 	movw	r6, #51504	; 0xc930
 51016bc:	e3406510 	movt	r6, #1296	; 0x510
 51016c0:	e12fff36 	blx	r6
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 51016c4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 51016c8:	e3530000 	cmp	r3, #0
 51016cc:	130c5988 	movwne	r5, #51592	; 0xc988
 51016d0:	13405510 	movtne	r5, #1296	; 0x510
 51016d4:	1a000063 	bne	5101868 <xQueueReceive+0x1f4>
                if( xTicksToWait == ( TickType_t ) 0 )
 51016d8:	e59d200c 	ldr	r2, [sp, #12]
 51016dc:	e3520000 	cmp	r2, #0
 51016e0:	0a000083 	beq	51018f4 <xQueueReceive+0x280>
        prvLockQueue( pxQueue );
 51016e4:	e58d3004 	str	r3, [sp, #4]
                    vTaskInternalSetTimeOutState( &xTimeOut );
 51016e8:	e30731ec 	movw	r3, #29164	; 0x71ec
 51016ec:	e28d0010 	add	r0, sp, #16
 51016f0:	e30c5988 	movw	r5, #51592	; 0xc988
 51016f4:	e3403510 	movt	r3, #1296	; 0x510
 51016f8:	e12fff33 	blx	r3
                    xEntryTimeSet = pdTRUE;
 51016fc:	e30592a0 	movw	r9, #21152	; 0x52a0
 5101700:	e3058b8c 	movw	r8, #23436	; 0x5b8c
 5101704:	e3057efc 	movw	r7, #24316	; 0x5efc
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 5101708:	e306a718 	movw	sl, #26392	; 0x6718
                    taskYIELD_WITHIN_API();
 510170c:	e300b000 	movw	fp, #0
 5101710:	e3405510 	movt	r5, #1296	; 0x510
 5101714:	e3409510 	movt	r9, #1296	; 0x510
 5101718:	e3408510 	movt	r8, #1296	; 0x510
 510171c:	e3407510 	movt	r7, #1296	; 0x510
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 5101720:	e340a510 	movt	sl, #1296	; 0x510
                    taskYIELD_WITHIN_API();
 5101724:	e340b511 	movt	fp, #1297	; 0x511
        taskEXIT_CRITICAL();
 5101728:	e12fff35 	blx	r5
        vTaskSuspendAll();
 510172c:	e12fff39 	blx	r9
        prvLockQueue( pxQueue );
 5101730:	e12fff36 	blx	r6
 5101734:	e5d43044 	ldrb	r3, [r4, #68]	; 0x44
 5101738:	e35300ff 	cmp	r3, #255	; 0xff
 510173c:	059d3004 	ldreq	r3, [sp, #4]
 5101740:	05c43044 	strbeq	r3, [r4, #68]	; 0x44
 5101744:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
 5101748:	e35300ff 	cmp	r3, #255	; 0xff
 510174c:	059d3004 	ldreq	r3, [sp, #4]
 5101750:	05c43045 	strbeq	r3, [r4, #69]	; 0x45
 5101754:	e12fff35 	blx	r5
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 5101758:	e28d100c 	add	r1, sp, #12
 510175c:	e28d0010 	add	r0, sp, #16
 5101760:	e12fff38 	blx	r8
 5101764:	e3500000 	cmp	r0, #0
 5101768:	1a000012 	bne	51017b8 <xQueueReceive+0x144>
    taskENTER_CRITICAL();
 510176c:	e12fff36 	blx	r6
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 5101770:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5101774:	e3530000 	cmp	r3, #0
 5101778:	0a000017 	beq	51017dc <xQueueReceive+0x168>
    taskEXIT_CRITICAL();
 510177c:	e12fff35 	blx	r5
                prvUnlockQueue( pxQueue );
 5101780:	e1a00004 	mov	r0, r4
 5101784:	ebfffde3 	bl	5100f18 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 5101788:	e12fff37 	blx	r7
        taskENTER_CRITICAL();
 510178c:	e12fff36 	blx	r6
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101790:	e5943038 	ldr	r3, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 5101794:	e3530000 	cmp	r3, #0
 5101798:	1a000032 	bne	5101868 <xQueueReceive+0x1f4>
                if( xTicksToWait == ( TickType_t ) 0 )
 510179c:	e59d300c 	ldr	r3, [sp, #12]
 51017a0:	e3530000 	cmp	r3, #0
 51017a4:	1affffdf 	bne	5101728 <xQueueReceive+0xb4>
                    taskEXIT_CRITICAL();
 51017a8:	e12fff35 	blx	r5
                    return errQUEUE_EMPTY;
 51017ac:	e3a00000 	mov	r0, #0
}
 51017b0:	e28dd01c 	add	sp, sp, #28
 51017b4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            prvUnlockQueue( pxQueue );
 51017b8:	e1a00004 	mov	r0, r4
 51017bc:	ebfffdd5 	bl	5100f18 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 51017c0:	e12fff37 	blx	r7
    taskENTER_CRITICAL();
 51017c4:	e12fff36 	blx	r6
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 51017c8:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 51017cc:	e3530000 	cmp	r3, #0
 51017d0:	0afffff4 	beq	51017a8 <xQueueReceive+0x134>
    taskEXIT_CRITICAL();
 51017d4:	e12fff35 	blx	r5
 51017d8:	eaffffeb 	b	510178c <xQueueReceive+0x118>
 51017dc:	e12fff35 	blx	r5
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 51017e0:	e59d100c 	ldr	r1, [sp, #12]
 51017e4:	e2840024 	add	r0, r4, #36	; 0x24
 51017e8:	e12fff3a 	blx	sl
                prvUnlockQueue( pxQueue );
 51017ec:	e1a00004 	mov	r0, r4
 51017f0:	ebfffdc8 	bl	5100f18 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 51017f4:	e12fff37 	blx	r7
 51017f8:	e3500000 	cmp	r0, #0
 51017fc:	1affffe2 	bne	510178c <xQueueReceive+0x118>
                    taskYIELD_WITHIN_API();
 5101800:	e12fff3b 	blx	fp
        taskENTER_CRITICAL();
 5101804:	eaffffe0 	b	510178c <xQueueReceive+0x118>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101808:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 510180c:	e3530000 	cmp	r3, #0
 5101810:	0affffa0 	beq	5101698 <xQueueReceive+0x24>
 5101814:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101818:	e3003900 	movw	r3, #2304	; 0x900
 510181c:	e30015ed 	movw	r1, #1517	; 0x5ed
 5101820:	e3403511 	movt	r3, #1297	; 0x511
 5101824:	e3400512 	movt	r0, #1298	; 0x512
 5101828:	e12fff33 	blx	r3
 510182c:	eaffff99 	b	5101698 <xQueueReceive+0x24>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101830:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101834:	e3003900 	movw	r3, #2304	; 0x900
 5101838:	e30015f2 	movw	r1, #1522	; 0x5f2
 510183c:	e3403511 	movt	r3, #1297	; 0x511
 5101840:	e3400512 	movt	r0, #1298	; 0x512
 5101844:	e12fff33 	blx	r3
 5101848:	eaffff9a 	b	51016b8 <xQueueReceive+0x44>
    configASSERT( ( pxQueue ) );
 510184c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101850:	e3003900 	movw	r3, #2304	; 0x900
 5101854:	e30015e9 	movw	r1, #1513	; 0x5e9
 5101858:	e3403511 	movt	r3, #1297	; 0x511
 510185c:	e3400512 	movt	r0, #1298	; 0x512
 5101860:	e12fff33 	blx	r3
 5101864:	eaffff88 	b	510168c <xQueueReceive+0x18>
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 5101868:	e5942040 	ldr	r2, [r4, #64]	; 0x40
 510186c:	e3520000 	cmp	r2, #0
 5101870:	0a00000c 	beq	51018a8 <xQueueReceive+0x234>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101874:	e594100c 	ldr	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101878:	e3096ca1 	movw	r6, #40097	; 0x9ca1
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 510187c:	e5940008 	ldr	r0, [r4, #8]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101880:	e3406511 	movt	r6, #1297	; 0x511
 5101884:	e58d3004 	str	r3, [sp, #4]
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101888:	e0811002 	add	r1, r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 510188c:	e1510000 	cmp	r1, r0
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101890:	e584100c 	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101894:	e59d0008 	ldr	r0, [sp, #8]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 5101898:	25941000 	ldrcs	r1, [r4]
 510189c:	2584100c 	strcs	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 51018a0:	e12fff36 	blx	r6
 51018a4:	e59d3004 	ldr	r3, [sp, #4]
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 51018a8:	e5942010 	ldr	r2, [r4, #16]
                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 51018ac:	e2433001 	sub	r3, r3, #1
 51018b0:	e5843038 	str	r3, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 51018b4:	e3520000 	cmp	r2, #0
 51018b8:	1a000003 	bne	51018cc <xQueueReceive+0x258>
                taskEXIT_CRITICAL();
 51018bc:	e12fff35 	blx	r5
                return pdPASS;
 51018c0:	e3a00001 	mov	r0, #1
}
 51018c4:	e28dd01c 	add	sp, sp, #28
 51018c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 51018cc:	e30638d0 	movw	r3, #26832	; 0x68d0
 51018d0:	e2840010 	add	r0, r4, #16
 51018d4:	e3403510 	movt	r3, #1296	; 0x510
 51018d8:	e12fff33 	blx	r3
 51018dc:	e3500000 	cmp	r0, #0
 51018e0:	0afffff5 	beq	51018bc <xQueueReceive+0x248>
                        queueYIELD_IF_USING_PREEMPTION();
 51018e4:	e3003000 	movw	r3, #0
 51018e8:	e3403511 	movt	r3, #1297	; 0x511
 51018ec:	e12fff33 	blx	r3
 51018f0:	eafffff1 	b	51018bc <xQueueReceive+0x248>
 51018f4:	e30c5988 	movw	r5, #51592	; 0xc988
 51018f8:	e3405510 	movt	r5, #1296	; 0x510
 51018fc:	eaffffa9 	b	51017a8 <xQueueReceive+0x134>

05101900 <uxQueueMessagesWaiting>:
{
 5101900:	e92d4010 	push	{r4, lr}
    configASSERT( xQueue );
 5101904:	e2504000 	subs	r4, r0, #0
{
 5101908:	e24dd008 	sub	sp, sp, #8
    configASSERT( xQueue );
 510190c:	0a00000a 	beq	510193c <uxQueueMessagesWaiting+0x3c>
    taskENTER_CRITICAL();
 5101910:	e30c3930 	movw	r3, #51504	; 0xc930
 5101914:	e3403510 	movt	r3, #1296	; 0x510
 5101918:	e12fff33 	blx	r3
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 510191c:	e5940038 	ldr	r0, [r4, #56]	; 0x38
 5101920:	e58d0004 	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 5101924:	e30c3988 	movw	r3, #51592	; 0xc988
 5101928:	e3403510 	movt	r3, #1296	; 0x510
 510192c:	e12fff33 	blx	r3
}
 5101930:	e59d0004 	ldr	r0, [sp, #4]
 5101934:	e28dd008 	add	sp, sp, #8
 5101938:	e8bd8010 	pop	{r4, pc}
    configASSERT( xQueue );
 510193c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101940:	e3003900 	movw	r3, #2304	; 0x900
 5101944:	e300189b 	movw	r1, #2203	; 0x89b
 5101948:	e3403511 	movt	r3, #1297	; 0x511
 510194c:	e3400512 	movt	r0, #1298	; 0x512
 5101950:	e12fff33 	blx	r3
 5101954:	eaffffed 	b	5101910 <uxQueueMessagesWaiting+0x10>

05101958 <uxQueueSpacesAvailable>:
{
 5101958:	e92d4010 	push	{r4, lr}
    configASSERT( pxQueue );
 510195c:	e2504000 	subs	r4, r0, #0
{
 5101960:	e24dd008 	sub	sp, sp, #8
    configASSERT( pxQueue );
 5101964:	0a00000c 	beq	510199c <uxQueueSpacesAvailable+0x44>
    taskENTER_CRITICAL();
 5101968:	e30c3930 	movw	r3, #51504	; 0xc930
 510196c:	e3403510 	movt	r3, #1296	; 0x510
 5101970:	e12fff33 	blx	r3
        uxReturn = ( UBaseType_t ) ( pxQueue->uxLength - pxQueue->uxMessagesWaiting );
 5101974:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5101978:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
    taskEXIT_CRITICAL();
 510197c:	e30c3988 	movw	r3, #51592	; 0xc988
 5101980:	e3403510 	movt	r3, #1296	; 0x510
        uxReturn = ( UBaseType_t ) ( pxQueue->uxLength - pxQueue->uxMessagesWaiting );
 5101984:	e0400002 	sub	r0, r0, r2
 5101988:	e58d0004 	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 510198c:	e12fff33 	blx	r3
}
 5101990:	e59d0004 	ldr	r0, [sp, #4]
 5101994:	e28dd008 	add	sp, sp, #8
 5101998:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxQueue );
 510199c:	e30d0a74 	movw	r0, #55924	; 0xda74
 51019a0:	e3003900 	movw	r3, #2304	; 0x900
 51019a4:	e3a01e8b 	mov	r1, #2224	; 0x8b0
 51019a8:	e3403511 	movt	r3, #1297	; 0x511
 51019ac:	e3400512 	movt	r0, #1298	; 0x512
 51019b0:	e12fff33 	blx	r3
 51019b4:	eaffffeb 	b	5101968 <uxQueueSpacesAvailable+0x10>

051019b8 <vQueueDelete>:
{
 51019b8:	e92d4070 	push	{r4, r5, r6, lr}
    configASSERT( pxQueue );
 51019bc:	e2504000 	subs	r4, r0, #0
 51019c0:	0a000015 	beq	5101a1c <vQueueDelete+0x64>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 51019c4:	e30c0d78 	movw	r0, #52600	; 0xcd78
 51019c8:	e3a03000 	mov	r3, #0
 51019cc:	e3400511 	movt	r0, #1297	; 0x511
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 51019d0:	e0802183 	add	r2, r0, r3, lsl #3
 51019d4:	e5921004 	ldr	r1, [r2, #4]
 51019d8:	e1540001 	cmp	r4, r1
 51019dc:	0a00000a 	beq	5101a0c <vQueueDelete+0x54>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 51019e0:	e2833001 	add	r3, r3, #1
 51019e4:	e3530008 	cmp	r3, #8
 51019e8:	1afffff8 	bne	51019d0 <vQueueDelete+0x18>
        if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 51019ec:	e5d43046 	ldrb	r3, [r4, #70]	; 0x46
 51019f0:	e3530000 	cmp	r3, #0
 51019f4:	18bd8070 	popne	{r4, r5, r6, pc}
            vPortFree( pxQueue );
 51019f8:	e308333c 	movw	r3, #33596	; 0x833c
 51019fc:	e1a00004 	mov	r0, r4
 5101a00:	e3403510 	movt	r3, #1296	; 0x510
 5101a04:	e12fff33 	blx	r3
}
 5101a08:	e8bd8070 	pop	{r4, r5, r6, pc}
                xQueueRegistry[ ux ].pcQueueName = NULL;
 5101a0c:	e3a01000 	mov	r1, #0
 5101a10:	e7801183 	str	r1, [r0, r3, lsl #3]
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 5101a14:	e5821004 	str	r1, [r2, #4]
                break;
 5101a18:	eafffff3 	b	51019ec <vQueueDelete+0x34>
    configASSERT( pxQueue );
 5101a1c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101a20:	e3005900 	movw	r5, #2304	; 0x900
 5101a24:	e30018d4 	movw	r1, #2260	; 0x8d4
 5101a28:	e3405511 	movt	r5, #1297	; 0x511
 5101a2c:	e3400512 	movt	r0, #1298	; 0x512
 5101a30:	e12fff35 	blx	r5
        configASSERT( xQueue );
 5101a34:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101a38:	e3001c1d 	movw	r1, #3101	; 0xc1d
 5101a3c:	e3400512 	movt	r0, #1298	; 0x512
 5101a40:	e12fff35 	blx	r5
 5101a44:	eaffffde 	b	51019c4 <vQueueDelete+0xc>

05101a48 <xQueueGenericSendFromISR>:
{
 5101a48:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5101a4c:	e1a07001 	mov	r7, r1
    configASSERT( pxQueue );
 5101a50:	e2504000 	subs	r4, r0, #0
{
 5101a54:	e1a08002 	mov	r8, r2
 5101a58:	e1a05003 	mov	r5, r3
    configASSERT( pxQueue );
 5101a5c:	0a000053 	beq	5101bb0 <xQueueGenericSendFromISR+0x168>
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101a60:	e3570000 	cmp	r7, #0
 5101a64:	0a000031 	beq	5101b30 <xQueueGenericSendFromISR+0xe8>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 5101a68:	e3550002 	cmp	r5, #2
 5101a6c:	0a000005 	beq	5101a88 <xQueueGenericSendFromISR+0x40>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5101a70:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5101a74:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5101a78:	e1520003 	cmp	r2, r3
 5101a7c:	3a000005 	bcc	5101a98 <xQueueGenericSendFromISR+0x50>
            xReturn = errQUEUE_FULL;
 5101a80:	e3a00000 	mov	r0, #0
}
 5101a84:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 5101a88:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
 5101a8c:	e3530001 	cmp	r3, #1
 5101a90:	1a000030 	bne	5101b58 <xQueueGenericSendFromISR+0x110>
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5101a94:	e5943038 	ldr	r3, [r4, #56]	; 0x38
            const int8_t cTxLock = pxQueue->cTxLock;
 5101a98:	e5d46045 	ldrb	r6, [r4, #69]	; 0x45
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 5101a9c:	e1a01007 	mov	r1, r7
 5101aa0:	e1a02005 	mov	r2, r5
            const int8_t cTxLock = pxQueue->cTxLock;
 5101aa4:	e6af6076 	sxtb	r6, r6
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101aa8:	e5947038 	ldr	r7, [r4, #56]	; 0x38
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 5101aac:	e1a00004 	mov	r0, r4
 5101ab0:	ebfffc96 	bl	5100d10 <prvCopyDataToQueue>
            if( cTxLock == queueUNLOCKED )
 5101ab4:	e3760001 	cmn	r6, #1
 5101ab8:	1a000010 	bne	5101b00 <xQueueGenericSendFromISR+0xb8>
                    if( pxQueue->pxQueueSetContainer != NULL )
 5101abc:	e5943048 	ldr	r3, [r4, #72]	; 0x48
 5101ac0:	e3530000 	cmp	r3, #0
 5101ac4:	0a00002b 	beq	5101b78 <xQueueGenericSendFromISR+0x130>
                        if( ( xCopyPosition == queueOVERWRITE ) && ( uxPreviousMessagesWaiting != ( UBaseType_t ) 0 ) )
 5101ac8:	e2455002 	sub	r5, r5, #2
 5101acc:	e16f5f15 	clz	r5, r5
 5101ad0:	e3570000 	cmp	r7, #0
 5101ad4:	e1a052a5 	lsr	r5, r5, #5
 5101ad8:	03a05000 	moveq	r5, #0
 5101adc:	e3550000 	cmp	r5, #0
 5101ae0:	1a000004 	bne	5101af8 <xQueueGenericSendFromISR+0xb0>
                        else if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 5101ae4:	e1a00004 	mov	r0, r4
 5101ae8:	ebfffcc2 	bl	5100df8 <prvNotifyQueueSetContainer>
                            if( pxHigherPriorityTaskWoken != NULL )
 5101aec:	e3500000 	cmp	r0, #0
 5101af0:	13580000 	cmpne	r8, #0
 5101af4:	1a000029 	bne	5101ba0 <xQueueGenericSendFromISR+0x158>
            xReturn = pdPASS;
 5101af8:	e3a00001 	mov	r0, #1
 5101afc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101b00:	e30532d8 	movw	r3, #21208	; 0x52d8
 5101b04:	e3403510 	movt	r3, #1296	; 0x510
 5101b08:	e12fff33 	blx	r3
 5101b0c:	e1560000 	cmp	r6, r0
 5101b10:	2afffff8 	bcs	5101af8 <xQueueGenericSendFromISR+0xb0>
 5101b14:	e356007f 	cmp	r6, #127	; 0x7f
 5101b18:	0a00002b 	beq	5101bcc <xQueueGenericSendFromISR+0x184>
            xReturn = pdPASS;
 5101b1c:	e3a00001 	mov	r0, #1
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101b20:	e2866001 	add	r6, r6, #1
 5101b24:	e6af6076 	sxtb	r6, r6
 5101b28:	e5c46045 	strb	r6, [r4, #69]	; 0x45
    return xReturn;
 5101b2c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101b30:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 5101b34:	e3530000 	cmp	r3, #0
 5101b38:	0affffca 	beq	5101a68 <xQueueGenericSendFromISR+0x20>
 5101b3c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101b40:	e3003900 	movw	r3, #2304	; 0x900
 5101b44:	e3001491 	movw	r1, #1169	; 0x491
 5101b48:	e3403511 	movt	r3, #1297	; 0x511
 5101b4c:	e3400512 	movt	r0, #1298	; 0x512
 5101b50:	e12fff33 	blx	r3
 5101b54:	eaffffc3 	b	5101a68 <xQueueGenericSendFromISR+0x20>
    configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 5101b58:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101b5c:	e3003900 	movw	r3, #2304	; 0x900
 5101b60:	e3001492 	movw	r1, #1170	; 0x492
 5101b64:	e3403511 	movt	r3, #1297	; 0x511
 5101b68:	e3400512 	movt	r0, #1298	; 0x512
 5101b6c:	e12fff33 	blx	r3
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 5101b70:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5101b74:	eaffffc7 	b	5101a98 <xQueueGenericSendFromISR+0x50>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5101b78:	e5943024 	ldr	r3, [r4, #36]	; 0x24
 5101b7c:	e3530000 	cmp	r3, #0
 5101b80:	0affffdc 	beq	5101af8 <xQueueGenericSendFromISR+0xb0>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5101b84:	e30638d0 	movw	r3, #26832	; 0x68d0
 5101b88:	e2840024 	add	r0, r4, #36	; 0x24
 5101b8c:	e3403510 	movt	r3, #1296	; 0x510
 5101b90:	e12fff33 	blx	r3
                                if( pxHigherPriorityTaskWoken != NULL )
 5101b94:	e3500000 	cmp	r0, #0
 5101b98:	13580000 	cmpne	r8, #0
 5101b9c:	0affffd5 	beq	5101af8 <xQueueGenericSendFromISR+0xb0>
                                *pxHigherPriorityTaskWoken = pdTRUE;
 5101ba0:	e3a03001 	mov	r3, #1
            xReturn = pdPASS;
 5101ba4:	e1a00003 	mov	r0, r3
                                *pxHigherPriorityTaskWoken = pdTRUE;
 5101ba8:	e5883000 	str	r3, [r8]
 5101bac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( pxQueue );
 5101bb0:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101bb4:	e3003900 	movw	r3, #2304	; 0x900
 5101bb8:	e3a01e49 	mov	r1, #1168	; 0x490
 5101bbc:	e3403511 	movt	r3, #1297	; 0x511
 5101bc0:	e3400512 	movt	r0, #1298	; 0x512
 5101bc4:	e12fff33 	blx	r3
 5101bc8:	eaffffa4 	b	5101a60 <xQueueGenericSendFromISR+0x18>
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101bcc:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101bd0:	e3003900 	movw	r3, #2304	; 0x900
 5101bd4:	e300151e 	movw	r1, #1310	; 0x51e
 5101bd8:	e3403511 	movt	r3, #1297	; 0x511
 5101bdc:	e3400512 	movt	r0, #1298	; 0x512
 5101be0:	e12fff33 	blx	r3
 5101be4:	eaffffcc 	b	5101b1c <xQueueGenericSendFromISR+0xd4>

05101be8 <xQueueGiveFromISR>:
{
 5101be8:	e92d4070 	push	{r4, r5, r6, lr}
 5101bec:	e1a05001 	mov	r5, r1
    configASSERT( pxQueue );
 5101bf0:	e2504000 	subs	r4, r0, #0
 5101bf4:	0a000048 	beq	5101d1c <xQueueGiveFromISR+0x134>
    configASSERT( pxQueue->uxItemSize == 0 );
 5101bf8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 5101bfc:	e3530000 	cmp	r3, #0
 5101c00:	1a000024 	bne	5101c98 <xQueueGiveFromISR+0xb0>
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 5101c04:	e5943000 	ldr	r3, [r4]
 5101c08:	e3530000 	cmp	r3, #0
 5101c0c:	0a00002a 	beq	5101cbc <xQueueGiveFromISR+0xd4>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101c10:	e5943038 	ldr	r3, [r4, #56]	; 0x38
        if( uxMessagesWaiting < pxQueue->uxLength )
 5101c14:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
 5101c18:	e1520003 	cmp	r2, r3
 5101c1c:	9a00000f 	bls	5101c60 <xQueueGiveFromISR+0x78>
            const int8_t cTxLock = pxQueue->cTxLock;
 5101c20:	e5d42045 	ldrb	r2, [r4, #69]	; 0x45
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5101c24:	e2833001 	add	r3, r3, #1
            if( cTxLock == queueUNLOCKED )
 5101c28:	e35200ff 	cmp	r2, #255	; 0xff
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting + ( UBaseType_t ) 1 );
 5101c2c:	e5843038 	str	r3, [r4, #56]	; 0x38
            const int8_t cTxLock = pxQueue->cTxLock;
 5101c30:	e6af6072 	sxtb	r6, r2
            if( cTxLock == queueUNLOCKED )
 5101c34:	1a00000b 	bne	5101c68 <xQueueGiveFromISR+0x80>
                    if( pxQueue->pxQueueSetContainer != NULL )
 5101c38:	e5943048 	ldr	r3, [r4, #72]	; 0x48
 5101c3c:	e3530000 	cmp	r3, #0
 5101c40:	0a000027 	beq	5101ce4 <xQueueGiveFromISR+0xfc>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 5101c44:	e1a00004 	mov	r0, r4
 5101c48:	ebfffc6a 	bl	5100df8 <prvNotifyQueueSetContainer>
                            if( pxHigherPriorityTaskWoken != NULL )
 5101c4c:	e3550000 	cmp	r5, #0
 5101c50:	13500000 	cmpne	r0, #0
 5101c54:	1a00002c 	bne	5101d0c <xQueueGiveFromISR+0x124>
            xReturn = pdPASS;
 5101c58:	e3a00001 	mov	r0, #1
 5101c5c:	e8bd8070 	pop	{r4, r5, r6, pc}
            xReturn = errQUEUE_FULL;
 5101c60:	e3a00000 	mov	r0, #0
}
 5101c64:	e8bd8070 	pop	{r4, r5, r6, pc}
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101c68:	e30532d8 	movw	r3, #21208	; 0x52d8
 5101c6c:	e3403510 	movt	r3, #1296	; 0x510
 5101c70:	e12fff33 	blx	r3
 5101c74:	e1560000 	cmp	r6, r0
 5101c78:	2afffff6 	bcs	5101c58 <xQueueGiveFromISR+0x70>
 5101c7c:	e356007f 	cmp	r6, #127	; 0x7f
 5101c80:	0a00002c 	beq	5101d38 <xQueueGiveFromISR+0x150>
            xReturn = pdPASS;
 5101c84:	e3a00001 	mov	r0, #1
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101c88:	e2862001 	add	r2, r6, #1
 5101c8c:	e6af2072 	sxtb	r2, r2
 5101c90:	e5c42045 	strb	r2, [r4, #69]	; 0x45
 5101c94:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxQueue->uxItemSize == 0 );
 5101c98:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101c9c:	e3003900 	movw	r3, #2304	; 0x900
 5101ca0:	e3001544 	movw	r1, #1348	; 0x544
 5101ca4:	e3403511 	movt	r3, #1297	; 0x511
 5101ca8:	e3400512 	movt	r0, #1298	; 0x512
 5101cac:	e12fff33 	blx	r3
    configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
 5101cb0:	e5943000 	ldr	r3, [r4]
 5101cb4:	e3530000 	cmp	r3, #0
 5101cb8:	1affffd4 	bne	5101c10 <xQueueGiveFromISR+0x28>
 5101cbc:	e5943008 	ldr	r3, [r4, #8]
 5101cc0:	e3530000 	cmp	r3, #0
 5101cc4:	0affffd1 	beq	5101c10 <xQueueGiveFromISR+0x28>
 5101cc8:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101ccc:	e3003900 	movw	r3, #2304	; 0x900
 5101cd0:	e3001549 	movw	r1, #1353	; 0x549
 5101cd4:	e3403511 	movt	r3, #1297	; 0x511
 5101cd8:	e3400512 	movt	r0, #1298	; 0x512
 5101cdc:	e12fff33 	blx	r3
 5101ce0:	eaffffca 	b	5101c10 <xQueueGiveFromISR+0x28>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 5101ce4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
 5101ce8:	e3530000 	cmp	r3, #0
 5101cec:	0affffd9 	beq	5101c58 <xQueueGiveFromISR+0x70>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 5101cf0:	e30638d0 	movw	r3, #26832	; 0x68d0
 5101cf4:	e2840024 	add	r0, r4, #36	; 0x24
 5101cf8:	e3403510 	movt	r3, #1296	; 0x510
 5101cfc:	e12fff33 	blx	r3
                                if( pxHigherPriorityTaskWoken != NULL )
 5101d00:	e3500000 	cmp	r0, #0
 5101d04:	13550000 	cmpne	r5, #0
 5101d08:	0affffd2 	beq	5101c58 <xQueueGiveFromISR+0x70>
                                *pxHigherPriorityTaskWoken = pdTRUE;
 5101d0c:	e3a03001 	mov	r3, #1
            xReturn = pdPASS;
 5101d10:	e1a00003 	mov	r0, r3
                                *pxHigherPriorityTaskWoken = pdTRUE;
 5101d14:	e5853000 	str	r3, [r5]
 5101d18:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxQueue );
 5101d1c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101d20:	e3003900 	movw	r3, #2304	; 0x900
 5101d24:	e3a01d15 	mov	r1, #1344	; 0x540
 5101d28:	e3403511 	movt	r3, #1297	; 0x511
 5101d2c:	e3400512 	movt	r0, #1298	; 0x512
 5101d30:	e12fff33 	blx	r3
 5101d34:	eaffffaf 	b	5101bf8 <xQueueGiveFromISR+0x10>
                prvIncrementQueueTxLock( pxQueue, cTxLock );
 5101d38:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101d3c:	e3003900 	movw	r3, #2304	; 0x900
 5101d40:	e30015cb 	movw	r1, #1483	; 0x5cb
 5101d44:	e3403511 	movt	r3, #1297	; 0x511
 5101d48:	e3400512 	movt	r0, #1298	; 0x512
 5101d4c:	e12fff33 	blx	r3
 5101d50:	eaffffcb 	b	5101c84 <xQueueGiveFromISR+0x9c>

05101d54 <xQueueReceiveFromISR>:
{
 5101d54:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5101d58:	e1a05001 	mov	r5, r1
    configASSERT( pxQueue );
 5101d5c:	e2504000 	subs	r4, r0, #0
{
 5101d60:	e1a07002 	mov	r7, r2
    configASSERT( pxQueue );
 5101d64:	0a000037 	beq	5101e48 <xQueueReceiveFromISR+0xf4>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101d68:	e3550000 	cmp	r5, #0
 5101d6c:	0a000004 	beq	5101d84 <xQueueReceiveFromISR+0x30>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101d70:	e5946038 	ldr	r6, [r4, #56]	; 0x38
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 5101d74:	e3560000 	cmp	r6, #0
 5101d78:	1a000012 	bne	5101dc8 <xQueueReceiveFromISR+0x74>
            xReturn = pdFAIL;
 5101d7c:	e3a00000 	mov	r0, #0
 5101d80:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101d84:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 5101d88:	e3530000 	cmp	r3, #0
 5101d8c:	1a000034 	bne	5101e64 <xQueueReceiveFromISR+0x110>
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 5101d90:	e5946038 	ldr	r6, [r4, #56]	; 0x38
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 5101d94:	e3560000 	cmp	r6, #0
 5101d98:	0afffff7 	beq	5101d7c <xQueueReceiveFromISR+0x28>
            const int8_t cRxLock = pxQueue->cRxLock;
 5101d9c:	e5d48044 	ldrb	r8, [r4, #68]	; 0x44
 5101da0:	e6af8078 	sxtb	r8, r8
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 5101da4:	e2466001 	sub	r6, r6, #1
            if( cRxLock == queueUNLOCKED )
 5101da8:	e3780001 	cmn	r8, #1
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 5101dac:	e5846038 	str	r6, [r4, #56]	; 0x38
            if( cRxLock == queueUNLOCKED )
 5101db0:	1a000018 	bne	5101e18 <xQueueReceiveFromISR+0xc4>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 5101db4:	e5943010 	ldr	r3, [r4, #16]
 5101db8:	e3530000 	cmp	r3, #0
 5101dbc:	1a00002f 	bne	5101e80 <xQueueReceiveFromISR+0x12c>
            xReturn = pdPASS;
 5101dc0:	e3a00001 	mov	r0, #1
 5101dc4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 5101dc8:	e5942040 	ldr	r2, [r4, #64]	; 0x40
            const int8_t cRxLock = pxQueue->cRxLock;
 5101dcc:	e5d48044 	ldrb	r8, [r4, #68]	; 0x44
 5101dd0:	e6af8078 	sxtb	r8, r8
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 5101dd4:	e3520000 	cmp	r2, #0
 5101dd8:	0afffff1 	beq	5101da4 <xQueueReceiveFromISR+0x50>
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101ddc:	e594100c 	ldr	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101de0:	e1a00005 	mov	r0, r5
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 5101de4:	e5943008 	ldr	r3, [r4, #8]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 5101de8:	e2466001 	sub	r6, r6, #1
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101dec:	e0811002 	add	r1, r1, r2
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
 5101df0:	e1510003 	cmp	r1, r3
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
 5101df4:	e584100c 	str	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101df8:	e3093ca1 	movw	r3, #40097	; 0x9ca1
 5101dfc:	e3403511 	movt	r3, #1297	; 0x511
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 5101e00:	25941000 	ldrcs	r1, [r4]
 5101e04:	2584100c 	strcs	r1, [r4, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize );
 5101e08:	e12fff33 	blx	r3
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxMessagesWaiting - ( UBaseType_t ) 1 );
 5101e0c:	e5846038 	str	r6, [r4, #56]	; 0x38
            if( cRxLock == queueUNLOCKED )
 5101e10:	e3780001 	cmn	r8, #1
 5101e14:	0affffe6 	beq	5101db4 <xQueueReceiveFromISR+0x60>
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 5101e18:	e30532d8 	movw	r3, #21208	; 0x52d8
 5101e1c:	e3403510 	movt	r3, #1296	; 0x510
 5101e20:	e12fff33 	blx	r3
 5101e24:	e1580000 	cmp	r8, r0
 5101e28:	2affffe4 	bcs	5101dc0 <xQueueReceiveFromISR+0x6c>
 5101e2c:	e358007f 	cmp	r8, #127	; 0x7f
 5101e30:	0a00001d 	beq	5101eac <xQueueReceiveFromISR+0x158>
            xReturn = pdPASS;
 5101e34:	e3a00001 	mov	r0, #1
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 5101e38:	e2888001 	add	r8, r8, #1
 5101e3c:	e6af8078 	sxtb	r8, r8
 5101e40:	e5c48044 	strb	r8, [r4, #68]	; 0x44
}
 5101e44:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( pxQueue );
 5101e48:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101e4c:	e3003900 	movw	r3, #2304	; 0x900
 5101e50:	e30017fd 	movw	r1, #2045	; 0x7fd
 5101e54:	e3403511 	movt	r3, #1297	; 0x511
 5101e58:	e3400512 	movt	r0, #1298	; 0x512
 5101e5c:	e12fff33 	blx	r3
 5101e60:	eaffffc0 	b	5101d68 <xQueueReceiveFromISR+0x14>
    configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 5101e64:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101e68:	e3003900 	movw	r3, #2304	; 0x900
 5101e6c:	e30017fe 	movw	r1, #2046	; 0x7fe
 5101e70:	e3403511 	movt	r3, #1297	; 0x511
 5101e74:	e3400512 	movt	r0, #1298	; 0x512
 5101e78:	e12fff33 	blx	r3
 5101e7c:	eaffffbb 	b	5101d70 <xQueueReceiveFromISR+0x1c>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5101e80:	e30638d0 	movw	r3, #26832	; 0x68d0
 5101e84:	e2840010 	add	r0, r4, #16
 5101e88:	e3403510 	movt	r3, #1296	; 0x510
 5101e8c:	e12fff33 	blx	r3
                        if( pxHigherPriorityTaskWoken != NULL )
 5101e90:	e3570000 	cmp	r7, #0
 5101e94:	13500000 	cmpne	r0, #0
 5101e98:	0affffc8 	beq	5101dc0 <xQueueReceiveFromISR+0x6c>
                            *pxHigherPriorityTaskWoken = pdTRUE;
 5101e9c:	e3a03001 	mov	r3, #1
            xReturn = pdPASS;
 5101ea0:	e1a00003 	mov	r0, r3
                            *pxHigherPriorityTaskWoken = pdTRUE;
 5101ea4:	e5873000 	str	r3, [r7]
 5101ea8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                prvIncrementQueueRxLock( pxQueue, cRxLock );
 5101eac:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101eb0:	e3003900 	movw	r3, #2304	; 0x900
 5101eb4:	e3001844 	movw	r1, #2116	; 0x844
 5101eb8:	e3403511 	movt	r3, #1297	; 0x511
 5101ebc:	e3400512 	movt	r0, #1298	; 0x512
 5101ec0:	e12fff33 	blx	r3
 5101ec4:	eaffffda 	b	5101e34 <xQueueReceiveFromISR+0xe0>

05101ec8 <xQueueIsQueueEmptyFromISR>:
{
 5101ec8:	e92d4010 	push	{r4, lr}
    configASSERT( pxQueue );
 5101ecc:	e2504000 	subs	r4, r0, #0
 5101ed0:	0a000003 	beq	5101ee4 <xQueueIsQueueEmptyFromISR+0x1c>
    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 5101ed4:	e5940038 	ldr	r0, [r4, #56]	; 0x38
}
 5101ed8:	e16f0f10 	clz	r0, r0
 5101edc:	e1a002a0 	lsr	r0, r0, #5
 5101ee0:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxQueue );
 5101ee4:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101ee8:	e3003900 	movw	r3, #2304	; 0x900
 5101eec:	e3001a52 	movw	r1, #2642	; 0xa52
 5101ef0:	e3403511 	movt	r3, #1297	; 0x511
 5101ef4:	e3400512 	movt	r0, #1298	; 0x512
 5101ef8:	e12fff33 	blx	r3
 5101efc:	eafffff4 	b	5101ed4 <xQueueIsQueueEmptyFromISR+0xc>

05101f00 <xQueueIsQueueFullFromISR>:
{
 5101f00:	e92d4010 	push	{r4, lr}
    configASSERT( pxQueue );
 5101f04:	e2504000 	subs	r4, r0, #0
 5101f08:	0a000005 	beq	5101f24 <xQueueIsQueueFullFromISR+0x24>
    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 5101f0c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5101f10:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
}
 5101f14:	e0400003 	sub	r0, r0, r3
 5101f18:	e16f0f10 	clz	r0, r0
 5101f1c:	e1a002a0 	lsr	r0, r0, #5
 5101f20:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxQueue );
 5101f24:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101f28:	e3003900 	movw	r3, #2304	; 0x900
 5101f2c:	e3001a7f 	movw	r1, #2687	; 0xa7f
 5101f30:	e3403511 	movt	r3, #1297	; 0x511
 5101f34:	e3400512 	movt	r0, #1298	; 0x512
 5101f38:	e12fff33 	blx	r3
 5101f3c:	eafffff2 	b	5101f0c <xQueueIsQueueFullFromISR+0xc>

05101f40 <uxQueueMessagesWaitingFromISR>:
{
 5101f40:	e92d4010 	push	{r4, lr}
    configASSERT( pxQueue );
 5101f44:	e2504000 	subs	r4, r0, #0
 5101f48:	0a000001 	beq	5101f54 <uxQueueMessagesWaitingFromISR+0x14>
    uxReturn = pxQueue->uxMessagesWaiting;
 5101f4c:	e5940038 	ldr	r0, [r4, #56]	; 0x38
}
 5101f50:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxQueue );
 5101f54:	e30d0a74 	movw	r0, #55924	; 0xda74
 5101f58:	e3003900 	movw	r3, #2304	; 0x900
 5101f5c:	e30018c5 	movw	r1, #2245	; 0x8c5
 5101f60:	e3403511 	movt	r3, #1297	; 0x511
 5101f64:	e3400512 	movt	r0, #1298	; 0x512
 5101f68:	e12fff33 	blx	r3
    uxReturn = pxQueue->uxMessagesWaiting;
 5101f6c:	e5940038 	ldr	r0, [r4, #56]	; 0x38
}
 5101f70:	e8bd8010 	pop	{r4, pc}

05101f74 <xQueueSemaphoreTake>:
{
 5101f74:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    configASSERT( ( pxQueue ) );
 5101f78:	e2504000 	subs	r4, r0, #0
{
 5101f7c:	e24dd014 	sub	sp, sp, #20
 5101f80:	e58d1004 	str	r1, [sp, #4]
    configASSERT( ( pxQueue ) );
 5101f84:	0a000092 	beq	51021d4 <xQueueSemaphoreTake+0x260>
    configASSERT( pxQueue->uxItemSize == 0 );
 5101f88:	e5943040 	ldr	r3, [r4, #64]	; 0x40
 5101f8c:	e3530000 	cmp	r3, #0
 5101f90:	1a000072 	bne	5102160 <xQueueSemaphoreTake+0x1ec>
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 5101f94:	e3063e28 	movw	r3, #28200	; 0x6e28
 5101f98:	e3403510 	movt	r3, #1296	; 0x510
 5101f9c:	e12fff33 	blx	r3
 5101fa0:	e3500000 	cmp	r0, #0
 5101fa4:	1a000002 	bne	5101fb4 <xQueueSemaphoreTake+0x40>
 5101fa8:	e59d3004 	ldr	r3, [sp, #4]
 5101fac:	e3530000 	cmp	r3, #0
 5101fb0:	1a000080 	bne	51021b8 <xQueueSemaphoreTake+0x244>
 5101fb4:	e30c5930 	movw	r5, #51504	; 0xc930
{
 5101fb8:	e3a0a000 	mov	sl, #0
 5101fbc:	e30c6988 	movw	r6, #51592	; 0xc988
 5101fc0:	e3405510 	movt	r5, #1296	; 0x510
        taskENTER_CRITICAL();
 5101fc4:	e12fff35 	blx	r5
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 5101fc8:	e5943038 	ldr	r3, [r4, #56]	; 0x38
                    vTaskInternalSetTimeOutState( &xTimeOut );
 5101fcc:	e307b1ec 	movw	fp, #29164	; 0x71ec
        vTaskSuspendAll();
 5101fd0:	e30592a0 	movw	r9, #21152	; 0x52a0
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 5101fd4:	e3058b8c 	movw	r8, #23436	; 0x5b8c
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 5101fd8:	e3530000 	cmp	r3, #0
{
 5101fdc:	e1a0700a 	mov	r7, sl
 5101fe0:	e3406510 	movt	r6, #1296	; 0x510
                    vTaskInternalSetTimeOutState( &xTimeOut );
 5101fe4:	e340b510 	movt	fp, #1296	; 0x510
        vTaskSuspendAll();
 5101fe8:	e3409510 	movt	r9, #1296	; 0x510
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 5101fec:	e3408510 	movt	r8, #1296	; 0x510
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 5101ff0:	1a000025 	bne	510208c <xQueueSemaphoreTake+0x118>
                if( xTicksToWait == ( TickType_t ) 0 )
 5101ff4:	e59d3004 	ldr	r3, [sp, #4]
 5101ff8:	e3530000 	cmp	r3, #0
 5101ffc:	0a000083 	beq	5102210 <xQueueSemaphoreTake+0x29c>
                else if( xEntryTimeSet == pdFALSE )
 5102000:	e3570000 	cmp	r7, #0
                    vTaskInternalSetTimeOutState( &xTimeOut );
 5102004:	e28d7008 	add	r7, sp, #8
                else if( xEntryTimeSet == pdFALSE )
 5102008:	0a000037 	beq	51020ec <xQueueSemaphoreTake+0x178>
        taskEXIT_CRITICAL();
 510200c:	e12fff36 	blx	r6
        vTaskSuspendAll();
 5102010:	e12fff39 	blx	r9
        prvLockQueue( pxQueue );
 5102014:	e12fff35 	blx	r5
 5102018:	e5d43044 	ldrb	r3, [r4, #68]	; 0x44
 510201c:	e35300ff 	cmp	r3, #255	; 0xff
 5102020:	03a03000 	moveq	r3, #0
 5102024:	05c43044 	strbeq	r3, [r4, #68]	; 0x44
 5102028:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
 510202c:	e35300ff 	cmp	r3, #255	; 0xff
 5102030:	03a03000 	moveq	r3, #0
 5102034:	05c43045 	strbeq	r3, [r4, #69]	; 0x45
 5102038:	e12fff36 	blx	r6
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 510203c:	e1a00007 	mov	r0, r7
 5102040:	e28d1004 	add	r1, sp, #4
 5102044:	e12fff38 	blx	r8
 5102048:	e3500000 	cmp	r0, #0
 510204c:	1a00001b 	bne	51020c0 <xQueueSemaphoreTake+0x14c>
    taskENTER_CRITICAL();
 5102050:	e12fff35 	blx	r5
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 5102054:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5102058:	e3530000 	cmp	r3, #0
 510205c:	0a000025 	beq	51020f8 <xQueueSemaphoreTake+0x184>
    taskEXIT_CRITICAL();
 5102060:	e12fff36 	blx	r6
                prvUnlockQueue( pxQueue );
 5102064:	e1a00004 	mov	r0, r4
 5102068:	ebfffbaa 	bl	5100f18 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 510206c:	e3053efc 	movw	r3, #24316	; 0x5efc
 5102070:	e3403510 	movt	r3, #1296	; 0x510
 5102074:	e12fff33 	blx	r3
        taskENTER_CRITICAL();
 5102078:	e12fff35 	blx	r5
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
 510207c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
{
 5102080:	e3a07001 	mov	r7, #1
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
 5102084:	e3530000 	cmp	r3, #0
 5102088:	0affffd9 	beq	5101ff4 <xQueueSemaphoreTake+0x80>
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 510208c:	e5942000 	ldr	r2, [r4]
                pxQueue->uxMessagesWaiting = ( UBaseType_t ) ( uxSemaphoreCount - ( UBaseType_t ) 1 );
 5102090:	e2433001 	sub	r3, r3, #1
 5102094:	e5843038 	str	r3, [r4, #56]	; 0x38
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 5102098:	e3520000 	cmp	r2, #0
 510209c:	0a00006c 	beq	5102254 <xQueueSemaphoreTake+0x2e0>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 51020a0:	e5943010 	ldr	r3, [r4, #16]
 51020a4:	e3530000 	cmp	r3, #0
 51020a8:	1a00005f 	bne	510222c <xQueueSemaphoreTake+0x2b8>
                taskEXIT_CRITICAL();
 51020ac:	e12fff36 	blx	r6
                return pdPASS;
 51020b0:	e3a0a001 	mov	sl, #1
}
 51020b4:	e1a0000a 	mov	r0, sl
 51020b8:	e28dd014 	add	sp, sp, #20
 51020bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            prvUnlockQueue( pxQueue );
 51020c0:	e1a00004 	mov	r0, r4
 51020c4:	ebfffb93 	bl	5100f18 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 51020c8:	e3053efc 	movw	r3, #24316	; 0x5efc
 51020cc:	e3403510 	movt	r3, #1296	; 0x510
 51020d0:	e12fff33 	blx	r3
    taskENTER_CRITICAL();
 51020d4:	e12fff35 	blx	r5
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 51020d8:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 51020dc:	e3530000 	cmp	r3, #0
 51020e0:	0a000018 	beq	5102148 <xQueueSemaphoreTake+0x1d4>
    taskEXIT_CRITICAL();
 51020e4:	e12fff36 	blx	r6
    return xReturn;
 51020e8:	eaffffe2 	b	5102078 <xQueueSemaphoreTake+0x104>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 51020ec:	e1a00007 	mov	r0, r7
 51020f0:	e12fff3b 	blx	fp
                    xEntryTimeSet = pdTRUE;
 51020f4:	eaffffc4 	b	510200c <xQueueSemaphoreTake+0x98>
    taskEXIT_CRITICAL();
 51020f8:	e12fff36 	blx	r6
                    if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 51020fc:	e5943000 	ldr	r3, [r4]
 5102100:	e3530000 	cmp	r3, #0
 5102104:	0a000039 	beq	51021f0 <xQueueSemaphoreTake+0x27c>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 5102108:	e3063718 	movw	r3, #26392	; 0x6718
 510210c:	e2840024 	add	r0, r4, #36	; 0x24
 5102110:	e59d1004 	ldr	r1, [sp, #4]
 5102114:	e3403510 	movt	r3, #1296	; 0x510
 5102118:	e12fff33 	blx	r3
                prvUnlockQueue( pxQueue );
 510211c:	e1a00004 	mov	r0, r4
 5102120:	ebfffb7c 	bl	5100f18 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 5102124:	e3053efc 	movw	r3, #24316	; 0x5efc
 5102128:	e3403510 	movt	r3, #1296	; 0x510
 510212c:	e12fff33 	blx	r3
 5102130:	e3500000 	cmp	r0, #0
 5102134:	1affffcf 	bne	5102078 <xQueueSemaphoreTake+0x104>
                    taskYIELD_WITHIN_API();
 5102138:	e3003000 	movw	r3, #0
 510213c:	e3403511 	movt	r3, #1297	; 0x511
 5102140:	e12fff33 	blx	r3
 5102144:	eaffffcb 	b	5102078 <xQueueSemaphoreTake+0x104>
    taskEXIT_CRITICAL();
 5102148:	e12fff36 	blx	r6
                    if( xInheritanceOccurred != pdFALSE )
 510214c:	e35a0000 	cmp	sl, #0
 5102150:	1a000009 	bne	510217c <xQueueSemaphoreTake+0x208>
}
 5102154:	e1a0000a 	mov	r0, sl
 5102158:	e28dd014 	add	sp, sp, #20
 510215c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    configASSERT( pxQueue->uxItemSize == 0 );
 5102160:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102164:	e3003900 	movw	r3, #2304	; 0x900
 5102168:	e3001686 	movw	r1, #1670	; 0x686
 510216c:	e3403511 	movt	r3, #1297	; 0x511
 5102170:	e3400512 	movt	r0, #1298	; 0x512
 5102174:	e12fff33 	blx	r3
 5102178:	eaffff85 	b	5101f94 <xQueueSemaphoreTake+0x20>
                        taskENTER_CRITICAL();
 510217c:	e12fff35 	blx	r5
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 5102180:	e5941024 	ldr	r1, [r4, #36]	; 0x24
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 5102184:	e5940008 	ldr	r0, [r4, #8]
                return errQUEUE_EMPTY;
 5102188:	e3a0a000 	mov	sl, #0
        if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
 510218c:	e3510000 	cmp	r1, #0
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) ( ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) ) );
 5102190:	15943030 	ldrne	r3, [r4, #48]	; 0x30
 5102194:	15931000 	ldrne	r1, [r3]
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 5102198:	e3073094 	movw	r3, #28820	; 0x7094
 510219c:	e3403510 	movt	r3, #1296	; 0x510
            uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) ( ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) ) );
 51021a0:	12611007 	rsbne	r1, r1, #7
                            vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
 51021a4:	e12fff33 	blx	r3
                        taskEXIT_CRITICAL();
 51021a8:	e12fff36 	blx	r6
}
 51021ac:	e1a0000a 	mov	r0, sl
 51021b0:	e28dd014 	add	sp, sp, #20
 51021b4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 51021b8:	e30d0a74 	movw	r0, #55924	; 0xda74
 51021bc:	e3003900 	movw	r3, #2304	; 0x900
 51021c0:	e300168b 	movw	r1, #1675	; 0x68b
 51021c4:	e3403511 	movt	r3, #1297	; 0x511
 51021c8:	e3400512 	movt	r0, #1298	; 0x512
 51021cc:	e12fff33 	blx	r3
 51021d0:	eaffff77 	b	5101fb4 <xQueueSemaphoreTake+0x40>
    configASSERT( ( pxQueue ) );
 51021d4:	e30d0a74 	movw	r0, #55924	; 0xda74
 51021d8:	e3003900 	movw	r3, #2304	; 0x900
 51021dc:	e3001682 	movw	r1, #1666	; 0x682
 51021e0:	e3403511 	movt	r3, #1297	; 0x511
 51021e4:	e3400512 	movt	r0, #1298	; 0x512
 51021e8:	e12fff33 	blx	r3
 51021ec:	eaffff65 	b	5101f88 <xQueueSemaphoreTake+0x14>
                        taskENTER_CRITICAL();
 51021f0:	e12fff35 	blx	r5
                            xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
 51021f4:	e5940008 	ldr	r0, [r4, #8]
 51021f8:	e3063e58 	movw	r3, #28248	; 0x6e58
 51021fc:	e3403510 	movt	r3, #1296	; 0x510
 5102200:	e12fff33 	blx	r3
 5102204:	e1a0a000 	mov	sl, r0
                        taskEXIT_CRITICAL();
 5102208:	e12fff36 	blx	r6
 510220c:	eaffffbd 	b	5102108 <xQueueSemaphoreTake+0x194>
 5102210:	e58d3000 	str	r3, [sp]
                    taskEXIT_CRITICAL();
 5102214:	e12fff36 	blx	r6
                    return errQUEUE_EMPTY;
 5102218:	e59d3000 	ldr	r3, [sp]
 510221c:	e1a0a003 	mov	sl, r3
}
 5102220:	e1a0000a 	mov	r0, sl
 5102224:	e28dd014 	add	sp, sp, #20
 5102228:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 510222c:	e30638d0 	movw	r3, #26832	; 0x68d0
 5102230:	e2840010 	add	r0, r4, #16
 5102234:	e3403510 	movt	r3, #1296	; 0x510
 5102238:	e12fff33 	blx	r3
 510223c:	e3500000 	cmp	r0, #0
 5102240:	0affff99 	beq	51020ac <xQueueSemaphoreTake+0x138>
                        queueYIELD_IF_USING_PREEMPTION();
 5102244:	e3003000 	movw	r3, #0
 5102248:	e3403511 	movt	r3, #1297	; 0x511
 510224c:	e12fff33 	blx	r3
 5102250:	eaffff95 	b	51020ac <xQueueSemaphoreTake+0x138>
                        pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
 5102254:	e30731cc 	movw	r3, #29132	; 0x71cc
 5102258:	e3403510 	movt	r3, #1296	; 0x510
 510225c:	e12fff33 	blx	r3
 5102260:	e5840008 	str	r0, [r4, #8]
 5102264:	eaffff8d 	b	51020a0 <xQueueSemaphoreTake+0x12c>

05102268 <xQueueGetMutexHolder>:
    {
 5102268:	e92d4010 	push	{r4, lr}
        configASSERT( xSemaphore );
 510226c:	e2504000 	subs	r4, r0, #0
    {
 5102270:	e24dd008 	sub	sp, sp, #8
        configASSERT( xSemaphore );
 5102274:	0a00000d 	beq	51022b0 <xQueueGetMutexHolder+0x48>
        taskENTER_CRITICAL();
 5102278:	e30c3930 	movw	r3, #51504	; 0xc930
 510227c:	e3403510 	movt	r3, #1296	; 0x510
 5102280:	e12fff33 	blx	r3
            if( pxSemaphore->uxQueueType == queueQUEUE_IS_MUTEX )
 5102284:	e5943000 	ldr	r3, [r4]
 5102288:	e3530000 	cmp	r3, #0
                pxReturn = NULL;
 510228c:	13a00000 	movne	r0, #0
        taskEXIT_CRITICAL();
 5102290:	e30c3988 	movw	r3, #51592	; 0xc988
 5102294:	e3403510 	movt	r3, #1296	; 0x510
                pxReturn = pxSemaphore->u.xSemaphore.xMutexHolder;
 5102298:	05940008 	ldreq	r0, [r4, #8]
 510229c:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 51022a0:	e12fff33 	blx	r3
    }
 51022a4:	e59d0004 	ldr	r0, [sp, #4]
 51022a8:	e28dd008 	add	sp, sp, #8
 51022ac:	e8bd8010 	pop	{r4, pc}
        configASSERT( xSemaphore );
 51022b0:	e30d0a74 	movw	r0, #55924	; 0xda74
 51022b4:	e3003900 	movw	r3, #2304	; 0x900
 51022b8:	e3a01fae 	mov	r1, #696	; 0x2b8
 51022bc:	e3403511 	movt	r3, #1297	; 0x511
 51022c0:	e3400512 	movt	r0, #1298	; 0x512
 51022c4:	e12fff33 	blx	r3
 51022c8:	eaffffea 	b	5102278 <xQueueGetMutexHolder+0x10>

051022cc <xQueueGetMutexHolderFromISR>:
    {
 51022cc:	e92d4010 	push	{r4, lr}
        configASSERT( xSemaphore );
 51022d0:	e2504000 	subs	r4, r0, #0
 51022d4:	0a000004 	beq	51022ec <xQueueGetMutexHolderFromISR+0x20>
        if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
 51022d8:	e5943000 	ldr	r3, [r4]
 51022dc:	e3530000 	cmp	r3, #0
            pxReturn = ( ( Queue_t * ) xSemaphore )->u.xSemaphore.xMutexHolder;
 51022e0:	05940008 	ldreq	r0, [r4, #8]
            pxReturn = NULL;
 51022e4:	13a00000 	movne	r0, #0
    }
 51022e8:	e8bd8010 	pop	{r4, pc}
        configASSERT( xSemaphore );
 51022ec:	e30d0a74 	movw	r0, #55924	; 0xda74
 51022f0:	e3003900 	movw	r3, #2304	; 0x900
 51022f4:	e3a01fb7 	mov	r1, #732	; 0x2dc
 51022f8:	e3403511 	movt	r3, #1297	; 0x511
 51022fc:	e3400512 	movt	r0, #1298	; 0x512
 5102300:	e12fff33 	blx	r3
 5102304:	eafffff3 	b	51022d8 <xQueueGetMutexHolderFromISR+0xc>

05102308 <xQueueTakeMutexRecursive>:
    {
 5102308:	e92d4070 	push	{r4, r5, r6, lr}
 510230c:	e1a05001 	mov	r5, r1
        configASSERT( pxMutex );
 5102310:	e2504000 	subs	r4, r0, #0
 5102314:	0a000012 	beq	5102364 <xQueueTakeMutexRecursive+0x5c>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 5102318:	e5946008 	ldr	r6, [r4, #8]
 510231c:	e3063dec 	movw	r3, #28140	; 0x6dec
 5102320:	e3403510 	movt	r3, #1296	; 0x510
 5102324:	e12fff33 	blx	r3
 5102328:	e1560000 	cmp	r6, r0
 510232c:	0a000007 	beq	5102350 <xQueueTakeMutexRecursive+0x48>
            xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
 5102330:	e1a01005 	mov	r1, r5
 5102334:	e1a00004 	mov	r0, r4
 5102338:	ebffff0d 	bl	5101f74 <xQueueSemaphoreTake>
            if( xReturn != pdFAIL )
 510233c:	e3500000 	cmp	r0, #0
                ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 5102340:	1594300c 	ldrne	r3, [r4, #12]
 5102344:	12833001 	addne	r3, r3, #1
 5102348:	1584300c 	strne	r3, [r4, #12]
    }
 510234c:	e8bd8070 	pop	{r4, r5, r6, pc}
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 5102350:	e594300c 	ldr	r3, [r4, #12]
            xReturn = pdPASS;
 5102354:	e3a00001 	mov	r0, #1
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )++;
 5102358:	e0833000 	add	r3, r3, r0
 510235c:	e584300c 	str	r3, [r4, #12]
            xReturn = pdPASS;
 5102360:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( pxMutex );
 5102364:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102368:	e3003900 	movw	r3, #2304	; 0x900
 510236c:	e3001337 	movw	r1, #823	; 0x337
 5102370:	e3403511 	movt	r3, #1297	; 0x511
 5102374:	e3400512 	movt	r0, #1298	; 0x512
 5102378:	e12fff33 	blx	r3
 510237c:	eaffffe5 	b	5102318 <xQueueTakeMutexRecursive+0x10>

05102380 <xQueueGiveMutexRecursive>:
    {
 5102380:	e92d4070 	push	{r4, r5, r6, lr}
        configASSERT( pxMutex );
 5102384:	e2504000 	subs	r4, r0, #0
 5102388:	0a00000e 	beq	51023c8 <xQueueGiveMutexRecursive+0x48>
        if( pxMutex->u.xSemaphore.xMutexHolder == xTaskGetCurrentTaskHandle() )
 510238c:	e5945008 	ldr	r5, [r4, #8]
 5102390:	e3063dec 	movw	r3, #28140	; 0x6dec
 5102394:	e3403510 	movt	r3, #1296	; 0x510
 5102398:	e12fff33 	blx	r3
 510239c:	e1550000 	cmp	r5, r0
 51023a0:	0a000001 	beq	51023ac <xQueueGiveMutexRecursive+0x2c>
            xReturn = pdFAIL;
 51023a4:	e3a00000 	mov	r0, #0
 51023a8:	e8bd8070 	pop	{r4, r5, r6, pc}
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 51023ac:	e594300c 	ldr	r3, [r4, #12]
 51023b0:	e2433001 	sub	r3, r3, #1
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 51023b4:	e3530000 	cmp	r3, #0
            ( pxMutex->u.xSemaphore.uxRecursiveCallCount )--;
 51023b8:	e584300c 	str	r3, [r4, #12]
            if( pxMutex->u.xSemaphore.uxRecursiveCallCount == ( UBaseType_t ) 0 )
 51023bc:	0a000008 	beq	51023e4 <xQueueGiveMutexRecursive+0x64>
            xReturn = pdPASS;
 51023c0:	e3a00001 	mov	r0, #1
    }
 51023c4:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( pxMutex );
 51023c8:	e30d0a74 	movw	r0, #55924	; 0xda74
 51023cc:	e3003900 	movw	r3, #2304	; 0x900
 51023d0:	e30012fb 	movw	r1, #763	; 0x2fb
 51023d4:	e3403511 	movt	r3, #1297	; 0x511
 51023d8:	e3400512 	movt	r0, #1298	; 0x512
 51023dc:	e12fff33 	blx	r3
 51023e0:	eaffffe9 	b	510238c <xQueueGiveMutexRecursive+0xc>
                ( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
 51023e4:	e1a02003 	mov	r2, r3
 51023e8:	e1a01003 	mov	r1, r3
 51023ec:	e1a00004 	mov	r0, r4
 51023f0:	ebfffb0e 	bl	5101030 <xQueueGenericSend>
            xReturn = pdPASS;
 51023f4:	e3a00001 	mov	r0, #1
 51023f8:	e8bd8070 	pop	{r4, r5, r6, pc}

051023fc <vQueueAddToRegistry>:
    {
 51023fc:	e92d4070 	push	{r4, r5, r6, lr}
 5102400:	e1a05001 	mov	r5, r1
        configASSERT( xQueue );
 5102404:	e2504000 	subs	r4, r0, #0
 5102408:	0a000021 	beq	5102494 <vQueueAddToRegistry+0x98>
        if( pcQueueName != NULL )
 510240c:	e3550000 	cmp	r5, #0
 5102410:	08bd8070 	popeq	{r4, r5, r6, pc}
        QueueRegistryItem_t * pxEntryToWrite = NULL;
 5102414:	e3a0c000 	mov	ip, #0
 5102418:	e30c0d78 	movw	r0, #52600	; 0xcd78
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 510241c:	e1a0300c 	mov	r3, ip
 5102420:	e3400511 	movt	r0, #1297	; 0x511
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 5102424:	e0802183 	add	r2, r0, r3, lsl #3
 5102428:	e1a0e183 	lsl	lr, r3, #3
 510242c:	e5922004 	ldr	r2, [r2, #4]
 5102430:	e1520004 	cmp	r2, r4
 5102434:	0a000012 	beq	5102484 <vQueueAddToRegistry+0x88>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 5102438:	e35c0000 	cmp	ip, #0
 510243c:	0a000005 	beq	5102458 <vQueueAddToRegistry+0x5c>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 5102440:	e2833001 	add	r3, r3, #1
 5102444:	e3530008 	cmp	r3, #8
 5102448:	1afffff5 	bne	5102424 <vQueueAddToRegistry+0x28>
            pxEntryToWrite->pcQueueName = pcQueueName;
 510244c:	e58c5000 	str	r5, [ip]
            pxEntryToWrite->xHandle = xQueue;
 5102450:	e58c4004 	str	r4, [ip, #4]
    }
 5102454:	e8bd8070 	pop	{r4, r5, r6, pc}
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 5102458:	e7902183 	ldr	r2, [r0, r3, lsl #3]
 510245c:	e3520000 	cmp	r2, #0
 5102460:	0a000009 	beq	510248c <vQueueAddToRegistry+0x90>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 5102464:	e2833001 	add	r3, r3, #1
 5102468:	e3530008 	cmp	r3, #8
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 510246c:	e0802183 	add	r2, r0, r3, lsl #3
 5102470:	e1a0e183 	lsl	lr, r3, #3
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 5102474:	08bd8070 	popeq	{r4, r5, r6, pc}
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 5102478:	e5922004 	ldr	r2, [r2, #4]
 510247c:	e1540002 	cmp	r4, r2
 5102480:	1afffff4 	bne	5102458 <vQueueAddToRegistry+0x5c>
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 5102484:	e080c00e 	add	ip, r0, lr
        if( pxEntryToWrite != NULL )
 5102488:	eaffffef 	b	510244c <vQueueAddToRegistry+0x50>
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 510248c:	e080c00e 	add	ip, r0, lr
 5102490:	eaffffea 	b	5102440 <vQueueAddToRegistry+0x44>
        configASSERT( xQueue );
 5102494:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102498:	e3003900 	movw	r3, #2304	; 0x900
 510249c:	e3001bc9 	movw	r1, #3017	; 0xbc9
 51024a0:	e3400512 	movt	r0, #1298	; 0x512
 51024a4:	e3403511 	movt	r3, #1297	; 0x511
 51024a8:	e12fff33 	blx	r3
        if( pcQueueName != NULL )
 51024ac:	e3550000 	cmp	r5, #0
 51024b0:	1affffd7 	bne	5102414 <vQueueAddToRegistry+0x18>
 51024b4:	e8bd8070 	pop	{r4, r5, r6, pc}

051024b8 <vQueueUnregisterQueue>:
    {
 51024b8:	e92d4010 	push	{r4, lr}
        configASSERT( xQueue );
 51024bc:	e2504000 	subs	r4, r0, #0
 51024c0:	0a00000e 	beq	5102500 <vQueueUnregisterQueue+0x48>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 51024c4:	e30c0d78 	movw	r0, #52600	; 0xcd78
 51024c8:	e3a03000 	mov	r3, #0
 51024cc:	e3400511 	movt	r0, #1297	; 0x511
 51024d0:	ea000002 	b	51024e0 <vQueueUnregisterQueue+0x28>
 51024d4:	e2833001 	add	r3, r3, #1
 51024d8:	e3530008 	cmp	r3, #8
 51024dc:	08bd8010 	popeq	{r4, pc}
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 51024e0:	e0802183 	add	r2, r0, r3, lsl #3
 51024e4:	e5921004 	ldr	r1, [r2, #4]
 51024e8:	e1510004 	cmp	r1, r4
 51024ec:	1afffff8 	bne	51024d4 <vQueueUnregisterQueue+0x1c>
                xQueueRegistry[ ux ].pcQueueName = NULL;
 51024f0:	e3a01000 	mov	r1, #0
 51024f4:	e7801183 	str	r1, [r0, r3, lsl #3]
                xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 51024f8:	e5821004 	str	r1, [r2, #4]
                break;
 51024fc:	e8bd8010 	pop	{r4, pc}
        configASSERT( xQueue );
 5102500:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102504:	e3003900 	movw	r3, #2304	; 0x900
 5102508:	e3001c1d 	movw	r1, #3101	; 0xc1d
 510250c:	e3403511 	movt	r3, #1297	; 0x511
 5102510:	e3400512 	movt	r0, #1298	; 0x512
 5102514:	e12fff33 	blx	r3
 5102518:	eaffffe9 	b	51024c4 <vQueueUnregisterQueue+0xc>

0510251c <pcQueueGetName>:
    {
 510251c:	e92d4010 	push	{r4, lr}
        configASSERT( xQueue );
 5102520:	e2504000 	subs	r4, r0, #0
 5102524:	0a00000d 	beq	5102560 <pcQueueGetName+0x44>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 5102528:	e30c1d78 	movw	r1, #52600	; 0xcd78
 510252c:	e3a03000 	mov	r3, #0
 5102530:	e3401511 	movt	r1, #1297	; 0x511
            if( xQueueRegistry[ ux ].xHandle == xQueue )
 5102534:	e0812183 	add	r2, r1, r3, lsl #3
 5102538:	e5922004 	ldr	r2, [r2, #4]
 510253c:	e1520004 	cmp	r2, r4
 5102540:	0a000004 	beq	5102558 <pcQueueGetName+0x3c>
        for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 5102544:	e2833001 	add	r3, r3, #1
 5102548:	e3530008 	cmp	r3, #8
 510254c:	1afffff8 	bne	5102534 <pcQueueGetName+0x18>
        const char * pcReturn = NULL;
 5102550:	e3a00000 	mov	r0, #0
    }
 5102554:	e8bd8010 	pop	{r4, pc}
                pcReturn = xQueueRegistry[ ux ].pcQueueName;
 5102558:	e7910183 	ldr	r0, [r1, r3, lsl #3]
                break;
 510255c:	e8bd8010 	pop	{r4, pc}
        configASSERT( xQueue );
 5102560:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102564:	e3003900 	movw	r3, #2304	; 0x900
 5102568:	e3001bfb 	movw	r1, #3067	; 0xbfb
 510256c:	e3403511 	movt	r3, #1297	; 0x511
 5102570:	e3400512 	movt	r0, #1298	; 0x512
 5102574:	e12fff33 	blx	r3
 5102578:	eaffffea 	b	5102528 <pcQueueGetName+0xc>

0510257c <xQueueGenericGetStaticBuffers>:
    {
 510257c:	e92d4070 	push	{r4, r5, r6, lr}
 5102580:	e1a05001 	mov	r5, r1
        configASSERT( pxQueue );
 5102584:	e2506000 	subs	r6, r0, #0
    {
 5102588:	e1a04002 	mov	r4, r2
        configASSERT( pxQueue );
 510258c:	0a000013 	beq	51025e0 <xQueueGenericGetStaticBuffers+0x64>
        configASSERT( ppxStaticQueue );
 5102590:	e3540000 	cmp	r4, #0
 5102594:	0a00000a 	beq	51025c4 <xQueueGenericGetStaticBuffers+0x48>
            if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdTRUE )
 5102598:	e5d63046 	ldrb	r3, [r6, #70]	; 0x46
 510259c:	e3530001 	cmp	r3, #1
 51025a0:	0a000001 	beq	51025ac <xQueueGenericGetStaticBuffers+0x30>
                xReturn = pdFALSE;
 51025a4:	e3a00000 	mov	r0, #0
    }
 51025a8:	e8bd8070 	pop	{r4, r5, r6, pc}
                xReturn = pdTRUE;
 51025ac:	e3a00001 	mov	r0, #1
                if( ppucQueueStorage != NULL )
 51025b0:	e3550000 	cmp	r5, #0
                    *ppucQueueStorage = ( uint8_t * ) pxQueue->pcHead;
 51025b4:	15963000 	ldrne	r3, [r6]
 51025b8:	15853000 	strne	r3, [r5]
                *ppxStaticQueue = ( StaticQueue_t * ) pxQueue;
 51025bc:	e5846000 	str	r6, [r4]
                xReturn = pdTRUE;
 51025c0:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( ppxStaticQueue );
 51025c4:	e30d0a74 	movw	r0, #55924	; 0xda74
 51025c8:	e3003900 	movw	r3, #2304	; 0x900
 51025cc:	e3a01f72 	mov	r1, #456	; 0x1c8
 51025d0:	e3403511 	movt	r3, #1297	; 0x511
 51025d4:	e3400512 	movt	r0, #1298	; 0x512
 51025d8:	e12fff33 	blx	r3
 51025dc:	eaffffed 	b	5102598 <xQueueGenericGetStaticBuffers+0x1c>
        configASSERT( pxQueue );
 51025e0:	e30d0a74 	movw	r0, #55924	; 0xda74
 51025e4:	e3003900 	movw	r3, #2304	; 0x900
 51025e8:	e30011c7 	movw	r1, #455	; 0x1c7
 51025ec:	e3403511 	movt	r3, #1297	; 0x511
 51025f0:	e3400512 	movt	r0, #1298	; 0x512
 51025f4:	e12fff33 	blx	r3
 51025f8:	eaffffe4 	b	5102590 <xQueueGenericGetStaticBuffers+0x14>

051025fc <xQueueAddToSet>:
    {
 51025fc:	e92d4030 	push	{r4, r5, lr}
 5102600:	e1a04000 	mov	r4, r0
        taskENTER_CRITICAL();
 5102604:	e30c3930 	movw	r3, #51504	; 0xc930
    {
 5102608:	e24dd00c 	sub	sp, sp, #12
 510260c:	e1a05001 	mov	r5, r1
        taskENTER_CRITICAL();
 5102610:	e3403510 	movt	r3, #1296	; 0x510
 5102614:	e12fff33 	blx	r3
            if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
 5102618:	e5940048 	ldr	r0, [r4, #72]	; 0x48
 510261c:	e3500000 	cmp	r0, #0
                xReturn = pdFAIL;
 5102620:	13a00000 	movne	r0, #0
            if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
 5102624:	0a000006 	beq	5102644 <xQueueAddToSet+0x48>
 5102628:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 510262c:	e30c3988 	movw	r3, #51592	; 0xc988
 5102630:	e3403510 	movt	r3, #1296	; 0x510
 5102634:	e12fff33 	blx	r3
    }
 5102638:	e59d0004 	ldr	r0, [sp, #4]
 510263c:	e28dd00c 	add	sp, sp, #12
 5102640:	e8bd8030 	pop	{r4, r5, pc}
            else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
 5102644:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5102648:	e3530000 	cmp	r3, #0
                xReturn = pdPASS;
 510264c:	03a00001 	moveq	r0, #1
                ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
 5102650:	05845048 	streq	r5, [r4, #72]	; 0x48
                xReturn = pdPASS;
 5102654:	eafffff3 	b	5102628 <xQueueAddToSet+0x2c>

05102658 <xQueueRemoveFromSet>:
        if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
 5102658:	e5903048 	ldr	r3, [r0, #72]	; 0x48
 510265c:	e1530001 	cmp	r3, r1
 5102660:	0a000001 	beq	510266c <xQueueRemoveFromSet+0x14>
            xReturn = pdFAIL;
 5102664:	e3a00000 	mov	r0, #0
    }
 5102668:	e12fff1e 	bx	lr
    {
 510266c:	e92d4010 	push	{r4, lr}
        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 5102670:	e5904038 	ldr	r4, [r0, #56]	; 0x38
    {
 5102674:	e24dd008 	sub	sp, sp, #8
        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 5102678:	e3540000 	cmp	r4, #0
            xReturn = pdFAIL;
 510267c:	13a00000 	movne	r0, #0
        else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
 5102680:	0a000001 	beq	510268c <xQueueRemoveFromSet+0x34>
    }
 5102684:	e28dd008 	add	sp, sp, #8
 5102688:	e8bd8010 	pop	{r4, pc}
 510268c:	e58d0004 	str	r0, [sp, #4]
            taskENTER_CRITICAL();
 5102690:	e30c3930 	movw	r3, #51504	; 0xc930
 5102694:	e3403510 	movt	r3, #1296	; 0x510
 5102698:	e12fff33 	blx	r3
                pxQueueOrSemaphore->pxQueueSetContainer = NULL;
 510269c:	e59d0004 	ldr	r0, [sp, #4]
 51026a0:	e5804048 	str	r4, [r0, #72]	; 0x48
            taskEXIT_CRITICAL();
 51026a4:	e30c3988 	movw	r3, #51592	; 0xc988
 51026a8:	e3403510 	movt	r3, #1296	; 0x510
 51026ac:	e12fff33 	blx	r3
            xReturn = pdPASS;
 51026b0:	e3a00001 	mov	r0, #1
 51026b4:	eafffff2 	b	5102684 <xQueueRemoveFromSet+0x2c>

051026b8 <xQueueSelectFromSet>:
    {
 51026b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        QueueSetMemberHandle_t xReturn = NULL;
 51026bc:	e3a03000 	mov	r3, #0
    {
 51026c0:	e24dd00c 	sub	sp, sp, #12
 51026c4:	e1a02001 	mov	r2, r1
        ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait );
 51026c8:	e28d1004 	add	r1, sp, #4
        QueueSetMemberHandle_t xReturn = NULL;
 51026cc:	e58d3004 	str	r3, [sp, #4]
        ( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait );
 51026d0:	ebfffbe7 	bl	5101674 <xQueueReceive>
    }
 51026d4:	e59d0004 	ldr	r0, [sp, #4]
 51026d8:	e28dd00c 	add	sp, sp, #12
 51026dc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

051026e0 <xQueueSelectFromSetFromISR>:
    {
 51026e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        QueueSetMemberHandle_t xReturn = NULL;
 51026e4:	e3a02000 	mov	r2, #0
    {
 51026e8:	e24dd00c 	sub	sp, sp, #12
        ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL );
 51026ec:	e28d1004 	add	r1, sp, #4
        QueueSetMemberHandle_t xReturn = NULL;
 51026f0:	e58d2004 	str	r2, [sp, #4]
        ( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL );
 51026f4:	ebfffd96 	bl	5101d54 <xQueueReceiveFromISR>
    }
 51026f8:	e59d0004 	ldr	r0, [sp, #4]
 51026fc:	e28dd00c 	add	sp, sp, #12
 5102700:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

05102704 <vQueueWaitForMessageRestricted>:
        prvLockQueue( pxQueue );
 5102704:	e30c3930 	movw	r3, #51504	; 0xc930
    {
 5102708:	e92d4070 	push	{r4, r5, r6, lr}
 510270c:	e1a04000 	mov	r4, r0
        prvLockQueue( pxQueue );
 5102710:	e3403510 	movt	r3, #1296	; 0x510
    {
 5102714:	e1a05001 	mov	r5, r1
 5102718:	e1a06002 	mov	r6, r2
        prvLockQueue( pxQueue );
 510271c:	e12fff33 	blx	r3
 5102720:	e5d43044 	ldrb	r3, [r4, #68]	; 0x44
 5102724:	e35300ff 	cmp	r3, #255	; 0xff
 5102728:	03a03000 	moveq	r3, #0
 510272c:	05c43044 	strbeq	r3, [r4, #68]	; 0x44
 5102730:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
 5102734:	e35300ff 	cmp	r3, #255	; 0xff
 5102738:	03a03000 	moveq	r3, #0
 510273c:	05c43045 	strbeq	r3, [r4, #69]	; 0x45
 5102740:	e30c3988 	movw	r3, #51592	; 0xc988
 5102744:	e3403510 	movt	r3, #1296	; 0x510
 5102748:	e12fff33 	blx	r3
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 510274c:	e5943038 	ldr	r3, [r4, #56]	; 0x38
 5102750:	e3530000 	cmp	r3, #0
 5102754:	0a000002 	beq	5102764 <vQueueWaitForMessageRestricted+0x60>
        prvUnlockQueue( pxQueue );
 5102758:	e1a00004 	mov	r0, r4
 510275c:	ebfff9ed 	bl	5100f18 <prvUnlockQueue>
    }
 5102760:	e8bd8070 	pop	{r4, r5, r6, pc}
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 5102764:	e3063838 	movw	r3, #26680	; 0x6838
 5102768:	e1a02006 	mov	r2, r6
 510276c:	e1a01005 	mov	r1, r5
 5102770:	e2840024 	add	r0, r4, #36	; 0x24
 5102774:	e3403510 	movt	r3, #1296	; 0x510
 5102778:	e12fff33 	blx	r3
 510277c:	eafffff5 	b	5102758 <vQueueWaitForMessageRestricted+0x54>

05102780 <xQueueGenericReset>:
{
 5102780:	e92d4070 	push	{r4, r5, r6, lr}
    configASSERT( pxQueue );
 5102784:	e2504000 	subs	r4, r0, #0
 5102788:	0a00002a 	beq	5102838 <xQueueGenericReset+0xb8>
        ( pxQueue->uxLength >= 1U ) &&
 510278c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
    if( ( pxQueue != NULL ) &&
 5102790:	e3530000 	cmp	r3, #0
 5102794:	0a00001f 	beq	5102818 <xQueueGenericReset+0x98>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 5102798:	e5946040 	ldr	r6, [r4, #64]	; 0x40
 510279c:	e0863396 	umull	r3, r6, r6, r3
 51027a0:	e3560000 	cmp	r6, #0
 51027a4:	1a00001b 	bne	5102818 <xQueueGenericReset+0x98>
        taskENTER_CRITICAL();
 51027a8:	e30c3930 	movw	r3, #51504	; 0xc930
 51027ac:	e1a05001 	mov	r5, r1
 51027b0:	e3403510 	movt	r3, #1296	; 0x510
 51027b4:	e12fff33 	blx	r3
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 51027b8:	e5941040 	ldr	r1, [r4, #64]	; 0x40
 51027bc:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
            pxQueue->cRxLock = queueUNLOCKED;
 51027c0:	e3e00000 	mvn	r0, #0
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 51027c4:	e5942000 	ldr	r2, [r4]
            if( xNewQueue == pdFALSE )
 51027c8:	e3550000 	cmp	r5, #0
            pxQueue->pcWriteTo = pxQueue->pcHead;
 51027cc:	e5842004 	str	r2, [r4, #4]
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 51027d0:	e0030193 	mul	r3, r3, r1
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 51027d4:	e5846038 	str	r6, [r4, #56]	; 0x38
            pxQueue->cRxLock = queueUNLOCKED;
 51027d8:	e5c40044 	strb	r0, [r4, #68]	; 0x44
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );
 51027dc:	e0431001 	sub	r1, r3, r1
            pxQueue->cTxLock = queueUNLOCKED;
 51027e0:	e5c40045 	strb	r0, [r4, #69]	; 0x45
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 51027e4:	e0823003 	add	r3, r2, r3
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );
 51027e8:	e0822001 	add	r2, r2, r1
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 51027ec:	e5843008 	str	r3, [r4, #8]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize );
 51027f0:	e584200c 	str	r2, [r4, #12]
            if( xNewQueue == pdFALSE )
 51027f4:	1a000020 	bne	510287c <xQueueGenericReset+0xfc>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 51027f8:	e5943010 	ldr	r3, [r4, #16]
 51027fc:	e3530000 	cmp	r3, #0
 5102800:	1a000013 	bne	5102854 <xQueueGenericReset+0xd4>
        taskEXIT_CRITICAL();
 5102804:	e30c3988 	movw	r3, #51592	; 0xc988
 5102808:	e3403510 	movt	r3, #1296	; 0x510
 510280c:	e12fff33 	blx	r3
    BaseType_t xReturn = pdPASS;
 5102810:	e3a00001 	mov	r0, #1
 5102814:	e8bd8070 	pop	{r4, r5, r6, pc}
 5102818:	e3004900 	movw	r4, #2304	; 0x900
 510281c:	e3404511 	movt	r4, #1297	; 0x511
    configASSERT( xReturn != pdFAIL );
 5102820:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102824:	e3a01f5b 	mov	r1, #364	; 0x16c
 5102828:	e3400512 	movt	r0, #1298	; 0x512
 510282c:	e12fff34 	blx	r4
 5102830:	e3a00000 	mov	r0, #0
}
 5102834:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxQueue );
 5102838:	e30d0a74 	movw	r0, #55924	; 0xda74
 510283c:	e3004900 	movw	r4, #2304	; 0x900
 5102840:	e3001137 	movw	r1, #311	; 0x137
 5102844:	e3404511 	movt	r4, #1297	; 0x511
 5102848:	e3400512 	movt	r0, #1298	; 0x512
 510284c:	e12fff34 	blx	r4
    if( ( pxQueue != NULL ) &&
 5102850:	eafffff2 	b	5102820 <xQueueGenericReset+0xa0>
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 5102854:	e30638d0 	movw	r3, #26832	; 0x68d0
 5102858:	e2840010 	add	r0, r4, #16
 510285c:	e3403510 	movt	r3, #1296	; 0x510
 5102860:	e12fff33 	blx	r3
 5102864:	e3500000 	cmp	r0, #0
 5102868:	0affffe5 	beq	5102804 <xQueueGenericReset+0x84>
                        queueYIELD_IF_USING_PREEMPTION();
 510286c:	e3003000 	movw	r3, #0
 5102870:	e3403511 	movt	r3, #1297	; 0x511
 5102874:	e12fff33 	blx	r3
 5102878:	eaffffe1 	b	5102804 <xQueueGenericReset+0x84>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 510287c:	e3005c28 	movw	r5, #3112	; 0xc28
 5102880:	e2840010 	add	r0, r4, #16
 5102884:	e3405510 	movt	r5, #1296	; 0x510
 5102888:	e12fff35 	blx	r5
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 510288c:	e2840024 	add	r0, r4, #36	; 0x24
 5102890:	e12fff35 	blx	r5
 5102894:	eaffffda 	b	5102804 <xQueueGenericReset+0x84>

05102898 <xQueueGenericCreate>:
    {
 5102898:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 510289c:	e2504000 	subs	r4, r0, #0
 51028a0:	0a00001a 	beq	5102910 <xQueueGenericCreate+0x78>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 51028a4:	e0873194 	umull	r3, r7, r4, r1
 51028a8:	e1a05001 	mov	r5, r1
 51028ac:	e3570000 	cmp	r7, #0
 51028b0:	1a000016 	bne	5102910 <xQueueGenericCreate+0x78>
            ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 51028b4:	e0000491 	mul	r0, r1, r4
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 51028b8:	e370004d 	cmn	r0, #77	; 0x4d
 51028bc:	8a000013 	bhi	5102910 <xQueueGenericCreate+0x78>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 51028c0:	e3073f74 	movw	r3, #32628	; 0x7f74
 51028c4:	e280004c 	add	r0, r0, #76	; 0x4c
 51028c8:	e3403510 	movt	r3, #1296	; 0x510
 51028cc:	e12fff33 	blx	r3
            if( pxNewQueue != NULL )
 51028d0:	e2506000 	subs	r6, r0, #0
 51028d4:	0a000014 	beq	510292c <xQueueGenericCreate+0x94>
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 51028d8:	e3a01001 	mov	r1, #1
    if( uxItemSize == ( UBaseType_t ) 0 )
 51028dc:	e3550000 	cmp	r5, #0
 51028e0:	01a03006 	moveq	r3, r6
                pucQueueStorage += sizeof( Queue_t );
 51028e4:	1286304c 	addne	r3, r6, #76	; 0x4c
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
 51028e8:	e5c67046 	strb	r7, [r6, #70]	; 0x46
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 51028ec:	e1a00006 	mov	r0, r6
 51028f0:	e5863000 	str	r3, [r6]
    pxNewQueue->uxLength = uxQueueLength;
 51028f4:	e586403c 	str	r4, [r6, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 51028f8:	e5865040 	str	r5, [r6, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 51028fc:	ebffff9f 	bl	5102780 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
 5102900:	e3a03000 	mov	r3, #0
    }
 5102904:	e1a00006 	mov	r0, r6
        pxNewQueue->pxQueueSetContainer = NULL;
 5102908:	e5863048 	str	r3, [r6, #72]	; 0x48
    }
 510290c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            configASSERT( pxNewQueue );
 5102910:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102914:	e3003900 	movw	r3, #2304	; 0x900
 5102918:	e300122a 	movw	r1, #554	; 0x22a
 510291c:	e3400512 	movt	r0, #1298	; 0x512
        Queue_t * pxNewQueue = NULL;
 5102920:	e3a06000 	mov	r6, #0
            configASSERT( pxNewQueue );
 5102924:	e3403511 	movt	r3, #1297	; 0x511
 5102928:	e12fff33 	blx	r3
    }
 510292c:	e1a00006 	mov	r0, r6
 5102930:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05102934 <xQueueCreateCountingSemaphore>:
    {
 5102934:	e92d4070 	push	{r4, r5, r6, lr}
        if( ( uxMaxCount != 0U ) &&
 5102938:	e2504000 	subs	r4, r0, #0
 510293c:	13a04001 	movne	r4, #1
 5102940:	e1500001 	cmp	r0, r1
 5102944:	33a04000 	movcc	r4, #0
 5102948:	e3540000 	cmp	r4, #0
 510294c:	0a000006 	beq	510296c <xQueueCreateCountingSemaphore+0x38>
            xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 5102950:	e1a05001 	mov	r5, r1
 5102954:	e3a02002 	mov	r2, #2
 5102958:	e3a01000 	mov	r1, #0
 510295c:	ebffffcd 	bl	5102898 <xQueueGenericCreate>
            if( xHandle != NULL )
 5102960:	e3500000 	cmp	r0, #0
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 5102964:	15805038 	strne	r5, [r0, #56]	; 0x38
                traceCREATE_COUNTING_SEMAPHORE();
 5102968:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( xHandle );
 510296c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102970:	e3003900 	movw	r3, #2304	; 0x900
 5102974:	e300139f 	movw	r1, #927	; 0x39f
 5102978:	e3403511 	movt	r3, #1297	; 0x511
 510297c:	e3400512 	movt	r0, #1298	; 0x512
 5102980:	e12fff33 	blx	r3
        QueueHandle_t xHandle = NULL;
 5102984:	e1a00004 	mov	r0, r4
    }
 5102988:	e8bd8070 	pop	{r4, r5, r6, pc}

0510298c <xQueueGenericCreateStatic>:
    {
 510298c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
        configASSERT( pxStaticQueue );
 5102990:	e2534000 	subs	r4, r3, #0
    {
 5102994:	e24dd00c 	sub	sp, sp, #12
        configASSERT( pxStaticQueue );
 5102998:	0a000033 	beq	5102a6c <xQueueGenericCreateStatic+0xe0>
 510299c:	e1a06000 	mov	r6, r0
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 51029a0:	e3500000 	cmp	r0, #0
 51029a4:	0a000027 	beq	5102a48 <xQueueGenericCreateStatic+0xbc>
 51029a8:	e1a05001 	mov	r5, r1
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0U ) ) ) &&
 51029ac:	e2513000 	subs	r3, r1, #0
 51029b0:	13a03001 	movne	r3, #1
 51029b4:	e1a07002 	mov	r7, r2
            ( pxStaticQueue != NULL ) &&
 51029b8:	e3520000 	cmp	r2, #0
 51029bc:	03833001 	orreq	r3, r3, #1
 51029c0:	e3530000 	cmp	r3, #0
 51029c4:	0a00001f 	beq	5102a48 <xQueueGenericCreateStatic+0xbc>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0U ) ) ) )
 51029c8:	e16f3f11 	clz	r3, r1
 51029cc:	e1a032a3 	lsr	r3, r3, #5
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0U ) ) ) &&
 51029d0:	e3520000 	cmp	r2, #0
 51029d4:	13833001 	orrne	r3, r3, #1
 51029d8:	e3530000 	cmp	r3, #0
 51029dc:	0a000019 	beq	5102a48 <xQueueGenericCreateStatic+0xbc>
                volatile size_t xSize = sizeof( StaticQueue_t );
 51029e0:	e3a0304c 	mov	r3, #76	; 0x4c
 51029e4:	e58d3004 	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 51029e8:	e59d3004 	ldr	r3, [sp, #4]
 51029ec:	e353004c 	cmp	r3, #76	; 0x4c
 51029f0:	0a000005 	beq	5102a0c <xQueueGenericCreateStatic+0x80>
 51029f4:	e30d0a74 	movw	r0, #55924	; 0xda74
 51029f8:	e3003900 	movw	r3, #2304	; 0x900
 51029fc:	e3001196 	movw	r1, #406	; 0x196
 5102a00:	e3400512 	movt	r0, #1298	; 0x512
 5102a04:	e3403511 	movt	r3, #1297	; 0x511
 5102a08:	e12fff33 	blx	r3
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102a0c:	e3a01001 	mov	r1, #1
 5102a10:	e3550000 	cmp	r5, #0
 5102a14:	01a07004 	moveq	r7, r4
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102a18:	e1a00004 	mov	r0, r4
    pxNewQueue->uxLength = uxQueueLength;
 5102a1c:	e584603c 	str	r6, [r4, #60]	; 0x3c
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102a20:	e5c41046 	strb	r1, [r4, #70]	; 0x46
 5102a24:	e5847000 	str	r7, [r4]
    pxNewQueue->uxItemSize = uxItemSize;
 5102a28:	e5845040 	str	r5, [r4, #64]	; 0x40
                ( void ) xSize;                             /* Prevent unused variable warning when configASSERT() is not defined. */
 5102a2c:	e59d3004 	ldr	r3, [sp, #4]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102a30:	ebffff52 	bl	5102780 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
 5102a34:	e3a03000 	mov	r3, #0
}
 5102a38:	e1a00004 	mov	r0, r4
        pxNewQueue->pxQueueSetContainer = NULL;
 5102a3c:	e5843048 	str	r3, [r4, #72]	; 0x48
    }
 5102a40:	e28dd00c 	add	sp, sp, #12
 5102a44:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
 5102a48:	e3004900 	movw	r4, #2304	; 0x900
 5102a4c:	e3404511 	movt	r4, #1297	; 0x511
            configASSERT( pxNewQueue );
 5102a50:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102a54:	e3a01e1b 	mov	r1, #432	; 0x1b0
 5102a58:	e3400512 	movt	r0, #1298	; 0x512
 5102a5c:	e12fff34 	blx	r4
        Queue_t * pxNewQueue = NULL;
 5102a60:	e3a00000 	mov	r0, #0
    }
 5102a64:	e28dd00c 	add	sp, sp, #12
 5102a68:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxStaticQueue );
 5102a6c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102a70:	e3004900 	movw	r4, #2304	; 0x900
 5102a74:	e3a01f61 	mov	r1, #388	; 0x184
 5102a78:	e3404511 	movt	r4, #1297	; 0x511
 5102a7c:	e3400512 	movt	r0, #1298	; 0x512
 5102a80:	e12fff34 	blx	r4
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 5102a84:	eafffff1 	b	5102a50 <xQueueGenericCreateStatic+0xc4>

05102a88 <xQueueCreateMutexStatic>:
    {
 5102a88:	e92d4030 	push	{r4, r5, lr}
        configASSERT( pxStaticQueue );
 5102a8c:	e2514000 	subs	r4, r1, #0
    {
 5102a90:	e24dd00c 	sub	sp, sp, #12
        configASSERT( pxStaticQueue );
 5102a94:	0a000019 	beq	5102b00 <xQueueCreateMutexStatic+0x78>
                volatile size_t xSize = sizeof( StaticQueue_t );
 5102a98:	e3a0304c 	mov	r3, #76	; 0x4c
 5102a9c:	e58d3004 	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 5102aa0:	e59d3004 	ldr	r3, [sp, #4]
 5102aa4:	e353004c 	cmp	r3, #76	; 0x4c
 5102aa8:	1a000021 	bne	5102b34 <xQueueCreateMutexStatic+0xac>
    pxNewQueue->uxItemSize = uxItemSize;
 5102aac:	e3a05000 	mov	r5, #0
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102ab0:	e3a01001 	mov	r1, #1
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 5102ab4:	e5844000 	str	r4, [r4]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102ab8:	e1a00004 	mov	r0, r4
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102abc:	e5c41046 	strb	r1, [r4, #70]	; 0x46
    pxNewQueue->uxLength = uxQueueLength;
 5102ac0:	e584103c 	str	r1, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 5102ac4:	e5845040 	str	r5, [r4, #64]	; 0x40
                ( void ) xSize;                             /* Prevent unused variable warning when configASSERT() is not defined. */
 5102ac8:	e59d3004 	ldr	r3, [sp, #4]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102acc:	ebffff2b 	bl	5102780 <xQueueGenericReset>
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 5102ad0:	e1a03005 	mov	r3, r5
 5102ad4:	e1a02005 	mov	r2, r5
 5102ad8:	e1a01005 	mov	r1, r5
 5102adc:	e1a00004 	mov	r0, r4
        pxNewQueue->pxQueueSetContainer = NULL;
 5102ae0:	e5845048 	str	r5, [r4, #72]	; 0x48
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 5102ae4:	e5845008 	str	r5, [r4, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 5102ae8:	e5845000 	str	r5, [r4]
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 5102aec:	e584500c 	str	r5, [r4, #12]
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 5102af0:	ebfff94e 	bl	5101030 <xQueueGenericSend>
    }
 5102af4:	e1a00004 	mov	r0, r4
 5102af8:	e28dd00c 	add	sp, sp, #12
 5102afc:	e8bd8030 	pop	{r4, r5, pc}
        configASSERT( pxStaticQueue );
 5102b00:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102b04:	e3005900 	movw	r5, #2304	; 0x900
 5102b08:	e3a01f61 	mov	r1, #388	; 0x184
 5102b0c:	e3405511 	movt	r5, #1297	; 0x511
 5102b10:	e3400512 	movt	r0, #1298	; 0x512
 5102b14:	e12fff35 	blx	r5
            configASSERT( pxNewQueue );
 5102b18:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102b1c:	e3a01e1b 	mov	r1, #432	; 0x1b0
 5102b20:	e3400512 	movt	r0, #1298	; 0x512
 5102b24:	e12fff35 	blx	r5
    }
 5102b28:	e1a00004 	mov	r0, r4
 5102b2c:	e28dd00c 	add	sp, sp, #12
 5102b30:	e8bd8030 	pop	{r4, r5, pc}
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 5102b34:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102b38:	e3003900 	movw	r3, #2304	; 0x900
 5102b3c:	e3001196 	movw	r1, #406	; 0x196
 5102b40:	e3403511 	movt	r3, #1297	; 0x511
 5102b44:	e3400512 	movt	r0, #1298	; 0x512
 5102b48:	e12fff33 	blx	r3
 5102b4c:	eaffffd6 	b	5102aac <xQueueCreateMutexStatic+0x24>

05102b50 <xQueueCreateMutex>:
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 5102b50:	e3073f74 	movw	r3, #32628	; 0x7f74
 5102b54:	e3a0004c 	mov	r0, #76	; 0x4c
    {
 5102b58:	e92d4070 	push	{r4, r5, r6, lr}
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 5102b5c:	e3403510 	movt	r3, #1296	; 0x510
 5102b60:	e12fff33 	blx	r3
            if( pxNewQueue != NULL )
 5102b64:	e2504000 	subs	r4, r0, #0
 5102b68:	0a00000f 	beq	5102bac <xQueueCreateMutex+0x5c>
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
 5102b6c:	e3a05000 	mov	r5, #0
    pxNewQueue->uxLength = uxQueueLength;
 5102b70:	e3a01001 	mov	r1, #1
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 5102b74:	e5844000 	str	r4, [r4]
    pxNewQueue->uxLength = uxQueueLength;
 5102b78:	e584103c 	str	r1, [r4, #60]	; 0x3c
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
 5102b7c:	e5c45046 	strb	r5, [r4, #70]	; 0x46
    pxNewQueue->uxItemSize = uxItemSize;
 5102b80:	e5845040 	str	r5, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102b84:	ebfffefd 	bl	5102780 <xQueueGenericReset>
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 5102b88:	e1a03005 	mov	r3, r5
 5102b8c:	e1a02005 	mov	r2, r5
 5102b90:	e1a01005 	mov	r1, r5
        pxNewQueue->pxQueueSetContainer = NULL;
 5102b94:	e5845048 	str	r5, [r4, #72]	; 0x48
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 5102b98:	e1a00004 	mov	r0, r4
            pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
 5102b9c:	e5845008 	str	r5, [r4, #8]
            pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
 5102ba0:	e5845000 	str	r5, [r4]
            pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
 5102ba4:	e584500c 	str	r5, [r4, #12]
            ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
 5102ba8:	ebfff920 	bl	5101030 <xQueueGenericSend>
    }
 5102bac:	e1a00004 	mov	r0, r4
 5102bb0:	e8bd8070 	pop	{r4, r5, r6, pc}

05102bb4 <xQueueCreateCountingSemaphoreStatic>:
    {
 5102bb4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
        if( ( uxMaxCount != 0U ) &&
 5102bb8:	e2505000 	subs	r5, r0, #0
 5102bbc:	13a05001 	movne	r5, #1
 5102bc0:	e1500001 	cmp	r0, r1
 5102bc4:	33a05000 	movcc	r5, #0
    {
 5102bc8:	e24dd00c 	sub	sp, sp, #12
        if( ( uxMaxCount != 0U ) &&
 5102bcc:	e3550000 	cmp	r5, #0
 5102bd0:	0a000024 	beq	5102c68 <xQueueCreateCountingSemaphoreStatic+0xb4>
 5102bd4:	e1a04002 	mov	r4, r2
        configASSERT( pxStaticQueue );
 5102bd8:	e3520000 	cmp	r2, #0
 5102bdc:	0a000014 	beq	5102c34 <xQueueCreateCountingSemaphoreStatic+0x80>
                volatile size_t xSize = sizeof( StaticQueue_t );
 5102be0:	e3a0304c 	mov	r3, #76	; 0x4c
 5102be4:	e1a07001 	mov	r7, r1
 5102be8:	e1a06000 	mov	r6, r0
 5102bec:	e58d3004 	str	r3, [sp, #4]
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 5102bf0:	e59d3004 	ldr	r3, [sp, #4]
 5102bf4:	e353004c 	cmp	r3, #76	; 0x4c
 5102bf8:	1a000023 	bne	5102c8c <xQueueCreateCountingSemaphoreStatic+0xd8>
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102bfc:	e3a01001 	mov	r1, #1
    pxNewQueue->uxItemSize = uxItemSize;
 5102c00:	e3a05000 	mov	r5, #0
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 5102c04:	e5844000 	str	r4, [r4]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102c08:	e1a00004 	mov	r0, r4
    pxNewQueue->uxLength = uxQueueLength;
 5102c0c:	e584603c 	str	r6, [r4, #60]	; 0x3c
                pxNewQueue->ucStaticallyAllocated = pdTRUE;
 5102c10:	e5c41046 	strb	r1, [r4, #70]	; 0x46
    pxNewQueue->uxItemSize = uxItemSize;
 5102c14:	e5845040 	str	r5, [r4, #64]	; 0x40
                ( void ) xSize;                             /* Prevent unused variable warning when configASSERT() is not defined. */
 5102c18:	e59d3004 	ldr	r3, [sp, #4]
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102c1c:	ebfffed7 	bl	5102780 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
 5102c20:	e5845048 	str	r5, [r4, #72]	; 0x48
                ( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 5102c24:	e1a00004 	mov	r0, r4
 5102c28:	e5847038 	str	r7, [r4, #56]	; 0x38
    }
 5102c2c:	e28dd00c 	add	sp, sp, #12
 5102c30:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxStaticQueue );
 5102c34:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102c38:	e3005900 	movw	r5, #2304	; 0x900
 5102c3c:	e3a01f61 	mov	r1, #388	; 0x184
 5102c40:	e3405511 	movt	r5, #1297	; 0x511
 5102c44:	e3400512 	movt	r0, #1298	; 0x512
 5102c48:	e12fff35 	blx	r5
            configASSERT( pxNewQueue );
 5102c4c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102c50:	e3a01e1b 	mov	r1, #432	; 0x1b0
 5102c54:	e3400512 	movt	r0, #1298	; 0x512
 5102c58:	e12fff35 	blx	r5
        Queue_t * pxNewQueue = NULL;
 5102c5c:	e1a00004 	mov	r0, r4
    }
 5102c60:	e28dd00c 	add	sp, sp, #12
 5102c64:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
            configASSERT( xHandle );
 5102c68:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102c6c:	e3003900 	movw	r3, #2304	; 0x900
 5102c70:	e3a01fde 	mov	r1, #888	; 0x378
 5102c74:	e3403511 	movt	r3, #1297	; 0x511
 5102c78:	e3400512 	movt	r0, #1298	; 0x512
 5102c7c:	e12fff33 	blx	r3
        QueueHandle_t xHandle = NULL;
 5102c80:	e1a00005 	mov	r0, r5
    }
 5102c84:	e28dd00c 	add	sp, sp, #12
 5102c88:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
                configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 5102c8c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102c90:	e3003900 	movw	r3, #2304	; 0x900
 5102c94:	e3001196 	movw	r1, #406	; 0x196
 5102c98:	e3403511 	movt	r3, #1297	; 0x511
 5102c9c:	e3400512 	movt	r0, #1298	; 0x512
 5102ca0:	e12fff33 	blx	r3
 5102ca4:	eaffffd4 	b	5102bfc <xQueueCreateCountingSemaphoreStatic+0x48>

05102ca8 <xQueueCreateSet>:
    {
 5102ca8:	e92d4070 	push	{r4, r5, r6, lr}
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 5102cac:	e2504000 	subs	r4, r0, #0
 5102cb0:	0a000015 	beq	5102d0c <xQueueCreateSet+0x64>
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 5102cb4:	e1b06f24 	lsrs	r6, r4, #30
 5102cb8:	1a000013 	bne	5102d0c <xQueueCreateSet+0x64>
            ( ( UBaseType_t ) ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
 5102cbc:	e1a00104 	lsl	r0, r4, #2
            ( ( SIZE_MAX / uxQueueLength ) >= uxItemSize ) &&
 5102cc0:	e370004d 	cmn	r0, #77	; 0x4d
 5102cc4:	8a000010 	bhi	5102d0c <xQueueCreateSet+0x64>
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 5102cc8:	e3073f74 	movw	r3, #32628	; 0x7f74
 5102ccc:	e280004c 	add	r0, r0, #76	; 0x4c
 5102cd0:	e3403510 	movt	r3, #1296	; 0x510
 5102cd4:	e12fff33 	blx	r3
            if( pxNewQueue != NULL )
 5102cd8:	e2505000 	subs	r5, r0, #0
 5102cdc:	0a000011 	beq	5102d28 <xQueueCreateSet+0x80>
    pxNewQueue->uxItemSize = uxItemSize;
 5102ce0:	e3a03004 	mov	r3, #4
                pucQueueStorage += sizeof( Queue_t );
 5102ce4:	e285204c 	add	r2, r5, #76	; 0x4c
                    pxNewQueue->ucStaticallyAllocated = pdFALSE;
 5102ce8:	e5c56046 	strb	r6, [r5, #70]	; 0x46
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102cec:	e3a01001 	mov	r1, #1
    pxNewQueue->uxLength = uxQueueLength;
 5102cf0:	e585403c 	str	r4, [r5, #60]	; 0x3c
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 5102cf4:	e5852000 	str	r2, [r5]
    pxNewQueue->uxItemSize = uxItemSize;
 5102cf8:	e5853040 	str	r3, [r5, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 5102cfc:	ebfffe9f 	bl	5102780 <xQueueGenericReset>
        pxNewQueue->pxQueueSetContainer = NULL;
 5102d00:	e5856048 	str	r6, [r5, #72]	; 0x48
    }
 5102d04:	e1a00005 	mov	r0, r5
 5102d08:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( pxNewQueue );
 5102d0c:	e30d0a74 	movw	r0, #55924	; 0xda74
 5102d10:	e3003900 	movw	r3, #2304	; 0x900
 5102d14:	e300122a 	movw	r1, #554	; 0x22a
 5102d18:	e3400512 	movt	r0, #1298	; 0x512
        Queue_t * pxNewQueue = NULL;
 5102d1c:	e3a05000 	mov	r5, #0
            configASSERT( pxNewQueue );
 5102d20:	e3403511 	movt	r3, #1297	; 0x511
 5102d24:	e12fff33 	blx	r3
    }
 5102d28:	e1a00005 	mov	r0, r5
 5102d2c:	e8bd8070 	pop	{r4, r5, r6, pc}

05102d30 <uxQueueGetQueueItemSize>:
}
 5102d30:	e5900040 	ldr	r0, [r0, #64]	; 0x40
 5102d34:	e12fff1e 	bx	lr

05102d38 <uxQueueGetQueueLength>:
}
 5102d38:	e590003c 	ldr	r0, [r0, #60]	; 0x3c
 5102d3c:	e12fff1e 	bx	lr

05102d40 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
 5102d40:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5102d44:	e1a05000 	mov	r5, r0
    size_t xFirstLength;

    configASSERT( xCount > ( size_t ) 0 );
 5102d48:	e2524000 	subs	r4, r2, #0
{
 5102d4c:	e1a09001 	mov	r9, r1
 5102d50:	e1a06003 	mov	r6, r3
    configASSERT( xCount > ( size_t ) 0 );
 5102d54:	0a00001e 	beq	5102dd4 <prvWriteBytesToBuffer+0x94>

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 5102d58:	e5903008 	ldr	r3, [r0, #8]
 5102d5c:	e0437006 	sub	r7, r3, r6
 5102d60:	e1570004 	cmp	r7, r4
 5102d64:	21a07004 	movcs	r7, r4

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
 5102d68:	e0862007 	add	r2, r6, r7
 5102d6c:	e1530002 	cmp	r3, r2
 5102d70:	33008900 	movwcc	r8, #2304	; 0x900
 5102d74:	33408511 	movtcc	r8, #1297	; 0x511
 5102d78:	3a00001f 	bcc	5102dfc <prvWriteBytesToBuffer+0xbc>
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength );
 5102d7c:	e5950018 	ldr	r0, [r5, #24]
 5102d80:	e3098ca1 	movw	r8, #40097	; 0x9ca1
 5102d84:	e1a02007 	mov	r2, r7
 5102d88:	e3408511 	movt	r8, #1297	; 0x511
 5102d8c:	e1a01009 	mov	r1, r9
 5102d90:	e0800006 	add	r0, r0, r6
 5102d94:	e12fff38 	blx	r8
    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
 5102d98:	e5953008 	ldr	r3, [r5, #8]
    if( xCount > xFirstLength )
 5102d9c:	e1540007 	cmp	r4, r7
 5102da0:	9a000007 	bls	5102dc4 <prvWriteBytesToBuffer+0x84>
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
 5102da4:	e044a007 	sub	sl, r4, r7
 5102da8:	e15a0003 	cmp	sl, r3
 5102dac:	8a000017 	bhi	5102e10 <prvWriteBytesToBuffer+0xd0>
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength );
 5102db0:	e5950018 	ldr	r0, [r5, #24]
 5102db4:	e0891007 	add	r1, r9, r7
 5102db8:	e1a0200a 	mov	r2, sl
 5102dbc:	e12fff38 	blx	r8
 5102dc0:	e5953008 	ldr	r3, [r5, #8]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
 5102dc4:	e0840006 	add	r0, r4, r6

    if( xHead >= pxStreamBuffer->xLength )
 5102dc8:	e1530000 	cmp	r3, r0
    {
        xHead -= pxStreamBuffer->xLength;
 5102dcc:	90400003 	subls	r0, r0, r3
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
 5102dd0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    configASSERT( xCount > ( size_t ) 0 );
 5102dd4:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102dd8:	e3008900 	movw	r8, #2304	; 0x900
 5102ddc:	e30015cb 	movw	r1, #1483	; 0x5cb
 5102de0:	e3400512 	movt	r0, #1298	; 0x512
 5102de4:	e3408511 	movt	r8, #1297	; 0x511
 5102de8:	e12fff38 	blx	r8
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
 5102dec:	e5953008 	ldr	r3, [r5, #8]
 5102df0:	e1560003 	cmp	r6, r3
 5102df4:	9afffff2 	bls	5102dc4 <prvWriteBytesToBuffer+0x84>
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
 5102df8:	e1a07004 	mov	r7, r4
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
 5102dfc:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102e00:	e30015d3 	movw	r1, #1491	; 0x5d3
 5102e04:	e3400512 	movt	r0, #1298	; 0x512
 5102e08:	e12fff38 	blx	r8
 5102e0c:	eaffffda 	b	5102d7c <prvWriteBytesToBuffer+0x3c>
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
 5102e10:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102e14:	e3003900 	movw	r3, #2304	; 0x900
 5102e18:	e30015db 	movw	r1, #1499	; 0x5db
 5102e1c:	e3403511 	movt	r3, #1297	; 0x511
 5102e20:	e3400512 	movt	r0, #1298	; 0x512
 5102e24:	e12fff33 	blx	r3
 5102e28:	eaffffe0 	b	5102db0 <prvWriteBytesToBuffer+0x70>

05102e2c <prvWriteMessageToBuffer>:
{
 5102e2c:	e92d4070 	push	{r4, r5, r6, lr}
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5102e30:	e5d0c01c 	ldrb	ip, [r0, #28]
{
 5102e34:	e1a06001 	mov	r6, r1
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5102e38:	e31c0001 	tst	ip, #1
    size_t xNextHead = pxStreamBuffer->xHead;
 5102e3c:	e5901004 	ldr	r1, [r0, #4]
{
 5102e40:	e24dd008 	sub	sp, sp, #8
 5102e44:	e1a05000 	mov	r5, r0
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5102e48:	0a000007 	beq	5102e6c <prvWriteMessageToBuffer+0x40>
        if( xSpace >= xRequiredSpace )
 5102e4c:	e59dc018 	ldr	ip, [sp, #24]
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
 5102e50:	e58d2004 	str	r2, [sp, #4]
        if( xSpace >= xRequiredSpace )
 5102e54:	e153000c 	cmp	r3, ip
            xDataLengthBytes = 0;
 5102e58:	33a04000 	movcc	r4, #0
        if( xSpace >= xRequiredSpace )
 5102e5c:	2a000010 	bcs	5102ea4 <prvWriteMessageToBuffer+0x78>
}
 5102e60:	e1a00004 	mov	r0, r4
 5102e64:	e28dd008 	add	sp, sp, #8
 5102e68:	e8bd8070 	pop	{r4, r5, r6, pc}
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
 5102e6c:	e1530002 	cmp	r3, r2
 5102e70:	31a04003 	movcc	r4, r3
 5102e74:	21a04002 	movcs	r4, r2
    if( xDataLengthBytes != ( size_t ) 0 )
 5102e78:	e3540000 	cmp	r4, #0
 5102e7c:	0afffff7 	beq	5102e60 <prvWriteMessageToBuffer+0x34>
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead );
 5102e80:	e1a03001 	mov	r3, r1
 5102e84:	e1a02004 	mov	r2, r4
 5102e88:	e1a01006 	mov	r1, r6
 5102e8c:	e1a00005 	mov	r0, r5
 5102e90:	ebffffaa 	bl	5102d40 <prvWriteBytesToBuffer>
 5102e94:	e5850004 	str	r0, [r5, #4]
}
 5102e98:	e1a00004 	mov	r0, r4
 5102e9c:	e28dd008 	add	sp, sp, #8
 5102ea0:	e8bd8070 	pop	{r4, r5, r6, pc}
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
 5102ea4:	e1a04002 	mov	r4, r2
 5102ea8:	e3a02004 	mov	r2, #4
 5102eac:	e1a03001 	mov	r3, r1
 5102eb0:	e08d1002 	add	r1, sp, r2
 5102eb4:	ebffffa1 	bl	5102d40 <prvWriteBytesToBuffer>
 5102eb8:	e1a01000 	mov	r1, r0
 5102ebc:	eaffffed 	b	5102e78 <prvWriteMessageToBuffer+0x4c>

05102ec0 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
 5102ec0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5102ec4:	e1a07000 	mov	r7, r0
    size_t xFirstLength;

    configASSERT( xCount != ( size_t ) 0 );
 5102ec8:	e2524000 	subs	r4, r2, #0
{
 5102ecc:	e1a09001 	mov	r9, r1
 5102ed0:	e1a05003 	mov	r5, r3
    configASSERT( xCount != ( size_t ) 0 );
 5102ed4:	0a000025 	beq	5102f70 <prvReadBytesFromBuffer+0xb0>

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 5102ed8:	e5903008 	ldr	r3, [r0, #8]
 5102edc:	e0436005 	sub	r6, r3, r5
 5102ee0:	e1560004 	cmp	r6, r4
 5102ee4:	21a06004 	movcs	r6, r4

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
 5102ee8:	e1540006 	cmp	r4, r6
 5102eec:	3a000017 	bcc	5102f50 <prvReadBytesFromBuffer+0x90>
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 5102ef0:	e0852006 	add	r2, r5, r6
 5102ef4:	e1520003 	cmp	r2, r3
 5102ef8:	83008900 	movwhi	r8, #2304	; 0x900
 5102efc:	83408511 	movthi	r8, #1297	; 0x511
 5102f00:	8a000024 	bhi	5102f98 <prvReadBytesFromBuffer+0xd8>
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength );
 5102f04:	e5971018 	ldr	r1, [r7, #24]
 5102f08:	e3098ca1 	movw	r8, #40097	; 0x9ca1
 5102f0c:	e1a02006 	mov	r2, r6
 5102f10:	e3408511 	movt	r8, #1297	; 0x511
 5102f14:	e1a00009 	mov	r0, r9
 5102f18:	e0811005 	add	r1, r1, r5
 5102f1c:	e12fff38 	blx	r8

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
 5102f20:	e1540006 	cmp	r4, r6
 5102f24:	8a000004 	bhi	5102f3c <prvReadBytesFromBuffer+0x7c>
 5102f28:	e5973008 	ldr	r3, [r7, #8]
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
 5102f2c:	e0840005 	add	r0, r4, r5

    if( xTail >= pxStreamBuffer->xLength )
 5102f30:	e1530000 	cmp	r3, r0
    {
        xTail -= pxStreamBuffer->xLength;
 5102f34:	90400003 	subls	r0, r0, r3
    }

    return xTail;
}
 5102f38:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength );
 5102f3c:	e5971018 	ldr	r1, [r7, #24]
 5102f40:	e0890006 	add	r0, r9, r6
 5102f44:	e0442006 	sub	r2, r4, r6
 5102f48:	e12fff38 	blx	r8
 5102f4c:	eafffff5 	b	5102f28 <prvReadBytesFromBuffer+0x68>
    configASSERT( xFirstLength <= xCount );
 5102f50:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102f54:	e3008900 	movw	r8, #2304	; 0x900
 5102f58:	e3400512 	movt	r0, #1298	; 0x512
 5102f5c:	e3001602 	movw	r1, #1538	; 0x602
 5102f60:	e3408511 	movt	r8, #1297	; 0x511
 5102f64:	e12fff38 	blx	r8
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 5102f68:	e5973008 	ldr	r3, [r7, #8]
 5102f6c:	eaffffdf 	b	5102ef0 <prvReadBytesFromBuffer+0x30>
    configASSERT( xCount != ( size_t ) 0 );
 5102f70:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102f74:	e3008900 	movw	r8, #2304	; 0x900
 5102f78:	e30015f9 	movw	r1, #1529	; 0x5f9
 5102f7c:	e3400512 	movt	r0, #1298	; 0x512
 5102f80:	e3408511 	movt	r8, #1297	; 0x511
 5102f84:	e12fff38 	blx	r8
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 5102f88:	e5973008 	ldr	r3, [r7, #8]
 5102f8c:	e1550003 	cmp	r5, r3
 5102f90:	9affffe5 	bls	5102f2c <prvReadBytesFromBuffer+0x6c>
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
 5102f94:	e1a06004 	mov	r6, r4
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
 5102f98:	e30d0a94 	movw	r0, #55956	; 0xda94
 5102f9c:	e3001603 	movw	r1, #1539	; 0x603
 5102fa0:	e3400512 	movt	r0, #1298	; 0x512
 5102fa4:	e12fff38 	blx	r8
 5102fa8:	eaffffd5 	b	5102f04 <prvReadBytesFromBuffer+0x44>

05102fac <prvReadMessageFromBuffer>:
{
 5102fac:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 5102fb0:	e1a04003 	mov	r4, r3
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5102fb4:	e5d0301c 	ldrb	r3, [r0, #28]
 5102fb8:	e3130001 	tst	r3, #1
{
 5102fbc:	e1a05000 	mov	r5, r0
 5102fc0:	e24dd00c 	sub	sp, sp, #12
    size_t xNextTail = pxStreamBuffer->xTail;
 5102fc4:	e5903000 	ldr	r3, [r0]
{
 5102fc8:	e1a07001 	mov	r7, r1
 5102fcc:	e1a06002 	mov	r6, r2
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5102fd0:	1a00000b 	bne	5103004 <prvReadMessageFromBuffer+0x58>
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 5102fd4:	e1540006 	cmp	r4, r6
 5102fd8:	21a04006 	movcs	r4, r6
    if( xCount != ( size_t ) 0 )
 5102fdc:	e3540000 	cmp	r4, #0
 5102fe0:	0a000004 	beq	5102ff8 <prvReadMessageFromBuffer+0x4c>
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail );
 5102fe4:	e1a02004 	mov	r2, r4
 5102fe8:	e1a01007 	mov	r1, r7
 5102fec:	e1a00005 	mov	r0, r5
 5102ff0:	ebffffb2 	bl	5102ec0 <prvReadBytesFromBuffer>
 5102ff4:	e5850000 	str	r0, [r5]
}
 5102ff8:	e1a00004 	mov	r0, r4
 5102ffc:	e28dd00c 	add	sp, sp, #12
 5103000:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 5103004:	e3a02004 	mov	r2, #4
 5103008:	e08d1002 	add	r1, sp, r2
 510300c:	ebffffab 	bl	5102ec0 <prvReadBytesFromBuffer>
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
 5103010:	e59d2004 	ldr	r2, [sp, #4]
        if( xNextMessageLength > xBufferLengthBytes )
 5103014:	e1560002 	cmp	r6, r2
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
 5103018:	33a04000 	movcc	r4, #0
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
 510301c:	e1a03000 	mov	r3, r0
        if( xNextMessageLength > xBufferLengthBytes )
 5103020:	3afffff4 	bcc	5102ff8 <prvReadMessageFromBuffer+0x4c>
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
 5103024:	e1a06002 	mov	r6, r2
 5103028:	e2444004 	sub	r4, r4, #4
 510302c:	eaffffe8 	b	5102fd4 <prvReadMessageFromBuffer+0x28>

05103030 <xStreamBufferGetStaticBuffers>:
    {
 5103030:	e92d4070 	push	{r4, r5, r6, lr}
 5103034:	e1a06001 	mov	r6, r1
        configASSERT( pxStreamBuffer );
 5103038:	e2504000 	subs	r4, r0, #0
    {
 510303c:	e1a05002 	mov	r5, r2
        configASSERT( pxStreamBuffer );
 5103040:	0a00000a 	beq	5103070 <xStreamBufferGetStaticBuffers+0x40>
        configASSERT( ppucStreamBufferStorageArea );
 5103044:	e3560000 	cmp	r6, #0
 5103048:	0a000010 	beq	5103090 <xStreamBufferGetStaticBuffers+0x60>
        configASSERT( ppxStaticStreamBuffer );
 510304c:	e3550000 	cmp	r5, #0
 5103050:	0a000016 	beq	51030b0 <xStreamBufferGetStaticBuffers+0x80>
        if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) != ( uint8_t ) 0 )
 5103054:	e5d4301c 	ldrb	r3, [r4, #28]
 5103058:	e2130002 	ands	r0, r3, #2
            xReturn = pdTRUE;
 510305c:	13a00001 	movne	r0, #1
            *ppucStreamBufferStorageArea = pxStreamBuffer->pucBuffer;
 5103060:	15943018 	ldrne	r3, [r4, #24]
 5103064:	15863000 	strne	r3, [r6]
            *ppxStaticStreamBuffer = ( StaticStreamBuffer_t * ) pxStreamBuffer;
 5103068:	15854000 	strne	r4, [r5]
    }
 510306c:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( pxStreamBuffer );
 5103070:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103074:	e3003900 	movw	r3, #2304	; 0x900
 5103078:	e3a01f85 	mov	r1, #532	; 0x214
 510307c:	e3400512 	movt	r0, #1298	; 0x512
 5103080:	e3403511 	movt	r3, #1297	; 0x511
 5103084:	e12fff33 	blx	r3
        configASSERT( ppucStreamBufferStorageArea );
 5103088:	e3560000 	cmp	r6, #0
 510308c:	1affffee 	bne	510304c <xStreamBufferGetStaticBuffers+0x1c>
 5103090:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103094:	e3003900 	movw	r3, #2304	; 0x900
 5103098:	e3001215 	movw	r1, #533	; 0x215
 510309c:	e3400512 	movt	r0, #1298	; 0x512
 51030a0:	e3403511 	movt	r3, #1297	; 0x511
 51030a4:	e12fff33 	blx	r3
        configASSERT( ppxStaticStreamBuffer );
 51030a8:	e3550000 	cmp	r5, #0
 51030ac:	1affffe8 	bne	5103054 <xStreamBufferGetStaticBuffers+0x24>
 51030b0:	e30d0a94 	movw	r0, #55956	; 0xda94
 51030b4:	e3003900 	movw	r3, #2304	; 0x900
 51030b8:	e3001216 	movw	r1, #534	; 0x216
 51030bc:	e3403511 	movt	r3, #1297	; 0x511
 51030c0:	e3400512 	movt	r0, #1298	; 0x512
 51030c4:	e12fff33 	blx	r3
 51030c8:	eaffffe1 	b	5103054 <xStreamBufferGetStaticBuffers+0x24>

051030cc <xStreamBufferSend>:
{
 51030cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 51030d0:	ed2d8b02 	vpush	{d8}
 51030d4:	e1a04000 	mov	r4, r0
    configASSERT( pvTxData );
 51030d8:	e3510000 	cmp	r1, #0
 51030dc:	ee081a10 	vmov	s16, r1
{
 51030e0:	e24dd024 	sub	sp, sp, #36	; 0x24
 51030e4:	e58d200c 	str	r2, [sp, #12]
 51030e8:	e58d3014 	str	r3, [sp, #20]
    configASSERT( pvTxData );
 51030ec:	0a00009e 	beq	510336c <xStreamBufferSend+0x2a0>
    configASSERT( pxStreamBuffer );
 51030f0:	e3540000 	cmp	r4, #0
 51030f4:	0a0000a4 	beq	510338c <xStreamBufferSend+0x2c0>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 51030f8:	e5d4301c 	ldrb	r3, [r4, #28]
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 51030fc:	e5945008 	ldr	r5, [r4, #8]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5103100:	e3130001 	tst	r3, #1
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 5103104:	e59d300c 	ldr	r3, [sp, #12]
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
 5103108:	e2455001 	sub	r5, r5, #1
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 510310c:	0a00006c 	beq	51032c4 <xStreamBufferSend+0x1f8>
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 5103110:	e2837004 	add	r7, r3, #4
        configASSERT( xRequiredSpace > xDataLengthBytes );
 5103114:	e1530007 	cmp	r3, r7
 5103118:	2a000088 	bcs	5103340 <xStreamBufferSend+0x274>
        if( xRequiredSpace > xMaxReportedSpace )
 510311c:	e1550007 	cmp	r5, r7
            xTicksToWait = ( TickType_t ) 0;
 5103120:	33a03000 	movcc	r3, #0
 5103124:	358d3014 	strcc	r3, [sp, #20]
        if( xRequiredSpace > xMaxReportedSpace )
 5103128:	3a000043 	bcc	510323c <xStreamBufferSend+0x170>
    if( xTicksToWait != ( TickType_t ) 0 )
 510312c:	e59d3014 	ldr	r3, [sp, #20]
 5103130:	e3530000 	cmp	r3, #0
 5103134:	0a000040 	beq	510323c <xStreamBufferSend+0x170>
        vTaskSetTimeOutState( &xTimeOut );
 5103138:	e3053b34 	movw	r3, #23348	; 0x5b34
 510313c:	e28d0018 	add	r0, sp, #24
 5103140:	e30c9930 	movw	r9, #51504	; 0xc930
 5103144:	e3403510 	movt	r3, #1296	; 0x510
 5103148:	e12fff33 	blx	r3
 510314c:	e30c8988 	movw	r8, #51592	; 0xc988
                    ( void ) xTaskNotifyStateClearIndexed( NULL, pxStreamBuffer->uxNotificationIndex );
 5103150:	e305aa30 	movw	sl, #23088	; 0x5a30
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 5103154:	e30dba94 	movw	fp, #55956	; 0xda94
 5103158:	e3003900 	movw	r3, #2304	; 0x900
 510315c:	e3409510 	movt	r9, #1296	; 0x510
 5103160:	e3403511 	movt	r3, #1297	; 0x511
 5103164:	e3408510 	movt	r8, #1296	; 0x510
                    ( void ) xTaskNotifyStateClearIndexed( NULL, pxStreamBuffer->uxNotificationIndex );
 5103168:	e340a510 	movt	sl, #1296	; 0x510
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 510316c:	e58d3010 	str	r3, [sp, #16]
 5103170:	e340b512 	movt	fp, #1298	; 0x512
            taskENTER_CRITICAL();
 5103174:	e12fff39 	blx	r9
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103178:	e594c008 	ldr	ip, [r4, #8]
        xOriginalTail = pxStreamBuffer->xTail;
 510317c:	e5942000 	ldr	r2, [r4]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103180:	e5940000 	ldr	r0, [r4]
        xSpace -= pxStreamBuffer->xHead;
 5103184:	e5941004 	ldr	r1, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 5103188:	e5943000 	ldr	r3, [r4]
 510318c:	e1520003 	cmp	r2, r3
 5103190:	1afffff9 	bne	510317c <xStreamBufferSend+0xb0>
    xSpace -= ( size_t ) 1;
 5103194:	e24c5001 	sub	r5, ip, #1
 5103198:	e0855000 	add	r5, r5, r0
 510319c:	e0455001 	sub	r5, r5, r1
    if( xSpace >= pxStreamBuffer->xLength )
 51031a0:	e15c0005 	cmp	ip, r5
        xSpace -= pxStreamBuffer->xLength;
 51031a4:	9045500c 	subls	r5, r5, ip
                if( xSpace < xRequiredSpace )
 51031a8:	e1570005 	cmp	r7, r5
 51031ac:	9a000048 	bls	51032d4 <xStreamBufferSend+0x208>
                    ( void ) xTaskNotifyStateClearIndexed( NULL, pxStreamBuffer->uxNotificationIndex );
 51031b0:	e5941020 	ldr	r1, [r4, #32]
 51031b4:	e3a00000 	mov	r0, #0
 51031b8:	e12fff3a 	blx	sl
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 51031bc:	e5943014 	ldr	r3, [r4, #20]
 51031c0:	e3530000 	cmp	r3, #0
 51031c4:	0a000003 	beq	51031d8 <xStreamBufferSend+0x10c>
 51031c8:	e59d3010 	ldr	r3, [sp, #16]
 51031cc:	e3001375 	movw	r1, #885	; 0x375
 51031d0:	e1a0000b 	mov	r0, fp
 51031d4:	e12fff33 	blx	r3
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 51031d8:	e3063dec 	movw	r3, #28140	; 0x6dec
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 51031dc:	e3066450 	movw	r6, #25680	; 0x6450
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 51031e0:	e3403510 	movt	r3, #1296	; 0x510
 51031e4:	e12fff33 	blx	r3
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 51031e8:	e3406510 	movt	r6, #1296	; 0x510
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
 51031ec:	e5840014 	str	r0, [r4, #20]
            taskEXIT_CRITICAL();
 51031f0:	e12fff38 	blx	r8
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 51031f4:	e59d3014 	ldr	r3, [sp, #20]
 51031f8:	e58d3000 	str	r3, [sp]
 51031fc:	e3a03000 	mov	r3, #0
 5103200:	e1a01003 	mov	r1, r3
 5103204:	e1a02003 	mov	r2, r3
 5103208:	e5940020 	ldr	r0, [r4, #32]
 510320c:	e12fff36 	blx	r6
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 5103210:	e3a03000 	mov	r3, #0
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 5103214:	e28d1014 	add	r1, sp, #20
            pxStreamBuffer->xTaskWaitingToSend = NULL;
 5103218:	e5843014 	str	r3, [r4, #20]
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
 510321c:	e3053b8c 	movw	r3, #23436	; 0x5b8c
 5103220:	e3403510 	movt	r3, #1296	; 0x510
 5103224:	e28d0018 	add	r0, sp, #24
 5103228:	e12fff33 	blx	r3
 510322c:	e3500000 	cmp	r0, #0
 5103230:	0affffcf 	beq	5103174 <xStreamBufferSend+0xa8>
    if( xSpace == ( size_t ) 0 )
 5103234:	e3550000 	cmp	r5, #0
 5103238:	1a00000b 	bne	510326c <xStreamBufferSend+0x1a0>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 510323c:	e594c008 	ldr	ip, [r4, #8]
        xOriginalTail = pxStreamBuffer->xTail;
 5103240:	e5942000 	ldr	r2, [r4]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103244:	e5940000 	ldr	r0, [r4]
        xSpace -= pxStreamBuffer->xHead;
 5103248:	e5941004 	ldr	r1, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 510324c:	e5943000 	ldr	r3, [r4]
 5103250:	e1520003 	cmp	r2, r3
 5103254:	1afffff9 	bne	5103240 <xStreamBufferSend+0x174>
    xSpace -= ( size_t ) 1;
 5103258:	e24c5001 	sub	r5, ip, #1
 510325c:	e0855000 	add	r5, r5, r0
 5103260:	e0455001 	sub	r5, r5, r1
    if( xSpace >= pxStreamBuffer->xLength )
 5103264:	e15c0005 	cmp	ip, r5
        xSpace -= pxStreamBuffer->xLength;
 5103268:	9045500c 	subls	r5, r5, ip
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 510326c:	e1a03005 	mov	r3, r5
 5103270:	ee181a10 	vmov	r1, s16
 5103274:	e59d200c 	ldr	r2, [sp, #12]
 5103278:	e1a00004 	mov	r0, r4
 510327c:	e58d7000 	str	r7, [sp]
 5103280:	ebfffee9 	bl	5102e2c <prvWriteMessageToBuffer>
    if( xReturn > ( size_t ) 0 )
 5103284:	e2505000 	subs	r5, r0, #0
 5103288:	0a000009 	beq	51032b4 <xStreamBufferSend+0x1e8>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    /* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 510328c:	e5942008 	ldr	r2, [r4, #8]
 5103290:	e5943004 	ldr	r3, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 5103294:	e5941000 	ldr	r1, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103298:	e0823003 	add	r3, r2, r3
    xCount -= pxStreamBuffer->xTail;
 510329c:	e0433001 	sub	r3, r3, r1

    if( xCount >= pxStreamBuffer->xLength )
 51032a0:	e1520003 	cmp	r2, r3
    {
        xCount -= pxStreamBuffer->xLength;
 51032a4:	90433002 	subls	r3, r3, r2
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 51032a8:	e594200c 	ldr	r2, [r4, #12]
 51032ac:	e1520003 	cmp	r2, r3
 51032b0:	9a00000b 	bls	51032e4 <xStreamBufferSend+0x218>
}
 51032b4:	e1a00005 	mov	r0, r5
 51032b8:	e28dd024 	add	sp, sp, #36	; 0x24
 51032bc:	ecbd8b02 	vpop	{d8}
 51032c0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if( xRequiredSpace > xMaxReportedSpace )
 51032c4:	e1530005 	cmp	r3, r5
 51032c8:	31a07003 	movcc	r7, r3
 51032cc:	21a07005 	movcs	r7, r5
 51032d0:	eaffff95 	b	510312c <xStreamBufferSend+0x60>
                    taskEXIT_CRITICAL();
 51032d4:	e12fff38 	blx	r8
    if( xSpace == ( size_t ) 0 )
 51032d8:	e3550000 	cmp	r5, #0
 51032dc:	0affffd6 	beq	510323c <xStreamBufferSend+0x170>
 51032e0:	eaffffe1 	b	510326c <xStreamBufferSend+0x1a0>
            prvSEND_COMPLETED( pxStreamBuffer );
 51032e4:	e30532a0 	movw	r3, #21152	; 0x52a0
 51032e8:	e3403510 	movt	r3, #1296	; 0x510
 51032ec:	e12fff33 	blx	r3
 51032f0:	e5943010 	ldr	r3, [r4, #16]
 51032f4:	e3530000 	cmp	r3, #0
 51032f8:	0a000009 	beq	5103324 <xStreamBufferSend+0x258>
 51032fc:	e3a06000 	mov	r6, #0
 5103300:	e3057414 	movw	r7, #21524	; 0x5414
 5103304:	e5940010 	ldr	r0, [r4, #16]
 5103308:	e1a03006 	mov	r3, r6
 510330c:	e58d6000 	str	r6, [sp]
 5103310:	e3407510 	movt	r7, #1296	; 0x510
 5103314:	e5941020 	ldr	r1, [r4, #32]
 5103318:	e1a02006 	mov	r2, r6
 510331c:	e12fff37 	blx	r7
 5103320:	e5846010 	str	r6, [r4, #16]
 5103324:	e3053efc 	movw	r3, #24316	; 0x5efc
 5103328:	e3403510 	movt	r3, #1296	; 0x510
 510332c:	e12fff33 	blx	r3
}
 5103330:	e1a00005 	mov	r0, r5
 5103334:	e28dd024 	add	sp, sp, #36	; 0x24
 5103338:	ecbd8b02 	vpop	{d8}
 510333c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        configASSERT( xRequiredSpace > xDataLengthBytes );
 5103340:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103344:	e3003900 	movw	r3, #2304	; 0x900
 5103348:	e3403511 	movt	r3, #1297	; 0x511
 510334c:	e3001345 	movw	r1, #837	; 0x345
 5103350:	e3400512 	movt	r0, #1298	; 0x512
 5103354:	e12fff33 	blx	r3
        if( xRequiredSpace > xMaxReportedSpace )
 5103358:	e1550007 	cmp	r5, r7
            xTicksToWait = ( TickType_t ) 0;
 510335c:	33a03000 	movcc	r3, #0
 5103360:	358d3014 	strcc	r3, [sp, #20]
        if( xRequiredSpace > xMaxReportedSpace )
 5103364:	3affffb4 	bcc	510323c <xStreamBufferSend+0x170>
 5103368:	eaffff6f 	b	510312c <xStreamBufferSend+0x60>
    configASSERT( pvTxData );
 510336c:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103370:	e3003900 	movw	r3, #2304	; 0x900
 5103374:	e3001335 	movw	r1, #821	; 0x335
 5103378:	e3400512 	movt	r0, #1298	; 0x512
 510337c:	e3403511 	movt	r3, #1297	; 0x511
 5103380:	e12fff33 	blx	r3
    configASSERT( pxStreamBuffer );
 5103384:	e3540000 	cmp	r4, #0
 5103388:	1affff5a 	bne	51030f8 <xStreamBufferSend+0x2c>
 510338c:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103390:	e3003900 	movw	r3, #2304	; 0x900
 5103394:	e3001336 	movw	r1, #822	; 0x336
 5103398:	e3403511 	movt	r3, #1297	; 0x511
 510339c:	e3400512 	movt	r0, #1298	; 0x512
 51033a0:	e12fff33 	blx	r3
 51033a4:	eaffff53 	b	51030f8 <xStreamBufferSend+0x2c>

051033a8 <xStreamBufferSendFromISR>:
{
 51033a8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
 51033ac:	e1a04000 	mov	r4, r0
    configASSERT( pvTxData );
 51033b0:	e2516000 	subs	r6, r1, #0
{
 51033b4:	e1a09002 	mov	r9, r2
 51033b8:	e24dd00c 	sub	sp, sp, #12
 51033bc:	e1a07003 	mov	r7, r3
    configASSERT( pvTxData );
 51033c0:	0a000033 	beq	5103494 <xStreamBufferSendFromISR+0xec>
    configASSERT( pxStreamBuffer );
 51033c4:	e3540000 	cmp	r4, #0
 51033c8:	0a000039 	beq	51034b4 <xStreamBufferSendFromISR+0x10c>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 51033cc:	e5d4301c 	ldrb	r3, [r4, #28]
 51033d0:	e3130001 	tst	r3, #1
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
 51033d4:	12898004 	addne	r8, r9, #4
    size_t xRequiredSpace = xDataLengthBytes;
 51033d8:	01a08009 	moveq	r8, r9
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 51033dc:	e5941008 	ldr	r1, [r4, #8]
        xOriginalTail = pxStreamBuffer->xTail;
 51033e0:	e594c000 	ldr	ip, [r4]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 51033e4:	e5945000 	ldr	r5, [r4]
        xSpace -= pxStreamBuffer->xHead;
 51033e8:	e594e004 	ldr	lr, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 51033ec:	e5940000 	ldr	r0, [r4]
 51033f0:	e15c0000 	cmp	ip, r0
 51033f4:	1afffff9 	bne	51033e0 <xStreamBufferSendFromISR+0x38>
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 51033f8:	e1a02009 	mov	r2, r9
    xSpace -= ( size_t ) 1;
 51033fc:	e2413001 	sub	r3, r1, #1
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 5103400:	e1a00004 	mov	r0, r4
    xSpace -= ( size_t ) 1;
 5103404:	e0833005 	add	r3, r3, r5
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 5103408:	e58d8000 	str	r8, [sp]
    xSpace -= ( size_t ) 1;
 510340c:	e043300e 	sub	r3, r3, lr
    if( xSpace >= pxStreamBuffer->xLength )
 5103410:	e1510003 	cmp	r1, r3
        xSpace -= pxStreamBuffer->xLength;
 5103414:	90433001 	subls	r3, r3, r1
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
 5103418:	e1a01006 	mov	r1, r6
 510341c:	ebfffe82 	bl	5102e2c <prvWriteMessageToBuffer>
    if( xReturn > ( size_t ) 0 )
 5103420:	e2505000 	subs	r5, r0, #0
 5103424:	0a000017 	beq	5103488 <xStreamBufferSendFromISR+0xe0>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103428:	e5942008 	ldr	r2, [r4, #8]
 510342c:	e5943004 	ldr	r3, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 5103430:	e5941000 	ldr	r1, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103434:	e0823003 	add	r3, r2, r3
    xCount -= pxStreamBuffer->xTail;
 5103438:	e0433001 	sub	r3, r3, r1
    if( xCount >= pxStreamBuffer->xLength )
 510343c:	e1520003 	cmp	r2, r3
        xCount -= pxStreamBuffer->xLength;
 5103440:	90433002 	subls	r3, r3, r2
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
 5103444:	e594200c 	ldr	r2, [r4, #12]
 5103448:	e1520003 	cmp	r2, r3
 510344c:	8a00000d 	bhi	5103488 <xStreamBufferSendFromISR+0xe0>
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 5103450:	e5943010 	ldr	r3, [r4, #16]
 5103454:	e3530000 	cmp	r3, #0
 5103458:	0a00000a 	beq	5103488 <xStreamBufferSendFromISR+0xe0>
 510345c:	e5940010 	ldr	r0, [r4, #16]
 5103460:	e3a06000 	mov	r6, #0
 5103464:	e58d7004 	str	r7, [sp, #4]
 5103468:	e3057640 	movw	r7, #22080	; 0x5640
 510346c:	e58d6000 	str	r6, [sp]
 5103470:	e1a03006 	mov	r3, r6
 5103474:	e5941020 	ldr	r1, [r4, #32]
 5103478:	e3407510 	movt	r7, #1296	; 0x510
 510347c:	e1a02006 	mov	r2, r6
 5103480:	e12fff37 	blx	r7
 5103484:	e5846010 	str	r6, [r4, #16]
}
 5103488:	e1a00005 	mov	r0, r5
 510348c:	e28dd00c 	add	sp, sp, #12
 5103490:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    configASSERT( pvTxData );
 5103494:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103498:	e3003900 	movw	r3, #2304	; 0x900
 510349c:	e30013ba 	movw	r1, #954	; 0x3ba
 51034a0:	e3400512 	movt	r0, #1298	; 0x512
 51034a4:	e3403511 	movt	r3, #1297	; 0x511
 51034a8:	e12fff33 	blx	r3
    configASSERT( pxStreamBuffer );
 51034ac:	e3540000 	cmp	r4, #0
 51034b0:	1affffc5 	bne	51033cc <xStreamBufferSendFromISR+0x24>
 51034b4:	e30d0a94 	movw	r0, #55956	; 0xda94
 51034b8:	e3003900 	movw	r3, #2304	; 0x900
 51034bc:	e30013bb 	movw	r1, #955	; 0x3bb
 51034c0:	e3403511 	movt	r3, #1297	; 0x511
 51034c4:	e3400512 	movt	r0, #1298	; 0x512
 51034c8:	e12fff33 	blx	r3
 51034cc:	eaffffbe 	b	51033cc <xStreamBufferSendFromISR+0x24>

051034d0 <xStreamBufferReceive>:
{
 51034d0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
 51034d4:	e1a04000 	mov	r4, r0
    configASSERT( pvRxData );
 51034d8:	e2517000 	subs	r7, r1, #0
{
 51034dc:	e1a08002 	mov	r8, r2
 51034e0:	e24dd00c 	sub	sp, sp, #12
 51034e4:	e1a09003 	mov	r9, r3
    configASSERT( pvRxData );
 51034e8:	0a000042 	beq	51035f8 <xStreamBufferReceive+0x128>
    configASSERT( pxStreamBuffer );
 51034ec:	e3540000 	cmp	r4, #0
 51034f0:	0a000048 	beq	5103618 <xStreamBufferReceive+0x148>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 51034f4:	e5d4601c 	ldrb	r6, [r4, #28]
 51034f8:	e3160001 	tst	r6, #1
        xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
 51034fc:	13a06004 	movne	r6, #4
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5103500:	1a000001 	bne	510350c <xStreamBufferReceive+0x3c>
    else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_BATCHING_BUFFER ) != ( uint8_t ) 0 )
 5103504:	e2166004 	ands	r6, r6, #4
        xBytesToStoreMessageLength = pxStreamBuffer->xTriggerLevelBytes;
 5103508:	1594600c 	ldrne	r6, [r4, #12]
    if( xTicksToWait != ( TickType_t ) 0 )
 510350c:	e3590000 	cmp	r9, #0
 5103510:	1a00000c 	bne	5103548 <xStreamBufferReceive+0x78>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103514:	e5943008 	ldr	r3, [r4, #8]
 5103518:	e5945004 	ldr	r5, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 510351c:	e5942000 	ldr	r2, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103520:	e0835005 	add	r5, r3, r5
    xCount -= pxStreamBuffer->xTail;
 5103524:	e0455002 	sub	r5, r5, r2
    if( xCount >= pxStreamBuffer->xLength )
 5103528:	e1530005 	cmp	r3, r5
        xCount -= pxStreamBuffer->xLength;
 510352c:	90455003 	subls	r5, r5, r3
    if( xBytesAvailable > xBytesToStoreMessageLength )
 5103530:	e1550006 	cmp	r5, r6
 5103534:	8a000012 	bhi	5103584 <xStreamBufferReceive+0xb4>
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 5103538:	e3a05000 	mov	r5, #0
}
 510353c:	e1a00005 	mov	r0, r5
 5103540:	e28dd00c 	add	sp, sp, #12
 5103544:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        taskENTER_CRITICAL();
 5103548:	e30c3930 	movw	r3, #51504	; 0xc930
 510354c:	e3403510 	movt	r3, #1296	; 0x510
 5103550:	e12fff33 	blx	r3
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103554:	e5943008 	ldr	r3, [r4, #8]
 5103558:	e5945004 	ldr	r5, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 510355c:	e5942000 	ldr	r2, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103560:	e0835005 	add	r5, r3, r5
    xCount -= pxStreamBuffer->xTail;
 5103564:	e0455002 	sub	r5, r5, r2
    if( xCount >= pxStreamBuffer->xLength )
 5103568:	e1530005 	cmp	r3, r5
        xCount -= pxStreamBuffer->xLength;
 510356c:	90455003 	subls	r5, r5, r3
            if( xBytesAvailable <= xBytesToStoreMessageLength )
 5103570:	e1560005 	cmp	r6, r5
 5103574:	2a00002e 	bcs	5103634 <xStreamBufferReceive+0x164>
        taskEXIT_CRITICAL();
 5103578:	e30c3988 	movw	r3, #51592	; 0xc988
 510357c:	e3403510 	movt	r3, #1296	; 0x510
 5103580:	e12fff33 	blx	r3
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 5103584:	e1a03005 	mov	r3, r5
 5103588:	e1a02008 	mov	r2, r8
 510358c:	e1a01007 	mov	r1, r7
 5103590:	e1a00004 	mov	r0, r4
 5103594:	ebfffe84 	bl	5102fac <prvReadMessageFromBuffer>
        if( xReceivedLength != ( size_t ) 0 )
 5103598:	e2505000 	subs	r5, r0, #0
 510359c:	0affffe5 	beq	5103538 <xStreamBufferReceive+0x68>
            prvRECEIVE_COMPLETED( xStreamBuffer );
 51035a0:	e30532a0 	movw	r3, #21152	; 0x52a0
 51035a4:	e3403510 	movt	r3, #1296	; 0x510
 51035a8:	e12fff33 	blx	r3
 51035ac:	e5943014 	ldr	r3, [r4, #20]
 51035b0:	e3530000 	cmp	r3, #0
 51035b4:	0a000009 	beq	51035e0 <xStreamBufferReceive+0x110>
 51035b8:	e3a06000 	mov	r6, #0
 51035bc:	e3057414 	movw	r7, #21524	; 0x5414
 51035c0:	e5940014 	ldr	r0, [r4, #20]
 51035c4:	e1a03006 	mov	r3, r6
 51035c8:	e58d6000 	str	r6, [sp]
 51035cc:	e3407510 	movt	r7, #1296	; 0x510
 51035d0:	e5941020 	ldr	r1, [r4, #32]
 51035d4:	e1a02006 	mov	r2, r6
 51035d8:	e12fff37 	blx	r7
 51035dc:	e5846014 	str	r6, [r4, #20]
 51035e0:	e3053efc 	movw	r3, #24316	; 0x5efc
 51035e4:	e3403510 	movt	r3, #1296	; 0x510
 51035e8:	e12fff33 	blx	r3
}
 51035ec:	e1a00005 	mov	r0, r5
 51035f0:	e28dd00c 	add	sp, sp, #12
 51035f4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    configASSERT( pvRxData );
 51035f8:	e30d0a94 	movw	r0, #55956	; 0xda94
 51035fc:	e3003900 	movw	r3, #2304	; 0x900
 5103600:	e3001427 	movw	r1, #1063	; 0x427
 5103604:	e3400512 	movt	r0, #1298	; 0x512
 5103608:	e3403511 	movt	r3, #1297	; 0x511
 510360c:	e12fff33 	blx	r3
    configASSERT( pxStreamBuffer );
 5103610:	e3540000 	cmp	r4, #0
 5103614:	1affffb6 	bne	51034f4 <xStreamBufferReceive+0x24>
 5103618:	e30d0a94 	movw	r0, #55956	; 0xda94
 510361c:	e3003900 	movw	r3, #2304	; 0x900
 5103620:	e3001428 	movw	r1, #1064	; 0x428
 5103624:	e3403511 	movt	r3, #1297	; 0x511
 5103628:	e3400512 	movt	r0, #1298	; 0x512
 510362c:	e12fff33 	blx	r3
 5103630:	eaffffaf 	b	51034f4 <xStreamBufferReceive+0x24>
                ( void ) xTaskNotifyStateClearIndexed( NULL, pxStreamBuffer->uxNotificationIndex );
 5103634:	e3053a30 	movw	r3, #23088	; 0x5a30
 5103638:	e3a00000 	mov	r0, #0
 510363c:	e5941020 	ldr	r1, [r4, #32]
 5103640:	e3403510 	movt	r3, #1296	; 0x510
 5103644:	e12fff33 	blx	r3
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
 5103648:	e5943010 	ldr	r3, [r4, #16]
 510364c:	e3530000 	cmp	r3, #0
 5103650:	0a000005 	beq	510366c <xStreamBufferReceive+0x19c>
 5103654:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103658:	e3003900 	movw	r3, #2304	; 0x900
 510365c:	e3400512 	movt	r0, #1298	; 0x512
 5103660:	e3001453 	movw	r1, #1107	; 0x453
 5103664:	e3403511 	movt	r3, #1297	; 0x511
 5103668:	e12fff33 	blx	r3
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 510366c:	e3063dec 	movw	r3, #28140	; 0x6dec
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 5103670:	e3065450 	movw	r5, #25680	; 0x6450
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 5103674:	e3403510 	movt	r3, #1296	; 0x510
 5103678:	e12fff33 	blx	r3
        taskEXIT_CRITICAL();
 510367c:	e30c3988 	movw	r3, #51592	; 0xc988
 5103680:	e3403510 	movt	r3, #1296	; 0x510
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 5103684:	e3405510 	movt	r5, #1296	; 0x510
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
 5103688:	e5840010 	str	r0, [r4, #16]
        taskEXIT_CRITICAL();
 510368c:	e12fff33 	blx	r3
            ( void ) xTaskNotifyWaitIndexed( pxStreamBuffer->uxNotificationIndex, ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
 5103690:	e58d9000 	str	r9, [sp]
 5103694:	e5940020 	ldr	r0, [r4, #32]
 5103698:	e3a03000 	mov	r3, #0
 510369c:	e1a02003 	mov	r2, r3
 51036a0:	e1a01003 	mov	r1, r3
 51036a4:	e12fff35 	blx	r5
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
 51036a8:	e3a03000 	mov	r3, #0
 51036ac:	e5843010 	str	r3, [r4, #16]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 51036b0:	eaffff97 	b	5103514 <xStreamBufferReceive+0x44>

051036b4 <xStreamBufferReceiveFromISR>:
{
 51036b4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 51036b8:	e1a04000 	mov	r4, r0
    configASSERT( pvRxData );
 51036bc:	e2517000 	subs	r7, r1, #0
{
 51036c0:	e1a05002 	mov	r5, r2
 51036c4:	e24dd00c 	sub	sp, sp, #12
 51036c8:	e1a06003 	mov	r6, r3
    configASSERT( pvRxData );
 51036cc:	0a000028 	beq	5103774 <xStreamBufferReceiveFromISR+0xc0>
    configASSERT( pxStreamBuffer );
 51036d0:	e3540000 	cmp	r4, #0
 51036d4:	0a00002e 	beq	5103794 <xStreamBufferReceiveFromISR+0xe0>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 51036d8:	e594c008 	ldr	ip, [r4, #8]
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 51036dc:	e5d4301c 	ldrb	r3, [r4, #28]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 51036e0:	e5940004 	ldr	r0, [r4, #4]
        xBytesToStoreMessageLength = 0;
 51036e4:	e3130001 	tst	r3, #1
    xCount -= pxStreamBuffer->xTail;
 51036e8:	e5942000 	ldr	r2, [r4]
        xBytesToStoreMessageLength = 0;
 51036ec:	13a03004 	movne	r3, #4
 51036f0:	03a03000 	moveq	r3, #0
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 51036f4:	e08c0000 	add	r0, ip, r0
    xCount -= pxStreamBuffer->xTail;
 51036f8:	e0400002 	sub	r0, r0, r2
    if( xCount >= pxStreamBuffer->xLength )
 51036fc:	e15c0000 	cmp	ip, r0
        xCount -= pxStreamBuffer->xLength;
 5103700:	9040000c 	subls	r0, r0, ip
    if( xBytesAvailable > xBytesToStoreMessageLength )
 5103704:	e1530000 	cmp	r3, r0
 5103708:	3a000003 	bcc	510371c <xStreamBufferReceiveFromISR+0x68>
    size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
 510370c:	e3a05000 	mov	r5, #0
}
 5103710:	e1a00005 	mov	r0, r5
 5103714:	e28dd00c 	add	sp, sp, #12
 5103718:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
 510371c:	e1a03000 	mov	r3, r0
 5103720:	e1a02005 	mov	r2, r5
 5103724:	e1a01007 	mov	r1, r7
 5103728:	e1a00004 	mov	r0, r4
 510372c:	ebfffe1e 	bl	5102fac <prvReadMessageFromBuffer>
        if( xReceivedLength != ( size_t ) 0 )
 5103730:	e2505000 	subs	r5, r0, #0
 5103734:	0afffff4 	beq	510370c <xStreamBufferReceiveFromISR+0x58>
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
 5103738:	e5943014 	ldr	r3, [r4, #20]
 510373c:	e3530000 	cmp	r3, #0
 5103740:	0afffff2 	beq	5103710 <xStreamBufferReceiveFromISR+0x5c>
 5103744:	e5940014 	ldr	r0, [r4, #20]
 5103748:	e3a07000 	mov	r7, #0
 510374c:	e58d6004 	str	r6, [sp, #4]
 5103750:	e3056640 	movw	r6, #22080	; 0x5640
 5103754:	e58d7000 	str	r7, [sp]
 5103758:	e1a03007 	mov	r3, r7
 510375c:	e5941020 	ldr	r1, [r4, #32]
 5103760:	e3406510 	movt	r6, #1296	; 0x510
 5103764:	e1a02007 	mov	r2, r7
 5103768:	e12fff36 	blx	r6
 510376c:	e5847014 	str	r7, [r4, #20]
    return xReceivedLength;
 5103770:	eaffffe6 	b	5103710 <xStreamBufferReceiveFromISR+0x5c>
    configASSERT( pvRxData );
 5103774:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103778:	e3003900 	movw	r3, #2304	; 0x900
 510377c:	e30014c7 	movw	r1, #1223	; 0x4c7
 5103780:	e3400512 	movt	r0, #1298	; 0x512
 5103784:	e3403511 	movt	r3, #1297	; 0x511
 5103788:	e12fff33 	blx	r3
    configASSERT( pxStreamBuffer );
 510378c:	e3540000 	cmp	r4, #0
 5103790:	1affffd0 	bne	51036d8 <xStreamBufferReceiveFromISR+0x24>
 5103794:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103798:	e3003900 	movw	r3, #2304	; 0x900
 510379c:	e30014c8 	movw	r1, #1224	; 0x4c8
 51037a0:	e3403511 	movt	r3, #1297	; 0x511
 51037a4:	e3400512 	movt	r0, #1298	; 0x512
 51037a8:	e12fff33 	blx	r3
 51037ac:	eaffffc9 	b	51036d8 <xStreamBufferReceiveFromISR+0x24>

051037b0 <vStreamBufferDelete>:
{
 51037b0:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 51037b4:	e2504000 	subs	r4, r0, #0
 51037b8:	0a00000e 	beq	51037f8 <vStreamBufferDelete+0x48>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
 51037bc:	e5d4301c 	ldrb	r3, [r4, #28]
 51037c0:	e3130002 	tst	r3, #2
 51037c4:	1a000004 	bne	51037dc <vStreamBufferDelete+0x2c>
            vPortFree( ( void * ) pxStreamBuffer );
 51037c8:	e308333c 	movw	r3, #33596	; 0x833c
 51037cc:	e1a00004 	mov	r0, r4
 51037d0:	e3403510 	movt	r3, #1296	; 0x510
 51037d4:	e12fff33 	blx	r3
 51037d8:	e8bd8010 	pop	{r4, pc}
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 51037dc:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 51037e0:	e3a02024 	mov	r2, #36	; 0x24
 51037e4:	e3a01000 	mov	r1, #0
 51037e8:	e1a00004 	mov	r0, r4
 51037ec:	e3403511 	movt	r3, #1297	; 0x511
 51037f0:	e12fff33 	blx	r3
}
 51037f4:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 51037f8:	e30d0a94 	movw	r0, #55956	; 0xda94
 51037fc:	e3003900 	movw	r3, #2304	; 0x900
 5103800:	e3001233 	movw	r1, #563	; 0x233
 5103804:	e3403511 	movt	r3, #1297	; 0x511
 5103808:	e3400512 	movt	r0, #1298	; 0x512
 510380c:	e12fff33 	blx	r3
 5103810:	eaffffe9 	b	51037bc <vStreamBufferDelete+0xc>

05103814 <xStreamBufferIsFull>:
{
 5103814:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 5103818:	e2504000 	subs	r4, r0, #0
 510381c:	0a000013 	beq	5103870 <xStreamBufferIsFull+0x5c>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5103820:	e5d4301c 	ldrb	r3, [r4, #28]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103824:	e594e008 	ldr	lr, [r4, #8]
        xBytesToStoreMessageLength = 0;
 5103828:	e3130001 	tst	r3, #1
 510382c:	13a00004 	movne	r0, #4
 5103830:	03a00000 	moveq	r0, #0
        xOriginalTail = pxStreamBuffer->xTail;
 5103834:	e5942000 	ldr	r2, [r4]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103838:	e594c000 	ldr	ip, [r4]
        xSpace -= pxStreamBuffer->xHead;
 510383c:	e5941004 	ldr	r1, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 5103840:	e5943000 	ldr	r3, [r4]
 5103844:	e1520003 	cmp	r2, r3
 5103848:	1afffff9 	bne	5103834 <xStreamBufferIsFull+0x20>
    xSpace -= ( size_t ) 1;
 510384c:	e24e3001 	sub	r3, lr, #1
 5103850:	e083c00c 	add	ip, r3, ip
 5103854:	e04c1001 	sub	r1, ip, r1
    if( xSpace >= pxStreamBuffer->xLength )
 5103858:	e15e0001 	cmp	lr, r1
        xSpace -= pxStreamBuffer->xLength;
 510385c:	9041100e 	subls	r1, r1, lr
}
 5103860:	e1510000 	cmp	r1, r0
 5103864:	83a00000 	movhi	r0, #0
 5103868:	93a00001 	movls	r0, #1
 510386c:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 5103870:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103874:	e3003900 	movw	r3, #2304	; 0x900
 5103878:	e3001557 	movw	r1, #1367	; 0x557
 510387c:	e3403511 	movt	r3, #1297	; 0x511
 5103880:	e3400512 	movt	r0, #1298	; 0x512
 5103884:	e12fff33 	blx	r3
 5103888:	eaffffe4 	b	5103820 <xStreamBufferIsFull+0xc>

0510388c <xStreamBufferIsEmpty>:
{
 510388c:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 5103890:	e2504000 	subs	r4, r0, #0
 5103894:	0a000005 	beq	51038b0 <xStreamBufferIsEmpty+0x24>
    xTail = pxStreamBuffer->xTail;
 5103898:	e5943000 	ldr	r3, [r4]
    if( pxStreamBuffer->xHead == xTail )
 510389c:	e5940004 	ldr	r0, [r4, #4]
}
 51038a0:	e0400003 	sub	r0, r0, r3
 51038a4:	e16f0f10 	clz	r0, r0
 51038a8:	e1a002a0 	lsr	r0, r0, #5
 51038ac:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 51038b0:	e30d0a94 	movw	r0, #55956	; 0xda94
 51038b4:	e3003900 	movw	r3, #2304	; 0x900
 51038b8:	e300153b 	movw	r1, #1339	; 0x53b
 51038bc:	e3403511 	movt	r3, #1297	; 0x511
 51038c0:	e3400512 	movt	r0, #1298	; 0x512
 51038c4:	e12fff33 	blx	r3
 51038c8:	eafffff2 	b	5103898 <xStreamBufferIsEmpty+0xc>

051038cc <xStreamBufferReset>:
{
 51038cc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    configASSERT( pxStreamBuffer );
 51038d0:	e2504000 	subs	r4, r0, #0
{
 51038d4:	e24dd00c 	sub	sp, sp, #12
    configASSERT( pxStreamBuffer );
 51038d8:	0a00002c 	beq	5103990 <xStreamBufferReset+0xc4>
    taskENTER_CRITICAL();
 51038dc:	e30c3930 	movw	r3, #51504	; 0xc930
 51038e0:	e3403510 	movt	r3, #1296	; 0x510
 51038e4:	e12fff33 	blx	r3
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 51038e8:	e5940010 	ldr	r0, [r4, #16]
 51038ec:	e3500000 	cmp	r0, #0
    BaseType_t xReturn = pdFAIL;
 51038f0:	13a00000 	movne	r0, #0
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 51038f4:	0a000006 	beq	5103914 <xStreamBufferReset+0x48>
 51038f8:	e58d0004 	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 51038fc:	e30c3988 	movw	r3, #51592	; 0xc988
 5103900:	e3403510 	movt	r3, #1296	; 0x510
 5103904:	e12fff33 	blx	r3
}
 5103908:	e59d0004 	ldr	r0, [sp, #4]
 510390c:	e28dd00c 	add	sp, sp, #12
 5103910:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 5103914:	e5943014 	ldr	r3, [r4, #20]
 5103918:	e3530000 	cmp	r3, #0
 510391c:	1afffff5 	bne	51038f8 <xStreamBufferReset+0x2c>
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 5103920:	e5946018 	ldr	r6, [r4, #24]
    {
        /* The value written just has to be identifiable when looking at the
         * memory.  Don't use 0xA5 as that is the stack fill value and could
         * result in confusion as to what is actually being observed. */
        #define STREAM_BUFFER_BUFFER_WRITE_VALUE    ( 0x55 )
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 5103924:	e3095cbb 	movw	r5, #40123	; 0x9cbb
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 5103928:	e5947008 	ldr	r7, [r4, #8]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 510392c:	e3405511 	movt	r5, #1297	; 0x511
 5103930:	e1a02007 	mov	r2, r7
 5103934:	e3a01055 	mov	r1, #85	; 0x55
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 5103938:	e594900c 	ldr	r9, [r4, #12]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 510393c:	e1a00006 	mov	r0, r6
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 5103940:	e5d4801c 	ldrb	r8, [r4, #28]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 5103944:	e12fff35 	blx	r5
 5103948:	e1560000 	cmp	r6, r0
 510394c:	0a000005 	beq	5103968 <xStreamBufferReset+0x9c>
 5103950:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103954:	e3003900 	movw	r3, #2304	; 0x900
 5103958:	e3400512 	movt	r0, #1298	; 0x512
 510395c:	e3001644 	movw	r1, #1604	; 0x644
 5103960:	e3403511 	movt	r3, #1297	; 0x511
 5103964:	e12fff33 	blx	r3
    }
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 5103968:	e3a02024 	mov	r2, #36	; 0x24
 510396c:	e3a01000 	mov	r1, #0
 5103970:	e1a00004 	mov	r0, r4
 5103974:	e12fff35 	blx	r5
    pxStreamBuffer->pucBuffer = pucBuffer;
 5103978:	e5846018 	str	r6, [r4, #24]
    pxStreamBuffer->xLength = xBufferSizeBytes;
 510397c:	e5847008 	str	r7, [r4, #8]
            xReturn = pdPASS;
 5103980:	e3a00001 	mov	r0, #1
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103984:	e584900c 	str	r9, [r4, #12]
    pxStreamBuffer->ucFlags = ucFlags;
 5103988:	e5c4801c 	strb	r8, [r4, #28]
        /* More details at: https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/MISRA.md#rule-111 */
        /* coverity[misra_c_2012_rule_11_1_violation] */
        ( void ) pxReceiveCompletedCallback;
    }
    #endif /* if ( configUSE_SB_COMPLETED_CALLBACK == 1 ) */
}
 510398c:	eaffffd9 	b	51038f8 <xStreamBufferReset+0x2c>
    configASSERT( pxStreamBuffer );
 5103990:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103994:	e3003900 	movw	r3, #2304	; 0x900
 5103998:	e300125e 	movw	r1, #606	; 0x25e
 510399c:	e3403511 	movt	r3, #1297	; 0x511
 51039a0:	e3400512 	movt	r0, #1298	; 0x512
 51039a4:	e12fff33 	blx	r3
 51039a8:	eaffffcb 	b	51038dc <xStreamBufferReset+0x10>

051039ac <xStreamBufferResetFromISR>:
{
 51039ac:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    configASSERT( pxStreamBuffer );
 51039b0:	e2504000 	subs	r4, r0, #0
 51039b4:	0a000023 	beq	5103a48 <xStreamBufferResetFromISR+0x9c>
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 51039b8:	e5940010 	ldr	r0, [r4, #16]
 51039bc:	e3500000 	cmp	r0, #0
 51039c0:	0a000001 	beq	51039cc <xStreamBufferResetFromISR+0x20>
    BaseType_t xReturn = pdFAIL;
 51039c4:	e3a00000 	mov	r0, #0
}
 51039c8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
 51039cc:	e5943014 	ldr	r3, [r4, #20]
 51039d0:	e3530000 	cmp	r3, #0
 51039d4:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 51039d8:	e5946018 	ldr	r6, [r4, #24]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 51039dc:	e3095cbb 	movw	r5, #40123	; 0x9cbb
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 51039e0:	e5947008 	ldr	r7, [r4, #8]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 51039e4:	e3405511 	movt	r5, #1297	; 0x511
 51039e8:	e1a02007 	mov	r2, r7
 51039ec:	e3a01055 	mov	r1, #85	; 0x55
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 51039f0:	e594900c 	ldr	r9, [r4, #12]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 51039f4:	e1a00006 	mov	r0, r6
            prvInitialiseNewStreamBuffer( pxStreamBuffer,
 51039f8:	e5d4801c 	ldrb	r8, [r4, #28]
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 51039fc:	e12fff35 	blx	r5
 5103a00:	e1560000 	cmp	r6, r0
 5103a04:	0a000005 	beq	5103a20 <xStreamBufferResetFromISR+0x74>
 5103a08:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103a0c:	e3003900 	movw	r3, #2304	; 0x900
 5103a10:	e3400512 	movt	r0, #1298	; 0x512
 5103a14:	e3001644 	movw	r1, #1604	; 0x644
 5103a18:	e3403511 	movt	r3, #1297	; 0x511
 5103a1c:	e12fff33 	blx	r3
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 5103a20:	e3a02024 	mov	r2, #36	; 0x24
 5103a24:	e3a01000 	mov	r1, #0
 5103a28:	e1a00004 	mov	r0, r4
 5103a2c:	e12fff35 	blx	r5
    pxStreamBuffer->pucBuffer = pucBuffer;
 5103a30:	e5846018 	str	r6, [r4, #24]
    pxStreamBuffer->xLength = xBufferSizeBytes;
 5103a34:	e5847008 	str	r7, [r4, #8]
            xReturn = pdPASS;
 5103a38:	e3a00001 	mov	r0, #1
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103a3c:	e584900c 	str	r9, [r4, #12]
    pxStreamBuffer->ucFlags = ucFlags;
 5103a40:	e5c4801c 	strb	r8, [r4, #28]
}
 5103a44:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    configASSERT( pxStreamBuffer );
 5103a48:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103a4c:	e3003900 	movw	r3, #2304	; 0x900
 5103a50:	e3a01fa7 	mov	r1, #668	; 0x29c
 5103a54:	e3403511 	movt	r3, #1297	; 0x511
 5103a58:	e3400512 	movt	r0, #1298	; 0x512
 5103a5c:	e12fff33 	blx	r3
 5103a60:	eaffffd4 	b	51039b8 <xStreamBufferResetFromISR+0xc>

05103a64 <xStreamBufferSpacesAvailable>:
{
 5103a64:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 5103a68:	e2504000 	subs	r4, r0, #0
 5103a6c:	0a00000c 	beq	5103aa4 <xStreamBufferSpacesAvailable+0x40>
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103a70:	e594c008 	ldr	ip, [r4, #8]
        xOriginalTail = pxStreamBuffer->xTail;
 5103a74:	e5943000 	ldr	r3, [r4]
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
 5103a78:	e5941000 	ldr	r1, [r4]
        xSpace -= pxStreamBuffer->xHead;
 5103a7c:	e5940004 	ldr	r0, [r4, #4]
    } while( xOriginalTail != pxStreamBuffer->xTail );
 5103a80:	e5942000 	ldr	r2, [r4]
 5103a84:	e1520003 	cmp	r2, r3
 5103a88:	1afffff9 	bne	5103a74 <xStreamBufferSpacesAvailable+0x10>
    xSpace -= ( size_t ) 1;
 5103a8c:	e24c3001 	sub	r3, ip, #1
 5103a90:	e0831001 	add	r1, r3, r1
 5103a94:	e0410000 	sub	r0, r1, r0
    if( xSpace >= pxStreamBuffer->xLength )
 5103a98:	e15c0000 	cmp	ip, r0
        xSpace -= pxStreamBuffer->xLength;
 5103a9c:	9040000c 	subls	r0, r0, ip
}
 5103aa0:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 5103aa4:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103aa8:	e3003900 	movw	r3, #2304	; 0x900
 5103aac:	e30012fa 	movw	r1, #762	; 0x2fa
 5103ab0:	e3403511 	movt	r3, #1297	; 0x511
 5103ab4:	e3400512 	movt	r0, #1298	; 0x512
 5103ab8:	e12fff33 	blx	r3
 5103abc:	eaffffeb 	b	5103a70 <xStreamBufferSpacesAvailable+0xc>

05103ac0 <xStreamBufferBytesAvailable>:
{
 5103ac0:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 5103ac4:	e2504000 	subs	r4, r0, #0
 5103ac8:	0a000007 	beq	5103aec <xStreamBufferBytesAvailable+0x2c>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103acc:	e5943008 	ldr	r3, [r4, #8]
 5103ad0:	e5940004 	ldr	r0, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 5103ad4:	e5942000 	ldr	r2, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5103ad8:	e0830000 	add	r0, r3, r0
    xCount -= pxStreamBuffer->xTail;
 5103adc:	e0400002 	sub	r0, r0, r2
    if( xCount >= pxStreamBuffer->xLength )
 5103ae0:	e1530000 	cmp	r3, r0
        xCount -= pxStreamBuffer->xLength;
 5103ae4:	90400003 	subls	r0, r0, r3
}
 5103ae8:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 5103aec:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103af0:	e3003900 	movw	r3, #2304	; 0x900
 5103af4:	e300131e 	movw	r1, #798	; 0x31e
 5103af8:	e3403511 	movt	r3, #1297	; 0x511
 5103afc:	e3400512 	movt	r0, #1298	; 0x512
 5103b00:	e12fff33 	blx	r3
 5103b04:	eafffff0 	b	5103acc <xStreamBufferBytesAvailable+0xc>

05103b08 <xStreamBufferSetTriggerLevel>:
{
 5103b08:	e92d4070 	push	{r4, r5, r6, lr}
 5103b0c:	e1a04001 	mov	r4, r1
    configASSERT( pxStreamBuffer );
 5103b10:	e2505000 	subs	r5, r0, #0
 5103b14:	0a000007 	beq	5103b38 <xStreamBufferSetTriggerLevel+0x30>
    if( xTriggerLevel < pxStreamBuffer->xLength )
 5103b18:	e5953008 	ldr	r3, [r5, #8]
 5103b1c:	e3540001 	cmp	r4, #1
 5103b20:	33a04001 	movcc	r4, #1
 5103b24:	e1530004 	cmp	r3, r4
        xReturn = pdPASS;
 5103b28:	83a00001 	movhi	r0, #1
        xReturn = pdFALSE;
 5103b2c:	93a00000 	movls	r0, #0
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
 5103b30:	8585400c 	strhi	r4, [r5, #12]
}
 5103b34:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxStreamBuffer );
 5103b38:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103b3c:	e3003900 	movw	r3, #2304	; 0x900
 5103b40:	e3a01fb6 	mov	r1, #728	; 0x2d8
 5103b44:	e3403511 	movt	r3, #1297	; 0x511
 5103b48:	e3400512 	movt	r0, #1298	; 0x512
 5103b4c:	e12fff33 	blx	r3
 5103b50:	eafffff0 	b	5103b18 <xStreamBufferSetTriggerLevel+0x10>

05103b54 <xStreamBufferSendCompletedFromISR>:
{
 5103b54:	e92d4070 	push	{r4, r5, r6, lr}
 5103b58:	e1a05001 	mov	r5, r1
    configASSERT( pxStreamBuffer );
 5103b5c:	e2504000 	subs	r4, r0, #0
{
 5103b60:	e24dd008 	sub	sp, sp, #8
    configASSERT( pxStreamBuffer );
 5103b64:	0a000010 	beq	5103bac <xStreamBufferSendCompletedFromISR+0x58>
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
 5103b68:	e5940010 	ldr	r0, [r4, #16]
 5103b6c:	e3500000 	cmp	r0, #0
 5103b70:	0a00000b 	beq	5103ba4 <xStreamBufferSendCompletedFromISR+0x50>
            ( void ) xTaskNotifyIndexedFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
 5103b74:	e5940010 	ldr	r0, [r4, #16]
 5103b78:	e3a06000 	mov	r6, #0
 5103b7c:	e58d5004 	str	r5, [sp, #4]
 5103b80:	e3055640 	movw	r5, #22080	; 0x5640
 5103b84:	e58d6000 	str	r6, [sp]
 5103b88:	e1a03006 	mov	r3, r6
 5103b8c:	e5941020 	ldr	r1, [r4, #32]
 5103b90:	e3405510 	movt	r5, #1296	; 0x510
 5103b94:	e1a02006 	mov	r2, r6
 5103b98:	e12fff35 	blx	r5
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
 5103b9c:	e5846010 	str	r6, [r4, #16]
            xReturn = pdTRUE;
 5103ba0:	e3a00001 	mov	r0, #1
}
 5103ba4:	e28dd008 	add	sp, sp, #8
 5103ba8:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxStreamBuffer );
 5103bac:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103bb0:	e3003900 	movw	r3, #2304	; 0x900
 5103bb4:	e300157f 	movw	r1, #1407	; 0x57f
 5103bb8:	e3403511 	movt	r3, #1297	; 0x511
 5103bbc:	e3400512 	movt	r0, #1298	; 0x512
 5103bc0:	e12fff33 	blx	r3
 5103bc4:	eaffffe7 	b	5103b68 <xStreamBufferSendCompletedFromISR+0x14>

05103bc8 <xStreamBufferReceiveCompletedFromISR>:
{
 5103bc8:	e92d4070 	push	{r4, r5, r6, lr}
 5103bcc:	e1a05001 	mov	r5, r1
    configASSERT( pxStreamBuffer );
 5103bd0:	e2504000 	subs	r4, r0, #0
{
 5103bd4:	e24dd008 	sub	sp, sp, #8
    configASSERT( pxStreamBuffer );
 5103bd8:	0a000010 	beq	5103c20 <xStreamBufferReceiveCompletedFromISR+0x58>
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
 5103bdc:	e5940014 	ldr	r0, [r4, #20]
 5103be0:	e3500000 	cmp	r0, #0
 5103be4:	0a00000b 	beq	5103c18 <xStreamBufferReceiveCompletedFromISR+0x50>
            ( void ) xTaskNotifyIndexedFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
 5103be8:	e5940014 	ldr	r0, [r4, #20]
 5103bec:	e3a06000 	mov	r6, #0
 5103bf0:	e58d5004 	str	r5, [sp, #4]
 5103bf4:	e3055640 	movw	r5, #22080	; 0x5640
 5103bf8:	e58d6000 	str	r6, [sp]
 5103bfc:	e1a03006 	mov	r3, r6
 5103c00:	e5941020 	ldr	r1, [r4, #32]
 5103c04:	e3405510 	movt	r5, #1296	; 0x510
 5103c08:	e1a02006 	mov	r2, r6
 5103c0c:	e12fff35 	blx	r5
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
 5103c10:	e5846014 	str	r6, [r4, #20]
            xReturn = pdTRUE;
 5103c14:	e3a00001 	mov	r0, #1
}
 5103c18:	e28dd008 	add	sp, sp, #8
 5103c1c:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxStreamBuffer );
 5103c20:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103c24:	e3003900 	movw	r3, #2304	; 0x900
 5103c28:	e30015a6 	movw	r1, #1446	; 0x5a6
 5103c2c:	e3403511 	movt	r3, #1297	; 0x511
 5103c30:	e3400512 	movt	r0, #1298	; 0x512
 5103c34:	e12fff33 	blx	r3
 5103c38:	eaffffe7 	b	5103bdc <xStreamBufferReceiveCompletedFromISR+0x14>

05103c3c <uxStreamBufferGetStreamBufferNotificationIndex>:
/*-----------------------------------------------------------*/

UBaseType_t uxStreamBufferGetStreamBufferNotificationIndex( StreamBufferHandle_t xStreamBuffer )
{
 5103c3c:	e92d4010 	push	{r4, lr}
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;

    traceENTER_uxStreamBufferGetStreamBufferNotificationIndex( xStreamBuffer );

    configASSERT( pxStreamBuffer );
 5103c40:	e2504000 	subs	r4, r0, #0
 5103c44:	0a000001 	beq	5103c50 <uxStreamBufferGetStreamBufferNotificationIndex+0x14>

    traceRETURN_uxStreamBufferGetStreamBufferNotificationIndex( pxStreamBuffer->uxNotificationIndex );

    return pxStreamBuffer->uxNotificationIndex;
}
 5103c48:	e5940020 	ldr	r0, [r4, #32]
 5103c4c:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 5103c50:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103c54:	e3003900 	movw	r3, #2304	; 0x900
 5103c58:	e3001669 	movw	r1, #1641	; 0x669
 5103c5c:	e3403511 	movt	r3, #1297	; 0x511
 5103c60:	e3400512 	movt	r0, #1298	; 0x512
 5103c64:	e12fff33 	blx	r3
}
 5103c68:	e5940020 	ldr	r0, [r4, #32]
 5103c6c:	e8bd8010 	pop	{r4, pc}

05103c70 <vStreamBufferSetStreamBufferNotificationIndex>:
/*-----------------------------------------------------------*/

void vStreamBufferSetStreamBufferNotificationIndex( StreamBufferHandle_t xStreamBuffer,
                                                    UBaseType_t uxNotificationIndex )
{
 5103c70:	e92d4070 	push	{r4, r5, r6, lr}
 5103c74:	e1a05001 	mov	r5, r1
    StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;

    traceENTER_vStreamBufferSetStreamBufferNotificationIndex( xStreamBuffer, uxNotificationIndex );

    configASSERT( pxStreamBuffer );
 5103c78:	e2504000 	subs	r4, r0, #0
 5103c7c:	0a00001d 	beq	5103cf8 <vStreamBufferSetStreamBufferNotificationIndex+0x88>

    /* There should be no task waiting otherwise we'd never resume them. */
    configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
 5103c80:	e5943010 	ldr	r3, [r4, #16]
 5103c84:	e3530000 	cmp	r3, #0
 5103c88:	0a000005 	beq	5103ca4 <vStreamBufferSetStreamBufferNotificationIndex+0x34>
 5103c8c:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103c90:	e3003900 	movw	r3, #2304	; 0x900
 5103c94:	e300167b 	movw	r1, #1659	; 0x67b
 5103c98:	e3400512 	movt	r0, #1298	; 0x512
 5103c9c:	e3403511 	movt	r3, #1297	; 0x511
 5103ca0:	e12fff33 	blx	r3
    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
 5103ca4:	e5943014 	ldr	r3, [r4, #20]
 5103ca8:	e3530000 	cmp	r3, #0
 5103cac:	0a000005 	beq	5103cc8 <vStreamBufferSetStreamBufferNotificationIndex+0x58>
 5103cb0:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103cb4:	e3003900 	movw	r3, #2304	; 0x900
 5103cb8:	e300167c 	movw	r1, #1660	; 0x67c
 5103cbc:	e3400512 	movt	r0, #1298	; 0x512
 5103cc0:	e3403511 	movt	r3, #1297	; 0x511
 5103cc4:	e12fff33 	blx	r3

    /* Check that the task notification index is valid. */
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5103cc8:	e3550000 	cmp	r5, #0
 5103ccc:	1a000001 	bne	5103cd8 <vStreamBufferSetStreamBufferNotificationIndex+0x68>

    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
 5103cd0:	e5845020 	str	r5, [r4, #32]

    traceRETURN_vStreamBufferSetStreamBufferNotificationIndex();
}
 5103cd4:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( uxNotificationIndex < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5103cd8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103cdc:	e3003900 	movw	r3, #2304	; 0x900
 5103ce0:	e300167f 	movw	r1, #1663	; 0x67f
 5103ce4:	e3400512 	movt	r0, #1298	; 0x512
 5103ce8:	e3403511 	movt	r3, #1297	; 0x511
 5103cec:	e12fff33 	blx	r3
    pxStreamBuffer->uxNotificationIndex = uxNotificationIndex;
 5103cf0:	e5845020 	str	r5, [r4, #32]
}
 5103cf4:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxStreamBuffer );
 5103cf8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103cfc:	e3003900 	movw	r3, #2304	; 0x900
 5103d00:	e3001678 	movw	r1, #1656	; 0x678
 5103d04:	e3403511 	movt	r3, #1297	; 0x511
 5103d08:	e3400512 	movt	r0, #1298	; 0x512
 5103d0c:	e12fff33 	blx	r3
 5103d10:	eaffffda 	b	5103c80 <vStreamBufferSetStreamBufferNotificationIndex+0x10>

05103d14 <xStreamBufferGenericCreate>:
        if( xStreamBufferType == sbTYPE_MESSAGE_BUFFER )
 5103d14:	e3520001 	cmp	r2, #1
    {
 5103d18:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5103d1c:	e1a07002 	mov	r7, r2
 5103d20:	e1a04000 	mov	r4, r0
 5103d24:	e1a05001 	mov	r5, r1
        if( xStreamBufferType == sbTYPE_MESSAGE_BUFFER )
 5103d28:	0a000016 	beq	5103d88 <xStreamBufferGenericCreate+0x74>
        else if( xStreamBufferType == sbTYPE_STREAM_BATCHING_BUFFER )
 5103d2c:	e3520002 	cmp	r2, #2
 5103d30:	0a000009 	beq	5103d5c <xStreamBufferGenericCreate+0x48>
            configASSERT( xBufferSizeBytes > 0 );
 5103d34:	e3500000 	cmp	r0, #0
            ucFlags = 0;
 5103d38:	13a07000 	movne	r7, #0
            configASSERT( xBufferSizeBytes > 0 );
 5103d3c:	0a000043 	beq	5103e50 <xStreamBufferGenericCreate+0x13c>
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 5103d40:	e1540005 	cmp	r4, r5
 5103d44:	3a00003a 	bcc	5103e34 <xStreamBufferGenericCreate+0x120>
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1U + sizeof( StreamBuffer_t ) ) )
 5103d48:	e3740026 	cmn	r4, #38	; 0x26
 5103d4c:	9a000017 	bls	5103db0 <xStreamBufferGenericCreate+0x9c>
            pvAllocatedMemory = NULL;
 5103d50:	e3a06000 	mov	r6, #0
    }
 5103d54:	e1a00006 	mov	r0, r6
 5103d58:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            configASSERT( xBufferSizeBytes > 0 );
 5103d5c:	e3500000 	cmp	r0, #0
            ucFlags = sbFLAGS_IS_BATCHING_BUFFER;
 5103d60:	13a07004 	movne	r7, #4
            configASSERT( xBufferSizeBytes > 0 );
 5103d64:	1afffff5 	bne	5103d40 <xStreamBufferGenericCreate+0x2c>
 5103d68:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103d6c:	e3006900 	movw	r6, #2304	; 0x900
 5103d70:	e3a01f59 	mov	r1, #356	; 0x164
 5103d74:	e3400512 	movt	r0, #1298	; 0x512
            ucFlags = sbFLAGS_IS_BATCHING_BUFFER;
 5103d78:	e3a07004 	mov	r7, #4
            configASSERT( xBufferSizeBytes > 0 );
 5103d7c:	e3406511 	movt	r6, #1297	; 0x511
 5103d80:	e12fff36 	blx	r6
 5103d84:	ea000007 	b	5103da8 <xStreamBufferGenericCreate+0x94>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 5103d88:	e3500004 	cmp	r0, #4
 5103d8c:	8affffeb 	bhi	5103d40 <xStreamBufferGenericCreate+0x2c>
 5103d90:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103d94:	e3006900 	movw	r6, #2304	; 0x900
 5103d98:	e300115e 	movw	r1, #350	; 0x15e
 5103d9c:	e3400512 	movt	r0, #1298	; 0x512
 5103da0:	e3406511 	movt	r6, #1297	; 0x511
 5103da4:	e12fff36 	blx	r6
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 5103da8:	e1540005 	cmp	r4, r5
 5103dac:	3a000022 	bcc	5103e3c <xStreamBufferGenericCreate+0x128>
            pvAllocatedMemory = pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) );
 5103db0:	e3073f74 	movw	r3, #32628	; 0x7f74
 5103db4:	e3550001 	cmp	r5, #1
 5103db8:	e2840025 	add	r0, r4, #37	; 0x25
 5103dbc:	33a05001 	movcc	r5, #1
 5103dc0:	e3403510 	movt	r3, #1296	; 0x510
 5103dc4:	e12fff33 	blx	r3
        if( pvAllocatedMemory != NULL )
 5103dc8:	e2506000 	subs	r6, r0, #0
 5103dcc:	0affffdf 	beq	5103d50 <xStreamBufferGenericCreate+0x3c>
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pvAllocatedMemory,                         /* Structure at the start of the allocated memory. */
 5103dd0:	e2869024 	add	r9, r6, #36	; 0x24
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 5103dd4:	e3098cbb 	movw	r8, #40123	; 0x9cbb
            xBufferSizeBytes++;
 5103dd8:	e2844001 	add	r4, r4, #1
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 5103ddc:	e1a02004 	mov	r2, r4
 5103de0:	e3408511 	movt	r8, #1297	; 0x511
 5103de4:	e3a01055 	mov	r1, #85	; 0x55
 5103de8:	e1a00009 	mov	r0, r9
 5103dec:	e12fff38 	blx	r8
 5103df0:	e1590000 	cmp	r9, r0
 5103df4:	0a000005 	beq	5103e10 <xStreamBufferGenericCreate+0xfc>
 5103df8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103dfc:	e3003900 	movw	r3, #2304	; 0x900
 5103e00:	e3400512 	movt	r0, #1298	; 0x512
 5103e04:	e3001644 	movw	r1, #1604	; 0x644
 5103e08:	e3403511 	movt	r3, #1297	; 0x511
 5103e0c:	e12fff33 	blx	r3
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 5103e10:	e3a02024 	mov	r2, #36	; 0x24
 5103e14:	e3a01000 	mov	r1, #0
 5103e18:	e1a00006 	mov	r0, r6
 5103e1c:	e12fff38 	blx	r8
    pxStreamBuffer->pucBuffer = pucBuffer;
 5103e20:	e5869018 	str	r9, [r6, #24]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103e24:	e1c640f8 	strd	r4, [r6, #8]
    }
 5103e28:	e1a00006 	mov	r0, r6
    pxStreamBuffer->ucFlags = ucFlags;
 5103e2c:	e5c6701c 	strb	r7, [r6, #28]
    }
 5103e30:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 5103e34:	e3006900 	movw	r6, #2304	; 0x900
 5103e38:	e3406511 	movt	r6, #1297	; 0x511
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 5103e3c:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103e40:	e300116d 	movw	r1, #365	; 0x16d
 5103e44:	e3400512 	movt	r0, #1298	; 0x512
 5103e48:	e12fff36 	blx	r6
 5103e4c:	eaffffbd 	b	5103d48 <xStreamBufferGenericCreate+0x34>
            configASSERT( xBufferSizeBytes > 0 );
 5103e50:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103e54:	e3006900 	movw	r6, #2304	; 0x900
 5103e58:	e300116a 	movw	r1, #362	; 0x16a
 5103e5c:	e3400512 	movt	r0, #1298	; 0x512
            ucFlags = 0;
 5103e60:	e1a07004 	mov	r7, r4
            configASSERT( xBufferSizeBytes > 0 );
 5103e64:	e3406511 	movt	r6, #1297	; 0x511
 5103e68:	e12fff36 	blx	r6
 5103e6c:	eaffffcd 	b	5103da8 <xStreamBufferGenericCreate+0x94>

05103e70 <xStreamBufferGenericCreateStatic>:
    {
 5103e70:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
 5103e74:	e24dd00c 	sub	sp, sp, #12
 5103e78:	e1a08000 	mov	r8, r0
        configASSERT( pucStreamBufferStorageArea );
 5103e7c:	e2534000 	subs	r4, r3, #0
    {
 5103e80:	e1a06001 	mov	r6, r1
 5103e84:	e1a07002 	mov	r7, r2
 5103e88:	e59d5028 	ldr	r5, [sp, #40]	; 0x28
        configASSERT( pucStreamBufferStorageArea );
 5103e8c:	0a000051 	beq	5103fd8 <xStreamBufferGenericCreateStatic+0x168>
        configASSERT( pxStaticStreamBuffer );
 5103e90:	e3550000 	cmp	r5, #0
 5103e94:	0a000057 	beq	5103ff8 <xStreamBufferGenericCreateStatic+0x188>
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 5103e98:	e1560008 	cmp	r6, r8
 5103e9c:	8a000046 	bhi	5103fbc <xStreamBufferGenericCreateStatic+0x14c>
        if( xStreamBufferType == sbTYPE_MESSAGE_BUFFER )
 5103ea0:	e3570001 	cmp	r7, #1
 5103ea4:	0a000039 	beq	5103f90 <xStreamBufferGenericCreateStatic+0x120>
        else if( xStreamBufferType == sbTYPE_STREAM_BATCHING_BUFFER )
 5103ea8:	e3570002 	cmp	r7, #2
            ucFlags = sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103eac:	13a09002 	movne	r9, #2
        else if( xStreamBufferType == sbTYPE_STREAM_BATCHING_BUFFER )
 5103eb0:	0a00002b 	beq	5103f64 <xStreamBufferGenericCreateStatic+0xf4>
            volatile size_t xSize = sizeof( StaticStreamBuffer_t );
 5103eb4:	e3a03024 	mov	r3, #36	; 0x24
 5103eb8:	e58d3004 	str	r3, [sp, #4]
            configASSERT( xSize == sizeof( StreamBuffer_t ) );
 5103ebc:	e59d3004 	ldr	r3, [sp, #4]
 5103ec0:	e3530024 	cmp	r3, #36	; 0x24
 5103ec4:	0a000005 	beq	5103ee0 <xStreamBufferGenericCreateStatic+0x70>
 5103ec8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103ecc:	e3003900 	movw	r3, #2304	; 0x900
 5103ed0:	e3400512 	movt	r0, #1298	; 0x512
 5103ed4:	e3a01f79 	mov	r1, #484	; 0x1e4
 5103ed8:	e3403511 	movt	r3, #1297	; 0x511
 5103edc:	e12fff33 	blx	r3
        if( ( pucStreamBufferStorageArea != NULL ) && ( pxStaticStreamBuffer != NULL ) )
 5103ee0:	e3540000 	cmp	r4, #0
 5103ee4:	13550000 	cmpne	r5, #0
 5103ee8:	13a00001 	movne	r0, #1
 5103eec:	03a00000 	moveq	r0, #0
 5103ef0:	0a000019 	beq	5103f5c <xStreamBufferGenericCreateStatic+0xec>
        configASSERT( memset( pucBuffer, ( int ) STREAM_BUFFER_BUFFER_WRITE_VALUE, xBufferSizeBytes ) == pucBuffer );
 5103ef4:	e3097cbb 	movw	r7, #40123	; 0x9cbb
 5103ef8:	e1a02008 	mov	r2, r8
 5103efc:	e3a01055 	mov	r1, #85	; 0x55
 5103f00:	e3407511 	movt	r7, #1297	; 0x511
 5103f04:	e1a00004 	mov	r0, r4
 5103f08:	e12fff37 	blx	r7
 5103f0c:	e1540000 	cmp	r4, r0
 5103f10:	0a000005 	beq	5103f2c <xStreamBufferGenericCreateStatic+0xbc>
 5103f14:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103f18:	e3003900 	movw	r3, #2304	; 0x900
 5103f1c:	e3400512 	movt	r0, #1298	; 0x512
 5103f20:	e3001644 	movw	r1, #1604	; 0x644
 5103f24:	e3403511 	movt	r3, #1297	; 0x511
 5103f28:	e12fff33 	blx	r3
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 5103f2c:	e3a02024 	mov	r2, #36	; 0x24
 5103f30:	e3a01000 	mov	r1, #0
 5103f34:	e1a00005 	mov	r0, r5
            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103f38:	e3899002 	orr	r9, r9, #2
    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
 5103f3c:	e12fff37 	blx	r7
    pxStreamBuffer->pucBuffer = pucBuffer;
 5103f40:	e1a00005 	mov	r0, r5
 5103f44:	e5854018 	str	r4, [r5, #24]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103f48:	e3560001 	cmp	r6, #1
    pxStreamBuffer->xLength = xBufferSizeBytes;
 5103f4c:	e5858008 	str	r8, [r5, #8]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103f50:	33a06001 	movcc	r6, #1
            pxStreamBuffer->ucFlags |= sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103f54:	e5c5901c 	strb	r9, [r5, #28]
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
 5103f58:	e585600c 	str	r6, [r5, #12]
    }
 5103f5c:	e28dd00c 	add	sp, sp, #12
 5103f60:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
            configASSERT( xBufferSizeBytes > 0 );
 5103f64:	e3580000 	cmp	r8, #0
            ucFlags = sbFLAGS_IS_BATCHING_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103f68:	13a09006 	movne	r9, #6
            configASSERT( xBufferSizeBytes > 0 );
 5103f6c:	1affffd0 	bne	5103eb4 <xStreamBufferGenericCreateStatic+0x44>
 5103f70:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103f74:	e3003900 	movw	r3, #2304	; 0x900
 5103f78:	e30011d6 	movw	r1, #470	; 0x1d6
 5103f7c:	e3400512 	movt	r0, #1298	; 0x512
            ucFlags = sbFLAGS_IS_BATCHING_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103f80:	e3a09006 	mov	r9, #6
            configASSERT( xBufferSizeBytes > 0 );
 5103f84:	e3403511 	movt	r3, #1297	; 0x511
 5103f88:	e12fff33 	blx	r3
 5103f8c:	eaffffc8 	b	5103eb4 <xStreamBufferGenericCreateStatic+0x44>
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 5103f90:	e3580004 	cmp	r8, #4
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103f94:	83a09003 	movhi	r9, #3
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 5103f98:	8affffc5 	bhi	5103eb4 <xStreamBufferGenericCreateStatic+0x44>
 5103f9c:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103fa0:	e3003900 	movw	r3, #2304	; 0x900
 5103fa4:	e3a01e1d 	mov	r1, #464	; 0x1d0
 5103fa8:	e3400512 	movt	r0, #1298	; 0x512
            ucFlags = sbFLAGS_IS_MESSAGE_BUFFER | sbFLAGS_IS_STATICALLY_ALLOCATED;
 5103fac:	e3a09003 	mov	r9, #3
            configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
 5103fb0:	e3403511 	movt	r3, #1297	; 0x511
 5103fb4:	e12fff33 	blx	r3
 5103fb8:	eaffffbd 	b	5103eb4 <xStreamBufferGenericCreateStatic+0x44>
        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );
 5103fbc:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103fc0:	e3003900 	movw	r3, #2304	; 0x900
 5103fc4:	e30011be 	movw	r1, #446	; 0x1be
 5103fc8:	e3403511 	movt	r3, #1297	; 0x511
 5103fcc:	e3400512 	movt	r0, #1298	; 0x512
 5103fd0:	e12fff33 	blx	r3
 5103fd4:	eaffffb1 	b	5103ea0 <xStreamBufferGenericCreateStatic+0x30>
        configASSERT( pucStreamBufferStorageArea );
 5103fd8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103fdc:	e3003900 	movw	r3, #2304	; 0x900
 5103fe0:	e3400512 	movt	r0, #1298	; 0x512
 5103fe4:	e3a01f6f 	mov	r1, #444	; 0x1bc
 5103fe8:	e3403511 	movt	r3, #1297	; 0x511
 5103fec:	e12fff33 	blx	r3
        configASSERT( pxStaticStreamBuffer );
 5103ff0:	e3550000 	cmp	r5, #0
 5103ff4:	1affffa7 	bne	5103e98 <xStreamBufferGenericCreateStatic+0x28>
 5103ff8:	e30d0a94 	movw	r0, #55956	; 0xda94
 5103ffc:	e3003900 	movw	r3, #2304	; 0x900
 5104000:	e30011bd 	movw	r1, #445	; 0x1bd
 5104004:	e3403511 	movt	r3, #1297	; 0x511
 5104008:	e3400512 	movt	r0, #1298	; 0x512
 510400c:	e12fff33 	blx	r3
 5104010:	eaffffa0 	b	5103e98 <xStreamBufferGenericCreateStatic+0x28>

05104014 <xStreamBufferNextMessageLengthBytes>:
{
 5104014:	e92d4010 	push	{r4, lr}
    configASSERT( pxStreamBuffer );
 5104018:	e2504000 	subs	r4, r0, #0
{
 510401c:	e24dd008 	sub	sp, sp, #8
    configASSERT( pxStreamBuffer );
 5104020:	0a000020 	beq	51040a8 <xStreamBufferNextMessageLengthBytes+0x94>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
 5104024:	e5d4301c 	ldrb	r3, [r4, #28]
 5104028:	e2130001 	ands	r0, r3, #1
 510402c:	0a00000a 	beq	510405c <xStreamBufferNextMessageLengthBytes+0x48>
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 5104030:	e5942008 	ldr	r2, [r4, #8]
 5104034:	e5943004 	ldr	r3, [r4, #4]
    xCount -= pxStreamBuffer->xTail;
 5104038:	e5940000 	ldr	r0, [r4]
    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
 510403c:	e0823003 	add	r3, r2, r3
    xCount -= pxStreamBuffer->xTail;
 5104040:	e0430000 	sub	r0, r3, r0
    if( xCount >= pxStreamBuffer->xLength )
 5104044:	e1520000 	cmp	r2, r0
        xCount -= pxStreamBuffer->xLength;
 5104048:	90400002 	subls	r0, r0, r2
        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
 510404c:	e3500004 	cmp	r0, #4
 5104050:	8a000003 	bhi	5104064 <xStreamBufferNextMessageLengthBytes+0x50>
            configASSERT( xBytesAvailable == 0 );
 5104054:	e3500000 	cmp	r0, #0
 5104058:	1a000009 	bne	5104084 <xStreamBufferNextMessageLengthBytes+0x70>
}
 510405c:	e28dd008 	add	sp, sp, #8
 5104060:	e8bd8010 	pop	{r4, pc}
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
 5104064:	e3a02004 	mov	r2, #4
 5104068:	e1a00004 	mov	r0, r4
 510406c:	e5943000 	ldr	r3, [r4]
 5104070:	e08d1002 	add	r1, sp, r2
 5104074:	ebfffb91 	bl	5102ec0 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
 5104078:	e59d0004 	ldr	r0, [sp, #4]
}
 510407c:	e28dd008 	add	sp, sp, #8
 5104080:	e8bd8010 	pop	{r4, pc}
            configASSERT( xBytesAvailable == 0 );
 5104084:	e30d0a94 	movw	r0, #55956	; 0xda94
 5104088:	e3003900 	movw	r3, #2304	; 0x900
 510408c:	e30014ae 	movw	r1, #1198	; 0x4ae
 5104090:	e3403511 	movt	r3, #1297	; 0x511
 5104094:	e3400512 	movt	r0, #1298	; 0x512
 5104098:	e12fff33 	blx	r3
            xReturn = 0;
 510409c:	e3a00000 	mov	r0, #0
}
 51040a0:	e28dd008 	add	sp, sp, #8
 51040a4:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxStreamBuffer );
 51040a8:	e30d0a94 	movw	r0, #55956	; 0xda94
 51040ac:	e3003900 	movw	r3, #2304	; 0x900
 51040b0:	e3001499 	movw	r1, #1177	; 0x499
 51040b4:	e3403511 	movt	r3, #1297	; 0x511
 51040b8:	e3400512 	movt	r0, #1298	; 0x512
 51040bc:	e12fff33 	blx	r3
 51040c0:	eaffffd7 	b	5104024 <xStreamBufferNextMessageLengthBytes+0x10>

051040c4 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 51040c4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 51040c8:	e30c4db8 	movw	r4, #52664	; 0xcdb8
    #if ( INCLUDE_xTaskAbortDelay == 1 )
    {
        /* About to enter a delayed list, so ensure the ucDelayAborted flag is
         * reset to pdFALSE so it can be detected as having been set to pdTRUE
         * when the task leaves the Blocked state. */
        pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
 51040cc:	e3a02000 	mov	r2, #0
{
 51040d0:	e1a06000 	mov	r6, r0
    const TickType_t xConstTickCount = xTickCount;
 51040d4:	e3404511 	movt	r4, #1297	; 0x511
{
 51040d8:	e1a05001 	mov	r5, r1
    const TickType_t xConstTickCount = xTickCount;
 51040dc:	e5947000 	ldr	r7, [r4]
    List_t * const pxDelayedList = pxDelayedTaskList;
 51040e0:	e5948004 	ldr	r8, [r4, #4]
    List_t * const pxOverflowDelayedList = pxOverflowDelayedTaskList;
 51040e4:	e5949008 	ldr	r9, [r4, #8]
        pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
 51040e8:	e594300c 	ldr	r3, [r4, #12]
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 51040ec:	e594000c 	ldr	r0, [r4, #12]
        pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
 51040f0:	e5c3239a 	strb	r2, [r3, #922]	; 0x39a
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 51040f4:	e3003cd8 	movw	r3, #3288	; 0xcd8
 51040f8:	e2800e35 	add	r0, r0, #848	; 0x350
 51040fc:	e3403510 	movt	r3, #1296	; 0x510
 5104100:	e12fff33 	blx	r3
 5104104:	e3500000 	cmp	r0, #0
 5104108:	1a000005 	bne	5104124 <prvAddCurrentTaskToDelayedList+0x60>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 510410c:	e594300c 	ldr	r3, [r4, #12]
 5104110:	e3a01001 	mov	r1, #1
 5104114:	e5932378 	ldr	r2, [r3, #888]	; 0x378
 5104118:	e5943010 	ldr	r3, [r4, #16]
 510411c:	e1c33211 	bic	r3, r3, r1, lsl r2
 5104120:	e5843010 	str	r3, [r4, #16]
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
    {
        if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 5104124:	e2555000 	subs	r5, r5, #0
 5104128:	13a05001 	movne	r5, #1
 510412c:	e3760001 	cmn	r6, #1
 5104130:	13a05000 	movne	r5, #0
 5104134:	e3550000 	cmp	r5, #0
 5104138:	0a000013 	beq	510418c <prvAddCurrentTaskToDelayedList+0xc8>
        {
            /* Add the task to the suspended task list instead of a delayed task
             * list to ensure it is not woken by a timing event.  It will block
             * indefinitely. */
            listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 510413c:	e5943018 	ldr	r3, [r4, #24]
 5104140:	e594000c 	ldr	r0, [r4, #12]
 5104144:	e5803354 	str	r3, [r0, #852]	; 0x354
 5104148:	e594200c 	ldr	r2, [r4, #12]
 510414c:	e5930008 	ldr	r0, [r3, #8]
 5104150:	e5820358 	str	r0, [r2, #856]	; 0x358
 5104154:	e594200c 	ldr	r2, [r4, #12]
 5104158:	e5930008 	ldr	r0, [r3, #8]
 510415c:	e5941014 	ldr	r1, [r4, #20]
 5104160:	e2822e35 	add	r2, r2, #848	; 0x350
 5104164:	e5802004 	str	r2, [r0, #4]
 5104168:	e2811001 	add	r1, r1, #1
 510416c:	e594200c 	ldr	r2, [r4, #12]
 5104170:	e59f0060 	ldr	r0, [pc, #96]	; 51041d8 <prvAddCurrentTaskToDelayedList+0x114>
 5104174:	e5841014 	str	r1, [r4, #20]
 5104178:	e2822e35 	add	r2, r2, #848	; 0x350
 510417c:	e594100c 	ldr	r1, [r4, #12]
 5104180:	e5832008 	str	r2, [r3, #8]
 5104184:	e5810360 	str	r0, [r1, #864]	; 0x360
 5104188:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
             * does not occur.  This may overflow but this doesn't matter, the
             * kernel will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 510418c:	e594300c 	ldr	r3, [r4, #12]
 5104190:	e0976006 	adds	r6, r7, r6
            if( xTimeToWake < xConstTickCount )
            {
                /* Wake time has overflowed.  Place this item in the overflow
                 * list. */
                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
 5104194:	e594100c 	ldr	r1, [r4, #12]
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 5104198:	e5836350 	str	r6, [r3, #848]	; 0x350
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
 510419c:	e3003c54 	movw	r3, #3156	; 0xc54
            if( xTimeToWake < xConstTickCount )
 51041a0:	3a000004 	bcc	51041b8 <prvAddCurrentTaskToDelayedList+0xf4>
                vListInsert( pxOverflowDelayedList, &( pxCurrentTCB->xStateListItem ) );
 51041a4:	e1a00009 	mov	r0, r9
 51041a8:	e3403510 	movt	r3, #1296	; 0x510
 51041ac:	e2811e35 	add	r1, r1, #848	; 0x350
 51041b0:	e12fff33 	blx	r3
 51041b4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            else
            {
                /* The wake time has not overflowed, so the current block list
                 * is used. */
                traceMOVED_TASK_TO_DELAYED_LIST();
                vListInsert( pxDelayedList, &( pxCurrentTCB->xStateListItem ) );
 51041b8:	e1a00008 	mov	r0, r8
 51041bc:	e3403510 	movt	r3, #1296	; 0x510
 51041c0:	e2811e35 	add	r1, r1, #848	; 0x350
 51041c4:	e12fff33 	blx	r3

                /* If the task entering the blocked state was placed at the
                 * head of the list of blocked tasks then xNextTaskUnblockTime
                 * needs to be updated too. */
                if( xTimeToWake < xNextTaskUnblockTime )
 51041c8:	e5943028 	ldr	r3, [r4, #40]	; 0x28
 51041cc:	e1530006 	cmp	r3, r6
                {
                    xNextTaskUnblockTime = xTimeToWake;
 51041d0:	85846028 	strhi	r6, [r4, #40]	; 0x28

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
 51041d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 51041d8:	0511cdcc 	.word	0x0511cdcc

051041dc <prvSearchForNameWithinSingleList>:
        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
 51041dc:	e5903000 	ldr	r3, [r0]
 51041e0:	e3530000 	cmp	r3, #0
 51041e4:	0a000018 	beq	510424c <prvSearchForNameWithinSingleList+0x70>
    {
 51041e8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            for( pxIterator = listGET_HEAD_ENTRY( pxList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
 51041ec:	e590400c 	ldr	r4, [r0, #12]
        const ListItem_t * pxEndMarker = listGET_END_MARKER( pxList );
 51041f0:	e2805008 	add	r5, r0, #8
            for( pxIterator = listGET_HEAD_ENTRY( pxList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
 51041f4:	e1550004 	cmp	r5, r4
 51041f8:	0a000011 	beq	5104244 <prvSearchForNameWithinSingleList+0x68>
 51041fc:	e300837f 	movw	r8, #895	; 0x37f
 5104200:	e2416001 	sub	r6, r1, #1
 5104204:	e3007389 	movw	r7, #905	; 0x389
                pxTCB = listGET_LIST_ITEM_OWNER( pxIterator );
 5104208:	e594000c 	ldr	r0, [r4, #12]
                for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 510420c:	e1a01006 	mov	r1, r6
 5104210:	e0803008 	add	r3, r0, r8
 5104214:	e080e007 	add	lr, r0, r7
                    cNextChar = pxTCB->pcTaskName[ x ];
 5104218:	e1f3c0d1 	ldrsb	ip, [r3, #1]!
                    if( cNextChar != pcNameToQuery[ x ] )
 510421c:	e1f120d1 	ldrsb	r2, [r1, #1]!
 5104220:	e152000c 	cmp	r2, ip
 5104224:	1a000003 	bne	5104238 <prvSearchForNameWithinSingleList+0x5c>
                    else if( cNextChar == ( char ) 0x00 )
 5104228:	e3520000 	cmp	r2, #0
 510422c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
                for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 5104230:	e153000e 	cmp	r3, lr
 5104234:	1afffff7 	bne	5104218 <prvSearchForNameWithinSingleList+0x3c>
            for( pxIterator = listGET_HEAD_ENTRY( pxList ); pxIterator != pxEndMarker; pxIterator = listGET_NEXT( pxIterator ) )
 5104238:	e5944004 	ldr	r4, [r4, #4]
 510423c:	e1550004 	cmp	r5, r4
 5104240:	1afffff0 	bne	5104208 <prvSearchForNameWithinSingleList+0x2c>
        TCB_t * pxReturn = NULL;
 5104244:	e3a00000 	mov	r0, #0
    }
 5104248:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        TCB_t * pxReturn = NULL;
 510424c:	e1a00003 	mov	r0, r3
    }
 5104250:	e12fff1e 	bx	lr

05104254 <prvInitialiseNewTask>:
{
 5104254:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5104258:	e24dd00c 	sub	sp, sp, #12
 510425c:	e1a09003 	mov	r9, r3
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) uxStackDepth * sizeof( StackType_t ) );
 5104260:	e1a06102 	lsl	r6, r2, #2
 5104264:	e3093cbb 	movw	r3, #40123	; 0x9cbb
{
 5104268:	e1a0a001 	mov	sl, r1
 510426c:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
 5104270:	e1a07002 	mov	r7, r2
 5104274:	e1a08000 	mov	r8, r0
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) uxStackDepth * sizeof( StackType_t ) );
 5104278:	e1a02006 	mov	r2, r6
 510427c:	e3a010a5 	mov	r1, #165	; 0xa5
 5104280:	e3403511 	movt	r3, #1297	; 0x511
 5104284:	e594037c 	ldr	r0, [r4, #892]	; 0x37c
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 5104288:	e2466004 	sub	r6, r6, #4
{
 510428c:	e59d5030 	ldr	r5, [sp, #48]	; 0x30
        ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) uxStackDepth * sizeof( StackType_t ) );
 5104290:	e12fff33 	blx	r3
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 5104294:	e594237c 	ldr	r2, [r4, #892]	; 0x37c
    if( pcName != NULL )
 5104298:	e35a0000 	cmp	sl, #0
        pxTopOfStack = &( pxNewTCB->pxStack[ uxStackDepth - ( configSTACK_DEPTH_TYPE ) 1 ] );
 510429c:	e0826006 	add	r6, r2, r6
        if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
 51042a0:	e1a0bfa5 	lsr	fp, r5, #31
        pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 51042a4:	e3c66007 	bic	r6, r6, #7
        uxPriority &= ~portPRIVILEGE_BIT;
 51042a8:	e3c55102 	bic	r5, r5, #-2147483648	; 0x80000000
    if( pcName != NULL )
 51042ac:	0a00000b 	beq	51042e0 <prvInitialiseNewTask+0x8c>
 51042b0:	e2840fdf 	add	r0, r4, #892	; 0x37c
 51042b4:	e2800003 	add	r0, r0, #3
 51042b8:	e24a3001 	sub	r3, sl, #1
 51042bc:	e28a1009 	add	r1, sl, #9
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 51042c0:	e1f320d1 	ldrsb	r2, [r3, #1]!
 51042c4:	e5e02001 	strb	r2, [r0, #1]!
            if( pcName[ x ] == ( char ) 0x00 )
 51042c8:	e3520000 	cmp	r2, #0
 51042cc:	0a000001 	beq	51042d8 <prvInitialiseNewTask+0x84>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 51042d0:	e1530001 	cmp	r3, r1
 51042d4:	1afffff9 	bne	51042c0 <prvInitialiseNewTask+0x6c>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1U ] = '\0';
 51042d8:	e3a03000 	mov	r3, #0
 51042dc:	e5c43389 	strb	r3, [r4, #905]	; 0x389
    configASSERT( uxPriority < configMAX_PRIORITIES );
 51042e0:	e3550006 	cmp	r5, #6
 51042e4:	8a000023 	bhi	5104378 <prvInitialiseNewTask+0x124>
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 51042e8:	e300ac48 	movw	sl, #3144	; 0xc48
 51042ec:	e3550006 	cmp	r5, #6
 51042f0:	23a05006 	movcs	r5, #6
 51042f4:	e340a510 	movt	sl, #1296	; 0x510
 51042f8:	e2840e35 	add	r0, r4, #848	; 0x350
    pxNewTCB->uxPriority = uxPriority;
 51042fc:	e5845378 	str	r5, [r4, #888]	; 0x378
        pxNewTCB->uxBasePriority = uxPriority;
 5104300:	e584538c 	str	r5, [r4, #908]	; 0x38c
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 5104304:	e2655007 	rsb	r5, r5, #7
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 5104308:	e12fff3a 	blx	sl
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 510430c:	e2840fd9 	add	r0, r4, #868	; 0x364
 5104310:	e12fff3a 	blx	sl
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority );
 5104314:	e5845364 	str	r5, [r4, #868]	; 0x364
        vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, uxStackDepth );
 5104318:	e1a03007 	mov	r3, r7
 510431c:	e2845004 	add	r5, r4, #4
 5104320:	e30c7620 	movw	r7, #50720	; 0xc620
 5104324:	e1a00005 	mov	r0, r5
 5104328:	e594237c 	ldr	r2, [r4, #892]	; 0x37c
 510432c:	e3407510 	movt	r7, #1296	; 0x510
 5104330:	e59d103c 	ldr	r1, [sp, #60]	; 0x3c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 5104334:	e584435c 	str	r4, [r4, #860]	; 0x35c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 5104338:	e5844370 	str	r4, [r4, #880]	; 0x370
        vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, uxStackDepth );
 510433c:	e12fff37 	blx	r7
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged, &( pxNewTCB->xMPUSettings ) );
 5104340:	e58d5000 	str	r5, [sp]
 5104344:	e30c53c0 	movw	r5, #50112	; 0xc3c0
 5104348:	e1a0300b 	mov	r3, fp
 510434c:	e1a02009 	mov	r2, r9
 5104350:	e1a01008 	mov	r1, r8
 5104354:	e1a00006 	mov	r0, r6
 5104358:	e3405510 	movt	r5, #1296	; 0x510
 510435c:	e12fff35 	blx	r5
    if( pxCreatedTask != NULL )
 5104360:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5104364:	e3530000 	cmp	r3, #0
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged, &( pxNewTCB->xMPUSettings ) );
 5104368:	e5840000 	str	r0, [r4]
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 510436c:	15834000 	strne	r4, [r3]
}
 5104370:	e28dd00c 	add	sp, sp, #12
 5104374:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    configASSERT( uxPriority < configMAX_PRIORITIES );
 5104378:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510437c:	e3003900 	movw	r3, #2304	; 0x900
 5104380:	e3001762 	movw	r1, #1890	; 0x762
 5104384:	e3403511 	movt	r3, #1297	; 0x511
 5104388:	e3400512 	movt	r0, #1298	; 0x512
 510438c:	e12fff33 	blx	r3
 5104390:	eaffffd4 	b	51042e8 <prvInitialiseNewTask+0x94>

05104394 <prvAddNewTaskToReadyList>:
    {
 5104394:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 5104398:	e30c4db8 	movw	r4, #52664	; 0xcdb8
        taskENTER_CRITICAL();
 510439c:	e30c3930 	movw	r3, #51504	; 0xc930
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 51043a0:	e3404511 	movt	r4, #1297	; 0x511
    {
 51043a4:	e1a05000 	mov	r5, r0
        taskENTER_CRITICAL();
 51043a8:	e3403510 	movt	r3, #1296	; 0x510
 51043ac:	e12fff33 	blx	r3
            uxCurrentNumberOfTasks = ( UBaseType_t ) ( uxCurrentNumberOfTasks + 1U );
 51043b0:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 51043b4:	e2833001 	add	r3, r3, #1
 51043b8:	e584302c 	str	r3, [r4, #44]	; 0x2c
            if( pxCurrentTCB == NULL )
 51043bc:	e594300c 	ldr	r3, [r4, #12]
 51043c0:	e3530000 	cmp	r3, #0
 51043c4:	0a000030 	beq	510448c <prvAddNewTaskToReadyList+0xf8>
                if( xSchedulerRunning == pdFALSE )
 51043c8:	e594310c 	ldr	r3, [r4, #268]	; 0x10c
 51043cc:	e3530000 	cmp	r3, #0
 51043d0:	0a000026 	beq	5104470 <prvAddNewTaskToReadyList+0xdc>
            prvAddTaskToReadyList( pxNewTCB );
 51043d4:	e5952378 	ldr	r2, [r5, #888]	; 0x378
 51043d8:	e2846030 	add	r6, r4, #48	; 0x30
            uxTaskNumber++;
 51043dc:	e5943110 	ldr	r3, [r4, #272]	; 0x110
            prvAddTaskToReadyList( pxNewTCB );
 51043e0:	e3a00001 	mov	r0, #1
 51043e4:	e5941010 	ldr	r1, [r4, #16]
            uxTaskNumber++;
 51043e8:	e2833001 	add	r3, r3, #1
 51043ec:	e5843110 	str	r3, [r4, #272]	; 0x110
            prvAddTaskToReadyList( pxNewTCB );
 51043f0:	e0823102 	add	r3, r2, r2, lsl #2
 51043f4:	e1812210 	orr	r2, r1, r0, lsl r2
 51043f8:	e0866103 	add	r6, r6, r3, lsl #2
 51043fc:	e5842010 	str	r2, [r4, #16]
 5104400:	e0843103 	add	r3, r4, r3, lsl #2
 5104404:	e5932034 	ldr	r2, [r3, #52]	; 0x34
 5104408:	e5930030 	ldr	r0, [r3, #48]	; 0x30
 510440c:	e5852354 	str	r2, [r5, #852]	; 0x354
 5104410:	e5921008 	ldr	r1, [r2, #8]
 5104414:	e2800001 	add	r0, r0, #1
 5104418:	e5851358 	str	r1, [r5, #856]	; 0x358
 510441c:	e2851e35 	add	r1, r5, #848	; 0x350
 5104420:	e592c008 	ldr	ip, [r2, #8]
 5104424:	e58c1004 	str	r1, [ip, #4]
 5104428:	e5821008 	str	r1, [r2, #8]
 510442c:	e5830030 	str	r0, [r3, #48]	; 0x30
        taskEXIT_CRITICAL();
 5104430:	e30c3988 	movw	r3, #51592	; 0xc988
            prvAddTaskToReadyList( pxNewTCB );
 5104434:	e5856360 	str	r6, [r5, #864]	; 0x360
        taskEXIT_CRITICAL();
 5104438:	e3403510 	movt	r3, #1296	; 0x510
 510443c:	e12fff33 	blx	r3
        if( xSchedulerRunning != pdFALSE )
 5104440:	e594310c 	ldr	r3, [r4, #268]	; 0x10c
 5104444:	e3530000 	cmp	r3, #0
 5104448:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
            taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxNewTCB );
 510444c:	e594200c 	ldr	r2, [r4, #12]
 5104450:	e5953378 	ldr	r3, [r5, #888]	; 0x378
 5104454:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5104458:	e1520003 	cmp	r2, r3
 510445c:	28bd87f0 	popcs	{r4, r5, r6, r7, r8, r9, sl, pc}
 5104460:	e3003000 	movw	r3, #0
 5104464:	e3403511 	movt	r3, #1297	; 0x511
 5104468:	e12fff33 	blx	r3
    }
 510446c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                    if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 5104470:	e594300c 	ldr	r3, [r4, #12]
 5104474:	e2846030 	add	r6, r4, #48	; 0x30
 5104478:	e5952378 	ldr	r2, [r5, #888]	; 0x378
 510447c:	e5933378 	ldr	r3, [r3, #888]	; 0x378
 5104480:	e1530002 	cmp	r3, r2
                        pxCurrentTCB = pxNewTCB;
 5104484:	9584500c 	strls	r5, [r4, #12]
 5104488:	eaffffd3 	b	51043dc <prvAddNewTaskToReadyList+0x48>
                pxCurrentTCB = pxNewTCB;
 510448c:	e584500c 	str	r5, [r4, #12]
                if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 5104490:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5104494:	e3530001 	cmp	r3, #1
 5104498:	1affffcd 	bne	51043d4 <prvAddNewTaskToReadyList+0x40>
 510449c:	e3008c28 	movw	r8, #3112	; 0xc28
 51044a0:	e2846030 	add	r6, r4, #48	; 0x30
 51044a4:	e1a07006 	mov	r7, r6
 51044a8:	e28490bc 	add	r9, r4, #188	; 0xbc
 51044ac:	e3408510 	movt	r8, #1296	; 0x510
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 51044b0:	e1a00007 	mov	r0, r7
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 51044b4:	e2877014 	add	r7, r7, #20
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 51044b8:	e12fff38 	blx	r8
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 51044bc:	e1590007 	cmp	r9, r7
 51044c0:	1afffffa 	bne	51044b0 <prvAddNewTaskToReadyList+0x11c>
    vListInitialise( &xDelayedTaskList2 );
 51044c4:	e59f7034 	ldr	r7, [pc, #52]	; 5104500 <prvAddNewTaskToReadyList+0x16c>
    vListInitialise( &xDelayedTaskList1 );
 51044c8:	e2470014 	sub	r0, r7, #20
 51044cc:	e12fff38 	blx	r8
    vListInitialise( &xDelayedTaskList2 );
 51044d0:	e1a00007 	mov	r0, r7
 51044d4:	e12fff38 	blx	r8
    vListInitialise( &xPendingReadyList );
 51044d8:	e2870014 	add	r0, r7, #20
 51044dc:	e12fff38 	blx	r8
        vListInitialise( &xTasksWaitingTermination );
 51044e0:	e2870028 	add	r0, r7, #40	; 0x28
 51044e4:	e12fff38 	blx	r8
        vListInitialise( &xSuspendedTaskList );
 51044e8:	e24700bc 	sub	r0, r7, #188	; 0xbc
 51044ec:	e12fff38 	blx	r8
    pxDelayedTaskList = &xDelayedTaskList1;
 51044f0:	e5849004 	str	r9, [r4, #4]
            prvAddTaskToReadyList( pxNewTCB );
 51044f4:	e5952378 	ldr	r2, [r5, #888]	; 0x378
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 51044f8:	e5847008 	str	r7, [r4, #8]
}
 51044fc:	eaffffb6 	b	51043dc <prvAddNewTaskToReadyList+0x48>
 5104500:	0511ce88 	.word	0x0511ce88

05104504 <prvCheckTasksWaitingTermination>:
{
 5104504:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 5104508:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 510450c:	e3404511 	movt	r4, #1297	; 0x511
 5104510:	e5943114 	ldr	r3, [r4, #276]	; 0x114
 5104514:	e3530000 	cmp	r3, #0
 5104518:	08bd8ff8 	popeq	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 510451c:	e30c7930 	movw	r7, #51504	; 0xc930
 5104520:	e3006cd8 	movw	r6, #3288	; 0xcd8
 5104524:	e30c5988 	movw	r5, #51592	; 0xc988
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 5104528:	e30d9abc 	movw	r9, #55996	; 0xdabc
 510452c:	e300a900 	movw	sl, #2304	; 0x900
                vPortFree( pxTCB );
 5104530:	e308833c 	movw	r8, #33596	; 0x833c
 5104534:	e3407510 	movt	r7, #1296	; 0x510
 5104538:	e3406510 	movt	r6, #1296	; 0x510
 510453c:	e3405510 	movt	r5, #1296	; 0x510
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 5104540:	e3409512 	movt	r9, #1298	; 0x512
 5104544:	e340a511 	movt	sl, #1297	; 0x511
                vPortFree( pxTCB );
 5104548:	e3408510 	movt	r8, #1296	; 0x510
 510454c:	ea000009 	b	5104578 <prvCheckTasksWaitingTermination+0x74>
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 5104550:	e3530001 	cmp	r3, #1
 5104554:	0a00001b 	beq	51045c8 <prvCheckTasksWaitingTermination+0xc4>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 5104558:	e301192e 	movw	r1, #6446	; 0x192e
 510455c:	e3530002 	cmp	r3, #2
 5104560:	e1a00009 	mov	r0, r9
 5104564:	0a000000 	beq	510456c <prvCheckTasksWaitingTermination+0x68>
 5104568:	e12fff3a 	blx	sl
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 510456c:	e5943114 	ldr	r3, [r4, #276]	; 0x114
 5104570:	e3530000 	cmp	r3, #0
 5104574:	08bd8ff8 	popeq	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                taskENTER_CRITICAL();
 5104578:	e12fff37 	blx	r7
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 510457c:	e5943104 	ldr	r3, [r4, #260]	; 0x104
 5104580:	e593b00c 	ldr	fp, [r3, #12]
                        ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5104584:	e28b0e35 	add	r0, fp, #848	; 0x350
 5104588:	e12fff36 	blx	r6
                        --uxCurrentNumberOfTasks;
 510458c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5104590:	e2433001 	sub	r3, r3, #1
 5104594:	e584302c 	str	r3, [r4, #44]	; 0x2c
                        --uxDeletedTasksWaitingCleanUp;
 5104598:	e5943114 	ldr	r3, [r4, #276]	; 0x114
 510459c:	e2433001 	sub	r3, r3, #1
 51045a0:	e5843114 	str	r3, [r4, #276]	; 0x114
                taskEXIT_CRITICAL();
 51045a4:	e12fff35 	blx	r5
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 51045a8:	e5db3399 	ldrb	r3, [fp, #921]	; 0x399
 51045ac:	e3530000 	cmp	r3, #0
 51045b0:	1affffe6 	bne	5104550 <prvCheckTasksWaitingTermination+0x4c>
                vPortFreeStack( pxTCB->pxStack );
 51045b4:	e59b037c 	ldr	r0, [fp, #892]	; 0x37c
 51045b8:	e12fff38 	blx	r8
                vPortFree( pxTCB );
 51045bc:	e1a0000b 	mov	r0, fp
 51045c0:	e12fff38 	blx	r8
 51045c4:	eaffffe8 	b	510456c <prvCheckTasksWaitingTermination+0x68>
                vPortFree( pxTCB );
 51045c8:	e1a0000b 	mov	r0, fp
 51045cc:	e12fff38 	blx	r8
 51045d0:	eaffffe5 	b	510456c <prvCheckTasksWaitingTermination+0x68>

051045d4 <prvIdleTask>:
{
 51045d4:	e92d4010 	push	{r4, lr}
 51045d8:	e3004890 	movw	r4, #2192	; 0x890
 51045dc:	e3404511 	movt	r4, #1297	; 0x511
        prvCheckTasksWaitingTermination();
 51045e0:	ebffffc7 	bl	5104504 <prvCheckTasksWaitingTermination>
            vApplicationIdleHook();
 51045e4:	e12fff34 	blx	r4
    for( ; configCONTROL_INFINITE_LOOP(); )
 51045e8:	eafffffc 	b	51045e0 <prvIdleTask+0xc>

051045ec <xTaskCreate>:
    {
 51045ec:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 51045f0:	e3074f74 	movw	r4, #32628	; 0x7f74
    {
 51045f4:	e24dd014 	sub	sp, sp, #20
 51045f8:	e1a06000 	mov	r6, r0
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 51045fc:	e3404510 	movt	r4, #1296	; 0x510
    {
 5104600:	e1a05002 	mov	r5, r2
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 5104604:	e1a00102 	lsl	r0, r2, #2
    {
 5104608:	e1a07001 	mov	r7, r1
 510460c:	e1a08003 	mov	r8, r3
            pxStack = pvPortMallocStack( ( ( ( size_t ) uxStackDepth ) * sizeof( StackType_t ) ) );
 5104610:	e12fff34 	blx	r4
            if( pxStack != NULL )
 5104614:	e2509000 	subs	r9, r0, #0
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 5104618:	03e00000 	mvneq	r0, #0
            if( pxStack != NULL )
 510461c:	0a000018 	beq	5104684 <xTaskCreate+0x98>
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 5104620:	e3a00fe7 	mov	r0, #924	; 0x39c
 5104624:	e12fff34 	blx	r4
                if( pxNewTCB != NULL )
 5104628:	e2504000 	subs	r4, r0, #0
 510462c:	0a000016 	beq	510468c <xTaskCreate+0xa0>
                    ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 5104630:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5104634:	e3a02fe7 	mov	r2, #924	; 0x39c
 5104638:	e3a01000 	mov	r1, #0
 510463c:	e3403511 	movt	r3, #1297	; 0x511
 5104640:	e12fff33 	blx	r3
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 5104644:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
                    pxNewTCB->pxStack = pxStack;
 5104648:	e584937c 	str	r9, [r4, #892]	; 0x37c
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 510464c:	e1a03008 	mov	r3, r8
 5104650:	e58dc004 	str	ip, [sp, #4]
 5104654:	e1a02005 	mov	r2, r5
 5104658:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
 510465c:	e1a01007 	mov	r1, r7
 5104660:	e58dc000 	str	ip, [sp]
 5104664:	e3a0c000 	mov	ip, #0
 5104668:	e58d4008 	str	r4, [sp, #8]
 510466c:	e1a00006 	mov	r0, r6
 5104670:	e58dc00c 	str	ip, [sp, #12]
 5104674:	ebfffef6 	bl	5104254 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 5104678:	e1a00004 	mov	r0, r4
 510467c:	ebffff44 	bl	5104394 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 5104680:	e3a00001 	mov	r0, #1
    }
 5104684:	e28dd014 	add	sp, sp, #20
 5104688:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
                    vPortFreeStack( pxStack );
 510468c:	e308333c 	movw	r3, #33596	; 0x833c
 5104690:	e1a00009 	mov	r0, r9
 5104694:	e3403510 	movt	r3, #1296	; 0x510
 5104698:	e12fff33 	blx	r3
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 510469c:	e3e00000 	mvn	r0, #0
    }
 51046a0:	e28dd014 	add	sp, sp, #20
 51046a4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

051046a8 <xTaskCreateStatic>:
    {
 51046a8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 51046ac:	e1a08003 	mov	r8, r3
 51046b0:	e24dd018 	sub	sp, sp, #24
        TaskHandle_t xReturn = NULL;
 51046b4:	e3a03000 	mov	r3, #0
    {
 51046b8:	e1a05000 	mov	r5, r0
 51046bc:	e1a06001 	mov	r6, r1
 51046c0:	e1a07002 	mov	r7, r2
 51046c4:	e59d903c 	ldr	r9, [sp, #60]	; 0x3c
 51046c8:	e59d4040 	ldr	r4, [sp, #64]	; 0x40
        TaskHandle_t xReturn = NULL;
 51046cc:	e58d3010 	str	r3, [sp, #16]
        configASSERT( puxStackBuffer != NULL );
 51046d0:	e3590000 	cmp	r9, #0
 51046d4:	0a00003f 	beq	51047d8 <xTaskCreateStatic+0x130>
        configASSERT( pxTaskBuffer != NULL );
 51046d8:	e3540000 	cmp	r4, #0
 51046dc:	0a000030 	beq	51047a4 <xTaskCreateStatic+0xfc>
            volatile size_t xSize = sizeof( StaticTask_t );
 51046e0:	e3a03fe7 	mov	r3, #924	; 0x39c
 51046e4:	e58d3014 	str	r3, [sp, #20]
            configASSERT( xSize == sizeof( TCB_t ) );
 51046e8:	e59d3014 	ldr	r3, [sp, #20]
 51046ec:	e3530fe7 	cmp	r3, #924	; 0x39c
 51046f0:	1300a900 	movwne	sl, #2304	; 0x900
 51046f4:	1340a511 	movtne	sl, #1297	; 0x511
 51046f8:	1a000020 	bne	5104780 <xTaskCreateStatic+0xd8>
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 51046fc:	e3540000 	cmp	r4, #0
 5104700:	13590000 	cmpne	r9, #0
            ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not used. */
 5104704:	e59d3014 	ldr	r3, [sp, #20]
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 5104708:	1a000002 	bne	5104718 <xTaskCreateStatic+0x70>
        return xReturn;
 510470c:	e59d0010 	ldr	r0, [sp, #16]
    }
 5104710:	e28dd018 	add	sp, sp, #24
 5104714:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 5104718:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 510471c:	e3a02fe7 	mov	r2, #924	; 0x39c
 5104720:	e3a01000 	mov	r1, #0
 5104724:	e3403511 	movt	r3, #1297	; 0x511
 5104728:	e1a00004 	mov	r0, r4
 510472c:	e12fff33 	blx	r3
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 5104730:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 5104734:	e584937c 	str	r9, [r4, #892]	; 0x37c
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 5104738:	e1a03008 	mov	r3, r8
 510473c:	e58dc000 	str	ip, [sp]
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 5104740:	e3a0c002 	mov	ip, #2
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 5104744:	e58d4008 	str	r4, [sp, #8]
 5104748:	e1a02007 	mov	r2, r7
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 510474c:	e5c4c399 	strb	ip, [r4, #921]	; 0x399
            prvInitialiseNewTask( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 5104750:	e3a0c000 	mov	ip, #0
 5104754:	e1a01006 	mov	r1, r6
 5104758:	e1a00005 	mov	r0, r5
 510475c:	e58dc00c 	str	ip, [sp, #12]
 5104760:	e28dc010 	add	ip, sp, #16
 5104764:	e58dc004 	str	ip, [sp, #4]
 5104768:	ebfffeb9 	bl	5104254 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 510476c:	e1a00004 	mov	r0, r4
 5104770:	ebffff07 	bl	5104394 <prvAddNewTaskToReadyList>
        return xReturn;
 5104774:	e59d0010 	ldr	r0, [sp, #16]
    }
 5104778:	e28dd018 	add	sp, sp, #24
 510477c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            configASSERT( xSize == sizeof( TCB_t ) );
 5104780:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104784:	e30014fa 	movw	r1, #1274	; 0x4fa
 5104788:	e3400512 	movt	r0, #1298	; 0x512
 510478c:	e12fff3a 	blx	sl
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 5104790:	e3540000 	cmp	r4, #0
 5104794:	13590000 	cmpne	r9, #0
            ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not used. */
 5104798:	e59d3014 	ldr	r3, [sp, #20]
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 510479c:	0affffda 	beq	510470c <xTaskCreateStatic+0x64>
 51047a0:	eaffffdc 	b	5104718 <xTaskCreateStatic+0x70>
        configASSERT( pxTaskBuffer != NULL );
 51047a4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51047a8:	e300a900 	movw	sl, #2304	; 0x900
 51047ac:	e3400512 	movt	r0, #1298	; 0x512
 51047b0:	e30014f2 	movw	r1, #1266	; 0x4f2
 51047b4:	e340a511 	movt	sl, #1297	; 0x511
 51047b8:	e12fff3a 	blx	sl
            volatile size_t xSize = sizeof( StaticTask_t );
 51047bc:	e3a03fe7 	mov	r3, #924	; 0x39c
 51047c0:	e58d3014 	str	r3, [sp, #20]
            configASSERT( xSize == sizeof( TCB_t ) );
 51047c4:	e59d3014 	ldr	r3, [sp, #20]
 51047c8:	e3530fe7 	cmp	r3, #924	; 0x39c
 51047cc:	1affffeb 	bne	5104780 <xTaskCreateStatic+0xd8>
            ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not used. */
 51047d0:	e59d3014 	ldr	r3, [sp, #20]
        if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 51047d4:	eaffffcc 	b	510470c <xTaskCreateStatic+0x64>
        configASSERT( puxStackBuffer != NULL );
 51047d8:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51047dc:	e300a900 	movw	sl, #2304	; 0x900
 51047e0:	e30014f1 	movw	r1, #1265	; 0x4f1
 51047e4:	e340a511 	movt	sl, #1297	; 0x511
 51047e8:	e3400512 	movt	r0, #1298	; 0x512
 51047ec:	e12fff3a 	blx	sl
 51047f0:	eaffffb8 	b	51046d8 <xTaskCreateStatic+0x30>

051047f4 <xTaskCreateRestricted>:
        configASSERT( pxTaskDefinition->puxStackBuffer );
 51047f4:	e5903014 	ldr	r3, [r0, #20]
    {
 51047f8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 51047fc:	e1a04000 	mov	r4, r0
        configASSERT( pxTaskDefinition->puxStackBuffer );
 5104800:	e3530000 	cmp	r3, #0
    {
 5104804:	e1a07001 	mov	r7, r1
 5104808:	e24dd014 	sub	sp, sp, #20
        configASSERT( pxTaskDefinition->puxStackBuffer );
 510480c:	0a00001d 	beq	5104888 <xTaskCreateRestricted+0x94>
            pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 5104810:	e3073f74 	movw	r3, #32628	; 0x7f74
 5104814:	e3a00fe7 	mov	r0, #924	; 0x39c
 5104818:	e3403510 	movt	r3, #1296	; 0x510
 510481c:	e12fff33 	blx	r3
            if( pxNewTCB != NULL )
 5104820:	e2505000 	subs	r5, r0, #0
 5104824:	0a000020 	beq	51048ac <xTaskCreateRestricted+0xb8>
                ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 5104828:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 510482c:	e3a02fe7 	mov	r2, #924	; 0x39c
 5104830:	e3a01000 	mov	r1, #0
 5104834:	e3403511 	movt	r3, #1297	; 0x511
 5104838:	e12fff33 	blx	r3
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 510483c:	e3a06001 	mov	r6, #1
                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 5104840:	e5943014 	ldr	r3, [r4, #20]
                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 5104844:	e1a02004 	mov	r2, r4
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_ONLY;
 5104848:	e5c56399 	strb	r6, [r5, #921]	; 0x399
                pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 510484c:	e585337c 	str	r3, [r5, #892]	; 0x37c
                prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 5104850:	e58d7004 	str	r7, [sp, #4]
 5104854:	e5943010 	ldr	r3, [r4, #16]
 5104858:	e58d3000 	str	r3, [sp]
 510485c:	e58d5008 	str	r5, [sp, #8]
 5104860:	e4920018 	ldr	r0, [r2], #24
 5104864:	e594300c 	ldr	r3, [r4, #12]
 5104868:	e58d200c 	str	r2, [sp, #12]
 510486c:	e9940006 	ldmib	r4, {r1, r2}
 5104870:	ebfffe77 	bl	5104254 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 5104874:	e1a00005 	mov	r0, r5
 5104878:	ebfffec5 	bl	5104394 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 510487c:	e1a00006 	mov	r0, r6
    }
 5104880:	e28dd014 	add	sp, sp, #20
 5104884:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxTaskDefinition->puxStackBuffer );
 5104888:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510488c:	e3003900 	movw	r3, #2304	; 0x900
 5104890:	e30015e1 	movw	r1, #1505	; 0x5e1
 5104894:	e3403511 	movt	r3, #1297	; 0x511
 5104898:	e3400512 	movt	r0, #1298	; 0x512
 510489c:	e12fff33 	blx	r3
        if( pxTaskDefinition->puxStackBuffer != NULL )
 51048a0:	e5943014 	ldr	r3, [r4, #20]
 51048a4:	e3530000 	cmp	r3, #0
 51048a8:	1affffd8 	bne	5104810 <xTaskCreateRestricted+0x1c>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 51048ac:	e3e00000 	mvn	r0, #0
    }
 51048b0:	e28dd014 	add	sp, sp, #20
 51048b4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

051048b8 <xTaskCreateRestrictedStatic>:
    {
 51048b8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 51048bc:	e1a07001 	mov	r7, r1
        configASSERT( pxTaskDefinition != NULL );
 51048c0:	e2504000 	subs	r4, r0, #0
    {
 51048c4:	e24dd014 	sub	sp, sp, #20
        configASSERT( pxTaskDefinition != NULL );
 51048c8:	0a00001f 	beq	510494c <xTaskCreateRestrictedStatic+0x94>
        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 51048cc:	e5943014 	ldr	r3, [r4, #20]
 51048d0:	e3530000 	cmp	r3, #0
 51048d4:	0a000025 	beq	5104970 <xTaskCreateRestrictedStatic+0xb8>
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 51048d8:	e5945078 	ldr	r5, [r4, #120]	; 0x78
 51048dc:	e3550000 	cmp	r5, #0
 51048e0:	03006900 	movweq	r6, #2304	; 0x900
 51048e4:	03406511 	movteq	r6, #1297	; 0x511
 51048e8:	0a00002f 	beq	51049ac <xTaskCreateRestrictedStatic+0xf4>
            ( void ) memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
 51048ec:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 51048f0:	e3a02fe7 	mov	r2, #924	; 0x39c
 51048f4:	e3a01000 	mov	r1, #0
 51048f8:	e3403511 	movt	r3, #1297	; 0x511
 51048fc:	e1a00005 	mov	r0, r5
 5104900:	e12fff33 	blx	r3
            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 5104904:	e1a03004 	mov	r3, r4
            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 5104908:	e5941014 	ldr	r1, [r4, #20]
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 510490c:	e3a02002 	mov	r2, #2
            pxNewTCB->pxStack = pxTaskDefinition->puxStackBuffer;
 5104910:	e585137c 	str	r1, [r5, #892]	; 0x37c
                pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 5104914:	e5c52399 	strb	r2, [r5, #921]	; 0x399
            prvInitialiseNewTask( pxTaskDefinition->pvTaskCode,
 5104918:	e4930018 	ldr	r0, [r3], #24
 510491c:	e58d300c 	str	r3, [sp, #12]
 5104920:	e5943010 	ldr	r3, [r4, #16]
 5104924:	e88d0088 	stm	sp, {r3, r7}
 5104928:	e58d5008 	str	r5, [sp, #8]
 510492c:	e1c420d8 	ldrd	r2, [r4, #8]
 5104930:	e5941004 	ldr	r1, [r4, #4]
 5104934:	ebfffe46 	bl	5104254 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 5104938:	e1a00005 	mov	r0, r5
 510493c:	ebfffe94 	bl	5104394 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 5104940:	e3a00001 	mov	r0, #1
    }
 5104944:	e28dd014 	add	sp, sp, #20
 5104948:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxTaskDefinition != NULL );
 510494c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104950:	e3006900 	movw	r6, #2304	; 0x900
 5104954:	e300159d 	movw	r1, #1437	; 0x59d
 5104958:	e3400512 	movt	r0, #1298	; 0x512
 510495c:	e3406511 	movt	r6, #1297	; 0x511
 5104960:	e12fff36 	blx	r6
        configASSERT( pxTaskDefinition->puxStackBuffer != NULL );
 5104964:	e5943014 	ldr	r3, [r4, #20]
 5104968:	e3530000 	cmp	r3, #0
 510496c:	1affffd9 	bne	51048d8 <xTaskCreateRestrictedStatic+0x20>
 5104970:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104974:	e3006900 	movw	r6, #2304	; 0x900
 5104978:	e300156e 	movw	r1, #1390	; 0x56e
 510497c:	e3400512 	movt	r0, #1298	; 0x512
 5104980:	e3406511 	movt	r6, #1297	; 0x511
 5104984:	e12fff36 	blx	r6
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 5104988:	e5945078 	ldr	r5, [r4, #120]	; 0x78
 510498c:	e3550000 	cmp	r5, #0
 5104990:	0a000005 	beq	51049ac <xTaskCreateRestrictedStatic+0xf4>
        if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 5104994:	e5943014 	ldr	r3, [r4, #20]
 5104998:	e3530000 	cmp	r3, #0
 510499c:	1affffd2 	bne	51048ec <xTaskCreateRestrictedStatic+0x34>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 51049a0:	e3e00000 	mvn	r0, #0
    }
 51049a4:	e28dd014 	add	sp, sp, #20
 51049a8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( pxTaskDefinition->pxTaskBuffer != NULL );
 51049ac:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51049b0:	e300156f 	movw	r1, #1391	; 0x56f
 51049b4:	e3400512 	movt	r0, #1298	; 0x512
 51049b8:	e12fff36 	blx	r6
        if( ( pxTaskDefinition->puxStackBuffer != NULL ) && ( pxTaskDefinition->pxTaskBuffer != NULL ) )
 51049bc:	e5943014 	ldr	r3, [r4, #20]
 51049c0:	e3530000 	cmp	r3, #0
 51049c4:	0afffff5 	beq	51049a0 <xTaskCreateRestrictedStatic+0xe8>
 51049c8:	e5945078 	ldr	r5, [r4, #120]	; 0x78
 51049cc:	e3550000 	cmp	r5, #0
 51049d0:	0afffff2 	beq	51049a0 <xTaskCreateRestrictedStatic+0xe8>
 51049d4:	eaffffc4 	b	51048ec <xTaskCreateRestrictedStatic+0x34>

051049d8 <vTaskAllocateMPURegions>:
        pxTCB = prvGetTCBFromHandle( xTaskToModify );
 51049d8:	e3500000 	cmp	r0, #0
 51049dc:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 51049e0:	03403511 	movteq	r3, #1297	; 0x511
    {
 51049e4:	e92d4010 	push	{r4, lr}
        pxTCB = prvGetTCBFromHandle( xTaskToModify );
 51049e8:	0593000c 	ldreq	r0, [r3, #12]
        vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), pxRegions, NULL, 0 );
 51049ec:	e30c4620 	movw	r4, #50720	; 0xc620
 51049f0:	e3a03000 	mov	r3, #0
 51049f4:	e3404510 	movt	r4, #1296	; 0x510
 51049f8:	e1a02003 	mov	r2, r3
 51049fc:	e2800004 	add	r0, r0, #4
 5104a00:	e12fff34 	blx	r4
    }
 5104a04:	e8bd8010 	pop	{r4, pc}

05104a08 <vTaskDelete>:
        taskENTER_CRITICAL();
 5104a08:	e30c3930 	movw	r3, #51504	; 0xc930
    {
 5104a0c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5104a10:	e1a05000 	mov	r5, r0
        taskENTER_CRITICAL();
 5104a14:	e3403510 	movt	r3, #1296	; 0x510
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 5104a18:	e30c4db8 	movw	r4, #52664	; 0xcdb8
        taskENTER_CRITICAL();
 5104a1c:	e12fff33 	blx	r3
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 5104a20:	e3404511 	movt	r4, #1297	; 0x511
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5104a24:	e3006cd8 	movw	r6, #3288	; 0xcd8
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 5104a28:	e3550000 	cmp	r5, #0
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5104a2c:	e3406510 	movt	r6, #1296	; 0x510
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
 5104a30:	0594500c 	ldreq	r5, [r4, #12]
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5104a34:	e2857e35 	add	r7, r5, #848	; 0x350
 5104a38:	e1a00007 	mov	r0, r7
 5104a3c:	e12fff36 	blx	r6
 5104a40:	e3500000 	cmp	r0, #0
 5104a44:	1a000008 	bne	5104a6c <vTaskDelete+0x64>
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 5104a48:	e5952378 	ldr	r2, [r5, #888]	; 0x378
 5104a4c:	e0823102 	add	r3, r2, r2, lsl #2
 5104a50:	e0843103 	add	r3, r4, r3, lsl #2
 5104a54:	e5933030 	ldr	r3, [r3, #48]	; 0x30
 5104a58:	e3530000 	cmp	r3, #0
 5104a5c:	03a01001 	moveq	r1, #1
 5104a60:	05943010 	ldreq	r3, [r4, #16]
 5104a64:	01c32211 	biceq	r2, r3, r1, lsl r2
 5104a68:	05842010 	streq	r2, [r4, #16]
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5104a6c:	e5953374 	ldr	r3, [r5, #884]	; 0x374
 5104a70:	e3530000 	cmp	r3, #0
 5104a74:	0a000001 	beq	5104a80 <vTaskDelete+0x78>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 5104a78:	e2850fd9 	add	r0, r5, #868	; 0x364
 5104a7c:	e12fff36 	blx	r6
            uxTaskNumber++;
 5104a80:	e5943110 	ldr	r3, [r4, #272]	; 0x110
            xTaskIsRunningOrYielding = taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB );
 5104a84:	e594200c 	ldr	r2, [r4, #12]
            uxTaskNumber++;
 5104a88:	e2833001 	add	r3, r3, #1
            xTaskIsRunningOrYielding = taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB );
 5104a8c:	e1520005 	cmp	r2, r5
            uxTaskNumber++;
 5104a90:	e5843110 	str	r3, [r4, #272]	; 0x110
            if( ( xSchedulerRunning != pdFALSE ) && ( xTaskIsRunningOrYielding != pdFALSE ) )
 5104a94:	e594310c 	ldr	r3, [r4, #268]	; 0x10c
            xTaskIsRunningOrYielding = taskTASK_IS_RUNNING_OR_SCHEDULED_TO_YIELD( pxTCB );
 5104a98:	0a000027 	beq	5104b3c <vTaskDelete+0x134>
                --uxCurrentNumberOfTasks;
 5104a9c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5104aa0:	e2433001 	sub	r3, r3, #1
 5104aa4:	e584302c 	str	r3, [r4, #44]	; 0x2c
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5104aa8:	e5943004 	ldr	r3, [r4, #4]
 5104aac:	e5933000 	ldr	r3, [r3]
 5104ab0:	e3530000 	cmp	r3, #0
        xNextTaskUnblockTime = portMAX_DELAY;
 5104ab4:	03e03000 	mvneq	r3, #0
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 5104ab8:	15943004 	ldrne	r3, [r4, #4]
 5104abc:	1593300c 	ldrne	r3, [r3, #12]
 5104ac0:	15933000 	ldrne	r3, [r3]
 5104ac4:	e5843028 	str	r3, [r4, #40]	; 0x28
        taskEXIT_CRITICAL();
 5104ac8:	e30c3988 	movw	r3, #51592	; 0xc988
 5104acc:	e3403510 	movt	r3, #1296	; 0x510
 5104ad0:	e12fff33 	blx	r3
            if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 5104ad4:	e5d53399 	ldrb	r3, [r5, #921]	; 0x399
 5104ad8:	e3530000 	cmp	r3, #0
 5104adc:	0a000024 	beq	5104b74 <vTaskDelete+0x16c>
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 5104ae0:	e3530001 	cmp	r3, #1
 5104ae4:	0a000029 	beq	5104b90 <vTaskDelete+0x188>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 5104ae8:	e3530002 	cmp	r3, #2
 5104aec:	0a000005 	beq	5104b08 <vTaskDelete+0x100>
 5104af0:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104af4:	e3003900 	movw	r3, #2304	; 0x900
 5104af8:	e301192e 	movw	r1, #6446	; 0x192e
 5104afc:	e3400512 	movt	r0, #1298	; 0x512
 5104b00:	e3403511 	movt	r3, #1297	; 0x511
 5104b04:	e12fff33 	blx	r3
            if( xSchedulerRunning != pdFALSE )
 5104b08:	e594310c 	ldr	r3, [r4, #268]	; 0x10c
 5104b0c:	e3530000 	cmp	r3, #0
 5104b10:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
                if( pxTCB == pxCurrentTCB )
 5104b14:	e594300c 	ldr	r3, [r4, #12]
 5104b18:	e1530005 	cmp	r3, r5
 5104b1c:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                    configASSERT( uxSchedulerSuspended == 0 );
 5104b20:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5104b24:	e3530000 	cmp	r3, #0
 5104b28:	1a00001d 	bne	5104ba4 <vTaskDelete+0x19c>
                    taskYIELD_WITHIN_API();
 5104b2c:	e3003000 	movw	r3, #0
 5104b30:	e3403511 	movt	r3, #1297	; 0x511
 5104b34:	e12fff33 	blx	r3
    }
 5104b38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            if( ( xSchedulerRunning != pdFALSE ) && ( xTaskIsRunningOrYielding != pdFALSE ) )
 5104b3c:	e3530000 	cmp	r3, #0
 5104b40:	0affffd5 	beq	5104a9c <vTaskDelete+0x94>
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
 5104b44:	e3003cac 	movw	r3, #3244	; 0xcac
 5104b48:	e1a01007 	mov	r1, r7
 5104b4c:	e59f006c 	ldr	r0, [pc, #108]	; 5104bc0 <vTaskDelete+0x1b8>
 5104b50:	e3403510 	movt	r3, #1296	; 0x510
 5104b54:	e12fff33 	blx	r3
                ++uxDeletedTasksWaitingCleanUp;
 5104b58:	e5942114 	ldr	r2, [r4, #276]	; 0x114
        taskEXIT_CRITICAL();
 5104b5c:	e30c3988 	movw	r3, #51592	; 0xc988
                ++uxDeletedTasksWaitingCleanUp;
 5104b60:	e2822001 	add	r2, r2, #1
        taskEXIT_CRITICAL();
 5104b64:	e3403510 	movt	r3, #1296	; 0x510
                ++uxDeletedTasksWaitingCleanUp;
 5104b68:	e5842114 	str	r2, [r4, #276]	; 0x114
        taskEXIT_CRITICAL();
 5104b6c:	e12fff33 	blx	r3
        if( xDeleteTCBInIdleTask != pdTRUE )
 5104b70:	eaffffe4 	b	5104b08 <vTaskDelete+0x100>
                vPortFreeStack( pxTCB->pxStack );
 5104b74:	e595037c 	ldr	r0, [r5, #892]	; 0x37c
 5104b78:	e308633c 	movw	r6, #33596	; 0x833c
 5104b7c:	e3406510 	movt	r6, #1296	; 0x510
 5104b80:	e12fff36 	blx	r6
                vPortFree( pxTCB );
 5104b84:	e1a00005 	mov	r0, r5
 5104b88:	e12fff36 	blx	r6
 5104b8c:	eaffffdd 	b	5104b08 <vTaskDelete+0x100>
                vPortFree( pxTCB );
 5104b90:	e308333c 	movw	r3, #33596	; 0x833c
 5104b94:	e1a00005 	mov	r0, r5
 5104b98:	e3403510 	movt	r3, #1296	; 0x510
 5104b9c:	e12fff33 	blx	r3
 5104ba0:	eaffffd8 	b	5104b08 <vTaskDelete+0x100>
                    configASSERT( uxSchedulerSuspended == 0 );
 5104ba4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104ba8:	e3003900 	movw	r3, #2304	; 0x900
 5104bac:	e3001912 	movw	r1, #2322	; 0x912
 5104bb0:	e3403511 	movt	r3, #1297	; 0x511
 5104bb4:	e3400512 	movt	r0, #1298	; 0x512
 5104bb8:	e12fff33 	blx	r3
 5104bbc:	eaffffda 	b	5104b2c <vTaskDelete+0x124>
 5104bc0:	0511ceb0 	.word	0x0511ceb0

05104bc4 <uxTaskPriorityGet>:
        taskENTER_CRITICAL();
 5104bc4:	e30c3930 	movw	r3, #51504	; 0xc930
    {
 5104bc8:	e92d4010 	push	{r4, lr}
        taskENTER_CRITICAL();
 5104bcc:	e3403510 	movt	r3, #1296	; 0x510
    {
 5104bd0:	e1a04000 	mov	r4, r0
 5104bd4:	e24dd008 	sub	sp, sp, #8
        taskENTER_CRITICAL();
 5104bd8:	e12fff33 	blx	r3
            pxTCB = prvGetTCBFromHandle( xTask );
 5104bdc:	e3540000 	cmp	r4, #0
 5104be0:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5104be4:	03403511 	movteq	r3, #1297	; 0x511
 5104be8:	0593400c 	ldreq	r4, [r3, #12]
        taskEXIT_CRITICAL();
 5104bec:	e30c3988 	movw	r3, #51592	; 0xc988
 5104bf0:	e3403510 	movt	r3, #1296	; 0x510
            uxReturn = pxTCB->uxPriority;
 5104bf4:	e5940378 	ldr	r0, [r4, #888]	; 0x378
 5104bf8:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5104bfc:	e12fff33 	blx	r3
    }
 5104c00:	e59d0004 	ldr	r0, [sp, #4]
 5104c04:	e28dd008 	add	sp, sp, #8
 5104c08:	e8bd8010 	pop	{r4, pc}

05104c0c <uxTaskPriorityGetFromISR>:
            pxTCB = prvGetTCBFromHandle( xTask );
 5104c0c:	e3500000 	cmp	r0, #0
 5104c10:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5104c14:	03403511 	movteq	r3, #1297	; 0x511
 5104c18:	0593000c 	ldreq	r0, [r3, #12]
    }
 5104c1c:	e5900378 	ldr	r0, [r0, #888]	; 0x378
 5104c20:	e12fff1e 	bx	lr

05104c24 <uxTaskBasePriorityGet>:
        taskENTER_CRITICAL();
 5104c24:	e30c3930 	movw	r3, #51504	; 0xc930
    {
 5104c28:	e92d4010 	push	{r4, lr}
        taskENTER_CRITICAL();
 5104c2c:	e3403510 	movt	r3, #1296	; 0x510
    {
 5104c30:	e1a04000 	mov	r4, r0
 5104c34:	e24dd008 	sub	sp, sp, #8
        taskENTER_CRITICAL();
 5104c38:	e12fff33 	blx	r3
            pxTCB = prvGetTCBFromHandle( xTask );
 5104c3c:	e3540000 	cmp	r4, #0
 5104c40:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5104c44:	03403511 	movteq	r3, #1297	; 0x511
 5104c48:	0593400c 	ldreq	r4, [r3, #12]
        taskEXIT_CRITICAL();
 5104c4c:	e30c3988 	movw	r3, #51592	; 0xc988
 5104c50:	e3403510 	movt	r3, #1296	; 0x510
            uxReturn = pxTCB->uxBasePriority;
 5104c54:	e594038c 	ldr	r0, [r4, #908]	; 0x38c
 5104c58:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5104c5c:	e12fff33 	blx	r3
    }
 5104c60:	e59d0004 	ldr	r0, [sp, #4]
 5104c64:	e28dd008 	add	sp, sp, #8
 5104c68:	e8bd8010 	pop	{r4, pc}

05104c6c <uxTaskBasePriorityGetFromISR>:
            pxTCB = prvGetTCBFromHandle( xTask );
 5104c6c:	e3500000 	cmp	r0, #0
 5104c70:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5104c74:	03403511 	movteq	r3, #1297	; 0x511
 5104c78:	0593000c 	ldreq	r0, [r3, #12]
    }
 5104c7c:	e590038c 	ldr	r0, [r0, #908]	; 0x38c
 5104c80:	e12fff1e 	bx	lr

05104c84 <eTaskGetState>:
    {
 5104c84:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
        configASSERT( pxTCB );
 5104c88:	e2505000 	subs	r5, r0, #0
 5104c8c:	0a000026 	beq	5104d2c <eTaskGetState+0xa8>
            if( pxTCB == pxCurrentTCB )
 5104c90:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 5104c94:	e3404511 	movt	r4, #1297	; 0x511
 5104c98:	e594300c 	ldr	r3, [r4, #12]
 5104c9c:	e1530005 	cmp	r3, r5
 5104ca0:	0a000018 	beq	5104d08 <eTaskGetState+0x84>
            taskENTER_CRITICAL();
 5104ca4:	e30c3930 	movw	r3, #51504	; 0xc930
 5104ca8:	e3403510 	movt	r3, #1296	; 0x510
 5104cac:	e12fff33 	blx	r3
                pxEventList = listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) );
 5104cb0:	e5957374 	ldr	r7, [r5, #884]	; 0x374
                pxDelayedList = pxDelayedTaskList;
 5104cb4:	e5949004 	ldr	r9, [r4, #4]
            taskEXIT_CRITICAL();
 5104cb8:	e30c3988 	movw	r3, #51592	; 0xc988
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
 5104cbc:	e5956360 	ldr	r6, [r5, #864]	; 0x360
            taskEXIT_CRITICAL();
 5104cc0:	e3403510 	movt	r3, #1296	; 0x510
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
 5104cc4:	e5948008 	ldr	r8, [r4, #8]
            taskEXIT_CRITICAL();
 5104cc8:	e12fff33 	blx	r3
            if( pxEventList == &xPendingReadyList )
 5104ccc:	e28430e4 	add	r3, r4, #228	; 0xe4
 5104cd0:	e1570003 	cmp	r7, r3
 5104cd4:	0a00000d 	beq	5104d10 <eTaskGetState+0x8c>
            else if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
 5104cd8:	e1560008 	cmp	r6, r8
 5104cdc:	11560009 	cmpne	r6, r9
 5104ce0:	0a00000f 	beq	5104d24 <eTaskGetState+0xa0>
                else if( pxStateList == &xSuspendedTaskList )
 5104ce4:	e2843014 	add	r3, r4, #20
 5104ce8:	e1560003 	cmp	r6, r3
 5104cec:	0a000009 	beq	5104d18 <eTaskGetState+0x94>
                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
 5104cf0:	e28440f8 	add	r4, r4, #248	; 0xf8
                    eReturn = eDeleted;
 5104cf4:	e3560000 	cmp	r6, #0
 5104cf8:	11560004 	cmpne	r6, r4
 5104cfc:	13a00001 	movne	r0, #1
 5104d00:	03a00004 	moveq	r0, #4
 5104d04:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                eReturn = eRunning;
 5104d08:	e3a00000 	mov	r0, #0
 5104d0c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                    eReturn = eReady;
 5104d10:	e3a00001 	mov	r0, #1
 5104d14:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
 5104d18:	e5953374 	ldr	r3, [r5, #884]	; 0x374
 5104d1c:	e3530000 	cmp	r3, #0
 5104d20:	0a000008 	beq	5104d48 <eTaskGetState+0xc4>
                eReturn = eBlocked;
 5104d24:	e3a00002 	mov	r0, #2
    }
 5104d28:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        configASSERT( pxTCB );
 5104d2c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104d30:	e3003900 	movw	r3, #2304	; 0x900
 5104d34:	e30019be 	movw	r1, #2494	; 0x9be
 5104d38:	e3403511 	movt	r3, #1297	; 0x511
 5104d3c:	e3400512 	movt	r0, #1298	; 0x512
 5104d40:	e12fff33 	blx	r3
 5104d44:	eaffffd1 	b	5104c90 <eTaskGetState+0xc>
                                if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 5104d48:	e5d53398 	ldrb	r3, [r5, #920]	; 0x398
                            eReturn = eSuspended;
 5104d4c:	e3530001 	cmp	r3, #1
 5104d50:	03a00002 	moveq	r0, #2
 5104d54:	13a00003 	movne	r0, #3
 5104d58:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

05104d5c <vTaskPrioritySet>:
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
 5104d5c:	e3510006 	cmp	r1, #6
    {
 5104d60:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5104d64:	e1a04001 	mov	r4, r1
 5104d68:	e1a05000 	mov	r5, r0
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
 5104d6c:	8a000038 	bhi	5104e54 <vTaskPrioritySet+0xf8>
        taskENTER_CRITICAL();
 5104d70:	e30c3930 	movw	r3, #51504	; 0xc930
 5104d74:	e3540006 	cmp	r4, #6
 5104d78:	23a04006 	movcs	r4, #6
 5104d7c:	e3403510 	movt	r3, #1296	; 0x510
 5104d80:	e12fff33 	blx	r3
            pxTCB = prvGetTCBFromHandle( xTask );
 5104d84:	e3550000 	cmp	r5, #0
 5104d88:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5104d8c:	03403511 	movteq	r3, #1297	; 0x511
 5104d90:	0593500c 	ldreq	r5, [r3, #12]
                uxCurrentBasePriority = pxTCB->uxBasePriority;
 5104d94:	e595338c 	ldr	r3, [r5, #908]	; 0x38c
            if( uxCurrentBasePriority != uxNewPriority )
 5104d98:	e1540003 	cmp	r4, r3
 5104d9c:	0a00001e 	beq	5104e1c <vTaskPrioritySet+0xc0>
                        if( pxTCB != pxCurrentTCB )
 5104da0:	e30c6db8 	movw	r6, #52664	; 0xcdb8
 5104da4:	e3406511 	movt	r6, #1297	; 0x511
                if( uxNewPriority > uxCurrentBasePriority )
 5104da8:	8a00001f 	bhi	5104e2c <vTaskPrioritySet+0xd0>
                else if( taskTASK_IS_RUNNING( pxTCB ) == pdTRUE )
 5104dac:	e596800c 	ldr	r8, [r6, #12]
 5104db0:	e0488005 	sub	r8, r8, r5
 5104db4:	e16f8f18 	clz	r8, r8
 5104db8:	e1a082a8 	lsr	r8, r8, #5
                uxPriorityUsedOnEntry = pxTCB->uxPriority;
 5104dbc:	e5957378 	ldr	r7, [r5, #888]	; 0x378
                    pxTCB->uxBasePriority = uxNewPriority;
 5104dc0:	e585438c 	str	r4, [r5, #908]	; 0x38c
                    if( ( pxTCB->uxBasePriority == pxTCB->uxPriority ) || ( uxNewPriority > pxTCB->uxPriority ) )
 5104dc4:	e1540007 	cmp	r4, r7
 5104dc8:	93a02000 	movls	r2, #0
 5104dcc:	83a02001 	movhi	r2, #1
 5104dd0:	e1530007 	cmp	r3, r7
 5104dd4:	03822001 	orreq	r2, r2, #1
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 5104dd8:	e5953364 	ldr	r3, [r5, #868]	; 0x364
                    if( ( pxTCB->uxBasePriority == pxTCB->uxPriority ) || ( uxNewPriority > pxTCB->uxPriority ) )
 5104ddc:	e3520000 	cmp	r2, #0
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 5104de0:	e5952360 	ldr	r2, [r5, #864]	; 0x360
                        pxTCB->uxPriority = uxNewPriority;
 5104de4:	15854378 	strne	r4, [r5, #888]	; 0x378
                if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 5104de8:	e3530000 	cmp	r3, #0
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) );
 5104dec:	a2644007 	rsbge	r4, r4, #7
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 5104df0:	e0873107 	add	r3, r7, r7, lsl #2
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) );
 5104df4:	a5854364 	strge	r4, [r5, #868]	; 0x364
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 5104df8:	e59f40e8 	ldr	r4, [pc, #232]	; 5104ee8 <vTaskPrioritySet+0x18c>
 5104dfc:	e0843103 	add	r3, r4, r3, lsl #2
 5104e00:	e1520003 	cmp	r2, r3
 5104e04:	0a000019 	beq	5104e70 <vTaskPrioritySet+0x114>
                if( xYieldRequired != pdFALSE )
 5104e08:	e3580000 	cmp	r8, #0
 5104e0c:	0a000002 	beq	5104e1c <vTaskPrioritySet+0xc0>
                    taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxTCB );
 5104e10:	e3003000 	movw	r3, #0
 5104e14:	e3403511 	movt	r3, #1297	; 0x511
 5104e18:	e12fff33 	blx	r3
        taskEXIT_CRITICAL();
 5104e1c:	e30c3988 	movw	r3, #51592	; 0xc988
 5104e20:	e3403510 	movt	r3, #1296	; 0x510
 5104e24:	e12fff33 	blx	r3
    }
 5104e28:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                        if( pxTCB != pxCurrentTCB )
 5104e2c:	e596200c 	ldr	r2, [r6, #12]
 5104e30:	e1520005 	cmp	r2, r5
        BaseType_t xYieldRequired = pdFALSE;
 5104e34:	03a08000 	moveq	r8, #0
                        if( pxTCB != pxCurrentTCB )
 5104e38:	0affffdf 	beq	5104dbc <vTaskPrioritySet+0x60>
                            if( uxNewPriority > pxCurrentTCB->uxPriority )
 5104e3c:	e596200c 	ldr	r2, [r6, #12]
 5104e40:	e5928378 	ldr	r8, [r2, #888]	; 0x378
 5104e44:	e1580004 	cmp	r8, r4
 5104e48:	23a08000 	movcs	r8, #0
 5104e4c:	33a08001 	movcc	r8, #1
 5104e50:	eaffffd9 	b	5104dbc <vTaskPrioritySet+0x60>
        configASSERT( uxNewPriority < configMAX_PRIORITIES );
 5104e54:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104e58:	e3003900 	movw	r3, #2304	; 0x900
 5104e5c:	e3001ad8 	movw	r1, #2776	; 0xad8
 5104e60:	e3403511 	movt	r3, #1297	; 0x511
 5104e64:	e3400512 	movt	r0, #1298	; 0x512
 5104e68:	e12fff33 	blx	r3
 5104e6c:	eaffffbf 	b	5104d70 <vTaskPrioritySet+0x14>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5104e70:	e3003cd8 	movw	r3, #3288	; 0xcd8
 5104e74:	e2859e35 	add	r9, r5, #848	; 0x350
 5104e78:	e1a00009 	mov	r0, r9
 5104e7c:	e3403510 	movt	r3, #1296	; 0x510
 5104e80:	e12fff33 	blx	r3
                    prvAddTaskToReadyList( pxTCB );
 5104e84:	e3a01001 	mov	r1, #1
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5104e88:	e3500000 	cmp	r0, #0
                        portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 5104e8c:	03a02001 	moveq	r2, #1
 5104e90:	05963010 	ldreq	r3, [r6, #16]
 5104e94:	01c37712 	biceq	r7, r3, r2, lsl r7
                    prvAddTaskToReadyList( pxTCB );
 5104e98:	e5953378 	ldr	r3, [r5, #888]	; 0x378
                        portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
 5104e9c:	05867010 	streq	r7, [r6, #16]
                    prvAddTaskToReadyList( pxTCB );
 5104ea0:	e5962010 	ldr	r2, [r6, #16]
 5104ea4:	e1822311 	orr	r2, r2, r1, lsl r3
 5104ea8:	e0833103 	add	r3, r3, r3, lsl #2
 5104eac:	e5862010 	str	r2, [r6, #16]
 5104eb0:	e0866103 	add	r6, r6, r3, lsl #2
 5104eb4:	e0844103 	add	r4, r4, r3, lsl #2
 5104eb8:	e5963034 	ldr	r3, [r6, #52]	; 0x34
 5104ebc:	e5962030 	ldr	r2, [r6, #48]	; 0x30
 5104ec0:	e5853354 	str	r3, [r5, #852]	; 0x354
 5104ec4:	e0822001 	add	r2, r2, r1
 5104ec8:	e5931008 	ldr	r1, [r3, #8]
 5104ecc:	e5851358 	str	r1, [r5, #856]	; 0x358
 5104ed0:	e5931008 	ldr	r1, [r3, #8]
 5104ed4:	e5819004 	str	r9, [r1, #4]
 5104ed8:	e5839008 	str	r9, [r3, #8]
 5104edc:	e5854360 	str	r4, [r5, #864]	; 0x360
 5104ee0:	e5862030 	str	r2, [r6, #48]	; 0x30
 5104ee4:	eaffffc7 	b	5104e08 <vTaskPrioritySet+0xac>
 5104ee8:	0511cde8 	.word	0x0511cde8

05104eec <vTaskResume>:
    {
 5104eec:	e92d4070 	push	{r4, r5, r6, lr}
        configASSERT( xTaskToResume );
 5104ef0:	e2505000 	subs	r5, r0, #0
 5104ef4:	0a00000f 	beq	5104f38 <vTaskResume+0x4c>
            if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 5104ef8:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 5104efc:	e3404511 	movt	r4, #1297	; 0x511
 5104f00:	e594300c 	ldr	r3, [r4, #12]
 5104f04:	e1550003 	cmp	r5, r3
 5104f08:	08bd8070 	popeq	{r4, r5, r6, pc}
            taskENTER_CRITICAL();
 5104f0c:	e30c3930 	movw	r3, #51504	; 0xc930
 5104f10:	e3403510 	movt	r3, #1296	; 0x510
 5104f14:	e12fff33 	blx	r3
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 5104f18:	e5952360 	ldr	r2, [r5, #864]	; 0x360
 5104f1c:	e2843014 	add	r3, r4, #20
 5104f20:	e1520003 	cmp	r2, r3
 5104f24:	0a00000d 	beq	5104f60 <vTaskResume+0x74>
            taskEXIT_CRITICAL();
 5104f28:	e30c3988 	movw	r3, #51592	; 0xc988
 5104f2c:	e3403510 	movt	r3, #1296	; 0x510
 5104f30:	e12fff33 	blx	r3
    }
 5104f34:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( xTaskToResume );
 5104f38:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5104f3c:	e3003900 	movw	r3, #2304	; 0x900
 5104f40:	e3001d1e 	movw	r1, #3358	; 0xd1e
 5104f44:	e3403511 	movt	r3, #1297	; 0x511
 5104f48:	e3400512 	movt	r0, #1298	; 0x512
 5104f4c:	e12fff33 	blx	r3
            if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
 5104f50:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5104f54:	e3403511 	movt	r3, #1297	; 0x511
 5104f58:	e593300c 	ldr	r3, [r3, #12]
 5104f5c:	e8bd8070 	pop	{r4, r5, r6, pc}
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 5104f60:	e5952374 	ldr	r2, [r5, #884]	; 0x374
 5104f64:	e28430e4 	add	r3, r4, #228	; 0xe4
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 5104f68:	e0523003 	subs	r3, r2, r3
 5104f6c:	13a03001 	movne	r3, #1
 5104f70:	e3520000 	cmp	r2, #0
 5104f74:	13a03000 	movne	r3, #0
 5104f78:	e3530000 	cmp	r3, #0
 5104f7c:	0affffe9 	beq	5104f28 <vTaskResume+0x3c>
                            if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 5104f80:	e5d53398 	ldrb	r3, [r5, #920]	; 0x398
 5104f84:	e3530001 	cmp	r3, #1
 5104f88:	0affffe6 	beq	5104f28 <vTaskResume+0x3c>
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5104f8c:	e3003cd8 	movw	r3, #3288	; 0xcd8
 5104f90:	e2856e35 	add	r6, r5, #848	; 0x350
 5104f94:	e1a00006 	mov	r0, r6
 5104f98:	e3403510 	movt	r3, #1296	; 0x510
 5104f9c:	e12fff33 	blx	r3
                    prvAddTaskToReadyList( pxTCB );
 5104fa0:	e5953378 	ldr	r3, [r5, #888]	; 0x378
 5104fa4:	e5942010 	ldr	r2, [r4, #16]
 5104fa8:	e3a01001 	mov	r1, #1
 5104fac:	e1822311 	orr	r2, r2, r1, lsl r3
 5104fb0:	e0831103 	add	r1, r3, r3, lsl #2
 5104fb4:	e5842010 	str	r2, [r4, #16]
                    taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 5104fb8:	e594200c 	ldr	r2, [r4, #12]
 5104fbc:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5104fc0:	e1530002 	cmp	r3, r2
                    prvAddTaskToReadyList( pxTCB );
 5104fc4:	e0842101 	add	r2, r4, r1, lsl #2
 5104fc8:	e2844030 	add	r4, r4, #48	; 0x30
 5104fcc:	e0844101 	add	r4, r4, r1, lsl #2
 5104fd0:	e5923034 	ldr	r3, [r2, #52]	; 0x34
 5104fd4:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 5104fd8:	e5853354 	str	r3, [r5, #852]	; 0x354
 5104fdc:	e5930008 	ldr	r0, [r3, #8]
 5104fe0:	e2811001 	add	r1, r1, #1
 5104fe4:	e5850358 	str	r0, [r5, #856]	; 0x358
 5104fe8:	e5930008 	ldr	r0, [r3, #8]
 5104fec:	e5806004 	str	r6, [r0, #4]
 5104ff0:	e5836008 	str	r6, [r3, #8]
 5104ff4:	e5854360 	str	r4, [r5, #864]	; 0x360
 5104ff8:	e5821030 	str	r1, [r2, #48]	; 0x30
                    taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 5104ffc:	9affffc9 	bls	5104f28 <vTaskResume+0x3c>
 5105000:	e3003000 	movw	r3, #0
 5105004:	e3403511 	movt	r3, #1297	; 0x511
 5105008:	e12fff33 	blx	r3
 510500c:	eaffffc5 	b	5104f28 <vTaskResume+0x3c>

05105010 <xTaskResumeFromISR>:
    {
 5105010:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        configASSERT( xTaskToResume );
 5105014:	e2505000 	subs	r5, r0, #0
 5105018:	0a000038 	beq	5105100 <xTaskResumeFromISR+0xf0>
        if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
 510501c:	e5952360 	ldr	r2, [r5, #864]	; 0x360
 5105020:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 5105024:	e3404511 	movt	r4, #1297	; 0x511
 5105028:	e2843014 	add	r3, r4, #20
 510502c:	e1520003 	cmp	r2, r3
 5105030:	0a000002 	beq	5105040 <xTaskResumeFromISR+0x30>
        BaseType_t xYieldRequired = pdFALSE;
 5105034:	e3a06000 	mov	r6, #0
    }
 5105038:	e1a00006 	mov	r0, r6
 510503c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
 5105040:	e5953374 	ldr	r3, [r5, #884]	; 0x374
 5105044:	e28400e4 	add	r0, r4, #228	; 0xe4
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
 5105048:	e16f6f13 	clz	r6, r3
 510504c:	e1530000 	cmp	r3, r0
 5105050:	e1a062a6 	lsr	r6, r6, #5
 5105054:	03a06000 	moveq	r6, #0
 5105058:	e3560000 	cmp	r6, #0
 510505c:	0afffff5 	beq	5105038 <xTaskResumeFromISR+0x28>
                            if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 5105060:	e5d53398 	ldrb	r3, [r5, #920]	; 0x398
 5105064:	e3530001 	cmp	r3, #1
 5105068:	0afffff1 	beq	5105034 <xTaskResumeFromISR+0x24>
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 510506c:	e5946118 	ldr	r6, [r4, #280]	; 0x118
 5105070:	e3560000 	cmp	r6, #0
 5105074:	1a00002c 	bne	510512c <xTaskResumeFromISR+0x11c>
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105078:	e594300c 	ldr	r3, [r4, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 510507c:	e2857e35 	add	r7, r5, #848	; 0x350
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105080:	e5952378 	ldr	r2, [r5, #888]	; 0x378
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 5105084:	e1a00007 	mov	r0, r7
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105088:	e5933378 	ldr	r3, [r3, #888]	; 0x378
 510508c:	e1520003 	cmp	r2, r3
                            xYieldPendings[ 0 ] = pdTRUE;
 5105090:	83a03001 	movhi	r3, #1
                            xYieldRequired = pdTRUE;
 5105094:	81a06003 	movhi	r6, r3
                            xYieldPendings[ 0 ] = pdTRUE;
 5105098:	8584311c 	strhi	r3, [r4, #284]	; 0x11c
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 510509c:	e3003cd8 	movw	r3, #3288	; 0xcd8
 51050a0:	e3403510 	movt	r3, #1296	; 0x510
 51050a4:	e12fff33 	blx	r3
                    prvAddTaskToReadyList( pxTCB );
 51050a8:	e5953378 	ldr	r3, [r5, #888]	; 0x378
 51050ac:	e5941010 	ldr	r1, [r4, #16]
 51050b0:	e3a00001 	mov	r0, #1
 51050b4:	e59f208c 	ldr	r2, [pc, #140]	; 5105148 <xTaskResumeFromISR+0x138>
 51050b8:	e1811310 	orr	r1, r1, r0, lsl r3
 51050bc:	e0833103 	add	r3, r3, r3, lsl #2
 51050c0:	e5841010 	str	r1, [r4, #16]
 51050c4:	e0844103 	add	r4, r4, r3, lsl #2
 51050c8:	e0823103 	add	r3, r2, r3, lsl #2
 51050cc:	e5942034 	ldr	r2, [r4, #52]	; 0x34
 51050d0:	e5941030 	ldr	r1, [r4, #48]	; 0x30
 51050d4:	e5852354 	str	r2, [r5, #852]	; 0x354
 51050d8:	e0811000 	add	r1, r1, r0
 51050dc:	e5920008 	ldr	r0, [r2, #8]
 51050e0:	e5850358 	str	r0, [r5, #856]	; 0x358
 51050e4:	e5920008 	ldr	r0, [r2, #8]
 51050e8:	e5807004 	str	r7, [r0, #4]
    }
 51050ec:	e1a00006 	mov	r0, r6
                    prvAddTaskToReadyList( pxTCB );
 51050f0:	e5827008 	str	r7, [r2, #8]
 51050f4:	e5853360 	str	r3, [r5, #864]	; 0x360
 51050f8:	e5841030 	str	r1, [r4, #48]	; 0x30
    }
 51050fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( xTaskToResume );
 5105100:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105104:	e3004900 	movw	r4, #2304	; 0x900
 5105108:	e3001d5c 	movw	r1, #3420	; 0xd5c
 510510c:	e3404511 	movt	r4, #1297	; 0x511
 5105110:	e3400512 	movt	r0, #1298	; 0x512
 5105114:	e12fff34 	blx	r4
        configASSERT( xTask );
 5105118:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510511c:	e3001cda 	movw	r1, #3290	; 0xcda
 5105120:	e3400512 	movt	r0, #1298	; 0x512
 5105124:	e12fff34 	blx	r4
 5105128:	eaffffbb 	b	510501c <xTaskResumeFromISR+0xc>
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 510512c:	e3003cac 	movw	r3, #3244	; 0xcac
 5105130:	e2851fd9 	add	r1, r5, #868	; 0x364
        BaseType_t xYieldRequired = pdFALSE;
 5105134:	e3a06000 	mov	r6, #0
                    vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5105138:	e3403510 	movt	r3, #1296	; 0x510
 510513c:	e12fff33 	blx	r3
    }
 5105140:	e1a00006 	mov	r0, r6
 5105144:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5105148:	0511cde8 	.word	0x0511cde8

0510514c <vTaskStartScheduler>:
{
 510514c:	e92d4070 	push	{r4, r5, r6, lr}
 5105150:	e30d3adc 	movw	r3, #56028	; 0xdadc
 5105154:	e24dd028 	sub	sp, sp, #40	; 0x28
        cIdleName[ xIdleTaskNameIndex ] = configIDLE_TASK_NAME[ xIdleTaskNameIndex ];
 5105158:	e3a01049 	mov	r1, #73	; 0x49
 510515c:	e3403512 	movt	r3, #1298	; 0x512
 5105160:	e28d201d 	add	r2, sp, #29
 5105164:	e5cd101c 	strb	r1, [sp, #28]
 5105168:	e1f340d1 	ldrsb	r4, [r3, #1]!
 510516c:	e4c24001 	strb	r4, [r2], #1
        if( cIdleName[ xIdleTaskNameIndex ] == ( char ) 0x00 )
 5105170:	e3540000 	cmp	r4, #0
 5105174:	1afffffb 	bne	5105168 <vTaskStartScheduler+0x1c>
                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
 5105178:	e30038b8 	movw	r3, #2232	; 0x8b8
 510517c:	e28d2018 	add	r2, sp, #24
 5105180:	e28d1014 	add	r1, sp, #20
 5105184:	e28d0010 	add	r0, sp, #16
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 5105188:	e58d4010 	str	r4, [sp, #16]
                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
 510518c:	e3403511 	movt	r3, #1297	; 0x511
            StackType_t * pxIdleTaskStackBuffer = NULL;
 5105190:	e58d4014 	str	r4, [sp, #20]
                vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &uxIdleTaskStackSize );
 5105194:	e12fff33 	blx	r3
            xIdleTaskHandles[ xCoreID ] = xTaskCreateStatic( pxIdleTaskFunction,
 5105198:	e1cd01d0 	ldrd	r0, [sp, #16]
 510519c:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
 51051a0:	e58d0008 	str	r0, [sp, #8]
 51051a4:	e30405d4 	movw	r0, #17876	; 0x45d4
 51051a8:	e58d1004 	str	r1, [sp, #4]
 51051ac:	e1a03004 	mov	r3, r4
 51051b0:	e59d2018 	ldr	r2, [sp, #24]
 51051b4:	e28d101c 	add	r1, sp, #28
 51051b8:	e58dc000 	str	ip, [sp]
 51051bc:	e3400510 	movt	r0, #1296	; 0x510
 51051c0:	ebfffd38 	bl	51046a8 <xTaskCreateStatic>
 51051c4:	e30c5db8 	movw	r5, #52664	; 0xcdb8
 51051c8:	e3405511 	movt	r5, #1297	; 0x511
 51051cc:	e5850120 	str	r0, [r5, #288]	; 0x120
            if( xIdleTaskHandles[ xCoreID ] != NULL )
 51051d0:	e3500000 	cmp	r0, #0
 51051d4:	1a000004 	bne	51051ec <vTaskStartScheduler+0xa0>
    ( void ) uxTopUsedPriority;
 51051d8:	e30f3ab0 	movw	r3, #64176	; 0xfab0
 51051dc:	e3403512 	movt	r3, #1298	; 0x512
 51051e0:	e5933000 	ldr	r3, [r3]
}
 51051e4:	e28dd028 	add	sp, sp, #40	; 0x28
 51051e8:	e8bd8070 	pop	{r4, r5, r6, pc}
            xReturn = xTimerCreateTimerTask();
 51051ec:	e3073d2c 	movw	r3, #32044	; 0x7d2c
 51051f0:	e3403510 	movt	r3, #1296	; 0x510
 51051f4:	e12fff33 	blx	r3
 51051f8:	e1a06000 	mov	r6, r0
    if( xReturn == pdPASS )
 51051fc:	e3500001 	cmp	r0, #1
 5105200:	0a000008 	beq	5105228 <vTaskStartScheduler+0xdc>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 5105204:	e3700001 	cmn	r0, #1
 5105208:	1afffff2 	bne	51051d8 <vTaskStartScheduler+0x8c>
 510520c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105210:	e3003900 	movw	r3, #2304	; 0x900
 5105214:	e3001ea6 	movw	r1, #3750	; 0xea6
 5105218:	e3403511 	movt	r3, #1297	; 0x511
 510521c:	e3400512 	movt	r0, #1298	; 0x512
 5105220:	e12fff33 	blx	r3
 5105224:	eaffffeb 	b	51051d8 <vTaskStartScheduler+0x8c>
        portDISABLE_INTERRUPTS();
 5105228:	e3003210 	movw	r3, #528	; 0x210
 510522c:	e3403510 	movt	r3, #1296	; 0x510
 5105230:	e12fff33 	blx	r3
        ( void ) xPortStartScheduler();
 5105234:	e30c39c8 	movw	r3, #51656	; 0xc9c8
        xNextTaskUnblockTime = portMAX_DELAY;
 5105238:	e3e02000 	mvn	r2, #0
        ( void ) xPortStartScheduler();
 510523c:	e3403510 	movt	r3, #1296	; 0x510
        xNextTaskUnblockTime = portMAX_DELAY;
 5105240:	e5852028 	str	r2, [r5, #40]	; 0x28
        xSchedulerRunning = pdTRUE;
 5105244:	e585610c 	str	r6, [r5, #268]	; 0x10c
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 5105248:	e5854000 	str	r4, [r5]
        ( void ) xPortStartScheduler();
 510524c:	e12fff33 	blx	r3
 5105250:	eaffffe0 	b	51051d8 <vTaskStartScheduler+0x8c>

05105254 <vTaskEndScheduler>:
{
 5105254:	e92d4010 	push	{r4, lr}
            vTaskDelete( xIdleTaskHandles[ xCoreID ] );
 5105258:	e30c4db8 	movw	r4, #52664	; 0xcdb8
            vTaskDelete( xTimerGetTimerDaemonTaskHandle() );
 510525c:	e3073a30 	movw	r3, #31280	; 0x7a30
            vTaskDelete( xIdleTaskHandles[ xCoreID ] );
 5105260:	e3404511 	movt	r4, #1297	; 0x511
            vTaskDelete( xTimerGetTimerDaemonTaskHandle() );
 5105264:	e3403510 	movt	r3, #1296	; 0x510
 5105268:	e12fff33 	blx	r3
 510526c:	ebfffde5 	bl	5104a08 <vTaskDelete>
            vTaskDelete( xIdleTaskHandles[ xCoreID ] );
 5105270:	e5940120 	ldr	r0, [r4, #288]	; 0x120
 5105274:	ebfffde3 	bl	5104a08 <vTaskDelete>
        prvCheckTasksWaitingTermination();
 5105278:	ebfffca1 	bl	5104504 <prvCheckTasksWaitingTermination>
    portDISABLE_INTERRUPTS();
 510527c:	e3003210 	movw	r3, #528	; 0x210
 5105280:	e3403510 	movt	r3, #1296	; 0x510
 5105284:	e12fff33 	blx	r3
    xSchedulerRunning = pdFALSE;
 5105288:	e3a02000 	mov	r2, #0
    vPortEndScheduler();
 510528c:	e30c35f0 	movw	r3, #50672	; 0xc5f0
    xSchedulerRunning = pdFALSE;
 5105290:	e584210c 	str	r2, [r4, #268]	; 0x10c
    vPortEndScheduler();
 5105294:	e3403510 	movt	r3, #1296	; 0x510
 5105298:	e12fff33 	blx	r3
}
 510529c:	e8bd8010 	pop	{r4, pc}

051052a0 <vTaskSuspendAll>:
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 51052a0:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51052a4:	e3403511 	movt	r3, #1297	; 0x511
 51052a8:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 51052ac:	e2822001 	add	r2, r2, #1
 51052b0:	e5832118 	str	r2, [r3, #280]	; 0x118
}
 51052b4:	e12fff1e 	bx	lr

051052b8 <xTaskGetTickCount>:
        xTicks = xTickCount;
 51052b8:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51052bc:	e3403511 	movt	r3, #1297	; 0x511
 51052c0:	e5930000 	ldr	r0, [r3]
}
 51052c4:	e12fff1e 	bx	lr

051052c8 <xTaskGetTickCountFromISR>:
 51052c8:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51052cc:	e3403511 	movt	r3, #1297	; 0x511
 51052d0:	e5930000 	ldr	r0, [r3]
 51052d4:	e12fff1e 	bx	lr

051052d8 <uxTaskGetNumberOfTasks>:
    return uxCurrentNumberOfTasks;
 51052d8:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51052dc:	e3403511 	movt	r3, #1297	; 0x511
 51052e0:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
}
 51052e4:	e12fff1e 	bx	lr

051052e8 <pcTaskGetName>:
{
 51052e8:	e92d4010 	push	{r4, lr}
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 51052ec:	e2504000 	subs	r4, r0, #0
 51052f0:	0a000001 	beq	51052fc <pcTaskGetName+0x14>
}
 51052f4:	e2840d0e 	add	r0, r4, #896	; 0x380
 51052f8:	e8bd8010 	pop	{r4, pc}
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 51052fc:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105300:	e3403511 	movt	r3, #1297	; 0x511
 5105304:	e593400c 	ldr	r4, [r3, #12]
    configASSERT( pxTCB );
 5105308:	e3540000 	cmp	r4, #0
 510530c:	1afffff8 	bne	51052f4 <pcTaskGetName+0xc>
 5105310:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105314:	e3003900 	movw	r3, #2304	; 0x900
 5105318:	e3011052 	movw	r1, #4178	; 0x1052
 510531c:	e3403511 	movt	r3, #1297	; 0x511
 5105320:	e3400512 	movt	r0, #1298	; 0x512
 5105324:	e12fff33 	blx	r3
}
 5105328:	e2840d0e 	add	r0, r4, #896	; 0x380
 510532c:	e8bd8010 	pop	{r4, pc}

05105330 <xTaskGetStaticBuffers>:
    {
 5105330:	e92d4070 	push	{r4, r5, r6, lr}
 5105334:	e1a04000 	mov	r4, r0
        configASSERT( ppuxStackBuffer != NULL );
 5105338:	e2516000 	subs	r6, r1, #0
    {
 510533c:	e1a05002 	mov	r5, r2
        configASSERT( ppuxStackBuffer != NULL );
 5105340:	0a00001b 	beq	51053b4 <xTaskGetStaticBuffers+0x84>
        configASSERT( ppxTaskBuffer != NULL );
 5105344:	e3550000 	cmp	r5, #0
 5105348:	0a000012 	beq	5105398 <xTaskGetStaticBuffers+0x68>
        pxTCB = prvGetTCBFromHandle( xTask );
 510534c:	e3540000 	cmp	r4, #0
 5105350:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5105354:	03403511 	movteq	r3, #1297	; 0x511
 5105358:	0593400c 	ldreq	r4, [r3, #12]
            if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB )
 510535c:	e5d40399 	ldrb	r0, [r4, #921]	; 0x399
 5105360:	e3500002 	cmp	r0, #2
 5105364:	0a000006 	beq	5105384 <xTaskGetStaticBuffers+0x54>
            else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 5105368:	e3500001 	cmp	r0, #1
                *ppxTaskBuffer = NULL;
 510536c:	03a03000 	moveq	r3, #0
                xReturn = pdFALSE;
 5105370:	13a00000 	movne	r0, #0
                *ppuxStackBuffer = pxTCB->pxStack;
 5105374:	0594237c 	ldreq	r2, [r4, #892]	; 0x37c
 5105378:	05862000 	streq	r2, [r6]
                *ppxTaskBuffer = NULL;
 510537c:	05853000 	streq	r3, [r5]
    }
 5105380:	e8bd8070 	pop	{r4, r5, r6, pc}
                *ppuxStackBuffer = pxTCB->pxStack;
 5105384:	e594337c 	ldr	r3, [r4, #892]	; 0x37c
                xReturn = pdTRUE;
 5105388:	e3a00001 	mov	r0, #1
                *ppuxStackBuffer = pxTCB->pxStack;
 510538c:	e5863000 	str	r3, [r6]
                *ppxTaskBuffer = ( StaticTask_t * ) pxTCB;
 5105390:	e5854000 	str	r4, [r5]
                xReturn = pdTRUE;
 5105394:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( ppxTaskBuffer != NULL );
 5105398:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510539c:	e3003900 	movw	r3, #2304	; 0x900
 51053a0:	e30110f2 	movw	r1, #4338	; 0x10f2
 51053a4:	e3403511 	movt	r3, #1297	; 0x511
 51053a8:	e3400512 	movt	r0, #1298	; 0x512
 51053ac:	e12fff33 	blx	r3
 51053b0:	eaffffe5 	b	510534c <xTaskGetStaticBuffers+0x1c>
        configASSERT( ppuxStackBuffer != NULL );
 51053b4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51053b8:	e3003900 	movw	r3, #2304	; 0x900
 51053bc:	e30110f1 	movw	r1, #4337	; 0x10f1
 51053c0:	e3403511 	movt	r3, #1297	; 0x511
 51053c4:	e3400512 	movt	r0, #1298	; 0x512
 51053c8:	e12fff33 	blx	r3
 51053cc:	eaffffdc 	b	5105344 <xTaskGetStaticBuffers+0x14>

051053d0 <uxTaskGetStackHighWaterMark>:
        pxTCB = prvGetTCBFromHandle( xTask );
 51053d0:	e3500000 	cmp	r0, #0
 51053d4:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 51053d8:	03403511 	movteq	r3, #1297	; 0x511
 51053dc:	0593000c 	ldreq	r0, [r3, #12]
            pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
 51053e0:	e590337c 	ldr	r3, [r0, #892]	; 0x37c
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 51053e4:	e5d32000 	ldrb	r2, [r3]
 51053e8:	e35200a5 	cmp	r2, #165	; 0xa5
 51053ec:	1a000006 	bne	510540c <uxTaskGetStackHighWaterMark+0x3c>
 51053f0:	e2631001 	rsb	r1, r3, #1
            uxCount++;
 51053f4:	e0810003 	add	r0, r1, r3
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 51053f8:	e5f32001 	ldrb	r2, [r3, #1]!
 51053fc:	e35200a5 	cmp	r2, #165	; 0xa5
 5105400:	0afffffb 	beq	51053f4 <uxTaskGetStackHighWaterMark+0x24>
        uxCount /= ( configSTACK_DEPTH_TYPE ) sizeof( StackType_t );
 5105404:	e1a00120 	lsr	r0, r0, #2
 5105408:	e12fff1e 	bx	lr
        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
 510540c:	e3a00000 	mov	r0, #0
    }
 5105410:	e12fff1e 	bx	lr

05105414 <xTaskGenericNotify>:
    {
 5105414:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5105418:	e24dd008 	sub	sp, sp, #8
 510541c:	e1a04000 	mov	r4, r0
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105420:	e2515000 	subs	r5, r1, #0
    {
 5105424:	e1a07002 	mov	r7, r2
 5105428:	e1a08003 	mov	r8, r3
 510542c:	e59d6020 	ldr	r6, [sp, #32]
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105430:	1a00005d 	bne	51055ac <xTaskGenericNotify+0x198>
        configASSERT( xTaskToNotify );
 5105434:	e3540000 	cmp	r4, #0
 5105438:	0a000063 	beq	51055cc <xTaskGenericNotify+0x1b8>
        taskENTER_CRITICAL();
 510543c:	e30c1930 	movw	r1, #51504	; 0xc930
 5105440:	e3401510 	movt	r1, #1296	; 0x510
 5105444:	e12fff31 	blx	r1
            if( pulPreviousNotificationValue != NULL )
 5105448:	e3560000 	cmp	r6, #0
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 510544c:	128530e4 	addne	r3, r5, #228	; 0xe4
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 5105450:	e0841005 	add	r1, r4, r5
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 5105454:	10843103 	addne	r3, r4, r3, lsl #2
 5105458:	15933004 	ldrne	r3, [r3, #4]
 510545c:	15863000 	strne	r3, [r6]
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5105460:	e3a03002 	mov	r3, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 5105464:	e5d16398 	ldrb	r6, [r1, #920]	; 0x398
 5105468:	e6ef6076 	uxtb	r6, r6
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 510546c:	e5c13398 	strb	r3, [r1, #920]	; 0x398
 5105470:	e3580004 	cmp	r8, #4
 5105474:	979ff108 	ldrls	pc, [pc, r8, lsl #2]
 5105478:	ea000064 	b	5105610 <xTaskGenericNotify+0x1fc>
 510547c:	051054a8 	.word	0x051054a8
 5105480:	051055fc 	.word	0x051055fc
 5105484:	051055e8 	.word	0x051055e8
 5105488:	0510549c 	.word	0x0510549c
 510548c:	05105490 	.word	0x05105490
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5105490:	e3560002 	cmp	r6, #2
                        xReturn = pdFAIL;
 5105494:	03a00000 	moveq	r0, #0
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 5105498:	0a000005 	beq	51054b4 <xTaskGenericNotify+0xa0>
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 510549c:	e28550e4 	add	r5, r5, #228	; 0xe4
 51054a0:	e0845105 	add	r5, r4, r5, lsl #2
 51054a4:	e5857004 	str	r7, [r5, #4]
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 51054a8:	e3560001 	cmp	r6, #1
 51054ac:	0a000007 	beq	51054d0 <xTaskGenericNotify+0xbc>
    {
 51054b0:	e3a00001 	mov	r0, #1
 51054b4:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 51054b8:	e30c3988 	movw	r3, #51592	; 0xc988
 51054bc:	e3403510 	movt	r3, #1296	; 0x510
 51054c0:	e12fff33 	blx	r3
    }
 51054c4:	e59d0004 	ldr	r0, [sp, #4]
 51054c8:	e28dd008 	add	sp, sp, #8
 51054cc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 51054d0:	e5942360 	ldr	r2, [r4, #864]	; 0x360
 51054d4:	e284ee35 	add	lr, r4, #848	; 0x350
 51054d8:	e5941354 	ldr	r1, [r4, #852]	; 0x354
                prvAddTaskToReadyList( pxTCB );
 51054dc:	e30c5db8 	movw	r5, #52664	; 0xcdb8
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 51054e0:	e5943358 	ldr	r3, [r4, #856]	; 0x358
                prvAddTaskToReadyList( pxTCB );
 51054e4:	e3405511 	movt	r5, #1297	; 0x511
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 51054e8:	e5813008 	str	r3, [r1, #8]
 51054ec:	e5831004 	str	r1, [r3, #4]
 51054f0:	e5921004 	ldr	r1, [r2, #4]
 51054f4:	e151000e 	cmp	r1, lr
 51054f8:	e5921000 	ldr	r1, [r2]
 51054fc:	05823004 	streq	r3, [r2, #4]
                prvAddTaskToReadyList( pxTCB );
 5105500:	e5943378 	ldr	r3, [r4, #888]	; 0x378
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105504:	e2411001 	sub	r1, r1, #1
 5105508:	e5821000 	str	r1, [r2]
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 510550c:	e5941374 	ldr	r1, [r4, #884]	; 0x374
                prvAddTaskToReadyList( pxTCB );
 5105510:	e0836103 	add	r6, r3, r3, lsl #2
 5105514:	e5952010 	ldr	r2, [r5, #16]
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5105518:	e3510000 	cmp	r1, #0
                prvAddTaskToReadyList( pxTCB );
 510551c:	e3a01001 	mov	r1, #1
 5105520:	e0850106 	add	r0, r5, r6, lsl #2
 5105524:	e1822311 	orr	r2, r2, r1, lsl r3
 5105528:	e590c030 	ldr	ip, [r0, #48]	; 0x30
 510552c:	e5852010 	str	r2, [r5, #16]
 5105530:	e5902034 	ldr	r2, [r0, #52]	; 0x34
 5105534:	e08cc001 	add	ip, ip, r1
 5105538:	e5842354 	str	r2, [r4, #852]	; 0x354
 510553c:	e2851030 	add	r1, r5, #48	; 0x30
 5105540:	e0811106 	add	r1, r1, r6, lsl #2
 5105544:	e5926008 	ldr	r6, [r2, #8]
 5105548:	e5846358 	str	r6, [r4, #856]	; 0x358
 510554c:	e5926008 	ldr	r6, [r2, #8]
 5105550:	e586e004 	str	lr, [r6, #4]
 5105554:	e582e008 	str	lr, [r2, #8]
 5105558:	e580c030 	str	ip, [r0, #48]	; 0x30
 510555c:	e5841360 	str	r1, [r4, #864]	; 0x360
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 5105560:	0a000006 	beq	5105580 <xTaskGenericNotify+0x16c>
 5105564:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105568:	e3003900 	movw	r3, #2304	; 0x900
 510556c:	e3011ee9 	movw	r1, #7913	; 0x1ee9
 5105570:	e3403511 	movt	r3, #1297	; 0x511
 5105574:	e3400512 	movt	r0, #1298	; 0x512
 5105578:	e12fff33 	blx	r3
                taskYIELD_ANY_CORE_IF_USING_PREEMPTION( pxTCB );
 510557c:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 5105580:	e595200c 	ldr	r2, [r5, #12]
 5105584:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5105588:	e1520003 	cmp	r2, r3
 510558c:	2affffc7 	bcs	51054b0 <xTaskGenericNotify+0x9c>
 5105590:	e3a00001 	mov	r0, #1
 5105594:	e3003000 	movw	r3, #0
 5105598:	e3403511 	movt	r3, #1297	; 0x511
 510559c:	e58d0004 	str	r0, [sp, #4]
 51055a0:	e12fff33 	blx	r3
 51055a4:	e59d0004 	ldr	r0, [sp, #4]
 51055a8:	eaffffc1 	b	51054b4 <xTaskGenericNotify+0xa0>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 51055ac:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51055b0:	e3003900 	movw	r3, #2304	; 0x900
 51055b4:	e3400512 	movt	r0, #1298	; 0x512
 51055b8:	e3011ea4 	movw	r1, #7844	; 0x1ea4
 51055bc:	e3403511 	movt	r3, #1297	; 0x511
 51055c0:	e12fff33 	blx	r3
        configASSERT( xTaskToNotify );
 51055c4:	e3540000 	cmp	r4, #0
 51055c8:	1affff9b 	bne	510543c <xTaskGenericNotify+0x28>
 51055cc:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51055d0:	e3003900 	movw	r3, #2304	; 0x900
 51055d4:	e3011ea5 	movw	r1, #7845	; 0x1ea5
 51055d8:	e3403511 	movt	r3, #1297	; 0x511
 51055dc:	e3400512 	movt	r0, #1298	; 0x512
 51055e0:	e12fff33 	blx	r3
 51055e4:	eaffff94 	b	510543c <xTaskGenericNotify+0x28>
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 51055e8:	e0845105 	add	r5, r4, r5, lsl #2
 51055ec:	e5953394 	ldr	r3, [r5, #916]	; 0x394
 51055f0:	e2833001 	add	r3, r3, #1
 51055f4:	e5853394 	str	r3, [r5, #916]	; 0x394
                    break;
 51055f8:	eaffffaa 	b	51054a8 <xTaskGenericNotify+0x94>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 51055fc:	e0845105 	add	r5, r4, r5, lsl #2
 5105600:	e5952394 	ldr	r2, [r5, #916]	; 0x394
 5105604:	e1827007 	orr	r7, r2, r7
 5105608:	e5857394 	str	r7, [r5, #916]	; 0x394
                    break;
 510560c:	eaffffa5 	b	51054a8 <xTaskGenericNotify+0x94>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
 5105610:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105614:	e3403511 	movt	r3, #1297	; 0x511
 5105618:	e5933000 	ldr	r3, [r3]
 510561c:	e3530000 	cmp	r3, #0
 5105620:	0affffa0 	beq	51054a8 <xTaskGenericNotify+0x94>
 5105624:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105628:	e3003900 	movw	r3, #2304	; 0x900
 510562c:	e3011eda 	movw	r1, #7898	; 0x1eda
 5105630:	e3403511 	movt	r3, #1297	; 0x511
 5105634:	e3400512 	movt	r0, #1298	; 0x512
 5105638:	e12fff33 	blx	r3
 510563c:	eaffff99 	b	51054a8 <xTaskGenericNotify+0x94>

05105640 <xTaskGenericNotifyFromISR>:
    {
 5105640:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5105644:	e59d7018 	ldr	r7, [sp, #24]
        configASSERT( xTaskToNotify );
 5105648:	e2504000 	subs	r4, r0, #0
    {
 510564c:	e1a05001 	mov	r5, r1
 5105650:	e1a08002 	mov	r8, r2
 5105654:	e1a06003 	mov	r6, r3
        configASSERT( xTaskToNotify );
 5105658:	0a000079 	beq	5105844 <xTaskGenericNotifyFromISR+0x204>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 510565c:	e3550000 	cmp	r5, #0
 5105660:	1a000053 	bne	51057b4 <xTaskGenericNotifyFromISR+0x174>
            if( pulPreviousNotificationValue != NULL )
 5105664:	e3570000 	cmp	r7, #0
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 5105668:	128530e4 	addne	r3, r5, #228	; 0xe4
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 510566c:	e0841005 	add	r1, r4, r5
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
 5105670:	10843103 	addne	r3, r4, r3, lsl #2
 5105674:	15933004 	ldrne	r3, [r3, #4]
 5105678:	15873000 	strne	r3, [r7]
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 510567c:	e3a03002 	mov	r3, #2
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 5105680:	e5d17398 	ldrb	r7, [r1, #920]	; 0x398
 5105684:	e6ef7077 	uxtb	r7, r7
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 5105688:	e5c13398 	strb	r3, [r1, #920]	; 0x398
 510568c:	e3560004 	cmp	r6, #4
 5105690:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
 5105694:	ea000071 	b	5105860 <xTaskGenericNotifyFromISR+0x220>
 5105698:	051056b8 	.word	0x051056b8
 510569c:	051057f4 	.word	0x051057f4
 51056a0:	051057d0 	.word	0x051057d0
 51056a4:	051056ac 	.word	0x051056ac
 51056a8:	051057e4 	.word	0x051057e4
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
 51056ac:	e28550e4 	add	r5, r5, #228	; 0xe4
 51056b0:	e0845105 	add	r5, r4, r5, lsl #2
 51056b4:	e5858004 	str	r8, [r5, #4]
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 51056b8:	e3570001 	cmp	r7, #1
 51056bc:	0a000001 	beq	51056c8 <xTaskGenericNotifyFromISR+0x88>
    {
 51056c0:	e3a00001 	mov	r0, #1
 51056c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 51056c8:	e5943374 	ldr	r3, [r4, #884]	; 0x374
 51056cc:	e3530000 	cmp	r3, #0
 51056d0:	0a000005 	beq	51056ec <xTaskGenericNotifyFromISR+0xac>
 51056d4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51056d8:	e3003900 	movw	r3, #2304	; 0x900
 51056dc:	e3011f74 	movw	r1, #8052	; 0x1f74
 51056e0:	e3400512 	movt	r0, #1298	; 0x512
 51056e4:	e3403511 	movt	r3, #1297	; 0x511
 51056e8:	e12fff33 	blx	r3
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 51056ec:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51056f0:	e3403511 	movt	r3, #1297	; 0x511
 51056f4:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 51056f8:	e3520000 	cmp	r2, #0
 51056fc:	1a000041 	bne	5105808 <xTaskGenericNotifyFromISR+0x1c8>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105700:	e5942360 	ldr	r2, [r4, #864]	; 0x360
 5105704:	e2845e35 	add	r5, r4, #848	; 0x350
 5105708:	e5940354 	ldr	r0, [r4, #852]	; 0x354
 510570c:	e5941358 	ldr	r1, [r4, #856]	; 0x358
 5105710:	e5801008 	str	r1, [r0, #8]
 5105714:	e5810004 	str	r0, [r1, #4]
 5105718:	e5920004 	ldr	r0, [r2, #4]
                    prvAddTaskToReadyList( pxTCB );
 510571c:	e59fe16c 	ldr	lr, [pc, #364]	; 5105890 <xTaskGenericNotifyFromISR+0x250>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105720:	e1500005 	cmp	r0, r5
                    prvAddTaskToReadyList( pxTCB );
 5105724:	e3a00001 	mov	r0, #1
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105728:	05821004 	streq	r1, [r2, #4]
 510572c:	e5921000 	ldr	r1, [r2]
 5105730:	e2411001 	sub	r1, r1, #1
 5105734:	e5821000 	str	r1, [r2]
                    prvAddTaskToReadyList( pxTCB );
 5105738:	e5942378 	ldr	r2, [r4, #888]	; 0x378
 510573c:	e5931010 	ldr	r1, [r3, #16]
 5105740:	e1811210 	orr	r1, r1, r0, lsl r2
 5105744:	e5831010 	str	r1, [r3, #16]
 5105748:	e0821102 	add	r1, r2, r2, lsl #2
 510574c:	e08ee101 	add	lr, lr, r1, lsl #2
 5105750:	e0831101 	add	r1, r3, r1, lsl #2
 5105754:	e5910034 	ldr	r0, [r1, #52]	; 0x34
 5105758:	e591c030 	ldr	ip, [r1, #48]	; 0x30
 510575c:	e5840354 	str	r0, [r4, #852]	; 0x354
 5105760:	e5906008 	ldr	r6, [r0, #8]
 5105764:	e28cc001 	add	ip, ip, #1
 5105768:	e5846358 	str	r6, [r4, #856]	; 0x358
 510576c:	e5906008 	ldr	r6, [r0, #8]
 5105770:	e5865004 	str	r5, [r6, #4]
 5105774:	e5805008 	str	r5, [r0, #8]
 5105778:	e584e360 	str	lr, [r4, #864]	; 0x360
 510577c:	e581c030 	str	ip, [r1, #48]	; 0x30
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105780:	e593100c 	ldr	r1, [r3, #12]
 5105784:	e5911378 	ldr	r1, [r1, #888]	; 0x378
 5105788:	e1510002 	cmp	r1, r2
 510578c:	2affffcb 	bcs	51056c0 <xTaskGenericNotifyFromISR+0x80>
                        if( pxHigherPriorityTaskWoken != NULL )
 5105790:	e59d201c 	ldr	r2, [sp, #28]
 5105794:	e3520000 	cmp	r2, #0
                            *pxHigherPriorityTaskWoken = pdTRUE;
 5105798:	13a02001 	movne	r2, #1
 510579c:	159d101c 	ldrne	r1, [sp, #28]
 51057a0:	15812000 	strne	r2, [r1]
                        xYieldPendings[ 0 ] = pdTRUE;
 51057a4:	e3a02001 	mov	r2, #1
 51057a8:	e1a00002 	mov	r0, r2
 51057ac:	e583211c 	str	r2, [r3, #284]	; 0x11c
 51057b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 51057b4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51057b8:	e3003900 	movw	r3, #2304	; 0x900
 51057bc:	e3011f1f 	movw	r1, #7967	; 0x1f1f
 51057c0:	e3403511 	movt	r3, #1297	; 0x511
 51057c4:	e3400512 	movt	r0, #1298	; 0x512
 51057c8:	e12fff33 	blx	r3
 51057cc:	eaffffa4 	b	5105664 <xTaskGenericNotifyFromISR+0x24>
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 51057d0:	e0845105 	add	r5, r4, r5, lsl #2
 51057d4:	e5953394 	ldr	r3, [r5, #916]	; 0x394
 51057d8:	e2833001 	add	r3, r3, #1
 51057dc:	e5853394 	str	r3, [r5, #916]	; 0x394
                    break;
 51057e0:	eaffffb4 	b	51056b8 <xTaskGenericNotifyFromISR+0x78>
                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 51057e4:	e3570002 	cmp	r7, #2
 51057e8:	1affffaf 	bne	51056ac <xTaskGenericNotifyFromISR+0x6c>
                        xReturn = pdFAIL;
 51057ec:	e3a00000 	mov	r0, #0
    }
 51057f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
 51057f4:	e0845105 	add	r5, r4, r5, lsl #2
 51057f8:	e5952394 	ldr	r2, [r5, #916]	; 0x394
 51057fc:	e1828008 	orr	r8, r2, r8
 5105800:	e5858394 	str	r8, [r5, #916]	; 0x394
                    break;
 5105804:	eaffffab 	b	51056b8 <xTaskGenericNotifyFromISR+0x78>
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5105808:	e59320e8 	ldr	r2, [r3, #232]	; 0xe8
 510580c:	e2840fd9 	add	r0, r4, #868	; 0x364
 5105810:	e5842368 	str	r2, [r4, #872]	; 0x368
 5105814:	e283c0e4 	add	ip, r3, #228	; 0xe4
 5105818:	e5921008 	ldr	r1, [r2, #8]
 510581c:	e584136c 	str	r1, [r4, #876]	; 0x36c
 5105820:	e5921008 	ldr	r1, [r2, #8]
 5105824:	e5810004 	str	r0, [r1, #4]
 5105828:	e59310e4 	ldr	r1, [r3, #228]	; 0xe4
 510582c:	e5820008 	str	r0, [r2, #8]
                    prvAddTaskToReadyList( pxTCB );
 5105830:	e5942378 	ldr	r2, [r4, #888]	; 0x378
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5105834:	e2811001 	add	r1, r1, #1
 5105838:	e584c374 	str	ip, [r4, #884]	; 0x374
 510583c:	e58310e4 	str	r1, [r3, #228]	; 0xe4
 5105840:	eaffffce 	b	5105780 <xTaskGenericNotifyFromISR+0x140>
        configASSERT( xTaskToNotify );
 5105844:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105848:	e3003900 	movw	r3, #2304	; 0x900
 510584c:	e3011f1e 	movw	r1, #7966	; 0x1f1e
 5105850:	e3403511 	movt	r3, #1297	; 0x511
 5105854:	e3400512 	movt	r0, #1298	; 0x512
 5105858:	e12fff33 	blx	r3
 510585c:	eaffff7e 	b	510565c <xTaskGenericNotifyFromISR+0x1c>
                    configASSERT( xTickCount == ( TickType_t ) 0 );
 5105860:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105864:	e3403511 	movt	r3, #1297	; 0x511
 5105868:	e5933000 	ldr	r3, [r3]
 510586c:	e3530000 	cmp	r3, #0
 5105870:	0affff90 	beq	51056b8 <xTaskGenericNotifyFromISR+0x78>
 5105874:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105878:	e3003900 	movw	r3, #2304	; 0x900
 510587c:	e3011f69 	movw	r1, #8041	; 0x1f69
 5105880:	e3403511 	movt	r3, #1297	; 0x511
 5105884:	e3400512 	movt	r0, #1298	; 0x512
 5105888:	e12fff33 	blx	r3
 510588c:	eaffff89 	b	51056b8 <xTaskGenericNotifyFromISR+0x78>
 5105890:	0511cde8 	.word	0x0511cde8

05105894 <vTaskGenericNotifyGiveFromISR>:
    {
 5105894:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5105898:	e1a04001 	mov	r4, r1
        configASSERT( xTaskToNotify );
 510589c:	e2505000 	subs	r5, r0, #0
    {
 51058a0:	e1a06002 	mov	r6, r2
        configASSERT( xTaskToNotify );
 51058a4:	0a000059 	beq	5105a10 <vTaskGenericNotifyGiveFromISR+0x17c>
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 51058a8:	e3540000 	cmp	r4, #0
 51058ac:	1a00002f 	bne	5105970 <vTaskGenericNotifyGiveFromISR+0xdc>
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
 51058b0:	e0853004 	add	r3, r5, r4
 51058b4:	e5d32398 	ldrb	r2, [r3, #920]	; 0x398
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 51058b8:	e0854104 	add	r4, r5, r4, lsl #2
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 51058bc:	e3520001 	cmp	r2, #1
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
 51058c0:	e3a02002 	mov	r2, #2
 51058c4:	e5c32398 	strb	r2, [r3, #920]	; 0x398
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
 51058c8:	e5943394 	ldr	r3, [r4, #916]	; 0x394
 51058cc:	e2833001 	add	r3, r3, #1
 51058d0:	e5843394 	str	r3, [r4, #916]	; 0x394
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 51058d4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 51058d8:	e5953374 	ldr	r3, [r5, #884]	; 0x374
 51058dc:	e3530000 	cmp	r3, #0
 51058e0:	0a000005 	beq	51058fc <vTaskGenericNotifyGiveFromISR+0x68>
 51058e4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51058e8:	e3003900 	movw	r3, #2304	; 0x900
 51058ec:	e3011fea 	movw	r1, #8170	; 0x1fea
 51058f0:	e3400512 	movt	r0, #1298	; 0x512
 51058f4:	e3403511 	movt	r3, #1297	; 0x511
 51058f8:	e12fff33 	blx	r3
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 51058fc:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105900:	e3403511 	movt	r3, #1297	; 0x511
 5105904:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 5105908:	e3520000 	cmp	r2, #0
 510590c:	0a00001e 	beq	510598c <vTaskGenericNotifyGiveFromISR+0xf8>
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 5105910:	e59310e8 	ldr	r1, [r3, #232]	; 0xe8
 5105914:	e2850fd9 	add	r0, r5, #868	; 0x364
 5105918:	e5851368 	str	r1, [r5, #872]	; 0x368
 510591c:	e283c0e4 	add	ip, r3, #228	; 0xe4
 5105920:	e5912008 	ldr	r2, [r1, #8]
 5105924:	e585236c 	str	r2, [r5, #876]	; 0x36c
 5105928:	e59320e4 	ldr	r2, [r3, #228]	; 0xe4
 510592c:	e591e008 	ldr	lr, [r1, #8]
 5105930:	e2822001 	add	r2, r2, #1
 5105934:	e58320e4 	str	r2, [r3, #228]	; 0xe4
                    prvAddTaskToReadyList( pxTCB );
 5105938:	e5952378 	ldr	r2, [r5, #888]	; 0x378
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 510593c:	e58e0004 	str	r0, [lr, #4]
 5105940:	e5810008 	str	r0, [r1, #8]
 5105944:	e585c374 	str	ip, [r5, #884]	; 0x374
                    if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105948:	e593100c 	ldr	r1, [r3, #12]
 510594c:	e5911378 	ldr	r1, [r1, #888]	; 0x378
 5105950:	e1510002 	cmp	r1, r2
 5105954:	28bd81f0 	popcs	{r4, r5, r6, r7, r8, pc}
                        if( pxHigherPriorityTaskWoken != NULL )
 5105958:	e3560000 	cmp	r6, #0
                            *pxHigherPriorityTaskWoken = pdTRUE;
 510595c:	13a02001 	movne	r2, #1
 5105960:	15862000 	strne	r2, [r6]
                        xYieldPendings[ 0 ] = pdTRUE;
 5105964:	e3a02001 	mov	r2, #1
 5105968:	e583211c 	str	r2, [r3, #284]	; 0x11c
    }
 510596c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105970:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105974:	e3003900 	movw	r3, #2304	; 0x900
 5105978:	e3011fc1 	movw	r1, #8129	; 0x1fc1
 510597c:	e3403511 	movt	r3, #1297	; 0x511
 5105980:	e3400512 	movt	r0, #1298	; 0x512
 5105984:	e12fff33 	blx	r3
 5105988:	eaffffc8 	b	51058b0 <vTaskGenericNotifyGiveFromISR+0x1c>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 510598c:	e5951360 	ldr	r1, [r5, #864]	; 0x360
 5105990:	e285ee35 	add	lr, r5, #848	; 0x350
 5105994:	e5950354 	ldr	r0, [r5, #852]	; 0x354
                    prvAddTaskToReadyList( pxTCB );
 5105998:	e3a0c001 	mov	ip, #1
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 510599c:	e5952358 	ldr	r2, [r5, #856]	; 0x358
 51059a0:	e5802008 	str	r2, [r0, #8]
 51059a4:	e5820004 	str	r0, [r2, #4]
 51059a8:	e5910004 	ldr	r0, [r1, #4]
                    prvAddTaskToReadyList( pxTCB );
 51059ac:	e59f4078 	ldr	r4, [pc, #120]	; 5105a2c <vTaskGenericNotifyGiveFromISR+0x198>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 51059b0:	e150000e 	cmp	r0, lr
 51059b4:	e5910000 	ldr	r0, [r1]
 51059b8:	05812004 	streq	r2, [r1, #4]
                    prvAddTaskToReadyList( pxTCB );
 51059bc:	e5952378 	ldr	r2, [r5, #888]	; 0x378
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 51059c0:	e2400001 	sub	r0, r0, #1
 51059c4:	e5810000 	str	r0, [r1]
                    prvAddTaskToReadyList( pxTCB );
 51059c8:	e5930010 	ldr	r0, [r3, #16]
 51059cc:	e0821102 	add	r1, r2, r2, lsl #2
 51059d0:	e0844101 	add	r4, r4, r1, lsl #2
 51059d4:	e0831101 	add	r1, r3, r1, lsl #2
 51059d8:	e180021c 	orr	r0, r0, ip, lsl r2
 51059dc:	e5830010 	str	r0, [r3, #16]
 51059e0:	e5910034 	ldr	r0, [r1, #52]	; 0x34
 51059e4:	e591c030 	ldr	ip, [r1, #48]	; 0x30
 51059e8:	e5850354 	str	r0, [r5, #852]	; 0x354
 51059ec:	e5907008 	ldr	r7, [r0, #8]
 51059f0:	e28cc001 	add	ip, ip, #1
 51059f4:	e5857358 	str	r7, [r5, #856]	; 0x358
 51059f8:	e5907008 	ldr	r7, [r0, #8]
 51059fc:	e587e004 	str	lr, [r7, #4]
 5105a00:	e580e008 	str	lr, [r0, #8]
 5105a04:	e5854360 	str	r4, [r5, #864]	; 0x360
 5105a08:	e581c030 	str	ip, [r1, #48]	; 0x30
 5105a0c:	eaffffcd 	b	5105948 <vTaskGenericNotifyGiveFromISR+0xb4>
        configASSERT( xTaskToNotify );
 5105a10:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105a14:	e3003900 	movw	r3, #2304	; 0x900
 5105a18:	e3a01d7f 	mov	r1, #8128	; 0x1fc0
 5105a1c:	e3403511 	movt	r3, #1297	; 0x511
 5105a20:	e3400512 	movt	r0, #1298	; 0x512
 5105a24:	e12fff33 	blx	r3
 5105a28:	eaffff9e 	b	51058a8 <vTaskGenericNotifyGiveFromISR+0x14>
 5105a2c:	0511cde8 	.word	0x0511cde8

05105a30 <xTaskGenericNotifyStateClear>:
    {
 5105a30:	e92d4030 	push	{r4, r5, lr}
 5105a34:	e1a04000 	mov	r4, r0
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105a38:	e2515000 	subs	r5, r1, #0
    {
 5105a3c:	e24dd00c 	sub	sp, sp, #12
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105a40:	1a000014 	bne	5105a98 <xTaskGenericNotifyStateClear+0x68>
        pxTCB = prvGetTCBFromHandle( xTask );
 5105a44:	e3540000 	cmp	r4, #0
 5105a48:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5105a4c:	03403511 	movteq	r3, #1297	; 0x511
 5105a50:	0593400c 	ldreq	r4, [r3, #12]
        taskENTER_CRITICAL();
 5105a54:	e30c3930 	movw	r3, #51504	; 0xc930
 5105a58:	e3403510 	movt	r3, #1296	; 0x510
 5105a5c:	e12fff33 	blx	r3
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
 5105a60:	e0844005 	add	r4, r4, r5
 5105a64:	e5d43398 	ldrb	r3, [r4, #920]	; 0x398
 5105a68:	e3530002 	cmp	r3, #2
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 5105a6c:	03a03000 	moveq	r3, #0
                xReturn = pdPASS;
 5105a70:	03a00001 	moveq	r0, #1
                xReturn = pdFAIL;
 5105a74:	13a00000 	movne	r0, #0
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
 5105a78:	05c43398 	strbeq	r3, [r4, #920]	; 0x398
        taskEXIT_CRITICAL();
 5105a7c:	e30c3988 	movw	r3, #51592	; 0xc988
 5105a80:	e3403510 	movt	r3, #1296	; 0x510
 5105a84:	e58d0004 	str	r0, [sp, #4]
 5105a88:	e12fff33 	blx	r3
    }
 5105a8c:	e59d0004 	ldr	r0, [sp, #4]
 5105a90:	e28dd00c 	add	sp, sp, #12
 5105a94:	e8bd8030 	pop	{r4, r5, pc}
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105a98:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105a9c:	e3003900 	movw	r3, #2304	; 0x900
 5105aa0:	e3021032 	movw	r1, #8242	; 0x2032
 5105aa4:	e3403511 	movt	r3, #1297	; 0x511
 5105aa8:	e3400512 	movt	r0, #1298	; 0x512
 5105aac:	e12fff33 	blx	r3
 5105ab0:	eaffffe3 	b	5105a44 <xTaskGenericNotifyStateClear+0x14>

05105ab4 <ulTaskGenericNotifyValueClear>:
    {
 5105ab4:	e92d4070 	push	{r4, r5, r6, lr}
 5105ab8:	e1a04000 	mov	r4, r0
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105abc:	e2515000 	subs	r5, r1, #0
    {
 5105ac0:	e1a06002 	mov	r6, r2
 5105ac4:	e24dd008 	sub	sp, sp, #8
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105ac8:	1a000012 	bne	5105b18 <ulTaskGenericNotifyValueClear+0x64>
        pxTCB = prvGetTCBFromHandle( xTask );
 5105acc:	e3540000 	cmp	r4, #0
 5105ad0:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5105ad4:	03403511 	movteq	r3, #1297	; 0x511
 5105ad8:	0593400c 	ldreq	r4, [r3, #12]
        taskENTER_CRITICAL();
 5105adc:	e30c3930 	movw	r3, #51504	; 0xc930
 5105ae0:	e3403510 	movt	r3, #1296	; 0x510
 5105ae4:	e12fff33 	blx	r3
        taskEXIT_CRITICAL();
 5105ae8:	e30c3988 	movw	r3, #51592	; 0xc988
 5105aec:	e0841105 	add	r1, r4, r5, lsl #2
 5105af0:	e3403510 	movt	r3, #1296	; 0x510
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 5105af4:	e5910394 	ldr	r0, [r1, #916]	; 0x394
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 5105af8:	e591c394 	ldr	ip, [r1, #916]	; 0x394
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
 5105afc:	e58d0004 	str	r0, [sp, #4]
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
 5105b00:	e1cc2006 	bic	r2, ip, r6
 5105b04:	e5812394 	str	r2, [r1, #916]	; 0x394
        taskEXIT_CRITICAL();
 5105b08:	e12fff33 	blx	r3
    }
 5105b0c:	e59d0004 	ldr	r0, [sp, #4]
 5105b10:	e28dd008 	add	sp, sp, #8
 5105b14:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5105b18:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105b1c:	e3003900 	movw	r3, #2304	; 0x900
 5105b20:	e3021059 	movw	r1, #8281	; 0x2059
 5105b24:	e3403511 	movt	r3, #1297	; 0x511
 5105b28:	e3400512 	movt	r0, #1298	; 0x512
 5105b2c:	e12fff33 	blx	r3
 5105b30:	eaffffe5 	b	5105acc <ulTaskGenericNotifyValueClear+0x18>

05105b34 <vTaskSetTimeOutState>:
{
 5105b34:	e92d4010 	push	{r4, lr}
    configASSERT( pxTimeOut );
 5105b38:	e2504000 	subs	r4, r0, #0
 5105b3c:	0a00000b 	beq	5105b70 <vTaskSetTimeOutState+0x3c>
    taskENTER_CRITICAL();
 5105b40:	e30c3930 	movw	r3, #51504	; 0xc930
 5105b44:	e3403510 	movt	r3, #1296	; 0x510
 5105b48:	e12fff33 	blx	r3
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 5105b4c:	e30c3db8 	movw	r3, #52664	; 0xcdb8
    taskEXIT_CRITICAL();
 5105b50:	e30c2988 	movw	r2, #51592	; 0xc988
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 5105b54:	e3403511 	movt	r3, #1297	; 0x511
    taskEXIT_CRITICAL();
 5105b58:	e3402510 	movt	r2, #1296	; 0x510
        pxTimeOut->xOverflowCount = xNumOfOverflows;
 5105b5c:	e5931124 	ldr	r1, [r3, #292]	; 0x124
        pxTimeOut->xTimeOnEntering = xTickCount;
 5105b60:	e5933000 	ldr	r3, [r3]
 5105b64:	e884000a 	stm	r4, {r1, r3}
    taskEXIT_CRITICAL();
 5105b68:	e12fff32 	blx	r2
}
 5105b6c:	e8bd8010 	pop	{r4, pc}
    configASSERT( pxTimeOut );
 5105b70:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105b74:	e3003900 	movw	r3, #2304	; 0x900
 5105b78:	e3011586 	movw	r1, #5510	; 0x1586
 5105b7c:	e3403511 	movt	r3, #1297	; 0x511
 5105b80:	e3400512 	movt	r0, #1298	; 0x512
 5105b84:	e12fff33 	blx	r3
 5105b88:	eaffffec 	b	5105b40 <vTaskSetTimeOutState+0xc>

05105b8c <xTaskCheckForTimeOut>:
{
 5105b8c:	e92d4030 	push	{r4, r5, lr}
 5105b90:	e1a04001 	mov	r4, r1
    configASSERT( pxTimeOut );
 5105b94:	e2505000 	subs	r5, r0, #0
{
 5105b98:	e24dd00c 	sub	sp, sp, #12
    configASSERT( pxTimeOut );
 5105b9c:	0a000030 	beq	5105c64 <xTaskCheckForTimeOut+0xd8>
    configASSERT( pxTicksToWait );
 5105ba0:	e3540000 	cmp	r4, #0
 5105ba4:	0a000036 	beq	5105c84 <xTaskCheckForTimeOut+0xf8>
    taskENTER_CRITICAL();
 5105ba8:	e30c3930 	movw	r3, #51504	; 0xc930
 5105bac:	e3403510 	movt	r3, #1296	; 0x510
 5105bb0:	e12fff33 	blx	r3
        const TickType_t xConstTickCount = xTickCount;
 5105bb4:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105bb8:	e3403511 	movt	r3, #1297	; 0x511
 5105bbc:	e593c000 	ldr	ip, [r3]
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
 5105bc0:	e593200c 	ldr	r2, [r3, #12]
 5105bc4:	e5d2039a 	ldrb	r0, [r2, #922]	; 0x39a
 5105bc8:	e3500000 	cmp	r0, #0
 5105bcc:	0a00000a 	beq	5105bfc <xTaskCheckForTimeOut+0x70>
                pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
 5105bd0:	e3a02000 	mov	r2, #0
                xReturn = pdTRUE;
 5105bd4:	e3a00001 	mov	r0, #1
                pxCurrentTCB->ucDelayAborted = ( uint8_t ) pdFALSE;
 5105bd8:	e593300c 	ldr	r3, [r3, #12]
 5105bdc:	e5c3239a 	strb	r2, [r3, #922]	; 0x39a
                xReturn = pdTRUE;
 5105be0:	e58d0004 	str	r0, [sp, #4]
    taskEXIT_CRITICAL();
 5105be4:	e30c3988 	movw	r3, #51592	; 0xc988
 5105be8:	e3403510 	movt	r3, #1296	; 0x510
 5105bec:	e12fff33 	blx	r3
}
 5105bf0:	e59d0004 	ldr	r0, [sp, #4]
 5105bf4:	e28dd00c 	add	sp, sp, #12
 5105bf8:	e8bd8030 	pop	{r4, r5, pc}
            if( *pxTicksToWait == portMAX_DELAY )
 5105bfc:	e5941000 	ldr	r1, [r4]
 5105c00:	e3710001 	cmn	r1, #1
 5105c04:	0afffff5 	beq	5105be0 <xTaskCheckForTimeOut+0x54>
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
 5105c08:	e5930124 	ldr	r0, [r3, #292]	; 0x124
 5105c0c:	e5952000 	ldr	r2, [r5]
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 5105c10:	e595e004 	ldr	lr, [r5, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) )
 5105c14:	e0520000 	subs	r0, r2, r0
 5105c18:	13a00001 	movne	r0, #1
 5105c1c:	e15e000c 	cmp	lr, ip
 5105c20:	83a00000 	movhi	r0, #0
 5105c24:	e3500000 	cmp	r0, #0
 5105c28:	1a000009 	bne	5105c54 <xTaskCheckForTimeOut+0xc8>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 5105c2c:	e04c200e 	sub	r2, ip, lr
        else if( xElapsedTime < *pxTicksToWait )
 5105c30:	e1510002 	cmp	r1, r2
 5105c34:	9a000006 	bls	5105c54 <xTaskCheckForTimeOut+0xc8>
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 5105c38:	e5932124 	ldr	r2, [r3, #292]	; 0x124
            *pxTicksToWait -= xElapsedTime;
 5105c3c:	e041100c 	sub	r1, r1, ip
    pxTimeOut->xTimeOnEntering = xTickCount;
 5105c40:	e5933000 	ldr	r3, [r3]
            *pxTicksToWait -= xElapsedTime;
 5105c44:	e081100e 	add	r1, r1, lr
 5105c48:	e5841000 	str	r1, [r4]
    pxTimeOut->xTimeOnEntering = xTickCount;
 5105c4c:	e1c520f0 	strd	r2, [r5]
            xReturn = pdFALSE;
 5105c50:	eaffffe2 	b	5105be0 <xTaskCheckForTimeOut+0x54>
            *pxTicksToWait = ( TickType_t ) 0;
 5105c54:	e3a03000 	mov	r3, #0
            xReturn = pdTRUE;
 5105c58:	e3a00001 	mov	r0, #1
            *pxTicksToWait = ( TickType_t ) 0;
 5105c5c:	e5843000 	str	r3, [r4]
 5105c60:	eaffffde 	b	5105be0 <xTaskCheckForTimeOut+0x54>
    configASSERT( pxTimeOut );
 5105c64:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105c68:	e3003900 	movw	r3, #2304	; 0x900
 5105c6c:	e30115a5 	movw	r1, #5541	; 0x15a5
 5105c70:	e3400512 	movt	r0, #1298	; 0x512
 5105c74:	e3403511 	movt	r3, #1297	; 0x511
 5105c78:	e12fff33 	blx	r3
    configASSERT( pxTicksToWait );
 5105c7c:	e3540000 	cmp	r4, #0
 5105c80:	1affffc8 	bne	5105ba8 <xTaskCheckForTimeOut+0x1c>
 5105c84:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105c88:	e3003900 	movw	r3, #2304	; 0x900
 5105c8c:	e30115a6 	movw	r1, #5542	; 0x15a6
 5105c90:	e3403511 	movt	r3, #1297	; 0x511
 5105c94:	e3400512 	movt	r0, #1298	; 0x512
 5105c98:	e12fff33 	blx	r3
 5105c9c:	eaffffc1 	b	5105ba8 <xTaskCheckForTimeOut+0x1c>

05105ca0 <vTaskResetState>:
    BaseType_t xCoreID;

    /* Task control block. */
    #if ( configNUMBER_OF_CORES == 1 )
    {
        pxCurrentTCB = NULL;
 5105ca0:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5105ca4:	e3a02000 	mov	r2, #0
 5105ca8:	e3403511 	movt	r3, #1297	; 0x511
 5105cac:	e583200c 	str	r2, [r3, #12]
    {
        xYieldPendings[ xCoreID ] = pdFALSE;
    }

    xNumOfOverflows = ( BaseType_t ) 0;
    uxTaskNumber = ( UBaseType_t ) 0U;
 5105cb0:	e5832110 	str	r2, [r3, #272]	; 0x110
        uxDeletedTasksWaitingCleanUp = ( UBaseType_t ) 0U;
 5105cb4:	e5832114 	str	r2, [r3, #276]	; 0x114
    uxCurrentNumberOfTasks = ( UBaseType_t ) 0U;
 5105cb8:	e583202c 	str	r2, [r3, #44]	; 0x2c
    xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 5105cbc:	e5832000 	str	r2, [r3]
    uxTopReadyPriority = tskIDLE_PRIORITY;
 5105cc0:	e5832010 	str	r2, [r3, #16]
    xSchedulerRunning = pdFALSE;
 5105cc4:	e583210c 	str	r2, [r3, #268]	; 0x10c
    xPendedTicks = ( TickType_t ) 0U;
 5105cc8:	e5832128 	str	r2, [r3, #296]	; 0x128
        xYieldPendings[ xCoreID ] = pdFALSE;
 5105ccc:	e583211c 	str	r2, [r3, #284]	; 0x11c
    xNumOfOverflows = ( BaseType_t ) 0;
 5105cd0:	e5832124 	str	r2, [r3, #292]	; 0x124
    xNextTaskUnblockTime = ( TickType_t ) 0U;
 5105cd4:	e5832028 	str	r2, [r3, #40]	; 0x28

    uxSchedulerSuspended = ( UBaseType_t ) 0U;
 5105cd8:	e5832118 	str	r2, [r3, #280]	; 0x118
            ulTaskSwitchedInTime[ xCoreID ] = 0U;
            ulTotalRunTime[ xCoreID ] = 0U;
        }
    }
    #endif /* #if ( configGENERATE_RUN_TIME_STATS == 1 ) */
}
 5105cdc:	e12fff1e 	bx	lr

05105ce0 <xTaskIncrementTick>:
{
 5105ce0:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5105ce4:	e30c4db8 	movw	r4, #52664	; 0xcdb8
    *pp = 0x1256;
 5105ce8:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
 5105cec:	e3012256 	movw	r2, #4694	; 0x1256
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5105cf0:	e3404511 	movt	r4, #1297	; 0x511
    *pp = 0x1256;
 5105cf4:	e583200c 	str	r2, [r3, #12]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5105cf8:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5105cfc:	e3530000 	cmp	r3, #0
 5105d00:	1a00006d 	bne	5105ebc <xTaskIncrementTick+0x1dc>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 5105d04:	e5945000 	ldr	r5, [r4]
 5105d08:	e2855001 	add	r5, r5, #1
        if( xConstTickCount == ( TickType_t ) 0U )
 5105d0c:	e3550000 	cmp	r5, #0
        xTickCount = xConstTickCount;
 5105d10:	e5845000 	str	r5, [r4]
        if( xConstTickCount == ( TickType_t ) 0U )
 5105d14:	1a000012 	bne	5105d64 <xTaskIncrementTick+0x84>
            taskSWITCH_DELAYED_LISTS();
 5105d18:	e5943004 	ldr	r3, [r4, #4]
 5105d1c:	e5933000 	ldr	r3, [r3]
 5105d20:	e3530000 	cmp	r3, #0
 5105d24:	1a000069 	bne	5105ed0 <xTaskIncrementTick+0x1f0>
 5105d28:	e5943004 	ldr	r3, [r4, #4]
 5105d2c:	e5942008 	ldr	r2, [r4, #8]
 5105d30:	e5842004 	str	r2, [r4, #4]
 5105d34:	e5843008 	str	r3, [r4, #8]
 5105d38:	e5943124 	ldr	r3, [r4, #292]	; 0x124
 5105d3c:	e2833001 	add	r3, r3, #1
 5105d40:	e5843124 	str	r3, [r4, #292]	; 0x124
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5105d44:	e5943004 	ldr	r3, [r4, #4]
 5105d48:	e5933000 	ldr	r3, [r3]
 5105d4c:	e3530000 	cmp	r3, #0
        xNextTaskUnblockTime = portMAX_DELAY;
 5105d50:	03e03000 	mvneq	r3, #0
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 5105d54:	15943004 	ldrne	r3, [r4, #4]
 5105d58:	1593300c 	ldrne	r3, [r3, #12]
 5105d5c:	15933000 	ldrne	r3, [r3]
 5105d60:	e5843028 	str	r3, [r4, #40]	; 0x28
        if( xConstTickCount >= xNextTaskUnblockTime )
 5105d64:	e5943028 	ldr	r3, [r4, #40]	; 0x28
 5105d68:	e1530005 	cmp	r3, r5
    BaseType_t xSwitchRequired = pdFALSE;
 5105d6c:	83a00000 	movhi	r0, #0
        if( xConstTickCount >= xNextTaskUnblockTime )
 5105d70:	8a000046 	bhi	5105e90 <xTaskIncrementTick+0x1b0>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5105d74:	e5943004 	ldr	r3, [r4, #4]
 5105d78:	e5930000 	ldr	r0, [r3]
 5105d7c:	e3500000 	cmp	r0, #0
 5105d80:	0a000059 	beq	5105eec <xTaskIncrementTick+0x20c>
    BaseType_t xSwitchRequired = pdFALSE;
 5105d84:	e3a00000 	mov	r0, #0
                    prvAddTaskToReadyList( pxTCB );
 5105d88:	e3a06001 	mov	r6, #1
 5105d8c:	e59fe164 	ldr	lr, [pc, #356]	; 5105ef8 <xTaskIncrementTick+0x218>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105d90:	e1a0c000 	mov	ip, r0
 5105d94:	ea000034 	b	5105e6c <xTaskIncrementTick+0x18c>
 5105d98:	e5938360 	ldr	r8, [r3, #864]	; 0x360
 5105d9c:	e5937354 	ldr	r7, [r3, #852]	; 0x354
 5105da0:	e5931358 	ldr	r1, [r3, #856]	; 0x358
 5105da4:	e5871008 	str	r1, [r7, #8]
 5105da8:	e5817004 	str	r7, [r1, #4]
 5105dac:	e5987004 	ldr	r7, [r8, #4]
 5105db0:	e1570002 	cmp	r7, r2
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5105db4:	e5937374 	ldr	r7, [r3, #884]	; 0x374
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105db8:	05881004 	streq	r1, [r8, #4]
 5105dbc:	e5981000 	ldr	r1, [r8]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5105dc0:	e3570000 	cmp	r7, #0
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105dc4:	e583c360 	str	ip, [r3, #864]	; 0x360
 5105dc8:	e2411001 	sub	r1, r1, #1
 5105dcc:	e5881000 	str	r1, [r8]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5105dd0:	0a00000b 	beq	5105e04 <xTaskIncrementTick+0x124>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 5105dd4:	e5978004 	ldr	r8, [r7, #4]
 5105dd8:	e5931368 	ldr	r1, [r3, #872]	; 0x368
 5105ddc:	e1580009 	cmp	r8, r9
 5105de0:	e593836c 	ldr	r8, [r3, #876]	; 0x36c
 5105de4:	e5818008 	str	r8, [r1, #8]
 5105de8:	e593836c 	ldr	r8, [r3, #876]	; 0x36c
 5105dec:	e5881004 	str	r1, [r8, #4]
 5105df0:	e5971000 	ldr	r1, [r7]
 5105df4:	05878004 	streq	r8, [r7, #4]
 5105df8:	e583c374 	str	ip, [r3, #884]	; 0x374
 5105dfc:	e2411001 	sub	r1, r1, #1
 5105e00:	e5871000 	str	r1, [r7]
                    prvAddTaskToReadyList( pxTCB );
 5105e04:	e5938378 	ldr	r8, [r3, #888]	; 0x378
 5105e08:	e5941010 	ldr	r1, [r4, #16]
 5105e0c:	e1811816 	orr	r1, r1, r6, lsl r8
 5105e10:	e5841010 	str	r1, [r4, #16]
 5105e14:	e0881108 	add	r1, r8, r8, lsl #2
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105e18:	e594b00c 	ldr	fp, [r4, #12]
                    prvAddTaskToReadyList( pxTCB );
 5105e1c:	e084a101 	add	sl, r4, r1, lsl #2
 5105e20:	e08e7101 	add	r7, lr, r1, lsl #2
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105e24:	e59bb378 	ldr	fp, [fp, #888]	; 0x378
                    prvAddTaskToReadyList( pxTCB );
 5105e28:	e59a9034 	ldr	r9, [sl, #52]	; 0x34
 5105e2c:	e5839354 	str	r9, [r3, #852]	; 0x354
                                xSwitchRequired = pdTRUE;
 5105e30:	e158000b 	cmp	r8, fp
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5105e34:	e5948004 	ldr	r8, [r4, #4]
                                xSwitchRequired = pdTRUE;
 5105e38:	83a00001 	movhi	r0, #1
                    prvAddTaskToReadyList( pxTCB );
 5105e3c:	e5991008 	ldr	r1, [r9, #8]
 5105e40:	e5831358 	str	r1, [r3, #856]	; 0x358
 5105e44:	e59a1030 	ldr	r1, [sl, #48]	; 0x30
 5105e48:	e599b008 	ldr	fp, [r9, #8]
 5105e4c:	e58b2004 	str	r2, [fp, #4]
 5105e50:	e2811001 	add	r1, r1, #1
 5105e54:	e5892008 	str	r2, [r9, #8]
 5105e58:	e58a1030 	str	r1, [sl, #48]	; 0x30
 5105e5c:	e5837360 	str	r7, [r3, #864]	; 0x360
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5105e60:	e5983000 	ldr	r3, [r8]
 5105e64:	e3530000 	cmp	r3, #0
 5105e68:	0a00001f 	beq	5105eec <xTaskIncrementTick+0x20c>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 5105e6c:	e5943004 	ldr	r3, [r4, #4]
 5105e70:	e593300c 	ldr	r3, [r3, #12]
 5105e74:	e593300c 	ldr	r3, [r3, #12]
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105e78:	e2832e35 	add	r2, r3, #848	; 0x350
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 5105e7c:	e5931350 	ldr	r1, [r3, #848]	; 0x350
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 5105e80:	e2839fd9 	add	r9, r3, #868	; 0x364
                    if( xConstTickCount < xItemValue )
 5105e84:	e1550001 	cmp	r5, r1
 5105e88:	2affffc2 	bcs	5105d98 <xTaskIncrementTick+0xb8>
                        xNextTaskUnblockTime = xItemValue;
 5105e8c:	e5841028 	str	r1, [r4, #40]	; 0x28
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
 5105e90:	e594300c 	ldr	r3, [r4, #12]
                if( xYieldPendings[ 0 ] != pdFALSE )
 5105e94:	e594211c 	ldr	r2, [r4, #284]	; 0x11c
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > 1U )
 5105e98:	e5933378 	ldr	r3, [r3, #888]	; 0x378
 5105e9c:	e0833103 	add	r3, r3, r3, lsl #2
 5105ea0:	e0844103 	add	r4, r4, r3, lsl #2
 5105ea4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
                    xSwitchRequired = pdTRUE;
 5105ea8:	e3530002 	cmp	r3, #2
 5105eac:	23a00001 	movcs	r0, #1
                    xSwitchRequired = pdTRUE;
 5105eb0:	e3520000 	cmp	r2, #0
 5105eb4:	13a00001 	movne	r0, #1
 5105eb8:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        xPendedTicks += 1U;
 5105ebc:	e5943128 	ldr	r3, [r4, #296]	; 0x128
    BaseType_t xSwitchRequired = pdFALSE;
 5105ec0:	e3a00000 	mov	r0, #0
        xPendedTicks += 1U;
 5105ec4:	e2833001 	add	r3, r3, #1
 5105ec8:	e5843128 	str	r3, [r4, #296]	; 0x128
}
 5105ecc:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            taskSWITCH_DELAYED_LISTS();
 5105ed0:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5105ed4:	e3003900 	movw	r3, #2304	; 0x900
 5105ed8:	e301125f 	movw	r1, #4703	; 0x125f
 5105edc:	e3403511 	movt	r3, #1297	; 0x511
 5105ee0:	e3400512 	movt	r0, #1298	; 0x512
 5105ee4:	e12fff33 	blx	r3
 5105ee8:	eaffff8e 	b	5105d28 <xTaskIncrementTick+0x48>
                    xNextTaskUnblockTime = portMAX_DELAY;
 5105eec:	e3e03000 	mvn	r3, #0
 5105ef0:	e5843028 	str	r3, [r4, #40]	; 0x28
                    break;
 5105ef4:	eaffffe5 	b	5105e90 <xTaskIncrementTick+0x1b0>
 5105ef8:	0511cde8 	.word	0x0511cde8

05105efc <xTaskResumeAll>:
{
 5105efc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
            configASSERT( uxSchedulerSuspended != 0U );
 5105f00:	e30c4db8 	movw	r4, #52664	; 0xcdb8
        taskENTER_CRITICAL();
 5105f04:	e30c3930 	movw	r3, #51504	; 0xc930
            configASSERT( uxSchedulerSuspended != 0U );
 5105f08:	e3404511 	movt	r4, #1297	; 0x511
        taskENTER_CRITICAL();
 5105f0c:	e3403510 	movt	r3, #1296	; 0x510
{
 5105f10:	e24dd00c 	sub	sp, sp, #12
        taskENTER_CRITICAL();
 5105f14:	e12fff33 	blx	r3
            configASSERT( uxSchedulerSuspended != 0U );
 5105f18:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5105f1c:	e3530000 	cmp	r3, #0
 5105f20:	0a00005e 	beq	51060a0 <xTaskResumeAll+0x1a4>
            uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended - 1U );
 5105f24:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5105f28:	e2433001 	sub	r3, r3, #1
 5105f2c:	e5843118 	str	r3, [r4, #280]	; 0x118
            if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5105f30:	e5945118 	ldr	r5, [r4, #280]	; 0x118
 5105f34:	e3550000 	cmp	r5, #0
 5105f38:	1a000050 	bne	5106080 <xTaskResumeAll+0x184>
                if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 5105f3c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5105f40:	e3530000 	cmp	r3, #0
 5105f44:	0a00004d 	beq	5106080 <xTaskResumeAll+0x184>
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 5105f48:	e59430e4 	ldr	r3, [r4, #228]	; 0xe4
 5105f4c:	e3530000 	cmp	r3, #0
 5105f50:	0a00003d 	beq	510604c <xTaskResumeAll+0x150>
 5105f54:	e59f7180 	ldr	r7, [pc, #384]	; 51060dc <xTaskResumeAll+0x1e0>
                        prvAddTaskToReadyList( pxTCB );
 5105f58:	e3a06001 	mov	r6, #1
                        pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 5105f5c:	e59430f0 	ldr	r3, [r4, #240]	; 0xf0
 5105f60:	e593300c 	ldr	r3, [r3, #12]
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 5105f64:	e283cfd9 	add	ip, r3, #868	; 0x364
 5105f68:	e5932374 	ldr	r2, [r3, #884]	; 0x374
 5105f6c:	e5930368 	ldr	r0, [r3, #872]	; 0x368
 5105f70:	e593136c 	ldr	r1, [r3, #876]	; 0x36c
 5105f74:	e5801008 	str	r1, [r0, #8]
 5105f78:	e5810004 	str	r0, [r1, #4]
 5105f7c:	e5920004 	ldr	r0, [r2, #4]
 5105f80:	e150000c 	cmp	r0, ip
 5105f84:	05821004 	streq	r1, [r2, #4]
 5105f88:	e5921000 	ldr	r1, [r2]
 5105f8c:	e5835374 	str	r5, [r3, #884]	; 0x374
 5105f90:	e2411001 	sub	r1, r1, #1
 5105f94:	e5821000 	str	r1, [r2]
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105f98:	e5930360 	ldr	r0, [r3, #864]	; 0x360
 5105f9c:	e2838e35 	add	r8, r3, #848	; 0x350
 5105fa0:	e5931354 	ldr	r1, [r3, #852]	; 0x354
 5105fa4:	e5932358 	ldr	r2, [r3, #856]	; 0x358
 5105fa8:	e5812008 	str	r2, [r1, #8]
 5105fac:	e5821004 	str	r1, [r2, #4]
 5105fb0:	e5901004 	ldr	r1, [r0, #4]
 5105fb4:	e590c000 	ldr	ip, [r0]
                        prvAddTaskToReadyList( pxTCB );
 5105fb8:	e594e010 	ldr	lr, [r4, #16]
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105fbc:	e1510008 	cmp	r1, r8
 5105fc0:	e24cc001 	sub	ip, ip, #1
 5105fc4:	05802004 	streq	r2, [r0, #4]
                        prvAddTaskToReadyList( pxTCB );
 5105fc8:	e5932378 	ldr	r2, [r3, #888]	; 0x378
                        listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 5105fcc:	e580c000 	str	ip, [r0]
                        prvAddTaskToReadyList( pxTCB );
 5105fd0:	e18ee216 	orr	lr, lr, r6, lsl r2
 5105fd4:	e0821102 	add	r1, r2, r2, lsl #2
 5105fd8:	e584e010 	str	lr, [r4, #16]
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5105fdc:	e594900c 	ldr	r9, [r4, #12]
                        prvAddTaskToReadyList( pxTCB );
 5105fe0:	e084c101 	add	ip, r4, r1, lsl #2
 5105fe4:	e0871101 	add	r1, r7, r1, lsl #2
 5105fe8:	e59c0034 	ldr	r0, [ip, #52]	; 0x34
 5105fec:	e5830354 	str	r0, [r3, #852]	; 0x354
 5105ff0:	e590e008 	ldr	lr, [r0, #8]
 5105ff4:	e583e358 	str	lr, [r3, #856]	; 0x358
 5105ff8:	e590e008 	ldr	lr, [r0, #8]
 5105ffc:	e58e8004 	str	r8, [lr, #4]
 5106000:	e59ce030 	ldr	lr, [ip, #48]	; 0x30
 5106004:	e5808008 	str	r8, [r0, #8]
 5106008:	e5831360 	str	r1, [r3, #864]	; 0x360
 510600c:	e28e3001 	add	r3, lr, #1
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5106010:	e5991378 	ldr	r1, [r9, #888]	; 0x378
                        prvAddTaskToReadyList( pxTCB );
 5106014:	e58c3030 	str	r3, [ip, #48]	; 0x30
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 5106018:	e59430e4 	ldr	r3, [r4, #228]	; 0xe4
                            if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 510601c:	e1520001 	cmp	r2, r1
                                xYieldPendings[ xCoreID ] = pdTRUE;
 5106020:	8584611c 	strhi	r6, [r4, #284]	; 0x11c
                    while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 5106024:	e3530000 	cmp	r3, #0
 5106028:	1affffcb 	bne	5105f5c <xTaskResumeAll+0x60>
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 510602c:	e5943004 	ldr	r3, [r4, #4]
 5106030:	e5933000 	ldr	r3, [r3]
 5106034:	e3530000 	cmp	r3, #0
        xNextTaskUnblockTime = portMAX_DELAY;
 5106038:	03e03000 	mvneq	r3, #0
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 510603c:	15943004 	ldrne	r3, [r4, #4]
 5106040:	1593300c 	ldrne	r3, [r3, #12]
 5106044:	15933000 	ldrne	r3, [r3]
 5106048:	e5843028 	str	r3, [r4, #40]	; 0x28
                        TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 510604c:	e5945128 	ldr	r5, [r4, #296]	; 0x128
                        if( xPendedCounts > ( TickType_t ) 0U )
 5106050:	e3550000 	cmp	r5, #0
 5106054:	0a000006 	beq	5106074 <xTaskResumeAll+0x178>
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 5106058:	e3a06001 	mov	r6, #1
                                if( xTaskIncrementTick() != pdFALSE )
 510605c:	ebffff1f 	bl	5105ce0 <xTaskIncrementTick>
 5106060:	e3500000 	cmp	r0, #0
                                    xYieldPendings[ xCoreID ] = pdTRUE;
 5106064:	1584611c 	strne	r6, [r4, #284]	; 0x11c
                            } while( xPendedCounts > ( TickType_t ) 0U );
 5106068:	e2555001 	subs	r5, r5, #1
 510606c:	1afffffa 	bne	510605c <xTaskResumeAll+0x160>
                            xPendedTicks = 0;
 5106070:	e5845128 	str	r5, [r4, #296]	; 0x128
                    if( xYieldPendings[ xCoreID ] != pdFALSE )
 5106074:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
 5106078:	e3530000 	cmp	r3, #0
 510607c:	1a00000e 	bne	51060bc <xTaskResumeAll+0x1c0>
    BaseType_t xAlreadyYielded = pdFALSE;
 5106080:	e3a00000 	mov	r0, #0
 5106084:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5106088:	e30c3988 	movw	r3, #51592	; 0xc988
 510608c:	e3403510 	movt	r3, #1296	; 0x510
 5106090:	e12fff33 	blx	r3
}
 5106094:	e59d0004 	ldr	r0, [sp, #4]
 5106098:	e28dd00c 	add	sp, sp, #12
 510609c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
            configASSERT( uxSchedulerSuspended != 0U );
 51060a0:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51060a4:	e3003900 	movw	r3, #2304	; 0x900
 51060a8:	e3001f88 	movw	r1, #3976	; 0xf88
 51060ac:	e3403511 	movt	r3, #1297	; 0x511
 51060b0:	e3400512 	movt	r0, #1298	; 0x512
 51060b4:	e12fff33 	blx	r3
 51060b8:	eaffff99 	b	5105f24 <xTaskResumeAll+0x28>
                            xAlreadyYielded = pdTRUE;
 51060bc:	e3a00001 	mov	r0, #1
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 51060c0:	e3003000 	movw	r3, #0
 51060c4:	e594200c 	ldr	r2, [r4, #12]
 51060c8:	e3403511 	movt	r3, #1297	; 0x511
                            xAlreadyYielded = pdTRUE;
 51060cc:	e58d0004 	str	r0, [sp, #4]
                            taskYIELD_TASK_CORE_IF_USING_PREEMPTION( pxCurrentTCB );
 51060d0:	e12fff33 	blx	r3
 51060d4:	e59d0004 	ldr	r0, [sp, #4]
 51060d8:	eaffffe9 	b	5106084 <xTaskResumeAll+0x188>
 51060dc:	0511cde8 	.word	0x0511cde8

051060e0 <vTaskDelay>:
    {
 51060e0:	e92d4010 	push	{r4, lr}
        if( xTicksToDelay > ( TickType_t ) 0U )
 51060e4:	e2504000 	subs	r4, r0, #0
 51060e8:	0a00000d 	beq	5106124 <vTaskDelay+0x44>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 51060ec:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51060f0:	e3403511 	movt	r3, #1297	; 0x511
 51060f4:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 51060f8:	e2822001 	add	r2, r2, #1
 51060fc:	e5832118 	str	r2, [r3, #280]	; 0x118
                configASSERT( uxSchedulerSuspended == 1U );
 5106100:	e5933118 	ldr	r3, [r3, #280]	; 0x118
 5106104:	e3530001 	cmp	r3, #1
 5106108:	1a000009 	bne	5106134 <vTaskDelay+0x54>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 510610c:	e3a01000 	mov	r1, #0
 5106110:	e1a00004 	mov	r0, r4
 5106114:	ebfff7ea 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = xTaskResumeAll();
 5106118:	ebffff77 	bl	5105efc <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 510611c:	e3500000 	cmp	r0, #0
 5106120:	18bd8010 	popne	{r4, pc}
            taskYIELD_WITHIN_API();
 5106124:	e3003000 	movw	r3, #0
 5106128:	e3403511 	movt	r3, #1297	; 0x511
 510612c:	e12fff33 	blx	r3
 5106130:	e8bd8010 	pop	{r4, pc}
                configASSERT( uxSchedulerSuspended == 1U );
 5106134:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106138:	e3003900 	movw	r3, #2304	; 0x900
 510613c:	e300198c 	movw	r1, #2444	; 0x98c
 5106140:	e3403511 	movt	r3, #1297	; 0x511
 5106144:	e3400512 	movt	r0, #1298	; 0x512
 5106148:	e12fff33 	blx	r3
 510614c:	eaffffee 	b	510610c <vTaskDelay+0x2c>

05106150 <xTaskDelayUntil>:
    {
 5106150:	e92d4070 	push	{r4, r5, r6, lr}
 5106154:	e1a04001 	mov	r4, r1
        configASSERT( pxPreviousWakeTime );
 5106158:	e2505000 	subs	r5, r0, #0
 510615c:	0a00003a 	beq	510624c <xTaskDelayUntil+0xfc>
        configASSERT( ( xTimeIncrement > 0U ) );
 5106160:	e3540000 	cmp	r4, #0
 5106164:	0a000031 	beq	5106230 <xTaskDelayUntil+0xe0>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5106168:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 510616c:	e3403511 	movt	r3, #1297	; 0x511
 5106170:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 5106174:	e2822001 	add	r2, r2, #1
 5106178:	e5832118 	str	r2, [r3, #280]	; 0x118
            const TickType_t xConstTickCount = xTickCount;
 510617c:	e5936000 	ldr	r6, [r3]
            configASSERT( uxSchedulerSuspended == 1U );
 5106180:	e5933118 	ldr	r3, [r3, #280]	; 0x118
 5106184:	e3530001 	cmp	r3, #1
 5106188:	0a000005 	beq	51061a4 <xTaskDelayUntil+0x54>
 510618c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106190:	e3003900 	movw	r3, #2304	; 0x900
 5106194:	e3001936 	movw	r1, #2358	; 0x936
 5106198:	e3400512 	movt	r0, #1298	; 0x512
 510619c:	e3403511 	movt	r3, #1297	; 0x511
 51061a0:	e12fff33 	blx	r3
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 51061a4:	e5953000 	ldr	r3, [r5]
 51061a8:	e0934004 	adds	r4, r3, r4
 51061ac:	23a00001 	movcs	r0, #1
 51061b0:	33a00000 	movcc	r0, #0
            if( xConstTickCount < *pxPreviousWakeTime )
 51061b4:	e1530006 	cmp	r3, r6
 51061b8:	9a000008 	bls	51061e0 <xTaskDelayUntil+0x90>
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 51061bc:	e3500000 	cmp	r0, #0
 51061c0:	1a000017 	bne	5106224 <xTaskDelayUntil+0xd4>
            *pxPreviousWakeTime = xTimeToWake;
 51061c4:	e5854000 	str	r4, [r5]
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
 51061c8:	e3a06000 	mov	r6, #0
        xAlreadyYielded = xTaskResumeAll();
 51061cc:	ebffff4a 	bl	5105efc <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 51061d0:	e3500000 	cmp	r0, #0
 51061d4:	0a00000d 	beq	5106210 <xTaskDelayUntil+0xc0>
    }
 51061d8:	e1a00006 	mov	r0, r6
 51061dc:	e8bd8070 	pop	{r4, r5, r6, pc}
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 51061e0:	e1560004 	cmp	r6, r4
 51061e4:	33800001 	orrcc	r0, r0, #1
 51061e8:	e3500000 	cmp	r0, #0
 51061ec:	0afffff4 	beq	51061c4 <xTaskDelayUntil+0x74>
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 51061f0:	e3a01000 	mov	r1, #0
 51061f4:	e0440006 	sub	r0, r4, r6
            *pxPreviousWakeTime = xTimeToWake;
 51061f8:	e5854000 	str	r4, [r5]
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
 51061fc:	e3a06001 	mov	r6, #1
 5106200:	ebfff7af 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
        xAlreadyYielded = xTaskResumeAll();
 5106204:	ebffff3c 	bl	5105efc <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 5106208:	e3500000 	cmp	r0, #0
 510620c:	1afffff1 	bne	51061d8 <xTaskDelayUntil+0x88>
            taskYIELD_WITHIN_API();
 5106210:	e3003000 	movw	r3, #0
 5106214:	e3403511 	movt	r3, #1297	; 0x511
 5106218:	e12fff33 	blx	r3
    }
 510621c:	e1a00006 	mov	r0, r6
 5106220:	e8bd8070 	pop	{r4, r5, r6, pc}
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 5106224:	e1560004 	cmp	r6, r4
 5106228:	3afffff0 	bcc	51061f0 <xTaskDelayUntil+0xa0>
 510622c:	eaffffe4 	b	51061c4 <xTaskDelayUntil+0x74>
        configASSERT( ( xTimeIncrement > 0U ) );
 5106230:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106234:	e3003900 	movw	r3, #2304	; 0x900
 5106238:	e300192e 	movw	r1, #2350	; 0x92e
 510623c:	e3403511 	movt	r3, #1297	; 0x511
 5106240:	e3400512 	movt	r0, #1298	; 0x512
 5106244:	e12fff33 	blx	r3
 5106248:	eaffffc6 	b	5106168 <xTaskDelayUntil+0x18>
        configASSERT( pxPreviousWakeTime );
 510624c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106250:	e3003900 	movw	r3, #2304	; 0x900
 5106254:	e300192d 	movw	r1, #2349	; 0x92d
 5106258:	e3403511 	movt	r3, #1297	; 0x511
 510625c:	e3400512 	movt	r0, #1298	; 0x512
 5106260:	e12fff33 	blx	r3
 5106264:	eaffffbd 	b	5106160 <xTaskDelayUntil+0x10>

05106268 <xTaskAbortDelay>:
    {
 5106268:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        configASSERT( pxTCB );
 510626c:	e2504000 	subs	r4, r0, #0
 5106270:	0a000038 	beq	5106358 <xTaskAbortDelay+0xf0>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5106274:	e30c5db8 	movw	r5, #52664	; 0xcdb8
 5106278:	e3405511 	movt	r5, #1297	; 0x511
 510627c:	e5953118 	ldr	r3, [r5, #280]	; 0x118
 5106280:	e2833001 	add	r3, r3, #1
 5106284:	e5853118 	str	r3, [r5, #280]	; 0x118
            if( eTaskGetState( xTask ) == eBlocked )
 5106288:	e1a00004 	mov	r0, r4
 510628c:	ebfffa7c 	bl	5104c84 <eTaskGetState>
 5106290:	e3500002 	cmp	r0, #2
                xReturn = pdFAIL;
 5106294:	13a04000 	movne	r4, #0
            if( eTaskGetState( xTask ) == eBlocked )
 5106298:	0a000002 	beq	51062a8 <xTaskAbortDelay+0x40>
        ( void ) xTaskResumeAll();
 510629c:	ebffff16 	bl	5105efc <xTaskResumeAll>
    }
 51062a0:	e1a00004 	mov	r0, r4
 51062a4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 51062a8:	e3006cd8 	movw	r6, #3288	; 0xcd8
 51062ac:	e2847e35 	add	r7, r4, #848	; 0x350
 51062b0:	e1a00007 	mov	r0, r7
 51062b4:	e3406510 	movt	r6, #1296	; 0x510
 51062b8:	e12fff36 	blx	r6
                taskENTER_CRITICAL();
 51062bc:	e30c3930 	movw	r3, #51504	; 0xc930
 51062c0:	e3403510 	movt	r3, #1296	; 0x510
 51062c4:	e12fff33 	blx	r3
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 51062c8:	e5943374 	ldr	r3, [r4, #884]	; 0x374
 51062cc:	e3530000 	cmp	r3, #0
 51062d0:	0a000003 	beq	51062e4 <xTaskAbortDelay+0x7c>
                        ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 51062d4:	e2840fd9 	add	r0, r4, #868	; 0x364
 51062d8:	e12fff36 	blx	r6
                        pxTCB->ucDelayAborted = ( uint8_t ) pdTRUE;
 51062dc:	e3a03001 	mov	r3, #1
 51062e0:	e5c4339a 	strb	r3, [r4, #922]	; 0x39a
                taskEXIT_CRITICAL();
 51062e4:	e30c3988 	movw	r3, #51592	; 0xc988
 51062e8:	e3403510 	movt	r3, #1296	; 0x510
 51062ec:	e12fff33 	blx	r3
                prvAddTaskToReadyList( pxTCB );
 51062f0:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 51062f4:	e5952010 	ldr	r2, [r5, #16]
 51062f8:	e3a0c001 	mov	ip, #1
 51062fc:	e59f0070 	ldr	r0, [pc, #112]	; 5106374 <xTaskAbortDelay+0x10c>
 5106300:	e182231c 	orr	r2, r2, ip, lsl r3
 5106304:	e0831103 	add	r1, r3, r3, lsl #2
 5106308:	e5852010 	str	r2, [r5, #16]
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 510630c:	e595200c 	ldr	r2, [r5, #12]
                prvAddTaskToReadyList( pxTCB );
 5106310:	e0800101 	add	r0, r0, r1, lsl #2
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 5106314:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5106318:	e1530002 	cmp	r3, r2
                prvAddTaskToReadyList( pxTCB );
 510631c:	e0852101 	add	r2, r5, r1, lsl #2
                            xYieldPendings[ 0 ] = pdTRUE;
 5106320:	8585c11c 	strhi	ip, [r5, #284]	; 0x11c
                prvAddTaskToReadyList( pxTCB );
 5106324:	e5923034 	ldr	r3, [r2, #52]	; 0x34
 5106328:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 510632c:	e5843354 	str	r3, [r4, #852]	; 0x354
 5106330:	e593e008 	ldr	lr, [r3, #8]
 5106334:	e081100c 	add	r1, r1, ip
 5106338:	e584e358 	str	lr, [r4, #856]	; 0x358
 510633c:	e593e008 	ldr	lr, [r3, #8]
 5106340:	e58e7004 	str	r7, [lr, #4]
 5106344:	e5837008 	str	r7, [r3, #8]
 5106348:	e5840360 	str	r0, [r4, #864]	; 0x360
                xReturn = pdPASS;
 510634c:	e1a0400c 	mov	r4, ip
                prvAddTaskToReadyList( pxTCB );
 5106350:	e5821030 	str	r1, [r2, #48]	; 0x30
                            xYieldPendings[ 0 ] = pdTRUE;
 5106354:	eaffffd0 	b	510629c <xTaskAbortDelay+0x34>
        configASSERT( pxTCB );
 5106358:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510635c:	e3003900 	movw	r3, #2304	; 0x900
 5106360:	e30111e4 	movw	r1, #4580	; 0x11e4
 5106364:	e3403511 	movt	r3, #1297	; 0x511
 5106368:	e3400512 	movt	r0, #1298	; 0x512
 510636c:	e12fff33 	blx	r3
 5106370:	eaffffbf 	b	5106274 <xTaskAbortDelay+0xc>
 5106374:	0511cde8 	.word	0x0511cde8

05106378 <xTaskGetHandle>:
        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
 5106378:	e3003331 	movw	r3, #817	; 0x331
    {
 510637c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5106380:	e1a06000 	mov	r6, r0
        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
 5106384:	e3403511 	movt	r3, #1297	; 0x511
 5106388:	e12fff33 	blx	r3
 510638c:	e3500009 	cmp	r0, #9
 5106390:	8a000025 	bhi	510642c <xTaskGetHandle+0xb4>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5106394:	e30c7db8 	movw	r7, #52664	; 0xcdb8
 5106398:	e3407511 	movt	r7, #1297	; 0x511
 510639c:	e5973118 	ldr	r3, [r7, #280]	; 0x118
 51063a0:	e2833001 	add	r3, r3, #1
 51063a4:	e5873118 	str	r3, [r7, #280]	; 0x118
    traceRETURN_vTaskSuspendAll();
 51063a8:	e2878030 	add	r8, r7, #48	; 0x30
 51063ac:	e28750a8 	add	r5, r7, #168	; 0xa8
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) &( pxReadyTasksLists[ uxQueue ] ), pcNameToQuery );
 51063b0:	e1a00005 	mov	r0, r5
 51063b4:	e1a01006 	mov	r1, r6
 51063b8:	ebfff787 	bl	51041dc <prvSearchForNameWithinSingleList>
            } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );
 51063bc:	e2453014 	sub	r3, r5, #20
                if( pxTCB != NULL )
 51063c0:	e2504000 	subs	r4, r0, #0
 51063c4:	1a000015 	bne	5106420 <xTaskGetHandle+0xa8>
            } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY );
 51063c8:	e1580005 	cmp	r8, r5
 51063cc:	e1a05003 	mov	r5, r3
 51063d0:	1afffff6 	bne	51063b0 <xTaskGetHandle+0x38>
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxDelayedTaskList, pcNameToQuery );
 51063d4:	e5970004 	ldr	r0, [r7, #4]
 51063d8:	e1a01006 	mov	r1, r6
 51063dc:	ebfff77e 	bl	51041dc <prvSearchForNameWithinSingleList>
            if( pxTCB == NULL )
 51063e0:	e2504000 	subs	r4, r0, #0
 51063e4:	1a00000d 	bne	5106420 <xTaskGetHandle+0xa8>
                pxTCB = prvSearchForNameWithinSingleList( ( List_t * ) pxOverflowDelayedTaskList, pcNameToQuery );
 51063e8:	e5970008 	ldr	r0, [r7, #8]
 51063ec:	e1a01006 	mov	r1, r6
 51063f0:	ebfff779 	bl	51041dc <prvSearchForNameWithinSingleList>
                if( pxTCB == NULL )
 51063f4:	e2504000 	subs	r4, r0, #0
 51063f8:	1a000008 	bne	5106420 <xTaskGetHandle+0xa8>
                    pxTCB = prvSearchForNameWithinSingleList( &xSuspendedTaskList, pcNameToQuery );
 51063fc:	e59f0044 	ldr	r0, [pc, #68]	; 5106448 <xTaskGetHandle+0xd0>
 5106400:	e1a01006 	mov	r1, r6
 5106404:	ebfff774 	bl	51041dc <prvSearchForNameWithinSingleList>
                if( pxTCB == NULL )
 5106408:	e2504000 	subs	r4, r0, #0
 510640c:	1a000003 	bne	5106420 <xTaskGetHandle+0xa8>
                    pxTCB = prvSearchForNameWithinSingleList( &xTasksWaitingTermination, pcNameToQuery );
 5106410:	e59f0034 	ldr	r0, [pc, #52]	; 510644c <xTaskGetHandle+0xd4>
 5106414:	e1a01006 	mov	r1, r6
 5106418:	ebfff76f 	bl	51041dc <prvSearchForNameWithinSingleList>
 510641c:	e1a04000 	mov	r4, r0
        ( void ) xTaskResumeAll();
 5106420:	ebfffeb5 	bl	5105efc <xTaskResumeAll>
    }
 5106424:	e1a00004 	mov	r0, r4
 5106428:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( strlen( pcNameToQuery ) < configMAX_TASK_NAME_LEN );
 510642c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106430:	e3003900 	movw	r3, #2304	; 0x900
 5106434:	e30110ac 	movw	r1, #4268	; 0x10ac
 5106438:	e3403511 	movt	r3, #1297	; 0x511
 510643c:	e3400512 	movt	r0, #1298	; 0x512
 5106440:	e12fff33 	blx	r3
 5106444:	eaffffd2 	b	5106394 <xTaskGetHandle+0x1c>
 5106448:	0511cdcc 	.word	0x0511cdcc
 510644c:	0511ceb0 	.word	0x0511ceb0

05106450 <xTaskGenericNotifyWait>:
    {
 5106450:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5106454:	e24dd00c 	sub	sp, sp, #12
 5106458:	e1a07001 	mov	r7, r1
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 510645c:	e2505000 	subs	r5, r0, #0
    {
 5106460:	e1a09002 	mov	r9, r2
 5106464:	e1a08003 	mov	r8, r3
 5106468:	e59da030 	ldr	sl, [sp, #48]	; 0x30
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 510646c:	1a000043 	bne	5106580 <xTaskGenericNotifyWait+0x130>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 5106470:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 5106474:	e3404511 	movt	r4, #1297	; 0x511
 5106478:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 510647c:	e2833001 	add	r3, r3, #1
 5106480:	e5843118 	str	r3, [r4, #280]	; 0x118
            taskENTER_CRITICAL();
 5106484:	e30c6930 	movw	r6, #51504	; 0xc930
 5106488:	e3406510 	movt	r6, #1296	; 0x510
 510648c:	e12fff36 	blx	r6
                if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
 5106490:	e594300c 	ldr	r3, [r4, #12]
 5106494:	e0833005 	add	r3, r3, r5
 5106498:	e5d33398 	ldrb	r3, [r3, #920]	; 0x398
 510649c:	e3530002 	cmp	r3, #2
 51064a0:	0a000017 	beq	5106504 <xTaskGenericNotifyWait+0xb4>
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
 51064a4:	e594300c 	ldr	r3, [r4, #12]
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 51064a8:	e3a0b001 	mov	fp, #1
                    if( xTicksToWait > ( TickType_t ) 0 )
 51064ac:	e35a0000 	cmp	sl, #0
 51064b0:	e0833105 	add	r3, r3, r5, lsl #2
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnEntry;
 51064b4:	e5931394 	ldr	r1, [r3, #916]	; 0x394
 51064b8:	e1c17007 	bic	r7, r1, r7
 51064bc:	e5837394 	str	r7, [r3, #916]	; 0x394
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 51064c0:	e594300c 	ldr	r3, [r4, #12]
 51064c4:	e0833005 	add	r3, r3, r5
 51064c8:	e5c3b398 	strb	fp, [r3, #920]	; 0x398
                    if( xTicksToWait > ( TickType_t ) 0 )
 51064cc:	0a00000c 	beq	5106504 <xTaskGenericNotifyWait+0xb4>
            taskEXIT_CRITICAL();
 51064d0:	e30c7988 	movw	r7, #51592	; 0xc988
 51064d4:	e3407510 	movt	r7, #1296	; 0x510
 51064d8:	e12fff37 	blx	r7
                prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 51064dc:	e1a0100b 	mov	r1, fp
 51064e0:	e1a0000a 	mov	r0, sl
 51064e4:	ebfff6f6 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
        xAlreadyYielded = xTaskResumeAll();
 51064e8:	ebfffe83 	bl	5105efc <xTaskResumeAll>
        if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
 51064ec:	e3500000 	cmp	r0, #0
 51064f0:	1a000007 	bne	5106514 <xTaskGenericNotifyWait+0xc4>
            taskYIELD_WITHIN_API();
 51064f4:	e3003000 	movw	r3, #0
 51064f8:	e3403511 	movt	r3, #1297	; 0x511
 51064fc:	e12fff33 	blx	r3
 5106500:	ea000003 	b	5106514 <xTaskGenericNotifyWait+0xc4>
            taskEXIT_CRITICAL();
 5106504:	e30c7988 	movw	r7, #51592	; 0xc988
 5106508:	e3407510 	movt	r7, #1296	; 0x510
 510650c:	e12fff37 	blx	r7
        xAlreadyYielded = xTaskResumeAll();
 5106510:	ebfffe79 	bl	5105efc <xTaskResumeAll>
        taskENTER_CRITICAL();
 5106514:	e12fff36 	blx	r6
            if( pulNotificationValue != NULL )
 5106518:	e3580000 	cmp	r8, #0
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
 510651c:	128520e4 	addne	r2, r5, #228	; 0xe4
 5106520:	1594300c 	ldrne	r3, [r4, #12]
 5106524:	10833102 	addne	r3, r3, r2, lsl #2
 5106528:	15933004 	ldrne	r3, [r3, #4]
 510652c:	15883000 	strne	r3, [r8]
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] != taskNOTIFICATION_RECEIVED )
 5106530:	e594300c 	ldr	r3, [r4, #12]
 5106534:	e0833005 	add	r3, r3, r5
 5106538:	e5d33398 	ldrb	r3, [r3, #920]	; 0x398
 510653c:	e3530002 	cmp	r3, #2
                xReturn = pdTRUE;
 5106540:	03a00001 	moveq	r0, #1
                xReturn = pdFALSE;
 5106544:	13a00000 	movne	r0, #0
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
 5106548:	0594300c 	ldreq	r3, [r4, #12]
 510654c:	e58d0004 	str	r0, [sp, #4]
 5106550:	00833105 	addeq	r3, r3, r5, lsl #2
 5106554:	05932394 	ldreq	r2, [r3, #916]	; 0x394
 5106558:	01c29009 	biceq	r9, r2, r9
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
 510655c:	e3a02000 	mov	r2, #0
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] &= ~ulBitsToClearOnExit;
 5106560:	05839394 	streq	r9, [r3, #916]	; 0x394
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
 5106564:	e594300c 	ldr	r3, [r4, #12]
 5106568:	e0835005 	add	r5, r3, r5
 510656c:	e5c52398 	strb	r2, [r5, #920]	; 0x398
        taskEXIT_CRITICAL();
 5106570:	e12fff37 	blx	r7
    }
 5106574:	e59d0004 	ldr	r0, [sp, #4]
 5106578:	e28dd00c 	add	sp, sp, #12
 510657c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 5106580:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106584:	e3003900 	movw	r3, #2304	; 0x900
 5106588:	e3011e2f 	movw	r1, #7727	; 0x1e2f
 510658c:	e3403511 	movt	r3, #1297	; 0x511
 5106590:	e3400512 	movt	r0, #1298	; 0x512
 5106594:	e12fff33 	blx	r3
 5106598:	eaffffb4 	b	5106470 <xTaskGenericNotifyWait+0x20>

0510659c <ulTaskGenericNotifyTake>:
    {
 510659c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 51065a0:	e1a0a001 	mov	sl, r1
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 51065a4:	e2505000 	subs	r5, r0, #0
    {
 51065a8:	e1a09002 	mov	r9, r2
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 51065ac:	1a000036 	bne	510668c <ulTaskGenericNotifyTake+0xf0>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 51065b0:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 51065b4:	e3404511 	movt	r4, #1297	; 0x511
 51065b8:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 51065bc:	e2833001 	add	r3, r3, #1
 51065c0:	e5843118 	str	r3, [r4, #280]	; 0x118
            taskENTER_CRITICAL();
 51065c4:	e30c8930 	movw	r8, #51504	; 0xc930
                if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
 51065c8:	e28560e4 	add	r6, r5, #228	; 0xe4
            taskEXIT_CRITICAL();
 51065cc:	e30c7988 	movw	r7, #51592	; 0xc988
            taskENTER_CRITICAL();
 51065d0:	e3408510 	movt	r8, #1296	; 0x510
 51065d4:	e12fff38 	blx	r8
                if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
 51065d8:	e594300c 	ldr	r3, [r4, #12]
            taskEXIT_CRITICAL();
 51065dc:	e3407510 	movt	r7, #1296	; 0x510
                if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] == 0U )
 51065e0:	e0833106 	add	r3, r3, r6, lsl #2
 51065e4:	e5933004 	ldr	r3, [r3, #4]
 51065e8:	e3530000 	cmp	r3, #0
 51065ec:	1a000005 	bne	5106608 <ulTaskGenericNotifyTake+0x6c>
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 51065f0:	e594300c 	ldr	r3, [r4, #12]
 51065f4:	e3a0b001 	mov	fp, #1
                    if( xTicksToWait > ( TickType_t ) 0 )
 51065f8:	e3590000 	cmp	r9, #0
                    pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskWAITING_NOTIFICATION;
 51065fc:	e0833005 	add	r3, r3, r5
 5106600:	e5c3b398 	strb	fp, [r3, #920]	; 0x398
                    if( xTicksToWait > ( TickType_t ) 0 )
 5106604:	1a000015 	bne	5106660 <ulTaskGenericNotifyTake+0xc4>
            taskEXIT_CRITICAL();
 5106608:	e12fff37 	blx	r7
        xAlreadyYielded = xTaskResumeAll();
 510660c:	ebfffe3a 	bl	5105efc <xTaskResumeAll>
        taskENTER_CRITICAL();
 5106610:	e12fff38 	blx	r8
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ];
 5106614:	e594300c 	ldr	r3, [r4, #12]
 5106618:	e0833106 	add	r3, r3, r6, lsl #2
 510661c:	e1a06106 	lsl	r6, r6, #2
 5106620:	e5938004 	ldr	r8, [r3, #4]
            if( ulReturn != 0U )
 5106624:	e3580000 	cmp	r8, #0
 5106628:	0a000005 	beq	5106644 <ulTaskGenericNotifyTake+0xa8>
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
 510662c:	e594300c 	ldr	r3, [r4, #12]
                if( xClearCountOnExit != pdFALSE )
 5106630:	e35a0000 	cmp	sl, #0
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ( uint32_t ) 0U;
 5106634:	e0836006 	add	r6, r3, r6
 5106638:	13a03000 	movne	r3, #0
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWaitOn ] = ulReturn - ( uint32_t ) 1;
 510663c:	02483001 	subeq	r3, r8, #1
 5106640:	e5863004 	str	r3, [r6, #4]
            pxCurrentTCB->ucNotifyState[ uxIndexToWaitOn ] = taskNOT_WAITING_NOTIFICATION;
 5106644:	e594300c 	ldr	r3, [r4, #12]
 5106648:	e3a02000 	mov	r2, #0
 510664c:	e0835005 	add	r5, r3, r5
 5106650:	e5c52398 	strb	r2, [r5, #920]	; 0x398
        taskEXIT_CRITICAL();
 5106654:	e12fff37 	blx	r7
    }
 5106658:	e1a00008 	mov	r0, r8
 510665c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
            taskEXIT_CRITICAL();
 5106660:	e12fff37 	blx	r7
                prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 5106664:	e1a0100b 	mov	r1, fp
 5106668:	e1a00009 	mov	r0, r9
 510666c:	ebfff694 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
        xAlreadyYielded = xTaskResumeAll();
 5106670:	ebfffe21 	bl	5105efc <xTaskResumeAll>
        if( ( xShouldBlock == pdTRUE ) && ( xAlreadyYielded == pdFALSE ) )
 5106674:	e3500000 	cmp	r0, #0
 5106678:	1affffe4 	bne	5106610 <ulTaskGenericNotifyTake+0x74>
            taskYIELD_WITHIN_API();
 510667c:	e3003000 	movw	r3, #0
 5106680:	e3403511 	movt	r3, #1297	; 0x511
 5106684:	e12fff33 	blx	r3
 5106688:	eaffffe0 	b	5106610 <ulTaskGenericNotifyTake+0x74>
        configASSERT( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES );
 510668c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106690:	e3003900 	movw	r3, #2304	; 0x900
 5106694:	e3011dc7 	movw	r1, #7623	; 0x1dc7
 5106698:	e3403511 	movt	r3, #1297	; 0x511
 510669c:	e3400512 	movt	r0, #1298	; 0x512
 51066a0:	e12fff33 	blx	r3
 51066a4:	eaffffc1 	b	51065b0 <ulTaskGenericNotifyTake+0x14>

051066a8 <xTaskCatchUpTicks>:
{
 51066a8:	e92d4070 	push	{r4, r5, r6, lr}
    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 51066ac:	e30c4db8 	movw	r4, #52664	; 0xcdb8
{
 51066b0:	e1a05000 	mov	r5, r0
    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 51066b4:	e3404511 	movt	r4, #1297	; 0x511
 51066b8:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 51066bc:	e3530000 	cmp	r3, #0
 51066c0:	1a00000d 	bne	51066fc <xTaskCatchUpTicks+0x54>
        uxSchedulerSuspended = ( UBaseType_t ) ( uxSchedulerSuspended + 1U );
 51066c4:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 51066c8:	e2833001 	add	r3, r3, #1
 51066cc:	e5843118 	str	r3, [r4, #280]	; 0x118
    taskENTER_CRITICAL();
 51066d0:	e30c3930 	movw	r3, #51504	; 0xc930
 51066d4:	e3403510 	movt	r3, #1296	; 0x510
 51066d8:	e12fff33 	blx	r3
        xPendedTicks += xTicksToCatchUp;
 51066dc:	e5942128 	ldr	r2, [r4, #296]	; 0x128
    taskEXIT_CRITICAL();
 51066e0:	e30c3988 	movw	r3, #51592	; 0xc988
        xPendedTicks += xTicksToCatchUp;
 51066e4:	e0820005 	add	r0, r2, r5
    taskEXIT_CRITICAL();
 51066e8:	e3403510 	movt	r3, #1296	; 0x510
        xPendedTicks += xTicksToCatchUp;
 51066ec:	e5840128 	str	r0, [r4, #296]	; 0x128
    taskEXIT_CRITICAL();
 51066f0:	e12fff33 	blx	r3
    xYieldOccurred = xTaskResumeAll();
 51066f4:	ebfffe00 	bl	5105efc <xTaskResumeAll>
}
 51066f8:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( uxSchedulerSuspended == ( UBaseType_t ) 0U );
 51066fc:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106700:	e3003900 	movw	r3, #2304	; 0x900
 5106704:	e30111c7 	movw	r1, #4551	; 0x11c7
 5106708:	e3403511 	movt	r3, #1297	; 0x511
 510670c:	e3400512 	movt	r0, #1298	; 0x512
 5106710:	e12fff33 	blx	r3
 5106714:	eaffffea 	b	51066c4 <xTaskCatchUpTicks+0x1c>

05106718 <vTaskPlaceOnEventList>:
{
 5106718:	e92d4070 	push	{r4, r5, r6, lr}
 510671c:	e1a05001 	mov	r5, r1
    configASSERT( pxEventList );
 5106720:	e2504000 	subs	r4, r0, #0
 5106724:	0a00000b 	beq	5106758 <vTaskPlaceOnEventList+0x40>
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 5106728:	e30c2db8 	movw	r2, #52664	; 0xcdb8
 510672c:	e3003c54 	movw	r3, #3156	; 0xc54
 5106730:	e1a00004 	mov	r0, r4
 5106734:	e3402511 	movt	r2, #1297	; 0x511
 5106738:	e3403510 	movt	r3, #1296	; 0x510
 510673c:	e592100c 	ldr	r1, [r2, #12]
 5106740:	e2811fd9 	add	r1, r1, #868	; 0x364
 5106744:	e12fff33 	blx	r3
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 5106748:	e3a01001 	mov	r1, #1
 510674c:	e1a00005 	mov	r0, r5
 5106750:	ebfff65b 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
}
 5106754:	e8bd8070 	pop	{r4, r5, r6, pc}
    configASSERT( pxEventList );
 5106758:	e30d0abc 	movw	r0, #55996	; 0xdabc
 510675c:	e3003900 	movw	r3, #2304	; 0x900
 5106760:	e3a01d52 	mov	r1, #5248	; 0x1480
 5106764:	e3403511 	movt	r3, #1297	; 0x511
 5106768:	e3400512 	movt	r0, #1298	; 0x512
 510676c:	e12fff33 	blx	r3
 5106770:	eaffffec 	b	5106728 <vTaskPlaceOnEventList+0x10>

05106774 <vTaskPlaceOnUnorderedEventList>:
{
 5106774:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5106778:	e1a06001 	mov	r6, r1
    configASSERT( pxEventList );
 510677c:	e2505000 	subs	r5, r0, #0
{
 5106780:	e1a07002 	mov	r7, r2
    configASSERT( pxEventList );
 5106784:	0a000024 	beq	510681c <vTaskPlaceOnUnorderedEventList+0xa8>
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 5106788:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 510678c:	e3404511 	movt	r4, #1297	; 0x511
 5106790:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5106794:	e3530000 	cmp	r3, #0
 5106798:	0a000018 	beq	5106800 <vTaskPlaceOnUnorderedEventList+0x8c>
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 510679c:	e594300c 	ldr	r3, [r4, #12]
 51067a0:	e3866102 	orr	r6, r6, #-2147483648	; 0x80000000
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 51067a4:	e594200c 	ldr	r2, [r4, #12]
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 51067a8:	e1a00007 	mov	r0, r7
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 51067ac:	e5836364 	str	r6, [r3, #868]	; 0x364
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 51067b0:	e5953004 	ldr	r3, [r5, #4]
 51067b4:	e594600c 	ldr	r6, [r4, #12]
 51067b8:	e5823368 	str	r3, [r2, #872]	; 0x368
 51067bc:	e594c00c 	ldr	ip, [r4, #12]
 51067c0:	e5952000 	ldr	r2, [r5]
 51067c4:	e594100c 	ldr	r1, [r4, #12]
 51067c8:	e28ccfd9 	add	ip, ip, #868	; 0x364
 51067cc:	e594e00c 	ldr	lr, [r4, #12]
 51067d0:	e2822001 	add	r2, r2, #1
 51067d4:	e5934008 	ldr	r4, [r3, #8]
 51067d8:	e2811fd9 	add	r1, r1, #868	; 0x364
 51067dc:	e586436c 	str	r4, [r6, #876]	; 0x36c
 51067e0:	e5934008 	ldr	r4, [r3, #8]
 51067e4:	e584c004 	str	ip, [r4, #4]
 51067e8:	e5831008 	str	r1, [r3, #8]
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 51067ec:	e3a01001 	mov	r1, #1
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 51067f0:	e58e5374 	str	r5, [lr, #884]	; 0x374
 51067f4:	e5852000 	str	r2, [r5]
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 51067f8:	ebfff631 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
}
 51067fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 5106800:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106804:	e3003900 	movw	r3, #2304	; 0x900
 5106808:	e30114a2 	movw	r1, #5282	; 0x14a2
 510680c:	e3403511 	movt	r3, #1297	; 0x511
 5106810:	e3400512 	movt	r0, #1298	; 0x512
 5106814:	e12fff33 	blx	r3
 5106818:	eaffffdf 	b	510679c <vTaskPlaceOnUnorderedEventList+0x28>
    configASSERT( pxEventList );
 510681c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106820:	e3003900 	movw	r3, #2304	; 0x900
 5106824:	e301149e 	movw	r1, #5278	; 0x149e
 5106828:	e3403511 	movt	r3, #1297	; 0x511
 510682c:	e3400512 	movt	r0, #1298	; 0x512
 5106830:	e12fff33 	blx	r3
 5106834:	eaffffd3 	b	5106788 <vTaskPlaceOnUnorderedEventList+0x14>

05106838 <vTaskPlaceOnEventListRestricted>:
    {
 5106838:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 510683c:	e1a05001 	mov	r5, r1
        configASSERT( pxEventList );
 5106840:	e2504000 	subs	r4, r0, #0
    {
 5106844:	e1a06002 	mov	r6, r2
        configASSERT( pxEventList );
 5106848:	0a000019 	beq	51068b4 <vTaskPlaceOnEventListRestricted+0x7c>
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 510684c:	e30c3db8 	movw	r3, #52664	; 0xcdb8
            xTicksToWait = portMAX_DELAY;
 5106850:	e3560000 	cmp	r6, #0
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 5106854:	e594c004 	ldr	ip, [r4, #4]
 5106858:	e3403511 	movt	r3, #1297	; 0x511
 510685c:	e5942000 	ldr	r2, [r4]
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 5106860:	01a00005 	moveq	r0, r5
 5106864:	e1a01006 	mov	r1, r6
 5106868:	13e00000 	mvnne	r0, #0
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 510686c:	e593e00c 	ldr	lr, [r3, #12]
 5106870:	e2822001 	add	r2, r2, #1
 5106874:	e593700c 	ldr	r7, [r3, #12]
 5106878:	e58ec368 	str	ip, [lr, #872]	; 0x368
 510687c:	e593500c 	ldr	r5, [r3, #12]
 5106880:	e593e00c 	ldr	lr, [r3, #12]
 5106884:	e593600c 	ldr	r6, [r3, #12]
 5106888:	e2855fd9 	add	r5, r5, #868	; 0x364
 510688c:	e28e3fd9 	add	r3, lr, #868	; 0x364
 5106890:	e59ce008 	ldr	lr, [ip, #8]
 5106894:	e587e36c 	str	lr, [r7, #876]	; 0x36c
 5106898:	e59ce008 	ldr	lr, [ip, #8]
 510689c:	e58e5004 	str	r5, [lr, #4]
 51068a0:	e58c3008 	str	r3, [ip, #8]
 51068a4:	e5864374 	str	r4, [r6, #884]	; 0x374
 51068a8:	e5842000 	str	r2, [r4]
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 51068ac:	ebfff604 	bl	51040c4 <prvAddCurrentTaskToDelayedList>
    }
 51068b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( pxEventList );
 51068b4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51068b8:	e3003900 	movw	r3, #2304	; 0x900
 51068bc:	e30114be 	movw	r1, #5310	; 0x14be
 51068c0:	e3403511 	movt	r3, #1297	; 0x511
 51068c4:	e3400512 	movt	r0, #1298	; 0x512
 51068c8:	e12fff33 	blx	r3
 51068cc:	eaffffde 	b	510684c <vTaskPlaceOnEventListRestricted+0x14>

051068d0 <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 51068d0:	e590300c 	ldr	r3, [r0, #12]
{
 51068d4:	e92d4070 	push	{r4, r5, r6, lr}
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 51068d8:	e593400c 	ldr	r4, [r3, #12]
    configASSERT( pxUnblockedTCB );
 51068dc:	e3540000 	cmp	r4, #0
 51068e0:	0a000049 	beq	5106a0c <xTaskRemoveFromEventList+0x13c>
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 51068e4:	e5942374 	ldr	r2, [r4, #884]	; 0x374
 51068e8:	e2840fd9 	add	r0, r4, #868	; 0x364
 51068ec:	e5941368 	ldr	r1, [r4, #872]	; 0x368
 51068f0:	e3a0c000 	mov	ip, #0
 51068f4:	e594336c 	ldr	r3, [r4, #876]	; 0x36c
 51068f8:	e5813008 	str	r3, [r1, #8]
 51068fc:	e5831004 	str	r1, [r3, #4]
 5106900:	e5921004 	ldr	r1, [r2, #4]
 5106904:	e1510000 	cmp	r1, r0
 5106908:	e5921000 	ldr	r1, [r2]
 510690c:	05823004 	streq	r3, [r2, #4]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5106910:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5106914:	e3403511 	movt	r3, #1297	; 0x511
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 5106918:	e584c374 	str	ip, [r4, #884]	; 0x374
 510691c:	e2411001 	sub	r1, r1, #1
 5106920:	e5821000 	str	r1, [r2]
    if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5106924:	e5932118 	ldr	r2, [r3, #280]	; 0x118
 5106928:	e152000c 	cmp	r2, ip
 510692c:	1a000028 	bne	51069d4 <xTaskRemoveFromEventList+0x104>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106930:	e5942360 	ldr	r2, [r4, #864]	; 0x360
 5106934:	e2845e35 	add	r5, r4, #848	; 0x350
 5106938:	e5941354 	ldr	r1, [r4, #852]	; 0x354
 510693c:	e5940358 	ldr	r0, [r4, #856]	; 0x358
 5106940:	e5810008 	str	r0, [r1, #8]
 5106944:	e5940358 	ldr	r0, [r4, #856]	; 0x358
 5106948:	e5801004 	str	r1, [r0, #4]
 510694c:	e5921004 	ldr	r1, [r2, #4]
        prvAddTaskToReadyList( pxUnblockedTCB );
 5106950:	e59fe0d0 	ldr	lr, [pc, #208]	; 5106a28 <xTaskRemoveFromEventList+0x158>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106954:	e1510005 	cmp	r1, r5
 5106958:	e5921000 	ldr	r1, [r2]
 510695c:	05820004 	streq	r0, [r2, #4]
        prvAddTaskToReadyList( pxUnblockedTCB );
 5106960:	e3a00001 	mov	r0, #1
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106964:	e2411001 	sub	r1, r1, #1
 5106968:	e5821000 	str	r1, [r2]
        prvAddTaskToReadyList( pxUnblockedTCB );
 510696c:	e5942378 	ldr	r2, [r4, #888]	; 0x378
 5106970:	e5931010 	ldr	r1, [r3, #16]
 5106974:	e1811210 	orr	r1, r1, r0, lsl r2
 5106978:	e5831010 	str	r1, [r3, #16]
 510697c:	e0821102 	add	r1, r2, r2, lsl #2
 5106980:	e08ee101 	add	lr, lr, r1, lsl #2
 5106984:	e0831101 	add	r1, r3, r1, lsl #2
 5106988:	e5910034 	ldr	r0, [r1, #52]	; 0x34
 510698c:	e591c030 	ldr	ip, [r1, #48]	; 0x30
 5106990:	e5840354 	str	r0, [r4, #852]	; 0x354
 5106994:	e5906008 	ldr	r6, [r0, #8]
 5106998:	e28cc001 	add	ip, ip, #1
 510699c:	e5846358 	str	r6, [r4, #856]	; 0x358
 51069a0:	e5906008 	ldr	r6, [r0, #8]
 51069a4:	e5865004 	str	r5, [r6, #4]
 51069a8:	e5805008 	str	r5, [r0, #8]
 51069ac:	e584e360 	str	lr, [r4, #864]	; 0x360
 51069b0:	e581c030 	str	ip, [r1, #48]	; 0x30
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 51069b4:	e593100c 	ldr	r1, [r3, #12]
 51069b8:	e5911378 	ldr	r1, [r1, #888]	; 0x378
 51069bc:	e1510002 	cmp	r1, r2
            xYieldPendings[ 0 ] = pdTRUE;
 51069c0:	33a02001 	movcc	r2, #1
            xReturn = pdTRUE;
 51069c4:	31a00002 	movcc	r0, r2
            xReturn = pdFALSE;
 51069c8:	23a00000 	movcs	r0, #0
            xYieldPendings[ 0 ] = pdTRUE;
 51069cc:	3583211c 	strcc	r2, [r3, #284]	; 0x11c
}
 51069d0:	e8bd8070 	pop	{r4, r5, r6, pc}
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 51069d4:	e59320e8 	ldr	r2, [r3, #232]	; 0xe8
 51069d8:	e283c0e4 	add	ip, r3, #228	; 0xe4
 51069dc:	e5842368 	str	r2, [r4, #872]	; 0x368
 51069e0:	e5921008 	ldr	r1, [r2, #8]
 51069e4:	e584136c 	str	r1, [r4, #876]	; 0x36c
 51069e8:	e5921008 	ldr	r1, [r2, #8]
 51069ec:	e5810004 	str	r0, [r1, #4]
 51069f0:	e59310e4 	ldr	r1, [r3, #228]	; 0xe4
 51069f4:	e5820008 	str	r0, [r2, #8]
        prvAddTaskToReadyList( pxUnblockedTCB );
 51069f8:	e5942378 	ldr	r2, [r4, #888]	; 0x378
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 51069fc:	e2811001 	add	r1, r1, #1
 5106a00:	e584c374 	str	ip, [r4, #884]	; 0x374
 5106a04:	e58310e4 	str	r1, [r3, #228]	; 0xe4
 5106a08:	eaffffe9 	b	51069b4 <xTaskRemoveFromEventList+0xe4>
    configASSERT( pxUnblockedTCB );
 5106a0c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106a10:	e3003900 	movw	r3, #2304	; 0x900
 5106a14:	e30114f5 	movw	r1, #5365	; 0x14f5
 5106a18:	e3403511 	movt	r3, #1297	; 0x511
 5106a1c:	e3400512 	movt	r0, #1298	; 0x512
 5106a20:	e12fff33 	blx	r3
 5106a24:	eaffffae 	b	51068e4 <xTaskRemoveFromEventList+0x14>
 5106a28:	0511cde8 	.word	0x0511cde8

05106a2c <vTaskRemoveFromUnorderedEventList>:
{
 5106a2c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 5106a30:	e30c6db8 	movw	r6, #52664	; 0xcdb8
{
 5106a34:	e1a05000 	mov	r5, r0
 5106a38:	e1a07001 	mov	r7, r1
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 5106a3c:	e3406511 	movt	r6, #1297	; 0x511
 5106a40:	e5963118 	ldr	r3, [r6, #280]	; 0x118
 5106a44:	e3530000 	cmp	r3, #0
 5106a48:	0a000036 	beq	5106b28 <vTaskRemoveFromUnorderedEventList+0xfc>
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem );
 5106a4c:	e595400c 	ldr	r4, [r5, #12]
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 5106a50:	e3877102 	orr	r7, r7, #-2147483648	; 0x80000000
 5106a54:	e5857000 	str	r7, [r5]
    configASSERT( pxUnblockedTCB );
 5106a58:	e3540000 	cmp	r4, #0
 5106a5c:	0a000038 	beq	5106b44 <vTaskRemoveFromUnorderedEventList+0x118>
    listREMOVE_ITEM( pxEventListItem );
 5106a60:	e5952010 	ldr	r2, [r5, #16]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106a64:	e284ce35 	add	ip, r4, #848	; 0x350
    listREMOVE_ITEM( pxEventListItem );
 5106a68:	e995000a 	ldmib	r5, {r1, r3}
    prvAddTaskToReadyList( pxUnblockedTCB );
 5106a6c:	e3a0e001 	mov	lr, #1
    listREMOVE_ITEM( pxEventListItem );
 5106a70:	e5813008 	str	r3, [r1, #8]
 5106a74:	e5831004 	str	r1, [r3, #4]
 5106a78:	e5921004 	ldr	r1, [r2, #4]
    prvAddTaskToReadyList( pxUnblockedTCB );
 5106a7c:	e59f00dc 	ldr	r0, [pc, #220]	; 5106b60 <vTaskRemoveFromUnorderedEventList+0x134>
    listREMOVE_ITEM( pxEventListItem );
 5106a80:	e1510005 	cmp	r1, r5
 5106a84:	e5921000 	ldr	r1, [r2]
 5106a88:	05823004 	streq	r3, [r2, #4]
 5106a8c:	e3a03000 	mov	r3, #0
 5106a90:	e2411001 	sub	r1, r1, #1
 5106a94:	e5853010 	str	r3, [r5, #16]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106a98:	e5943360 	ldr	r3, [r4, #864]	; 0x360
    listREMOVE_ITEM( pxEventListItem );
 5106a9c:	e5821000 	str	r1, [r2]
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 5106aa0:	e5942354 	ldr	r2, [r4, #852]	; 0x354
 5106aa4:	e5941358 	ldr	r1, [r4, #856]	; 0x358
 5106aa8:	e5821008 	str	r1, [r2, #8]
 5106aac:	e5941358 	ldr	r1, [r4, #856]	; 0x358
 5106ab0:	e5812004 	str	r2, [r1, #4]
 5106ab4:	e5932004 	ldr	r2, [r3, #4]
 5106ab8:	e152000c 	cmp	r2, ip
 5106abc:	e5932000 	ldr	r2, [r3]
 5106ac0:	05831004 	streq	r1, [r3, #4]
 5106ac4:	e2422001 	sub	r2, r2, #1
 5106ac8:	e5832000 	str	r2, [r3]
    prvAddTaskToReadyList( pxUnblockedTCB );
 5106acc:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 5106ad0:	e5962010 	ldr	r2, [r6, #16]
 5106ad4:	e182231e 	orr	r2, r2, lr, lsl r3
 5106ad8:	e0831103 	add	r1, r3, r3, lsl #2
 5106adc:	e5862010 	str	r2, [r6, #16]
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 5106ae0:	e596200c 	ldr	r2, [r6, #12]
    prvAddTaskToReadyList( pxUnblockedTCB );
 5106ae4:	e0800101 	add	r0, r0, r1, lsl #2
        if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 5106ae8:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5106aec:	e1530002 	cmp	r3, r2
    prvAddTaskToReadyList( pxUnblockedTCB );
 5106af0:	e0862101 	add	r2, r6, r1, lsl #2
 5106af4:	e5923034 	ldr	r3, [r2, #52]	; 0x34
 5106af8:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 5106afc:	e5843354 	str	r3, [r4, #852]	; 0x354
 5106b00:	e5935008 	ldr	r5, [r3, #8]
 5106b04:	e081100e 	add	r1, r1, lr
 5106b08:	e5845358 	str	r5, [r4, #856]	; 0x358
 5106b0c:	e5935008 	ldr	r5, [r3, #8]
 5106b10:	e585c004 	str	ip, [r5, #4]
 5106b14:	e583c008 	str	ip, [r3, #8]
 5106b18:	e5840360 	str	r0, [r4, #864]	; 0x360
 5106b1c:	e5821030 	str	r1, [r2, #48]	; 0x30
            xYieldPendings[ 0 ] = pdTRUE;
 5106b20:	8586e11c 	strhi	lr, [r6, #284]	; 0x11c
}
 5106b24:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    configASSERT( uxSchedulerSuspended != ( UBaseType_t ) 0U );
 5106b28:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106b2c:	e3003900 	movw	r3, #2304	; 0x900
 5106b30:	e3011543 	movw	r1, #5443	; 0x1543
 5106b34:	e3403511 	movt	r3, #1297	; 0x511
 5106b38:	e3400512 	movt	r0, #1298	; 0x512
 5106b3c:	e12fff33 	blx	r3
 5106b40:	eaffffc1 	b	5106a4c <vTaskRemoveFromUnorderedEventList+0x20>
    configASSERT( pxUnblockedTCB );
 5106b44:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106b48:	e3003900 	movw	r3, #2304	; 0x900
 5106b4c:	e301154e 	movw	r1, #5454	; 0x154e
 5106b50:	e3403511 	movt	r3, #1297	; 0x511
 5106b54:	e3400512 	movt	r0, #1298	; 0x512
 5106b58:	e12fff33 	blx	r3
 5106b5c:	eaffffbf 	b	5106a60 <vTaskRemoveFromUnorderedEventList+0x34>
 5106b60:	0511cde8 	.word	0x0511cde8

05106b64 <vTaskSwitchContext>:
    {
 5106b64:	e92d4070 	push	{r4, r5, r6, lr}
        if( uxSchedulerSuspended != ( UBaseType_t ) 0U )
 5106b68:	e30c4db8 	movw	r4, #52664	; 0xcdb8
 5106b6c:	e3404511 	movt	r4, #1297	; 0x511
 5106b70:	e5943118 	ldr	r3, [r4, #280]	; 0x118
 5106b74:	e3530000 	cmp	r3, #0
 5106b78:	0a000002 	beq	5106b88 <vTaskSwitchContext+0x24>
            xYieldPendings[ 0 ] = pdTRUE;
 5106b7c:	e3a03001 	mov	r3, #1
 5106b80:	e584311c 	str	r3, [r4, #284]	; 0x11c
 5106b84:	e8bd8070 	pop	{r4, r5, r6, pc}
            xYieldPendings[ 0 ] = pdFALSE;
 5106b88:	e584311c 	str	r3, [r4, #284]	; 0x11c
            taskCHECK_FOR_STACK_OVERFLOW();
 5106b8c:	e30a35a5 	movw	r3, #42405	; 0xa5a5
 5106b90:	e594200c 	ldr	r2, [r4, #12]
 5106b94:	e34a35a5 	movt	r3, #42405	; 0xa5a5
 5106b98:	e592237c 	ldr	r2, [r2, #892]	; 0x37c
 5106b9c:	e5921000 	ldr	r1, [r2]
 5106ba0:	e1510003 	cmp	r1, r3
 5106ba4:	1a000002 	bne	5106bb4 <vTaskSwitchContext+0x50>
 5106ba8:	e5923004 	ldr	r3, [r2, #4]
 5106bac:	e1530001 	cmp	r3, r1
 5106bb0:	0a00001f 	beq	5106c34 <vTaskSwitchContext+0xd0>
 5106bb4:	e594100c 	ldr	r1, [r4, #12]
 5106bb8:	e30038a4 	movw	r3, #2212	; 0x8a4
 5106bbc:	e594000c 	ldr	r0, [r4, #12]
 5106bc0:	e3403511 	movt	r3, #1297	; 0x511
 5106bc4:	e2811d0e 	add	r1, r1, #896	; 0x380
 5106bc8:	e12fff33 	blx	r3
            taskSELECT_HIGHEST_PRIORITY_TASK();
 5106bcc:	e5940010 	ldr	r0, [r4, #16]
 5106bd0:	e3003040 	movw	r3, #64	; 0x40
 5106bd4:	e3403511 	movt	r3, #1297	; 0x511
 5106bd8:	e12fff33 	blx	r3
 5106bdc:	e260501f 	rsb	r5, r0, #31
 5106be0:	e0853105 	add	r3, r5, r5, lsl #2
 5106be4:	e1a06105 	lsl	r6, r5, #2
 5106be8:	e0843103 	add	r3, r4, r3, lsl #2
 5106bec:	e5933030 	ldr	r3, [r3, #48]	; 0x30
 5106bf0:	e3530000 	cmp	r3, #0
 5106bf4:	0a000015 	beq	5106c50 <vTaskSwitchContext+0xec>
 5106bf8:	e0860005 	add	r0, r6, r5
 5106bfc:	e59f5068 	ldr	r5, [pc, #104]	; 5106c6c <vTaskSwitchContext+0x108>
 5106c00:	e0842100 	add	r2, r4, r0, lsl #2
 5106c04:	e0855100 	add	r5, r5, r0, lsl #2
 5106c08:	e2855008 	add	r5, r5, #8
 5106c0c:	e5923034 	ldr	r3, [r2, #52]	; 0x34
 5106c10:	e5933004 	ldr	r3, [r3, #4]
 5106c14:	e5823034 	str	r3, [r2, #52]	; 0x34
 5106c18:	e1530005 	cmp	r3, r5
 5106c1c:	0592303c 	ldreq	r3, [r2, #60]	; 0x3c
 5106c20:	05823034 	streq	r3, [r2, #52]	; 0x34
 5106c24:	e593300c 	ldr	r3, [r3, #12]
 5106c28:	e584300c 	str	r3, [r4, #12]
            portTASK_SWITCH_HOOK( pxCurrentTCB );
 5106c2c:	e594300c 	ldr	r3, [r4, #12]
    }
 5106c30:	e8bd8070 	pop	{r4, r5, r6, pc}
            taskCHECK_FOR_STACK_OVERFLOW();
 5106c34:	e5921008 	ldr	r1, [r2, #8]
 5106c38:	e1510003 	cmp	r1, r3
 5106c3c:	1affffdc 	bne	5106bb4 <vTaskSwitchContext+0x50>
 5106c40:	e592300c 	ldr	r3, [r2, #12]
 5106c44:	e1530001 	cmp	r3, r1
 5106c48:	1affffd9 	bne	5106bb4 <vTaskSwitchContext+0x50>
 5106c4c:	eaffffde 	b	5106bcc <vTaskSwitchContext+0x68>
            taskSELECT_HIGHEST_PRIORITY_TASK();
 5106c50:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106c54:	e3003900 	movw	r3, #2304	; 0x900
 5106c58:	e30113fa 	movw	r1, #5114	; 0x13fa
 5106c5c:	e3403511 	movt	r3, #1297	; 0x511
 5106c60:	e3400512 	movt	r0, #1298	; 0x512
 5106c64:	e12fff33 	blx	r3
 5106c68:	eaffffe2 	b	5106bf8 <vTaskSwitchContext+0x94>
 5106c6c:	0511cde8 	.word	0x0511cde8

05106c70 <vTaskSuspend>:
    {
 5106c70:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        taskENTER_CRITICAL();
 5106c74:	e30c7930 	movw	r7, #51504	; 0xc930
    {
 5106c78:	e1a04000 	mov	r4, r0
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 5106c7c:	e30c5db8 	movw	r5, #52664	; 0xcdb8
        taskENTER_CRITICAL();
 5106c80:	e3407510 	movt	r7, #1296	; 0x510
 5106c84:	e12fff37 	blx	r7
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 5106c88:	e3405511 	movt	r5, #1297	; 0x511
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5106c8c:	e3006cd8 	movw	r6, #3288	; 0xcd8
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 5106c90:	e3540000 	cmp	r4, #0
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5106c94:	e3406510 	movt	r6, #1296	; 0x510
            pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 5106c98:	0595400c 	ldreq	r4, [r5, #12]
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5106c9c:	e2848e35 	add	r8, r4, #848	; 0x350
 5106ca0:	e1a00008 	mov	r0, r8
 5106ca4:	e12fff36 	blx	r6
 5106ca8:	e3500000 	cmp	r0, #0
 5106cac:	1a000008 	bne	5106cd4 <vTaskSuspend+0x64>
                taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 5106cb0:	e5942378 	ldr	r2, [r4, #888]	; 0x378
 5106cb4:	e0823102 	add	r3, r2, r2, lsl #2
 5106cb8:	e0853103 	add	r3, r5, r3, lsl #2
 5106cbc:	e5933030 	ldr	r3, [r3, #48]	; 0x30
 5106cc0:	e3530000 	cmp	r3, #0
 5106cc4:	03a01001 	moveq	r1, #1
 5106cc8:	05953010 	ldreq	r3, [r5, #16]
 5106ccc:	01c32211 	biceq	r2, r3, r1, lsl r2
 5106cd0:	05852010 	streq	r2, [r5, #16]
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 5106cd4:	e5943374 	ldr	r3, [r4, #884]	; 0x374
 5106cd8:	e3530000 	cmp	r3, #0
 5106cdc:	0a000001 	beq	5106ce8 <vTaskSuspend+0x78>
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 5106ce0:	e2840fd9 	add	r0, r4, #868	; 0x364
 5106ce4:	e12fff36 	blx	r6
            vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 5106ce8:	e3003cac 	movw	r3, #3244	; 0xcac
 5106cec:	e1a01008 	mov	r1, r8
 5106cf0:	e59f00c8 	ldr	r0, [pc, #200]	; 5106dc0 <vTaskSuspend+0x150>
 5106cf4:	e3403510 	movt	r3, #1296	; 0x510
 5106cf8:	e12fff33 	blx	r3
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 5106cfc:	e5d43398 	ldrb	r3, [r4, #920]	; 0x398
        taskEXIT_CRITICAL();
 5106d00:	e30c6988 	movw	r6, #51592	; 0xc988
                    if( pxTCB->ucNotifyState[ x ] == taskWAITING_NOTIFICATION )
 5106d04:	e3530001 	cmp	r3, #1
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 5106d08:	03a03000 	moveq	r3, #0
        taskEXIT_CRITICAL();
 5106d0c:	e3406510 	movt	r6, #1296	; 0x510
                        pxTCB->ucNotifyState[ x ] = taskNOT_WAITING_NOTIFICATION;
 5106d10:	05c43398 	strbeq	r3, [r4, #920]	; 0x398
        taskEXIT_CRITICAL();
 5106d14:	e12fff36 	blx	r6
            if( xSchedulerRunning != pdFALSE )
 5106d18:	e595310c 	ldr	r3, [r5, #268]	; 0x10c
 5106d1c:	e3530000 	cmp	r3, #0
 5106d20:	1a00000c 	bne	5106d58 <vTaskSuspend+0xe8>
            if( pxTCB == pxCurrentTCB )
 5106d24:	e595300c 	ldr	r3, [r5, #12]
 5106d28:	e1530004 	cmp	r3, r4
 5106d2c:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                if( xSchedulerRunning != pdFALSE )
 5106d30:	e595310c 	ldr	r3, [r5, #268]	; 0x10c
 5106d34:	e3530000 	cmp	r3, #0
 5106d38:	0a000011 	beq	5106d84 <vTaskSuspend+0x114>
                    configASSERT( uxSchedulerSuspended == 0 );
 5106d3c:	e5953118 	ldr	r3, [r5, #280]	; 0x118
 5106d40:	e3530000 	cmp	r3, #0
 5106d44:	1a000016 	bne	5106da4 <vTaskSuspend+0x134>
                    portYIELD_WITHIN_API();
 5106d48:	e3003000 	movw	r3, #0
 5106d4c:	e3403511 	movt	r3, #1297	; 0x511
 5106d50:	e12fff33 	blx	r3
 5106d54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                taskENTER_CRITICAL();
 5106d58:	e12fff37 	blx	r7
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 5106d5c:	e5953004 	ldr	r3, [r5, #4]
 5106d60:	e5933000 	ldr	r3, [r3]
 5106d64:	e3530000 	cmp	r3, #0
        xNextTaskUnblockTime = portMAX_DELAY;
 5106d68:	03e03000 	mvneq	r3, #0
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 5106d6c:	15953004 	ldrne	r3, [r5, #4]
 5106d70:	1593300c 	ldrne	r3, [r3, #12]
 5106d74:	15933000 	ldrne	r3, [r3]
 5106d78:	e5853028 	str	r3, [r5, #40]	; 0x28
                taskEXIT_CRITICAL();
 5106d7c:	e12fff36 	blx	r6
 5106d80:	eaffffe7 	b	5106d24 <vTaskSuspend+0xb4>
                    if( uxCurrentListLength == uxCurrentNumberOfTasks )
 5106d84:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
 5106d88:	e5952014 	ldr	r2, [r5, #20]
 5106d8c:	e1510002 	cmp	r1, r2
 5106d90:	1a000001 	bne	5106d9c <vTaskSuspend+0x12c>
                        pxCurrentTCB = NULL;
 5106d94:	e585300c 	str	r3, [r5, #12]
 5106d98:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                        vTaskSwitchContext();
 5106d9c:	ebffff70 	bl	5106b64 <vTaskSwitchContext>
    }
 5106da0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    configASSERT( uxSchedulerSuspended == 0 );
 5106da4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106da8:	e3003900 	movw	r3, #2304	; 0x900
 5106dac:	e3001ca6 	movw	r1, #3238	; 0xca6
 5106db0:	e3403511 	movt	r3, #1297	; 0x511
 5106db4:	e3400512 	movt	r0, #1298	; 0x512
 5106db8:	e12fff33 	blx	r3
 5106dbc:	eaffffe1 	b	5106d48 <vTaskSuspend+0xd8>
 5106dc0:	0511cdcc 	.word	0x0511cdcc

05106dc4 <uxTaskResetEventItemValue>:
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 5106dc4:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5106dc8:	e3403511 	movt	r3, #1297	; 0x511
 5106dcc:	e593100c 	ldr	r1, [r3, #12]
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
 5106dd0:	e593000c 	ldr	r0, [r3, #12]
 5106dd4:	e593200c 	ldr	r2, [r3, #12]
 5106dd8:	e5903378 	ldr	r3, [r0, #888]	; 0x378
    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 5106ddc:	e5910364 	ldr	r0, [r1, #868]	; 0x364
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) );
 5106de0:	e2633007 	rsb	r3, r3, #7
 5106de4:	e5823364 	str	r3, [r2, #868]	; 0x364
}
 5106de8:	e12fff1e 	bx	lr

05106dec <xTaskGetCurrentTaskHandle>:
            xReturn = pxCurrentTCB;
 5106dec:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5106df0:	e3403511 	movt	r3, #1297	; 0x511
 5106df4:	e593000c 	ldr	r0, [r3, #12]
        }
 5106df8:	e12fff1e 	bx	lr

05106dfc <xTaskGetCurrentTaskHandleForCore>:
        if( taskVALID_CORE_ID( xCoreID ) != pdFALSE )
 5106dfc:	e3500000 	cmp	r0, #0
                xReturn = pxCurrentTCB;
 5106e00:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 5106e04:	03403511 	movteq	r3, #1297	; 0x511
 5106e08:	0593000c 	ldreq	r0, [r3, #12]
        TaskHandle_t xReturn = NULL;
 5106e0c:	13a00000 	movne	r0, #0
    }
 5106e10:	e12fff1e 	bx	lr

05106e14 <vTaskMissedYield>:
    xYieldPendings[ portGET_CORE_ID() ] = pdTRUE;
 5106e14:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5106e18:	e3a02001 	mov	r2, #1
 5106e1c:	e3403511 	movt	r3, #1297	; 0x511
 5106e20:	e583211c 	str	r2, [r3, #284]	; 0x11c
}
 5106e24:	e12fff1e 	bx	lr

05106e28 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 5106e28:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 5106e2c:	e3403511 	movt	r3, #1297	; 0x511
 5106e30:	e593210c 	ldr	r2, [r3, #268]	; 0x10c
 5106e34:	e3520000 	cmp	r2, #0
 5106e38:	0a000004 	beq	5106e50 <xTaskGetSchedulerState+0x28>
                if( uxSchedulerSuspended == ( UBaseType_t ) 0U )
 5106e3c:	e5933118 	ldr	r3, [r3, #280]	; 0x118
                    xReturn = taskSCHEDULER_SUSPENDED;
 5106e40:	e3530000 	cmp	r3, #0
 5106e44:	03a00002 	moveq	r0, #2
 5106e48:	13a00000 	movne	r0, #0
 5106e4c:	e12fff1e 	bx	lr
            xReturn = taskSCHEDULER_NOT_STARTED;
 5106e50:	e3a00001 	mov	r0, #1
    }
 5106e54:	e12fff1e 	bx	lr

05106e58 <xTaskPriorityInherit>:
    {
 5106e58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if( pxMutexHolder != NULL )
 5106e5c:	e2504000 	subs	r4, r0, #0
 5106e60:	0a00001e 	beq	5106ee0 <xTaskPriorityInherit+0x88>
            if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
 5106e64:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 5106e68:	e30c5db8 	movw	r5, #52664	; 0xcdb8
 5106e6c:	e3405511 	movt	r5, #1297	; 0x511
 5106e70:	e595200c 	ldr	r2, [r5, #12]
 5106e74:	e5922378 	ldr	r2, [r2, #888]	; 0x378
 5106e78:	e1530002 	cmp	r3, r2
 5106e7c:	2a000010 	bcs	5106ec4 <xTaskPriorityInherit+0x6c>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 5106e80:	e5942364 	ldr	r2, [r4, #868]	; 0x364
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 5106e84:	e0833103 	add	r3, r3, r3, lsl #2
 5106e88:	e59f60dc 	ldr	r6, [pc, #220]	; 5106f6c <xTaskPriorityInherit+0x114>
                if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 5106e8c:	e3520000 	cmp	r2, #0
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 5106e90:	e0863103 	add	r3, r6, r3, lsl #2
                    listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority );
 5106e94:	a595200c 	ldrge	r2, [r5, #12]
 5106e98:	a5922378 	ldrge	r2, [r2, #888]	; 0x378
 5106e9c:	a2622007 	rsbge	r2, r2, #7
 5106ea0:	a5842364 	strge	r2, [r4, #868]	; 0x364
                if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
 5106ea4:	e5942360 	ldr	r2, [r4, #864]	; 0x360
 5106ea8:	e1520003 	cmp	r2, r3
 5106eac:	0a00000d 	beq	5106ee8 <xTaskPriorityInherit+0x90>
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 5106eb0:	e595300c 	ldr	r3, [r5, #12]
                xReturn = pdTRUE;
 5106eb4:	e3a00001 	mov	r0, #1
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 5106eb8:	e5933378 	ldr	r3, [r3, #888]	; 0x378
 5106ebc:	e5843378 	str	r3, [r4, #888]	; 0x378
 5106ec0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
 5106ec4:	e595200c 	ldr	r2, [r5, #12]
 5106ec8:	e594338c 	ldr	r3, [r4, #908]	; 0x38c
 5106ecc:	e5920378 	ldr	r0, [r2, #888]	; 0x378
 5106ed0:	e1530000 	cmp	r3, r0
 5106ed4:	23a00000 	movcs	r0, #0
 5106ed8:	33a00001 	movcc	r0, #1
 5106edc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        BaseType_t xReturn = pdFALSE;
 5106ee0:	e1a00004 	mov	r0, r4
    }
 5106ee4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5106ee8:	e3003cd8 	movw	r3, #3288	; 0xcd8
 5106eec:	e2847e35 	add	r7, r4, #848	; 0x350
 5106ef0:	e1a00007 	mov	r0, r7
 5106ef4:	e3403510 	movt	r3, #1296	; 0x510
 5106ef8:	e12fff33 	blx	r3
 5106efc:	e3500000 	cmp	r0, #0
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 5106f00:	03a01001 	moveq	r1, #1
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 5106f04:	e3a00001 	mov	r0, #1
                        portRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority, uxTopReadyPriority );
 5106f08:	05953010 	ldreq	r3, [r5, #16]
 5106f0c:	05942378 	ldreq	r2, [r4, #888]	; 0x378
 5106f10:	01c33211 	biceq	r3, r3, r1, lsl r2
 5106f14:	05853010 	streq	r3, [r5, #16]
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 5106f18:	e595300c 	ldr	r3, [r5, #12]
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 5106f1c:	e5952010 	ldr	r2, [r5, #16]
                    pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
 5106f20:	e5933378 	ldr	r3, [r3, #888]	; 0x378
 5106f24:	e5843378 	str	r3, [r4, #888]	; 0x378
                    prvAddTaskToReadyList( pxMutexHolderTCB );
 5106f28:	e1822310 	orr	r2, r2, r0, lsl r3
 5106f2c:	e0833103 	add	r3, r3, r3, lsl #2
 5106f30:	e5852010 	str	r2, [r5, #16]
 5106f34:	e0855103 	add	r5, r5, r3, lsl #2
 5106f38:	e0863103 	add	r3, r6, r3, lsl #2
 5106f3c:	e5952034 	ldr	r2, [r5, #52]	; 0x34
 5106f40:	e5951030 	ldr	r1, [r5, #48]	; 0x30
 5106f44:	e5842354 	str	r2, [r4, #852]	; 0x354
 5106f48:	e592c008 	ldr	ip, [r2, #8]
 5106f4c:	e0811000 	add	r1, r1, r0
 5106f50:	e584c358 	str	ip, [r4, #856]	; 0x358
 5106f54:	e592c008 	ldr	ip, [r2, #8]
 5106f58:	e58c7004 	str	r7, [ip, #4]
 5106f5c:	e5827008 	str	r7, [r2, #8]
 5106f60:	e5843360 	str	r3, [r4, #864]	; 0x360
 5106f64:	e5851030 	str	r1, [r5, #48]	; 0x30
 5106f68:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5106f6c:	0511cde8 	.word	0x0511cde8

05106f70 <xTaskPriorityDisinherit>:
    {
 5106f70:	e92d4070 	push	{r4, r5, r6, lr}
        if( pxMutexHolder != NULL )
 5106f74:	e2504000 	subs	r4, r0, #0
 5106f78:	0a000017 	beq	5106fdc <xTaskPriorityDisinherit+0x6c>
            configASSERT( pxTCB == pxCurrentTCB );
 5106f7c:	e30c5db8 	movw	r5, #52664	; 0xcdb8
 5106f80:	e3405511 	movt	r5, #1297	; 0x511
 5106f84:	e595300c 	ldr	r3, [r5, #12]
 5106f88:	e1530004 	cmp	r3, r4
 5106f8c:	0a000005 	beq	5106fa8 <xTaskPriorityDisinherit+0x38>
 5106f90:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106f94:	e3003900 	movw	r3, #2304	; 0x900
 5106f98:	e3011a28 	movw	r1, #6696	; 0x1a28
 5106f9c:	e3400512 	movt	r0, #1298	; 0x512
 5106fa0:	e3403511 	movt	r3, #1297	; 0x511
 5106fa4:	e12fff33 	blx	r3
            configASSERT( pxTCB->uxMutexesHeld );
 5106fa8:	e5943390 	ldr	r3, [r4, #912]	; 0x390
 5106fac:	e3530000 	cmp	r3, #0
 5106fb0:	0a00000b 	beq	5106fe4 <xTaskPriorityDisinherit+0x74>
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 5106fb4:	e5942378 	ldr	r2, [r4, #888]	; 0x378
            ( pxTCB->uxMutexesHeld )--;
 5106fb8:	e2433001 	sub	r3, r3, #1
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 5106fbc:	e594138c 	ldr	r1, [r4, #908]	; 0x38c
            ( pxTCB->uxMutexesHeld )--;
 5106fc0:	e5843390 	str	r3, [r4, #912]	; 0x390
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 5106fc4:	e0522001 	subs	r2, r2, r1
 5106fc8:	13a02001 	movne	r2, #1
 5106fcc:	e3530000 	cmp	r3, #0
 5106fd0:	13a02000 	movne	r2, #0
 5106fd4:	e3520000 	cmp	r2, #0
 5106fd8:	1a000009 	bne	5107004 <xTaskPriorityDisinherit+0x94>
        BaseType_t xReturn = pdFALSE;
 5106fdc:	e3a00000 	mov	r0, #0
 5106fe0:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( pxTCB->uxMutexesHeld );
 5106fe4:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5106fe8:	e3003900 	movw	r3, #2304	; 0x900
 5106fec:	e3011a29 	movw	r1, #6697	; 0x1a29
 5106ff0:	e3403511 	movt	r3, #1297	; 0x511
 5106ff4:	e3400512 	movt	r0, #1298	; 0x512
 5106ff8:	e12fff33 	blx	r3
            ( pxTCB->uxMutexesHeld )--;
 5106ffc:	e5943390 	ldr	r3, [r4, #912]	; 0x390
 5107000:	eaffffeb 	b	5106fb4 <xTaskPriorityDisinherit+0x44>
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5107004:	e3003cd8 	movw	r3, #3288	; 0xcd8
 5107008:	e2846e35 	add	r6, r4, #848	; 0x350
 510700c:	e1a00006 	mov	r0, r6
 5107010:	e3403510 	movt	r3, #1296	; 0x510
 5107014:	e12fff33 	blx	r3
 5107018:	e3500000 	cmp	r0, #0
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 510701c:	03a01001 	moveq	r1, #1
                    prvAddTaskToReadyList( pxTCB );
 5107020:	e3a00001 	mov	r0, #1
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 5107024:	05953010 	ldreq	r3, [r5, #16]
 5107028:	05942378 	ldreq	r2, [r4, #888]	; 0x378
 510702c:	01c33211 	biceq	r3, r3, r1, lsl r2
                    prvAddTaskToReadyList( pxTCB );
 5107030:	e59f1058 	ldr	r1, [pc, #88]	; 5107090 <xTaskPriorityDisinherit+0x120>
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 5107034:	05853010 	streq	r3, [r5, #16]
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 5107038:	e594338c 	ldr	r3, [r4, #908]	; 0x38c
 510703c:	e5843378 	str	r3, [r4, #888]	; 0x378
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
 5107040:	e2632007 	rsb	r2, r3, #7
                    prvAddTaskToReadyList( pxTCB );
 5107044:	e083c103 	add	ip, r3, r3, lsl #2
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority );
 5107048:	e5842364 	str	r2, [r4, #868]	; 0x364
                    prvAddTaskToReadyList( pxTCB );
 510704c:	e5952010 	ldr	r2, [r5, #16]
 5107050:	e081110c 	add	r1, r1, ip, lsl #2
 5107054:	e1823310 	orr	r3, r2, r0, lsl r3
 5107058:	e5853010 	str	r3, [r5, #16]
 510705c:	e085510c 	add	r5, r5, ip, lsl #2
 5107060:	e5953034 	ldr	r3, [r5, #52]	; 0x34
 5107064:	e5952030 	ldr	r2, [r5, #48]	; 0x30
 5107068:	e5843354 	str	r3, [r4, #852]	; 0x354
 510706c:	e593c008 	ldr	ip, [r3, #8]
 5107070:	e0822000 	add	r2, r2, r0
 5107074:	e584c358 	str	ip, [r4, #856]	; 0x358
 5107078:	e593c008 	ldr	ip, [r3, #8]
 510707c:	e58c6004 	str	r6, [ip, #4]
 5107080:	e5836008 	str	r6, [r3, #8]
 5107084:	e5841360 	str	r1, [r4, #864]	; 0x360
 5107088:	e5852030 	str	r2, [r5, #48]	; 0x30
    }
 510708c:	e8bd8070 	pop	{r4, r5, r6, pc}
 5107090:	0511cde8 	.word	0x0511cde8

05107094 <vTaskPriorityDisinheritAfterTimeout>:
    {
 5107094:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if( pxMutexHolder != NULL )
 5107098:	e2504000 	subs	r4, r0, #0
 510709c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            configASSERT( pxTCB->uxMutexesHeld );
 51070a0:	e5943390 	ldr	r3, [r4, #912]	; 0x390
 51070a4:	e1a05001 	mov	r5, r1
 51070a8:	e3530000 	cmp	r3, #0
 51070ac:	0a000036 	beq	510718c <vTaskPriorityDisinheritAfterTimeout+0xf8>
            if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
 51070b0:	e594138c 	ldr	r1, [r4, #908]	; 0x38c
            if( pxTCB->uxPriority != uxPriorityToUse )
 51070b4:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 51070b8:	e1550001 	cmp	r5, r1
 51070bc:	31a05001 	movcc	r5, r1
 51070c0:	e1530005 	cmp	r3, r5
 51070c4:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
                if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
 51070c8:	e5942390 	ldr	r2, [r4, #912]	; 0x390
 51070cc:	e3520001 	cmp	r2, #1
 51070d0:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                    configASSERT( pxTCB != pxCurrentTCB );
 51070d4:	e30c6db8 	movw	r6, #52664	; 0xcdb8
 51070d8:	e3406511 	movt	r6, #1297	; 0x511
 51070dc:	e596200c 	ldr	r2, [r6, #12]
 51070e0:	e1520004 	cmp	r2, r4
 51070e4:	0a00002f 	beq	51071a8 <vTaskPriorityDisinheritAfterTimeout+0x114>
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 51070e8:	e5942364 	ldr	r2, [r4, #868]	; 0x364
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 51070ec:	e0833103 	add	r3, r3, r3, lsl #2
                    pxTCB->uxPriority = uxPriorityToUse;
 51070f0:	e5845378 	str	r5, [r4, #888]	; 0x378
                    if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == ( ( TickType_t ) 0U ) )
 51070f4:	e3520000 	cmp	r2, #0
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 51070f8:	e5942360 	ldr	r2, [r4, #864]	; 0x360
                        listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse );
 51070fc:	a2655007 	rsbge	r5, r5, #7
 5107100:	a5845364 	strge	r5, [r4, #868]	; 0x364
                    if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 5107104:	e59f50bc 	ldr	r5, [pc, #188]	; 51071c8 <vTaskPriorityDisinheritAfterTimeout+0x134>
 5107108:	e0853103 	add	r3, r5, r3, lsl #2
 510710c:	e1520003 	cmp	r2, r3
 5107110:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5107114:	e3003cd8 	movw	r3, #3288	; 0xcd8
 5107118:	e2847e35 	add	r7, r4, #848	; 0x350
 510711c:	e1a00007 	mov	r0, r7
 5107120:	e3403510 	movt	r3, #1296	; 0x510
 5107124:	e12fff33 	blx	r3
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 5107128:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 510712c:	e3a02001 	mov	r2, #1
 5107130:	e1a02312 	lsl	r2, r2, r3
                        prvAddTaskToReadyList( pxTCB );
 5107134:	e0833103 	add	r3, r3, r3, lsl #2
 5107138:	e0855103 	add	r5, r5, r3, lsl #2
 510713c:	e0863103 	add	r3, r6, r3, lsl #2
                        if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 5107140:	e3500000 	cmp	r0, #0
                            portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 5107144:	05961010 	ldreq	r1, [r6, #16]
 5107148:	01c11002 	biceq	r1, r1, r2
 510714c:	05861010 	streq	r1, [r6, #16]
                        prvAddTaskToReadyList( pxTCB );
 5107150:	e5961010 	ldr	r1, [r6, #16]
 5107154:	e1812002 	orr	r2, r1, r2
 5107158:	e5931030 	ldr	r1, [r3, #48]	; 0x30
 510715c:	e5862010 	str	r2, [r6, #16]
 5107160:	e5932034 	ldr	r2, [r3, #52]	; 0x34
 5107164:	e2811001 	add	r1, r1, #1
 5107168:	e5842354 	str	r2, [r4, #852]	; 0x354
 510716c:	e5920008 	ldr	r0, [r2, #8]
 5107170:	e5840358 	str	r0, [r4, #856]	; 0x358
 5107174:	e5920008 	ldr	r0, [r2, #8]
 5107178:	e5807004 	str	r7, [r0, #4]
 510717c:	e5827008 	str	r7, [r2, #8]
 5107180:	e5845360 	str	r5, [r4, #864]	; 0x360
 5107184:	e5831030 	str	r1, [r3, #48]	; 0x30
    }
 5107188:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            configASSERT( pxTCB->uxMutexesHeld );
 510718c:	e30d0abc 	movw	r0, #55996	; 0xdabc
 5107190:	e3003900 	movw	r3, #2304	; 0x900
 5107194:	e3011a86 	movw	r1, #6790	; 0x1a86
 5107198:	e3403511 	movt	r3, #1297	; 0x511
 510719c:	e3400512 	movt	r0, #1298	; 0x512
 51071a0:	e12fff33 	blx	r3
 51071a4:	eaffffc1 	b	51070b0 <vTaskPriorityDisinheritAfterTimeout+0x1c>
                    configASSERT( pxTCB != pxCurrentTCB );
 51071a8:	e30d0abc 	movw	r0, #55996	; 0xdabc
 51071ac:	e3003900 	movw	r3, #2304	; 0x900
 51071b0:	e3011aa1 	movw	r1, #6817	; 0x1aa1
 51071b4:	e3403511 	movt	r3, #1297	; 0x511
 51071b8:	e3400512 	movt	r0, #1298	; 0x512
 51071bc:	e12fff33 	blx	r3
                    uxPriorityUsedOnEntry = pxTCB->uxPriority;
 51071c0:	e5943378 	ldr	r3, [r4, #888]	; 0x378
 51071c4:	eaffffc7 	b	51070e8 <vTaskPriorityDisinheritAfterTimeout+0x54>
 51071c8:	0511cde8 	.word	0x0511cde8

051071cc <pvTaskIncrementMutexHeldCount>:
        pxTCB = pxCurrentTCB;
 51071cc:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51071d0:	e3403511 	movt	r3, #1297	; 0x511
 51071d4:	e593000c 	ldr	r0, [r3, #12]
        if( pxTCB != NULL )
 51071d8:	e3500000 	cmp	r0, #0
            ( pxTCB->uxMutexesHeld )++;
 51071dc:	15903390 	ldrne	r3, [r0, #912]	; 0x390
 51071e0:	12833001 	addne	r3, r3, #1
 51071e4:	15803390 	strne	r3, [r0, #912]	; 0x390
    }
 51071e8:	e12fff1e 	bx	lr

051071ec <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 51071ec:	e30c3db8 	movw	r3, #52664	; 0xcdb8
 51071f0:	e3403511 	movt	r3, #1297	; 0x511
 51071f4:	e5932124 	ldr	r2, [r3, #292]	; 0x124
    pxTimeOut->xTimeOnEntering = xTickCount;
 51071f8:	e5933000 	ldr	r3, [r3]
 51071fc:	e1c020f0 	strd	r2, [r0]
}
 5107200:	e12fff1e 	bx	lr

05107204 <xTaskGetMPUSettings>:
        pxTCB = prvGetTCBFromHandle( xTask );
 5107204:	e3500000 	cmp	r0, #0
 5107208:	030c3db8 	movweq	r3, #52664	; 0xcdb8
 510720c:	03403511 	movteq	r3, #1297	; 0x511
 5107210:	0593000c 	ldreq	r0, [r3, #12]
    }
 5107214:	e2800004 	add	r0, r0, #4
 5107218:	e12fff1e 	bx	lr

0510721c <prvCheckForValidListAndQueue>:
        pxOverflowTimerList = pxTemp;
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 510721c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
        {
            if( xTimerQueue == NULL )
 5107220:	e30c4ee4 	movw	r4, #52964	; 0xcee4
        taskENTER_CRITICAL();
 5107224:	e30c3930 	movw	r3, #51504	; 0xc930
            if( xTimerQueue == NULL )
 5107228:	e3404511 	movt	r4, #1297	; 0x511
    {
 510722c:	e24dd008 	sub	sp, sp, #8
        taskENTER_CRITICAL();
 5107230:	e3403510 	movt	r3, #1296	; 0x510
 5107234:	e12fff33 	blx	r3
            if( xTimerQueue == NULL )
 5107238:	e5945000 	ldr	r5, [r4]
 510723c:	e3550000 	cmp	r5, #0
 5107240:	0a000004 	beq	5107258 <prvCheckForValidListAndQueue+0x3c>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 5107244:	e30c3988 	movw	r3, #51592	; 0xc988
 5107248:	e3403510 	movt	r3, #1296	; 0x510
 510724c:	e12fff33 	blx	r3
    }
 5107250:	e28dd008 	add	sp, sp, #8
 5107254:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                vListInitialise( &xActiveTimerList1 );
 5107258:	e3006c28 	movw	r6, #3112	; 0xc28
 510725c:	e2848004 	add	r8, r4, #4
 5107260:	e1a00008 	mov	r0, r8
 5107264:	e3406510 	movt	r6, #1296	; 0x510
                vListInitialise( &xActiveTimerList2 );
 5107268:	e2847018 	add	r7, r4, #24
                vListInitialise( &xActiveTimerList1 );
 510726c:	e12fff36 	blx	r6
                vListInitialise( &xActiveTimerList2 );
 5107270:	e1a00007 	mov	r0, r7
 5107274:	e12fff36 	blx	r6
                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 5107278:	e58d5000 	str	r5, [sp]
 510727c:	e302598c 	movw	r5, #10636	; 0x298c
 5107280:	e2843034 	add	r3, r4, #52	; 0x34
 5107284:	e3a01010 	mov	r1, #16
 5107288:	e2842080 	add	r2, r4, #128	; 0x80
 510728c:	e3a00002 	mov	r0, #2
 5107290:	e3405510 	movt	r5, #1296	; 0x510
                pxCurrentTimerList = &xActiveTimerList1;
 5107294:	e584802c 	str	r8, [r4, #44]	; 0x2c
                pxOverflowTimerList = &xActiveTimerList2;
 5107298:	e5847030 	str	r7, [r4, #48]	; 0x30
                    xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 510729c:	e12fff35 	blx	r5
 51072a0:	e5840000 	str	r0, [r4]
                    if( xTimerQueue != NULL )
 51072a4:	e3500000 	cmp	r0, #0
 51072a8:	0affffe5 	beq	5107244 <prvCheckForValidListAndQueue+0x28>
                        vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 51072ac:	e30d1ae4 	movw	r1, #56036	; 0xdae4
 51072b0:	e30233fc 	movw	r3, #9212	; 0x23fc
 51072b4:	e3401512 	movt	r1, #1298	; 0x512
 51072b8:	e3403510 	movt	r3, #1296	; 0x510
 51072bc:	e12fff33 	blx	r3
 51072c0:	eaffffdf 	b	5107244 <prvCheckForValidListAndQueue+0x28>

051072c4 <prvProcessExpiredTimer>:
    {
 51072c4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 51072c8:	e30c6ee4 	movw	r6, #52964	; 0xcee4
    {
 51072cc:	e1a05000 	mov	r5, r0
 51072d0:	e1a08001 	mov	r8, r1
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
 51072d4:	e3406511 	movt	r6, #1297	; 0x511
 51072d8:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
 51072dc:	e593300c 	ldr	r3, [r3, #12]
 51072e0:	e593400c 	ldr	r4, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 51072e4:	e3003cd8 	movw	r3, #3288	; 0xcd8
 51072e8:	e3403510 	movt	r3, #1296	; 0x510
 51072ec:	e2847004 	add	r7, r4, #4
 51072f0:	e1a00007 	mov	r0, r7
 51072f4:	e12fff33 	blx	r3
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
 51072f8:	e5d43024 	ldrb	r3, [r4, #36]	; 0x24
 51072fc:	e3130004 	tst	r3, #4
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 5107300:	03c33001 	biceq	r3, r3, #1
 5107304:	05c43024 	strbeq	r3, [r4, #36]	; 0x24
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
 5107308:	1a000008 	bne	5107330 <prvProcessExpiredTimer+0x6c>
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 510730c:	e5943020 	ldr	r3, [r4, #32]
 5107310:	e1a00004 	mov	r0, r4
 5107314:	e12fff33 	blx	r3
    }
 5107318:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 510731c:	e15c0001 	cmp	ip, r1
 5107320:	8a000018 	bhi	5107388 <prvProcessExpiredTimer+0xc4>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 5107324:	e5943020 	ldr	r3, [r4, #32]
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 5107328:	e1a05002 	mov	r5, r2
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 510732c:	e12fff33 	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 5107330:	e594c018 	ldr	ip, [r4, #24]
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 5107334:	e1a00004 	mov	r0, r4
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 5107338:	e5844010 	str	r4, [r4, #16]
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 510733c:	e0481005 	sub	r1, r8, r5
 5107340:	e095200c 	adds	r2, r5, ip
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 5107344:	23a03001 	movcs	r3, #1
 5107348:	33a03000 	movcc	r3, #0
        if( xNextExpiryTime <= xTimeNow )
 510734c:	e1580002 	cmp	r8, r2
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 5107350:	e5842004 	str	r2, [r4, #4]
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 5107354:	e2233001 	eor	r3, r3, #1
        if( xNextExpiryTime <= xTimeNow )
 5107358:	2affffef 	bcs	510731c <prvProcessExpiredTimer+0x58>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 510735c:	e1580005 	cmp	r8, r5
 5107360:	23a03000 	movcs	r3, #0
 5107364:	32033001 	andcc	r3, r3, #1
 5107368:	e3530000 	cmp	r3, #0
 510736c:	1affffec 	bne	5107324 <prvProcessExpiredTimer+0x60>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 5107370:	e3003c54 	movw	r3, #3156	; 0xc54
 5107374:	e1a01007 	mov	r1, r7
 5107378:	e596002c 	ldr	r0, [r6, #44]	; 0x2c
 510737c:	e3403510 	movt	r3, #1296	; 0x510
 5107380:	e12fff33 	blx	r3
        return xProcessTimerNow;
 5107384:	eaffffe0 	b	510730c <prvProcessExpiredTimer+0x48>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 5107388:	e3003c54 	movw	r3, #3156	; 0xc54
 510738c:	e1a01007 	mov	r1, r7
 5107390:	e5960030 	ldr	r0, [r6, #48]	; 0x30
 5107394:	e3403510 	movt	r3, #1296	; 0x510
 5107398:	e12fff33 	blx	r3
        return xProcessTimerNow;
 510739c:	eaffffda 	b	510730c <prvProcessExpiredTimer+0x48>

051073a0 <prvTimerTask>:
    {
 51073a0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 51073a4:	ed2d8b02 	vpush	{d8}
 51073a8:	e3023704 	movw	r3, #9988	; 0x2704
 51073ac:	e30c4ee4 	movw	r4, #52964	; 0xcee4
 51073b0:	e305b2a0 	movw	fp, #21152	; 0x52a0
 51073b4:	e3403510 	movt	r3, #1296	; 0x510
 51073b8:	e30592b8 	movw	r9, #21176	; 0x52b8
 51073bc:	e305aefc 	movw	sl, #24316	; 0x5efc
 51073c0:	e3016674 	movw	r6, #5748	; 0x1674
 51073c4:	e3404511 	movt	r4, #1297	; 0x511
 51073c8:	e340b510 	movt	fp, #1296	; 0x510
 51073cc:	e3409510 	movt	r9, #1296	; 0x510
 51073d0:	e340a510 	movt	sl, #1296	; 0x510
 51073d4:	e24dd034 	sub	sp, sp, #52	; 0x34
 51073d8:	e3a08000 	mov	r8, #0
 51073dc:	e3406510 	movt	r6, #1296	; 0x510
 51073e0:	e58d3008 	str	r3, [sp, #8]
 51073e4:	e3003000 	movw	r3, #0
 51073e8:	e3403511 	movt	r3, #1297	; 0x511
 51073ec:	e58d3010 	str	r3, [sp, #16]
 51073f0:	e3003cd8 	movw	r3, #3288	; 0xcd8
 51073f4:	e3403510 	movt	r3, #1296	; 0x510
 51073f8:	e58d3004 	str	r3, [sp, #4]
 51073fc:	e3003c54 	movw	r3, #3156	; 0xc54
 5107400:	e3403510 	movt	r3, #1296	; 0x510
 5107404:	e58d300c 	str	r3, [sp, #12]
 5107408:	e3003900 	movw	r3, #2304	; 0x900
 510740c:	e3403511 	movt	r3, #1297	; 0x511
 5107410:	e58d3018 	str	r3, [sp, #24]
 5107414:	e308333c 	movw	r3, #33596	; 0x833c
 5107418:	e3403510 	movt	r3, #1296	; 0x510
 510741c:	e58d301c 	str	r3, [sp, #28]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 5107420:	e30d3aec 	movw	r3, #56044	; 0xdaec
 5107424:	e3403512 	movt	r3, #1298	; 0x512
 5107428:	ee083a10 	vmov	s16, r3
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 510742c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5107430:	e5937000 	ldr	r7, [r3]
 5107434:	e3570000 	cmp	r7, #0
 5107438:	0a0000a9 	beq	51076e4 <prvTimerTask+0x344>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 510743c:	e593300c 	ldr	r3, [r3, #12]
 5107440:	e5937000 	ldr	r7, [r3]
        vTaskSuspendAll();
 5107444:	e12fff3b 	blx	fp
        xTimeNow = xTaskGetTickCount();
 5107448:	e12fff39 	blx	r9
        if( xTimeNow < xLastTime )
 510744c:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
        xTimeNow = xTaskGetTickCount();
 5107450:	e1a05000 	mov	r5, r0
        if( xTimeNow < xLastTime )
 5107454:	e1500003 	cmp	r0, r3
 5107458:	3a000033 	bcc	510752c <prvTimerTask+0x18c>
        xLastTime = xTimeNow;
 510745c:	e58400a0 	str	r0, [r4, #160]	; 0xa0
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 5107460:	e1570000 	cmp	r7, r0
 5107464:	83a02000 	movhi	r2, #0
 5107468:	8a0000a8 	bhi	5107710 <prvTimerTask+0x370>
                    ( void ) xTaskResumeAll();
 510746c:	e12fff3a 	blx	sl
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 5107470:	e1a01005 	mov	r1, r5
 5107474:	e1a00007 	mov	r0, r7
 5107478:	ebffff91 	bl	51072c4 <prvProcessExpiredTimer>
        DaemonTaskMessage_t xMessage = { 0 };
 510747c:	e58d8020 	str	r8, [sp, #32]
 5107480:	e58d8024 	str	r8, [sp, #36]	; 0x24
 5107484:	e58d8028 	str	r8, [sp, #40]	; 0x28
 5107488:	e58d802c 	str	r8, [sp, #44]	; 0x2c
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
 510748c:	e5940000 	ldr	r0, [r4]
 5107490:	e3a02000 	mov	r2, #0
 5107494:	e28d1020 	add	r1, sp, #32
 5107498:	e12fff36 	blx	r6
 510749c:	e3500000 	cmp	r0, #0
 51074a0:	0affffe1 	beq	510742c <prvTimerTask+0x8c>
                if( xMessage.xMessageID < ( BaseType_t ) 0 )
 51074a4:	e59d3020 	ldr	r3, [sp, #32]
 51074a8:	e3530000 	cmp	r3, #0
 51074ac:	ba000085 	blt	51076c8 <prvTimerTask+0x328>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 51074b0:	e59d5028 	ldr	r5, [sp, #40]	; 0x28
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
 51074b4:	e5953014 	ldr	r3, [r5, #20]
 51074b8:	e3530000 	cmp	r3, #0
 51074bc:	0a000002 	beq	51074cc <prvTimerTask+0x12c>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 51074c0:	e59d3004 	ldr	r3, [sp, #4]
 51074c4:	e2850004 	add	r0, r5, #4
 51074c8:	e12fff33 	blx	r3
        xTimeNow = xTaskGetTickCount();
 51074cc:	e12fff39 	blx	r9
        if( xTimeNow < xLastTime )
 51074d0:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
        xTimeNow = xTaskGetTickCount();
 51074d4:	e1a07000 	mov	r7, r0
        if( xTimeNow < xLastTime )
 51074d8:	e1500003 	cmp	r0, r3
 51074dc:	3a00001f 	bcc	5107560 <prvTimerTask+0x1c0>
        xLastTime = xTimeNow;
 51074e0:	e59d3020 	ldr	r3, [sp, #32]
 51074e4:	e58470a0 	str	r7, [r4, #160]	; 0xa0
                switch( xMessage.xMessageID )
 51074e8:	e2433001 	sub	r3, r3, #1
 51074ec:	e3530008 	cmp	r3, #8
 51074f0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 51074f4:	eaffffe4 	b	510748c <prvTimerTask+0xec>
 51074f8:	0510757c 	.word	0x0510757c
 51074fc:	0510757c 	.word	0x0510757c
 5107500:	05107694 	.word	0x05107694
 5107504:	05107650 	.word	0x05107650
 5107508:	051076a4 	.word	0x051076a4
 510750c:	0510757c 	.word	0x0510757c
 5107510:	0510757c 	.word	0x0510757c
 5107514:	05107694 	.word	0x05107694
 5107518:	05107650 	.word	0x05107650
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 510751c:	e593300c 	ldr	r3, [r3, #12]
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 5107520:	e3e01000 	mvn	r1, #0
 5107524:	e5930000 	ldr	r0, [r3]
 5107528:	ebffff65 	bl	51072c4 <prvProcessExpiredTimer>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 510752c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5107530:	e5932000 	ldr	r2, [r3]
 5107534:	e3520000 	cmp	r2, #0
 5107538:	1afffff7 	bne	510751c <prvTimerTask+0x17c>
        pxCurrentTimerList = pxOverflowTimerList;
 510753c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
        xLastTime = xTimeNow;
 5107540:	e58450a0 	str	r5, [r4, #160]	; 0xa0
        pxOverflowTimerList = pxTemp;
 5107544:	e1c422fc 	strd	r2, [r4, #44]	; 0x2c
                ( void ) xTaskResumeAll();
 5107548:	e12fff3a 	blx	sl
 510754c:	eaffffca 	b	510747c <prvTimerTask+0xdc>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 5107550:	e593300c 	ldr	r3, [r3, #12]
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 5107554:	e3e01000 	mvn	r1, #0
 5107558:	e5930000 	ldr	r0, [r3]
 510755c:	ebffff58 	bl	51072c4 <prvProcessExpiredTimer>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 5107560:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
 5107564:	e5932000 	ldr	r2, [r3]
 5107568:	e3520000 	cmp	r2, #0
 510756c:	1afffff7 	bne	5107550 <prvTimerTask+0x1b0>
        pxCurrentTimerList = pxOverflowTimerList;
 5107570:	e5942030 	ldr	r2, [r4, #48]	; 0x30
 5107574:	e1c422fc 	strd	r2, [r4, #44]	; 0x2c
            *pxTimerListsWereSwitched = pdTRUE;
 5107578:	eaffffd8 	b	51074e0 <prvTimerTask+0x140>
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 510757c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 5107580:	e5d5c024 	ldrb	ip, [r5, #36]	; 0x24
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 5107584:	e5952018 	ldr	r2, [r5, #24]
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 5107588:	e38c3001 	orr	r3, ip, #1
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 510758c:	e5855010 	str	r5, [r5, #16]
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 5107590:	e5c53024 	strb	r3, [r5, #36]	; 0x24
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 5107594:	e0913002 	adds	r3, r1, r2
 5107598:	23a00001 	movcs	r0, #1
 510759c:	33a00000 	movcc	r0, #0
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 51075a0:	e5853004 	str	r3, [r5, #4]
        if( xNextExpiryTime <= xTimeNow )
 51075a4:	e1530007 	cmp	r3, r7
 51075a8:	8a000062 	bhi	5107738 <prvTimerTask+0x398>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 51075ac:	e0471001 	sub	r1, r7, r1
 51075b0:	e1520001 	cmp	r2, r1
 51075b4:	8a000072 	bhi	5107784 <prvTimerTask+0x3e4>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0U )
 51075b8:	e31c0004 	tst	ip, #4
 51075bc:	11a0c002 	movne	ip, r2
 51075c0:	158d4014 	strne	r4, [sp, #20]
 51075c4:	11a04007 	movne	r4, r7
 51075c8:	1a00000b 	bne	51075fc <prvTimerTask+0x25c>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 51075cc:	e3ccc001 	bic	ip, ip, #1
 51075d0:	e5c5c024 	strb	ip, [r5, #36]	; 0x24
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 51075d4:	e5953020 	ldr	r3, [r5, #32]
 51075d8:	e1a00005 	mov	r0, r5
 51075dc:	e12fff33 	blx	r3
 51075e0:	eaffffa9 	b	510748c <prvTimerTask+0xec>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 51075e4:	e15e000c 	cmp	lr, ip
 51075e8:	3a00006a 	bcc	5107798 <prvTimerTask+0x3f8>
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 51075ec:	e5953020 	ldr	r3, [r5, #32]
 51075f0:	e12fff33 	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 51075f4:	e595c018 	ldr	ip, [r5, #24]
 51075f8:	e1a03007 	mov	r3, r7
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 51075fc:	e1a00005 	mov	r0, r5
 5107600:	e093700c 	adds	r7, r3, ip
 5107604:	23a01001 	movcs	r1, #1
 5107608:	33a01000 	movcc	r1, #0
        if( xNextExpiryTime <= xTimeNow )
 510760c:	e1540007 	cmp	r4, r7
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 5107610:	e044e003 	sub	lr, r4, r3
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 5107614:	e5855010 	str	r5, [r5, #16]
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 5107618:	e2211001 	eor	r1, r1, #1
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 510761c:	e5857004 	str	r7, [r5, #4]
        if( xNextExpiryTime <= xTimeNow )
 5107620:	2affffef 	bcs	51075e4 <prvTimerTask+0x244>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 5107624:	e1540003 	cmp	r4, r3
 5107628:	23a01000 	movcs	r1, #0
 510762c:	32011001 	andcc	r1, r1, #1
 5107630:	e3510000 	cmp	r1, #0
 5107634:	1affffec 	bne	51075ec <prvTimerTask+0x24c>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 5107638:	e59d4014 	ldr	r4, [sp, #20]
 510763c:	e2851004 	add	r1, r5, #4
 5107640:	e59d300c 	ldr	r3, [sp, #12]
 5107644:	e594002c 	ldr	r0, [r4, #44]	; 0x2c
 5107648:	e12fff33 	blx	r3
        return xProcessTimerNow;
 510764c:	eaffffe0 	b	51075d4 <prvTimerTask+0x234>
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 5107650:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 5107654:	e5d52024 	ldrb	r2, [r5, #36]	; 0x24
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 5107658:	e5853018 	str	r3, [r5, #24]
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 510765c:	e3822001 	orr	r2, r2, #1
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 5107660:	e3530000 	cmp	r3, #0
                        pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_ACTIVE;
 5107664:	e5c52024 	strb	r2, [r5, #36]	; 0x24
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 5107668:	0a000039 	beq	5107754 <prvTimerTask+0x3b4>
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 510766c:	e5855010 	str	r5, [r5, #16]
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 5107670:	e0833007 	add	r3, r3, r7
        if( xNextExpiryTime <= xTimeNow )
 5107674:	e1570003 	cmp	r7, r3
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 5107678:	e5853004 	str	r3, [r5, #4]
        if( xNextExpiryTime <= xTimeNow )
 510767c:	2a000040 	bcs	5107784 <prvTimerTask+0x3e4>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 5107680:	e594002c 	ldr	r0, [r4, #44]	; 0x2c
 5107684:	e2851004 	add	r1, r5, #4
 5107688:	e59d300c 	ldr	r3, [sp, #12]
 510768c:	e12fff33 	blx	r3
 5107690:	eaffff7d 	b	510748c <prvTimerTask+0xec>
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 5107694:	e5d53024 	ldrb	r3, [r5, #36]	; 0x24
 5107698:	e3c33001 	bic	r3, r3, #1
 510769c:	e5c53024 	strb	r3, [r5, #36]	; 0x24
                        break;
 51076a0:	eaffff79 	b	510748c <prvTimerTask+0xec>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 51076a4:	e5d53024 	ldrb	r3, [r5, #36]	; 0x24
 51076a8:	e3130002 	tst	r3, #2
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 51076ac:	13c33001 	bicne	r3, r3, #1
 51076b0:	15c53024 	strbne	r3, [r5, #36]	; 0x24
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 51076b4:	1affff74 	bne	510748c <prvTimerTask+0xec>
                                vPortFree( pxTimer );
 51076b8:	e59d301c 	ldr	r3, [sp, #28]
 51076bc:	e1a00005 	mov	r0, r5
 51076c0:	e12fff33 	blx	r3
 51076c4:	eaffff70 	b	510748c <prvTimerTask+0xec>
                    pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 51076c8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 51076cc:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
 51076d0:	e12fff33 	blx	r3
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 51076d4:	e59d3020 	ldr	r3, [sp, #32]
 51076d8:	e3530000 	cmp	r3, #0
 51076dc:	baffff6a 	blt	510748c <prvTimerTask+0xec>
 51076e0:	eaffff72 	b	51074b0 <prvTimerTask+0x110>
        vTaskSuspendAll();
 51076e4:	e12fff3b 	blx	fp
        xTimeNow = xTaskGetTickCount();
 51076e8:	e12fff39 	blx	r9
        if( xTimeNow < xLastTime )
 51076ec:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
        xTimeNow = xTaskGetTickCount();
 51076f0:	e1a05000 	mov	r5, r0
        if( xTimeNow < xLastTime )
 51076f4:	e1500003 	cmp	r0, r3
 51076f8:	3affff8b 	bcc	510752c <prvTimerTask+0x18c>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 51076fc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
        xLastTime = xTimeNow;
 5107700:	e58450a0 	str	r5, [r4, #160]	; 0xa0
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 5107704:	e5932000 	ldr	r2, [r3]
 5107708:	e16f2f12 	clz	r2, r2
 510770c:	e1a022a2 	lsr	r2, r2, #5
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 5107710:	e5940000 	ldr	r0, [r4]
 5107714:	e0471005 	sub	r1, r7, r5
 5107718:	e59d3008 	ldr	r3, [sp, #8]
 510771c:	e12fff33 	blx	r3
                    if( xTaskResumeAll() == pdFALSE )
 5107720:	e12fff3a 	blx	sl
 5107724:	e3500000 	cmp	r0, #0
 5107728:	1affff53 	bne	510747c <prvTimerTask+0xdc>
                        taskYIELD_WITHIN_API();
 510772c:	e59d3010 	ldr	r3, [sp, #16]
 5107730:	e12fff33 	blx	r3
 5107734:	eaffff50 	b	510747c <prvTimerTask+0xdc>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 5107738:	e2200001 	eor	r0, r0, #1
 510773c:	e1510007 	cmp	r1, r7
 5107740:	93a00000 	movls	r0, #0
 5107744:	82000001 	andhi	r0, r0, #1
 5107748:	e3500000 	cmp	r0, #0
 510774c:	1affff99 	bne	51075b8 <prvTimerTask+0x218>
 5107750:	eaffffca 	b	5107680 <prvTimerTask+0x2e0>
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 5107754:	e59d3018 	ldr	r3, [sp, #24]
 5107758:	ee180a10 	vmov	r0, s16
 510775c:	e300141c 	movw	r1, #1052	; 0x41c
 5107760:	e12fff33 	blx	r3
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 5107764:	e5953018 	ldr	r3, [r5, #24]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 5107768:	e5855010 	str	r5, [r5, #16]
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 510776c:	e0832007 	add	r2, r3, r7
        if( xNextExpiryTime <= xTimeNow )
 5107770:	e1520007 	cmp	r2, r7
        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 5107774:	e5852004 	str	r2, [r5, #4]
        if( xNextExpiryTime <= xTimeNow )
 5107778:	8affffc0 	bhi	5107680 <prvTimerTask+0x2e0>
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
 510777c:	e3530000 	cmp	r3, #0
 5107780:	0affff41 	beq	510748c <prvTimerTask+0xec>
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 5107784:	e5940030 	ldr	r0, [r4, #48]	; 0x30
 5107788:	e2851004 	add	r1, r5, #4
 510778c:	e59d300c 	ldr	r3, [sp, #12]
 5107790:	e12fff33 	blx	r3
 5107794:	eaffff3c 	b	510748c <prvTimerTask+0xec>
 5107798:	e59d4014 	ldr	r4, [sp, #20]
 510779c:	e2851004 	add	r1, r5, #4
 51077a0:	e59d300c 	ldr	r3, [sp, #12]
 51077a4:	e5940030 	ldr	r0, [r4, #48]	; 0x30
 51077a8:	e12fff33 	blx	r3
        return xProcessTimerNow;
 51077ac:	eaffff88 	b	51075d4 <prvTimerTask+0x234>

051077b0 <xTimerCreate>:
        {
 51077b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 51077b4:	e1a05001 	mov	r5, r1
            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 51077b8:	e3071f74 	movw	r1, #32628	; 0x7f74
        {
 51077bc:	e1a08000 	mov	r8, r0
            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 51077c0:	e3401510 	movt	r1, #1296	; 0x510
 51077c4:	e3a00028 	mov	r0, #40	; 0x28
        {
 51077c8:	e1a06002 	mov	r6, r2
 51077cc:	e1a07003 	mov	r7, r3
            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
 51077d0:	e12fff31 	blx	r1
            if( pxNewTimer != NULL )
 51077d4:	e2504000 	subs	r4, r0, #0
 51077d8:	0a000011 	beq	5107824 <xTimerCreate+0x74>
                pxNewTimer->ucStatus = 0x00;
 51077dc:	e3a03000 	mov	r3, #0
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 51077e0:	e3550000 	cmp	r5, #0
                pxNewTimer->ucStatus = 0x00;
 51077e4:	e5c43024 	strb	r3, [r4, #36]	; 0x24
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 51077e8:	0a00000f 	beq	510782c <xTimerCreate+0x7c>
        prvCheckForValidListAndQueue();
 51077ec:	ebfffe8a 	bl	510721c <prvCheckForValidListAndQueue>
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 51077f0:	e59d3018 	ldr	r3, [sp, #24]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 51077f4:	e3002c48 	movw	r2, #3144	; 0xc48
 51077f8:	e2840004 	add	r0, r4, #4
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 51077fc:	e5843020 	str	r3, [r4, #32]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 5107800:	e3402510 	movt	r2, #1296	; 0x510
        pxNewTimer->pcTimerName = pcTimerName;
 5107804:	e5848000 	str	r8, [r4]
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 5107808:	e5845018 	str	r5, [r4, #24]
        pxNewTimer->pvTimerID = pvTimerID;
 510780c:	e584701c 	str	r7, [r4, #28]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 5107810:	e12fff32 	blx	r2
        if( xAutoReload != pdFALSE )
 5107814:	e3560000 	cmp	r6, #0
            pxNewTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 5107818:	15d43024 	ldrbne	r3, [r4, #36]	; 0x24
 510781c:	13833004 	orrne	r3, r3, #4
 5107820:	15c43024 	strbne	r3, [r4, #36]	; 0x24
        }
 5107824:	e1a00004 	mov	r0, r4
 5107828:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 510782c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107830:	e3003900 	movw	r3, #2304	; 0x900
 5107834:	e30011a9 	movw	r1, #425	; 0x1a9
 5107838:	e3403511 	movt	r3, #1297	; 0x511
 510783c:	e3400512 	movt	r0, #1298	; 0x512
 5107840:	e12fff33 	blx	r3
 5107844:	eaffffe8 	b	51077ec <xTimerCreate+0x3c>

05107848 <xTimerCreateStatic>:
        {
 5107848:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 510784c:	e1a07002 	mov	r7, r2
 5107850:	e24dd008 	sub	sp, sp, #8
                volatile size_t xSize = sizeof( StaticTimer_t );
 5107854:	e3a02028 	mov	r2, #40	; 0x28
        {
 5107858:	e1a06000 	mov	r6, r0
 510785c:	e1a05001 	mov	r5, r1
 5107860:	e1a08003 	mov	r8, r3
                volatile size_t xSize = sizeof( StaticTimer_t );
 5107864:	e58d2004 	str	r2, [sp, #4]
                configASSERT( xSize == sizeof( Timer_t ) );
 5107868:	e59d2004 	ldr	r2, [sp, #4]
        {
 510786c:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
                configASSERT( xSize == sizeof( Timer_t ) );
 5107870:	e3520028 	cmp	r2, #40	; 0x28
 5107874:	0a000005 	beq	5107890 <xTimerCreateStatic+0x48>
 5107878:	e30d0aec 	movw	r0, #56044	; 0xdaec
 510787c:	e3003900 	movw	r3, #2304	; 0x900
 5107880:	e3400512 	movt	r0, #1298	; 0x512
 5107884:	e3001183 	movw	r1, #387	; 0x183
 5107888:	e3403511 	movt	r3, #1297	; 0x511
 510788c:	e12fff33 	blx	r3
                ( void ) xSize; /* Prevent unused variable warning when configASSERT() is not defined. */
 5107890:	e59d3004 	ldr	r3, [sp, #4]
            configASSERT( pxTimerBuffer );
 5107894:	e3540000 	cmp	r4, #0
 5107898:	0a00001b 	beq	510790c <xTimerCreateStatic+0xc4>
                pxNewTimer->ucStatus = ( uint8_t ) tmrSTATUS_IS_STATICALLY_ALLOCATED;
 510789c:	e3a03002 	mov	r3, #2
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 51078a0:	e3550000 	cmp	r5, #0
                pxNewTimer->ucStatus = ( uint8_t ) tmrSTATUS_IS_STATICALLY_ALLOCATED;
 51078a4:	e5c43024 	strb	r3, [r4, #36]	; 0x24
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 51078a8:	0a000010 	beq	51078f0 <xTimerCreateStatic+0xa8>
        prvCheckForValidListAndQueue();
 51078ac:	ebfffe5a 	bl	510721c <prvCheckForValidListAndQueue>
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 51078b0:	e59d3020 	ldr	r3, [sp, #32]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 51078b4:	e3002c48 	movw	r2, #3144	; 0xc48
 51078b8:	e2840004 	add	r0, r4, #4
        pxNewTimer->pcTimerName = pcTimerName;
 51078bc:	e5846000 	str	r6, [r4]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 51078c0:	e3402510 	movt	r2, #1296	; 0x510
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
 51078c4:	e5845018 	str	r5, [r4, #24]
        pxNewTimer->pvTimerID = pvTimerID;
 51078c8:	e584801c 	str	r8, [r4, #28]
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
 51078cc:	e5843020 	str	r3, [r4, #32]
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
 51078d0:	e12fff32 	blx	r2
        if( xAutoReload != pdFALSE )
 51078d4:	e3570000 	cmp	r7, #0
            pxNewTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 51078d8:	15d43024 	ldrbne	r3, [r4, #36]	; 0x24
 51078dc:	13833004 	orrne	r3, r3, #4
 51078e0:	15c43024 	strbne	r3, [r4, #36]	; 0x24
        }
 51078e4:	e1a00004 	mov	r0, r4
 51078e8:	e28dd008 	add	sp, sp, #8
 51078ec:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( ( xTimerPeriodInTicks > 0 ) );
 51078f0:	e30d0aec 	movw	r0, #56044	; 0xdaec
 51078f4:	e3003900 	movw	r3, #2304	; 0x900
 51078f8:	e30011a9 	movw	r1, #425	; 0x1a9
 51078fc:	e3403511 	movt	r3, #1297	; 0x511
 5107900:	e3400512 	movt	r0, #1298	; 0x512
 5107904:	e12fff33 	blx	r3
 5107908:	eaffffe7 	b	51078ac <xTimerCreateStatic+0x64>
            configASSERT( pxTimerBuffer );
 510790c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107910:	e3003900 	movw	r3, #2304	; 0x900
 5107914:	e3001189 	movw	r1, #393	; 0x189
 5107918:	e3403511 	movt	r3, #1297	; 0x511
 510791c:	e3400512 	movt	r0, #1298	; 0x512
 5107920:	e12fff33 	blx	r3
        }
 5107924:	e1a00004 	mov	r0, r4
 5107928:	e28dd008 	add	sp, sp, #8
 510792c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05107930 <pvTimerGetTimerID>:
        return xReturn;
    }
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
 5107930:	e92d4010 	push	{r4, lr}
        Timer_t * const pxTimer = xTimer;
        void * pvReturn;

        traceENTER_pvTimerGetTimerID( xTimer );

        configASSERT( xTimer );
 5107934:	e2504000 	subs	r4, r0, #0
    {
 5107938:	e24dd008 	sub	sp, sp, #8
        configASSERT( xTimer );
 510793c:	0a00000a 	beq	510796c <pvTimerGetTimerID+0x3c>

        taskENTER_CRITICAL();
 5107940:	e30c3930 	movw	r3, #51504	; 0xc930
 5107944:	e3403510 	movt	r3, #1296	; 0x510
 5107948:	e12fff33 	blx	r3
        {
            pvReturn = pxTimer->pvTimerID;
 510794c:	e594001c 	ldr	r0, [r4, #28]
 5107950:	e58d0004 	str	r0, [sp, #4]
        }
        taskEXIT_CRITICAL();
 5107954:	e30c3988 	movw	r3, #51592	; 0xc988
 5107958:	e3403510 	movt	r3, #1296	; 0x510
 510795c:	e12fff33 	blx	r3

        traceRETURN_pvTimerGetTimerID( pvReturn );

        return pvReturn;
    }
 5107960:	e59d0004 	ldr	r0, [sp, #4]
 5107964:	e28dd008 	add	sp, sp, #8
 5107968:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 510796c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107970:	e3003900 	movw	r3, #2304	; 0x900
 5107974:	e30014ba 	movw	r1, #1210	; 0x4ba
 5107978:	e3403511 	movt	r3, #1297	; 0x511
 510797c:	e3400512 	movt	r0, #1298	; 0x512
 5107980:	e12fff33 	blx	r3
 5107984:	eaffffed 	b	5107940 <pvTimerGetTimerID+0x10>

05107988 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
 5107988:	e92d4070 	push	{r4, r5, r6, lr}
 510798c:	e1a05001 	mov	r5, r1
        Timer_t * const pxTimer = xTimer;

        traceENTER_vTimerSetTimerID( xTimer, pvNewID );

        configASSERT( xTimer );
 5107990:	e2504000 	subs	r4, r0, #0
 5107994:	0a000007 	beq	51079b8 <vTimerSetTimerID+0x30>

        taskENTER_CRITICAL();
 5107998:	e30c3930 	movw	r3, #51504	; 0xc930
 510799c:	e3403510 	movt	r3, #1296	; 0x510
 51079a0:	e12fff33 	blx	r3
        {
            pxTimer->pvTimerID = pvNewID;
 51079a4:	e584501c 	str	r5, [r4, #28]
        }
        taskEXIT_CRITICAL();
 51079a8:	e30c3988 	movw	r3, #51592	; 0xc988
 51079ac:	e3403510 	movt	r3, #1296	; 0x510
 51079b0:	e12fff33 	blx	r3

        traceRETURN_vTimerSetTimerID();
    }
 51079b4:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( xTimer );
 51079b8:	e30d0aec 	movw	r0, #56044	; 0xdaec
 51079bc:	e3003900 	movw	r3, #2304	; 0x900
 51079c0:	e30014cf 	movw	r1, #1231	; 0x4cf
 51079c4:	e3403511 	movt	r3, #1297	; 0x511
 51079c8:	e3400512 	movt	r0, #1298	; 0x512
 51079cc:	e12fff33 	blx	r3
 51079d0:	eafffff0 	b	5107998 <vTimerSetTimerID+0x10>

051079d4 <xTimerIsTimerActive>:
    {
 51079d4:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 51079d8:	e2504000 	subs	r4, r0, #0
    {
 51079dc:	e24dd008 	sub	sp, sp, #8
        configASSERT( xTimer );
 51079e0:	0a00000b 	beq	5107a14 <xTimerIsTimerActive+0x40>
        taskENTER_CRITICAL();
 51079e4:	e30c3930 	movw	r3, #51504	; 0xc930
 51079e8:	e3403510 	movt	r3, #1296	; 0x510
 51079ec:	e12fff33 	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0U )
 51079f0:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
        taskEXIT_CRITICAL();
 51079f4:	e30c3988 	movw	r3, #51592	; 0xc988
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0U )
 51079f8:	e2000001 	and	r0, r0, #1
        taskEXIT_CRITICAL();
 51079fc:	e3403510 	movt	r3, #1296	; 0x510
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0U )
 5107a00:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5107a04:	e12fff33 	blx	r3
    }
 5107a08:	e59d0004 	ldr	r0, [sp, #4]
 5107a0c:	e28dd008 	add	sp, sp, #8
 5107a10:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107a14:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107a18:	e3003900 	movw	r3, #2304	; 0x900
 5107a1c:	e300149d 	movw	r1, #1181	; 0x49d
 5107a20:	e3403511 	movt	r3, #1297	; 0x511
 5107a24:	e3400512 	movt	r0, #1298	; 0x512
 5107a28:	e12fff33 	blx	r3
 5107a2c:	eaffffec 	b	51079e4 <xTimerIsTimerActive+0x10>

05107a30 <xTimerGetTimerDaemonTaskHandle>:
    {
 5107a30:	e92d4010 	push	{r4, lr}
        configASSERT( ( xTimerTaskHandle != NULL ) );
 5107a34:	e30c4ee4 	movw	r4, #52964	; 0xcee4
 5107a38:	e3404511 	movt	r4, #1297	; 0x511
 5107a3c:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
 5107a40:	e3500000 	cmp	r0, #0
 5107a44:	18bd8010 	popne	{r4, pc}
 5107a48:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107a4c:	e3003900 	movw	r3, #2304	; 0x900
 5107a50:	e3001225 	movw	r1, #549	; 0x225
 5107a54:	e3403511 	movt	r3, #1297	; 0x511
 5107a58:	e3400512 	movt	r0, #1298	; 0x512
 5107a5c:	e12fff33 	blx	r3
        return xTimerTaskHandle;
 5107a60:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
    }
 5107a64:	e8bd8010 	pop	{r4, pc}

05107a68 <xTimerPendFunctionCallFromISR>:

        BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend,
                                                  void * pvParameter1,
                                                  uint32_t ulParameter2,
                                                  BaseType_t * pxHigherPriorityTaskWoken )
        {
 5107a68:	e92d4010 	push	{r4, lr}
 5107a6c:	e1a0c002 	mov	ip, r2
 5107a70:	e24dd010 	sub	sp, sp, #16
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;

            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 5107a74:	e3014a48 	movw	r4, #6728	; 0x1a48
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 5107a78:	e3e0e001 	mvn	lr, #1
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 5107a7c:	e58d0004 	str	r0, [sp, #4]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 5107a80:	e30c0ee4 	movw	r0, #52964	; 0xcee4
 5107a84:	e1a02003 	mov	r2, r3
 5107a88:	e3400511 	movt	r0, #1297	; 0x511
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 5107a8c:	e58d1008 	str	r1, [sp, #8]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 5107a90:	e3a03000 	mov	r3, #0
 5107a94:	e1a0100d 	mov	r1, sp
 5107a98:	e3404510 	movt	r4, #1296	; 0x510
 5107a9c:	e5900000 	ldr	r0, [r0]
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
 5107aa0:	e58de000 	str	lr, [sp]
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 5107aa4:	e58dc00c 	str	ip, [sp, #12]
            xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 5107aa8:	e12fff34 	blx	r4

            tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
            traceRETURN_xTimerPendFunctionCallFromISR( xReturn );

            return xReturn;
        }
 5107aac:	e28dd010 	add	sp, sp, #16
 5107ab0:	e8bd8010 	pop	{r4, pc}

05107ab4 <xTimerPendFunctionCall>:

        BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend,
                                           void * pvParameter1,
                                           uint32_t ulParameter2,
                                           TickType_t xTicksToWait )
        {
 5107ab4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
            traceENTER_xTimerPendFunctionCall( xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait );

            /* This function can only be called after a timer has been created or
             * after the scheduler has been started because, until then, the timer
             * queue does not exist. */
            configASSERT( xTimerQueue );
 5107ab8:	e30c4ee4 	movw	r4, #52964	; 0xcee4
        {
 5107abc:	e1a07000 	mov	r7, r0
 5107ac0:	e1a05002 	mov	r5, r2
            configASSERT( xTimerQueue );
 5107ac4:	e3404511 	movt	r4, #1297	; 0x511
        {
 5107ac8:	e1a06001 	mov	r6, r1
 5107acc:	e24dd01c 	sub	sp, sp, #28
 5107ad0:	e1a02003 	mov	r2, r3
            configASSERT( xTimerQueue );
 5107ad4:	e5940000 	ldr	r0, [r4]
 5107ad8:	e3500000 	cmp	r0, #0
 5107adc:	0a00000b 	beq	5107b10 <xTimerPendFunctionCall+0x5c>
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;

            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107ae0:	e3014030 	movw	r4, #4144	; 0x1030
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 5107ae4:	e3e0c000 	mvn	ip, #0
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107ae8:	e3a03000 	mov	r3, #0
 5107aec:	e3404510 	movt	r4, #1296	; 0x510
            xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
 5107af0:	e58d700c 	str	r7, [sp, #12]
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107af4:	e28d1008 	add	r1, sp, #8
            xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
 5107af8:	e58d6010 	str	r6, [sp, #16]
            xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
 5107afc:	e58d5014 	str	r5, [sp, #20]
            xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
 5107b00:	e58dc008 	str	ip, [sp, #8]
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107b04:	e12fff34 	blx	r4

            tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
            traceRETURN_xTimerPendFunctionCall( xReturn );

            return xReturn;
        }
 5107b08:	e28dd01c 	add	sp, sp, #28
 5107b0c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
 5107b10:	e58d3004 	str	r3, [sp, #4]
            configASSERT( xTimerQueue );
 5107b14:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107b18:	e3003900 	movw	r3, #2304	; 0x900
 5107b1c:	e3400512 	movt	r0, #1298	; 0x512
 5107b20:	e3001508 	movw	r1, #1288	; 0x508
 5107b24:	e3403511 	movt	r3, #1297	; 0x511
 5107b28:	e12fff33 	blx	r3
            xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107b2c:	e5940000 	ldr	r0, [r4]
 5107b30:	e59d2004 	ldr	r2, [sp, #4]
 5107b34:	eaffffe9 	b	5107ae0 <xTimerPendFunctionCall+0x2c>

05107b38 <pcTimerGetName>:
    {
 5107b38:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 5107b3c:	e2504000 	subs	r4, r0, #0
 5107b40:	0a000001 	beq	5107b4c <pcTimerGetName+0x14>
    }
 5107b44:	e5940000 	ldr	r0, [r4]
 5107b48:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107b4c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107b50:	e3003900 	movw	r3, #2304	; 0x900
 5107b54:	e30012b3 	movw	r1, #691	; 0x2b3
 5107b58:	e3403511 	movt	r3, #1297	; 0x511
 5107b5c:	e3400512 	movt	r0, #1298	; 0x512
 5107b60:	e12fff33 	blx	r3
    }
 5107b64:	e5940000 	ldr	r0, [r4]
 5107b68:	e8bd8010 	pop	{r4, pc}

05107b6c <vTimerSetReloadMode>:
    {
 5107b6c:	e92d4070 	push	{r4, r5, r6, lr}
 5107b70:	e1a05001 	mov	r5, r1
        configASSERT( xTimer );
 5107b74:	e2504000 	subs	r4, r0, #0
 5107b78:	0a00000b 	beq	5107bac <vTimerSetReloadMode+0x40>
        taskENTER_CRITICAL();
 5107b7c:	e30c3930 	movw	r3, #51504	; 0xc930
 5107b80:	e3403510 	movt	r3, #1296	; 0x510
 5107b84:	e12fff33 	blx	r3
                pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 5107b88:	e5d42024 	ldrb	r2, [r4, #36]	; 0x24
        taskEXIT_CRITICAL();
 5107b8c:	e30c3988 	movw	r3, #51592	; 0xc988
            if( xAutoReload != pdFALSE )
 5107b90:	e3550000 	cmp	r5, #0
                pxTimer->ucStatus |= ( uint8_t ) tmrSTATUS_IS_AUTORELOAD;
 5107b94:	13822004 	orrne	r2, r2, #4
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
 5107b98:	020220fb 	andeq	r2, r2, #251	; 0xfb
        taskEXIT_CRITICAL();
 5107b9c:	e3403510 	movt	r3, #1296	; 0x510
 5107ba0:	e5c42024 	strb	r2, [r4, #36]	; 0x24
 5107ba4:	e12fff33 	blx	r3
    }
 5107ba8:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( xTimer );
 5107bac:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107bb0:	e3003900 	movw	r3, #2304	; 0x900
 5107bb4:	e3001242 	movw	r1, #578	; 0x242
 5107bb8:	e3403511 	movt	r3, #1297	; 0x511
 5107bbc:	e3400512 	movt	r0, #1298	; 0x512
 5107bc0:	e12fff33 	blx	r3
 5107bc4:	eaffffec 	b	5107b7c <vTimerSetReloadMode+0x10>

05107bc8 <xTimerGetReloadMode>:
    {
 5107bc8:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 5107bcc:	e2504000 	subs	r4, r0, #0
    {
 5107bd0:	e24dd008 	sub	sp, sp, #8
        configASSERT( xTimer );
 5107bd4:	0a00000b 	beq	5107c08 <xTimerGetReloadMode+0x40>
        taskENTER_CRITICAL();
 5107bd8:	e30c3930 	movw	r3, #51504	; 0xc930
 5107bdc:	e3403510 	movt	r3, #1296	; 0x510
 5107be0:	e12fff33 	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107be4:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
        taskEXIT_CRITICAL();
 5107be8:	e30c3988 	movw	r3, #51592	; 0xc988
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107bec:	e7e00150 	ubfx	r0, r0, #2, #1
        taskEXIT_CRITICAL();
 5107bf0:	e3403510 	movt	r3, #1296	; 0x510
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107bf4:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5107bf8:	e12fff33 	blx	r3
    }
 5107bfc:	e59d0004 	ldr	r0, [sp, #4]
 5107c00:	e28dd008 	add	sp, sp, #8
 5107c04:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107c08:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107c0c:	e3003900 	movw	r3, #2304	; 0x900
 5107c10:	e300125b 	movw	r1, #603	; 0x25b
 5107c14:	e3403511 	movt	r3, #1297	; 0x511
 5107c18:	e3400512 	movt	r0, #1298	; 0x512
 5107c1c:	e12fff33 	blx	r3
 5107c20:	eaffffec 	b	5107bd8 <xTimerGetReloadMode+0x10>

05107c24 <uxTimerGetReloadMode>:
    {
 5107c24:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 5107c28:	e2504000 	subs	r4, r0, #0
    {
 5107c2c:	e24dd008 	sub	sp, sp, #8
        configASSERT( xTimer );
 5107c30:	0a00000b 	beq	5107c64 <uxTimerGetReloadMode+0x40>
        taskENTER_CRITICAL();
 5107c34:	e30c3930 	movw	r3, #51504	; 0xc930
 5107c38:	e3403510 	movt	r3, #1296	; 0x510
 5107c3c:	e12fff33 	blx	r3
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107c40:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
        taskEXIT_CRITICAL();
 5107c44:	e30c3988 	movw	r3, #51592	; 0xc988
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107c48:	e7e00150 	ubfx	r0, r0, #2, #1
        taskEXIT_CRITICAL();
 5107c4c:	e3403510 	movt	r3, #1296	; 0x510
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0U )
 5107c50:	e58d0004 	str	r0, [sp, #4]
        taskEXIT_CRITICAL();
 5107c54:	e12fff33 	blx	r3
    }
 5107c58:	e59d0004 	ldr	r0, [sp, #4]
 5107c5c:	e28dd008 	add	sp, sp, #8
 5107c60:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107c64:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107c68:	e3003900 	movw	r3, #2304	; 0x900
 5107c6c:	e300125b 	movw	r1, #603	; 0x25b
 5107c70:	e3403511 	movt	r3, #1297	; 0x511
 5107c74:	e3400512 	movt	r0, #1298	; 0x512
 5107c78:	e12fff33 	blx	r3
 5107c7c:	eaffffec 	b	5107c34 <uxTimerGetReloadMode+0x10>

05107c80 <xTimerGetPeriod>:
    {
 5107c80:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 5107c84:	e2504000 	subs	r4, r0, #0
 5107c88:	0a000001 	beq	5107c94 <xTimerGetPeriod+0x14>
    }
 5107c8c:	e5940018 	ldr	r0, [r4, #24]
 5107c90:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107c94:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107c98:	e3003900 	movw	r3, #2304	; 0x900
 5107c9c:	e3001233 	movw	r1, #563	; 0x233
 5107ca0:	e3403511 	movt	r3, #1297	; 0x511
 5107ca4:	e3400512 	movt	r0, #1298	; 0x512
 5107ca8:	e12fff33 	blx	r3
    }
 5107cac:	e5940018 	ldr	r0, [r4, #24]
 5107cb0:	e8bd8010 	pop	{r4, pc}

05107cb4 <xTimerGetExpiryTime>:
    {
 5107cb4:	e92d4010 	push	{r4, lr}
        configASSERT( xTimer );
 5107cb8:	e2504000 	subs	r4, r0, #0
 5107cbc:	0a000001 	beq	5107cc8 <xTimerGetExpiryTime+0x14>
    }
 5107cc0:	e5940004 	ldr	r0, [r4, #4]
 5107cc4:	e8bd8010 	pop	{r4, pc}
        configASSERT( xTimer );
 5107cc8:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107ccc:	e3003900 	movw	r3, #2304	; 0x900
 5107cd0:	e3001285 	movw	r1, #645	; 0x285
 5107cd4:	e3403511 	movt	r3, #1297	; 0x511
 5107cd8:	e3400512 	movt	r0, #1298	; 0x512
 5107cdc:	e12fff33 	blx	r3
    }
 5107ce0:	e5940004 	ldr	r0, [r4, #4]
 5107ce4:	e8bd8010 	pop	{r4, pc}

05107ce8 <xTimerGetStaticBuffer>:
        {
 5107ce8:	e92d4070 	push	{r4, r5, r6, lr}
 5107cec:	e1a05000 	mov	r5, r0
            configASSERT( ppxTimerBuffer != NULL );
 5107cf0:	e2514000 	subs	r4, r1, #0
 5107cf4:	0a000005 	beq	5107d10 <xTimerGetStaticBuffer+0x28>
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) != 0U )
 5107cf8:	e5d53024 	ldrb	r3, [r5, #36]	; 0x24
 5107cfc:	e2133002 	ands	r3, r3, #2
                xReturn = pdTRUE;
 5107d00:	13a00001 	movne	r0, #1
                xReturn = pdFALSE;
 5107d04:	01a00003 	moveq	r0, r3
                *ppxTimerBuffer = ( StaticTimer_t * ) pxTimer;
 5107d08:	15845000 	strne	r5, [r4]
        }
 5107d0c:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( ppxTimerBuffer != NULL );
 5107d10:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107d14:	e3003900 	movw	r3, #2304	; 0x900
 5107d18:	e3001297 	movw	r1, #663	; 0x297
 5107d1c:	e3403511 	movt	r3, #1297	; 0x511
 5107d20:	e3400512 	movt	r0, #1298	; 0x512
 5107d24:	e12fff33 	blx	r3
 5107d28:	eafffff2 	b	5107cf8 <xTimerGetStaticBuffer+0x10>

05107d2c <xTimerCreateTimerTask>:
    {
 5107d2c:	e92d4030 	push	{r4, r5, lr}
        if( xTimerQueue != NULL )
 5107d30:	e30c4ee4 	movw	r4, #52964	; 0xcee4
    {
 5107d34:	e24dd024 	sub	sp, sp, #36	; 0x24
        if( xTimerQueue != NULL )
 5107d38:	e3404511 	movt	r4, #1297	; 0x511
        prvCheckForValidListAndQueue();
 5107d3c:	ebfffd36 	bl	510721c <prvCheckForValidListAndQueue>
        if( xTimerQueue != NULL )
 5107d40:	e5943000 	ldr	r3, [r4]
 5107d44:	e3530000 	cmp	r3, #0
 5107d48:	0a00001d 	beq	5107dc4 <xTimerCreateTimerTask+0x98>
                    StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 5107d4c:	e3a05000 	mov	r5, #0
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &uxTimerTaskStackSize );
 5107d50:	e30038dc 	movw	r3, #2268	; 0x8dc
 5107d54:	e28d201c 	add	r2, sp, #28
 5107d58:	e28d1018 	add	r1, sp, #24
 5107d5c:	e28d0014 	add	r0, sp, #20
                    StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 5107d60:	e58d5014 	str	r5, [sp, #20]
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &uxTimerTaskStackSize );
 5107d64:	e3403511 	movt	r3, #1297	; 0x511
                    StackType_t * pxTimerTaskStackBuffer = NULL;
 5107d68:	e58d5018 	str	r5, [sp, #24]
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &uxTimerTaskStackSize );
 5107d6c:	e12fff33 	blx	r3
                    xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 5107d70:	e59d1014 	ldr	r1, [sp, #20]
 5107d74:	e3a0c11a 	mov	ip, #-2147483642	; 0x80000006
 5107d78:	e59d2018 	ldr	r2, [sp, #24]
 5107d7c:	e1a03005 	mov	r3, r5
 5107d80:	e58d1008 	str	r1, [sp, #8]
 5107d84:	e30703a0 	movw	r0, #29600	; 0x73a0
 5107d88:	e30d1b0c 	movw	r1, #56076	; 0xdb0c
 5107d8c:	e30456a8 	movw	r5, #18088	; 0x46a8
 5107d90:	e58d2004 	str	r2, [sp, #4]
 5107d94:	e3401512 	movt	r1, #1298	; 0x512
 5107d98:	e59d201c 	ldr	r2, [sp, #28]
 5107d9c:	e3400510 	movt	r0, #1296	; 0x510
 5107da0:	e58dc000 	str	ip, [sp]
 5107da4:	e3405510 	movt	r5, #1296	; 0x510
 5107da8:	e12fff35 	blx	r5
 5107dac:	e58400a4 	str	r0, [r4, #164]	; 0xa4
                    if( xTimerTaskHandle != NULL )
 5107db0:	e3500000 	cmp	r0, #0
                        xReturn = pdPASS;
 5107db4:	13a00001 	movne	r0, #1
                    if( xTimerTaskHandle != NULL )
 5107db8:	0a000001 	beq	5107dc4 <xTimerCreateTimerTask+0x98>
    }
 5107dbc:	e28dd024 	add	sp, sp, #36	; 0x24
 5107dc0:	e8bd8030 	pop	{r4, r5, pc}
        configASSERT( xReturn );
 5107dc4:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107dc8:	e3003900 	movw	r3, #2304	; 0x900
 5107dcc:	e3001146 	movw	r1, #326	; 0x146
 5107dd0:	e3403511 	movt	r3, #1297	; 0x511
 5107dd4:	e3400512 	movt	r0, #1298	; 0x512
 5107dd8:	e12fff33 	blx	r3
 5107ddc:	e3a00000 	mov	r0, #0
    }
 5107de0:	e28dd024 	add	sp, sp, #36	; 0x24
 5107de4:	e8bd8030 	pop	{r4, r5, pc}

05107de8 <xTimerGenericCommandFromTask>:
    {
 5107de8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 5107dec:	e1a05001 	mov	r5, r1
        configASSERT( xTimer );
 5107df0:	e2504000 	subs	r4, r0, #0
    {
 5107df4:	e1a07002 	mov	r7, r2
 5107df8:	e24dd014 	sub	sp, sp, #20
        configASSERT( xTimer );
 5107dfc:	0a000027 	beq	5107ea0 <xTimerGenericCommandFromTask+0xb8>
        if( xTimerQueue != NULL )
 5107e00:	e30c6ee4 	movw	r6, #52964	; 0xcee4
 5107e04:	e3406511 	movt	r6, #1297	; 0x511
 5107e08:	e5960000 	ldr	r0, [r6]
 5107e0c:	e3500000 	cmp	r0, #0
 5107e10:	0a00000f 	beq	5107e54 <xTimerGenericCommandFromTask+0x6c>
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 5107e14:	e88d00a0 	stm	sp, {r5, r7}
            configASSERT( xCommandID < tmrFIRST_FROM_ISR_COMMAND );
 5107e18:	e3550005 	cmp	r5, #5
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 5107e1c:	e58d4008 	str	r4, [sp, #8]
            configASSERT( xCommandID < tmrFIRST_FROM_ISR_COMMAND );
 5107e20:	ca00000d 	bgt	5107e5c <xTimerGenericCommandFromTask+0x74>
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 5107e24:	e3063e28 	movw	r3, #28200	; 0x6e28
 5107e28:	e3403510 	movt	r3, #1296	; 0x510
 5107e2c:	e12fff33 	blx	r3
 5107e30:	e3500002 	cmp	r0, #2
 5107e34:	0a000011 	beq	5107e80 <xTimerGenericCommandFromTask+0x98>
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 5107e38:	e3a03000 	mov	r3, #0
 5107e3c:	e3014030 	movw	r4, #4144	; 0x1030
 5107e40:	e5960000 	ldr	r0, [r6]
 5107e44:	e1a02003 	mov	r2, r3
 5107e48:	e1a0100d 	mov	r1, sp
 5107e4c:	e3404510 	movt	r4, #1296	; 0x510
 5107e50:	e12fff34 	blx	r4
    }
 5107e54:	e28dd014 	add	sp, sp, #20
 5107e58:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
            configASSERT( xCommandID < tmrFIRST_FROM_ISR_COMMAND );
 5107e5c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107e60:	e3003900 	movw	r3, #2304	; 0x900
 5107e64:	e3a01f76 	mov	r1, #472	; 0x1d8
 5107e68:	e3403511 	movt	r3, #1297	; 0x511
 5107e6c:	e3400512 	movt	r0, #1298	; 0x512
 5107e70:	e12fff33 	blx	r3
        BaseType_t xReturn = pdFAIL;
 5107e74:	e3a00000 	mov	r0, #0
    }
 5107e78:	e28dd014 	add	sp, sp, #20
 5107e7c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 5107e80:	e3014030 	movw	r4, #4144	; 0x1030
 5107e84:	e3a03000 	mov	r3, #0
 5107e88:	e5960000 	ldr	r0, [r6]
 5107e8c:	e1a0100d 	mov	r1, sp
 5107e90:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
 5107e94:	e3404510 	movt	r4, #1296	; 0x510
 5107e98:	e12fff34 	blx	r4
 5107e9c:	eaffffec 	b	5107e54 <xTimerGenericCommandFromTask+0x6c>
        configASSERT( xTimer );
 5107ea0:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107ea4:	e3003900 	movw	r3, #2304	; 0x900
 5107ea8:	e30011cd 	movw	r1, #461	; 0x1cd
 5107eac:	e3403511 	movt	r3, #1297	; 0x511
 5107eb0:	e3400512 	movt	r0, #1298	; 0x512
 5107eb4:	e12fff33 	blx	r3
 5107eb8:	eaffffd0 	b	5107e00 <xTimerGenericCommandFromTask+0x18>

05107ebc <xTimerGenericCommandFromISR>:
    {
 5107ebc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 5107ec0:	e1a05001 	mov	r5, r1
        configASSERT( xTimer );
 5107ec4:	e2504000 	subs	r4, r0, #0
    {
 5107ec8:	e1a06002 	mov	r6, r2
 5107ecc:	e24dd014 	sub	sp, sp, #20
 5107ed0:	e1a07003 	mov	r7, r3
        configASSERT( xTimer );
 5107ed4:	0a000019 	beq	5107f40 <xTimerGenericCommandFromISR+0x84>
        if( xTimerQueue != NULL )
 5107ed8:	e30c1ee4 	movw	r1, #52964	; 0xcee4
 5107edc:	e3401511 	movt	r1, #1297	; 0x511
 5107ee0:	e5910000 	ldr	r0, [r1]
 5107ee4:	e3500000 	cmp	r0, #0
 5107ee8:	0a000009 	beq	5107f14 <xTimerGenericCommandFromISR+0x58>
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 5107eec:	e88d0060 	stm	sp, {r5, r6}
            configASSERT( xCommandID >= tmrFIRST_FROM_ISR_COMMAND );
 5107ef0:	e3550005 	cmp	r5, #5
            xMessage.u.xTimerParameters.pxTimer = xTimer;
 5107ef4:	e58d4008 	str	r4, [sp, #8]
            configASSERT( xCommandID >= tmrFIRST_FROM_ISR_COMMAND );
 5107ef8:	da000007 	ble	5107f1c <xTimerGenericCommandFromISR+0x60>
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 5107efc:	e3014a48 	movw	r4, #6728	; 0x1a48
 5107f00:	e3a03000 	mov	r3, #0
 5107f04:	e1a02007 	mov	r2, r7
 5107f08:	e1a0100d 	mov	r1, sp
 5107f0c:	e3404510 	movt	r4, #1296	; 0x510
 5107f10:	e12fff34 	blx	r4
    }
 5107f14:	e28dd014 	add	sp, sp, #20
 5107f18:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
            configASSERT( xCommandID >= tmrFIRST_FROM_ISR_COMMAND );
 5107f1c:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107f20:	e3003900 	movw	r3, #2304	; 0x900
 5107f24:	e300120b 	movw	r1, #523	; 0x20b
 5107f28:	e3403511 	movt	r3, #1297	; 0x511
 5107f2c:	e3400512 	movt	r0, #1298	; 0x512
 5107f30:	e12fff33 	blx	r3
        BaseType_t xReturn = pdFAIL;
 5107f34:	e3a00000 	mov	r0, #0
    }
 5107f38:	e28dd014 	add	sp, sp, #20
 5107f3c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        configASSERT( xTimer );
 5107f40:	e30d0aec 	movw	r0, #56044	; 0xdaec
 5107f44:	e3003900 	movw	r3, #2304	; 0x900
 5107f48:	e3a01c02 	mov	r1, #512	; 0x200
 5107f4c:	e3403511 	movt	r3, #1297	; 0x511
 5107f50:	e3400512 	movt	r0, #1298	; 0x512
 5107f54:	e12fff33 	blx	r3
 5107f58:	eaffffde 	b	5107ed8 <xTimerGenericCommandFromISR+0x1c>

05107f5c <vTimerResetState>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
    void vTimerResetState( void )
    {
        xTimerQueue = NULL;
 5107f5c:	e30c3ee4 	movw	r3, #52964	; 0xcee4
 5107f60:	e3a02000 	mov	r2, #0
 5107f64:	e3403511 	movt	r3, #1297	; 0x511
 5107f68:	e5832000 	str	r2, [r3]
        xTimerTaskHandle = NULL;
 5107f6c:	e58320a4 	str	r2, [r3, #164]	; 0xa4
    }
 5107f70:	e12fff1e 	bx	lr

05107f74 <pvPortMalloc>:
    BlockLink_t * pxNewBlockLink;
    void * pvReturn = NULL;
    size_t xAdditionalRequiredSize;

    uint32_t* p0 = 0xb700005c;
    *p0 = xWantedSize;
 5107f74:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000

	uint32_t* pp = 0xb700004c;
   

    if( xWantedSize > 0 )
 5107f78:	e3500000 	cmp	r0, #0
{
 5107f7c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    *p0 = xWantedSize;
 5107f80:	e583005c 	str	r0, [r3, #92]	; 0x5c
{
 5107f84:	e24dd00c 	sub	sp, sp, #12
    if( xWantedSize > 0 )
 5107f88:	0a000085 	beq	51081a4 <pvPortMalloc+0x230>
    {
*pp = 0x1234;
        /* The wanted size must be increased so it can contain a BlockLink_t
         * structure in addition to the requested amount of bytes. */
        if( heapADD_WILL_OVERFLOW( xWantedSize, xHeapStructSize ) == 0 )
 5107f8c:	e3700009 	cmn	r0, #9
 5107f90:	8a00009c 	bhi	5108208 <pvPortMalloc+0x294>
*pp = 0x1235;
            xWantedSize += xHeapStructSize;

            /* Ensure that blocks are always aligned to the required number
             * of bytes. */
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 5107f94:	e2102007 	ands	r2, r0, #7
            xWantedSize += xHeapStructSize;
 5107f98:	e2806008 	add	r6, r0, #8
            if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 5107f9c:	1a00009c 	bne	5108214 <pvPortMalloc+0x2a0>
                    xWantedSize = 0;
                }
            }
            else
            {
*pp = 0x1239;
 5107fa0:	e3012239 	movw	r2, #4665	; 0x1239
 5107fa4:	e583204c 	str	r2, [r3, #76]	; 0x4c

    vTaskSuspendAll();
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( pxEnd == NULL )
 5107fa8:	e30c7f8c 	movw	r7, #53132	; 0xcf8c
    vTaskSuspendAll();
 5107fac:	e30532a0 	movw	r3, #21152	; 0x52a0
        if( pxEnd == NULL )
 5107fb0:	e3407511 	movt	r7, #1297	; 0x511
    vTaskSuspendAll();
 5107fb4:	e3403510 	movt	r3, #1296	; 0x510
 5107fb8:	e12fff33 	blx	r3
        if( pxEnd == NULL )
 5107fbc:	e5973008 	ldr	r3, [r7, #8]
 5107fc0:	e3530000 	cmp	r3, #0

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
 5107fc4:	e1a03006 	mov	r3, r6
        if( pxEnd == NULL )
 5107fc8:	0a0000a4 	beq	5108260 <pvPortMalloc+0x2ec>
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
 5107fcc:	e3530000 	cmp	r3, #0
 5107fd0:	ba000082 	blt	51081e0 <pvPortMalloc+0x26c>
        {
//*pp = 0x1244;
uint32_t* pp1 = 0xb7000050;
uint32_t* pp2 = 0xb7000054;
*pp1=xWantedSize;
 5107fd4:	e3a024b7 	mov	r2, #-1224736768	; 0xb7000000
*pp2 = xFreeBytesRemaining;
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 5107fd8:	e3560000 	cmp	r6, #0
*pp2 = xFreeBytesRemaining;
 5107fdc:	e5973010 	ldr	r3, [r7, #16]
 5107fe0:	e5823054 	str	r3, [r2, #84]	; 0x54
*pp1=xWantedSize;
 5107fe4:	e5826050 	str	r6, [r2, #80]	; 0x50
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 5107fe8:	0a00007c 	beq	51081e0 <pvPortMalloc+0x26c>
 5107fec:	e1530006 	cmp	r3, r6
 5107ff0:	3a00007a 	bcc	51081e0 <pvPortMalloc+0x26c>
            {
//*pp = 0x1245;
                /* Traverse the list from the start (lowest address) block until
                 * one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = heapPROTECT_BLOCK_POINTER( xStart.pxNextFreeBlock );
 5107ff4:	e5975000 	ldr	r5, [r7]
                heapVALIDATE_BLOCK_POINTER( pxBlock );
 5107ff8:	e30c8fa8 	movw	r8, #53160	; 0xcfa8
 5107ffc:	e59f92e8 	ldr	r9, [pc, #744]	; 51082ec <pvPortMalloc+0x378>
 5108000:	e3408511 	movt	r8, #1297	; 0x511
 5108004:	e1550008 	cmp	r5, r8
 5108008:	33a03000 	movcc	r3, #0
 510800c:	23a03001 	movcs	r3, #1
 5108010:	e1550009 	cmp	r5, r9
 5108014:	83a03000 	movhi	r3, #0
 5108018:	e3530000 	cmp	r3, #0
 510801c:	1a000005 	bne	5108038 <pvPortMalloc+0xc4>
 5108020:	e30d0b14 	movw	r0, #56084	; 0xdb14
 5108024:	e3003900 	movw	r3, #2304	; 0x900
 5108028:	e3400512 	movt	r0, #1298	; 0x512
 510802c:	e3a01e11 	mov	r1, #272	; 0x110
 5108030:	e3403511 	movt	r3, #1297	; 0x511
 5108034:	e12fff33 	blx	r3

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 5108038:	e5953004 	ldr	r3, [r5, #4]
 510803c:	e30cbf8c 	movw	fp, #53132	; 0xcf8c
 5108040:	e340b511 	movt	fp, #1297	; 0x511
 5108044:	e1530006 	cmp	r3, r6
 5108048:	2a000018 	bcs	51080b0 <pvPortMalloc+0x13c>
                {
                    pxPreviousBlock = pxBlock;
                    pxBlock = heapPROTECT_BLOCK_POINTER( pxBlock->pxNextFreeBlock );
                    heapVALIDATE_BLOCK_POINTER( pxBlock );
 510804c:	e3003900 	movw	r3, #2304	; 0x900
 5108050:	e30dab14 	movw	sl, #56084	; 0xdb14
 5108054:	e3403511 	movt	r3, #1297	; 0x511
 5108058:	e340a512 	movt	sl, #1298	; 0x512
 510805c:	e58d3004 	str	r3, [sp, #4]
 5108060:	ea00000d 	b	510809c <pvPortMalloc+0x128>
 5108064:	e1a0b005 	mov	fp, r5
 5108068:	e1540008 	cmp	r4, r8
 510806c:	33a03000 	movcc	r3, #0
 5108070:	23a03001 	movcs	r3, #1
 5108074:	e1a05004 	mov	r5, r4
 5108078:	e1540009 	cmp	r4, r9
 510807c:	83a03000 	movhi	r3, #0
 5108080:	e3530000 	cmp	r3, #0
 5108084:	1a000001 	bne	5108090 <pvPortMalloc+0x11c>
 5108088:	e59d3004 	ldr	r3, [sp, #4]
 510808c:	e12fff33 	blx	r3
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 5108090:	e5943004 	ldr	r3, [r4, #4]
 5108094:	e1530006 	cmp	r3, r6
 5108098:	2a000065 	bcs	5108234 <pvPortMalloc+0x2c0>
 510809c:	e5954000 	ldr	r4, [r5]
                    heapVALIDATE_BLOCK_POINTER( pxBlock );
 51080a0:	e3001116 	movw	r1, #278	; 0x116
 51080a4:	e1a0000a 	mov	r0, sl
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != heapPROTECT_BLOCK_POINTER( NULL ) ) )
 51080a8:	e3540000 	cmp	r4, #0
 51080ac:	1affffec 	bne	5108064 <pvPortMalloc+0xf0>
                }

                /* If the end marker was reached then a block of adequate size
                 * was not found. */
                if( pxBlock != pxEnd )
 51080b0:	e5973008 	ldr	r3, [r7, #8]
 51080b4:	e1530005 	cmp	r3, r5
 51080b8:	0a000048 	beq	51081e0 <pvPortMalloc+0x26c>
                {
//*pp = 0x1246;
                    /* Return the memory space pointed to - jumping over the
                     * BlockLink_t structure at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxPreviousBlock->pxNextFreeBlock ) ) + xHeapStructSize );
 51080bc:	e59b4000 	ldr	r4, [fp]
 51080c0:	e2844008 	add	r4, r4, #8
                    heapVALIDATE_BLOCK_POINTER( pvReturn );
 51080c4:	e1540009 	cmp	r4, r9
 51080c8:	83a09000 	movhi	r9, #0
 51080cc:	93a09001 	movls	r9, #1
 51080d0:	e1540008 	cmp	r4, r8
 51080d4:	33a09000 	movcc	r9, #0
 51080d8:	e3590000 	cmp	r9, #0
 51080dc:	1a000005 	bne	51080f8 <pvPortMalloc+0x184>
 51080e0:	e30d0b14 	movw	r0, #56084	; 0xdb14
 51080e4:	e3003900 	movw	r3, #2304	; 0x900
 51080e8:	e3400512 	movt	r0, #1298	; 0x512
 51080ec:	e3001121 	movw	r1, #289	; 0x121
 51080f0:	e3403511 	movt	r3, #1297	; 0x511
 51080f4:	e12fff33 	blx	r3
                     * of the list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;

                    /* If the block is larger than required it can be split into
                     * two. */
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );
 51080f8:	e5953004 	ldr	r3, [r5, #4]
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 51080fc:	e5952000 	ldr	r2, [r5]
 5108100:	e58b2000 	str	r2, [fp]
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );
 5108104:	e1530006 	cmp	r3, r6
 5108108:	3a00004b 	bcc	510823c <pvPortMalloc+0x2c8>

                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 510810c:	e0432006 	sub	r2, r3, r6
 5108110:	e3520010 	cmp	r2, #16
 5108114:	9a000007 	bls	5108138 <pvPortMalloc+0x1c4>
//*pp = 0x1247;
                        /* This block is to be split into two.  Create a new
                         * block following the number of bytes requested. The void
                         * cast is used to prevent byte alignment warnings from the
                         * compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5108118:	e0858006 	add	r8, r5, r6
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 510811c:	e3180007 	tst	r8, #7
 5108120:	1a000065 	bne	51082bc <pvPortMalloc+0x348>

                        /* Calculate the sizes of two blocks split from the
                         * single block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5108124:	e5882004 	str	r2, [r8, #4]
                        pxBlock->xBlockSize = xWantedSize;

                        /* Insert the new block into the list of free blocks. */
                        pxNewBlockLink->pxNextFreeBlock = pxPreviousBlock->pxNextFreeBlock;
 5108128:	e1a03006 	mov	r3, r6
 510812c:	e59b2000 	ldr	r2, [fp]
 5108130:	e5882000 	str	r2, [r8]
                        pxPreviousBlock->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxNewBlockLink );
 5108134:	e58b8000 	str	r8, [fp]
                    {
//*pp = 0x1248;
                        mtCOVERAGE_TEST_MARKER();
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 5108138:	e5972010 	ldr	r2, [r7, #16]

                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 510813c:	e597100c 	ldr	r1, [r7, #12]
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 5108140:	e0422003 	sub	r2, r2, r3
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 5108144:	e1520001 	cmp	r2, r1
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 5108148:	e5872010 	str	r2, [r7, #16]
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
 510814c:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 5108150:	3587200c 	strcc	r2, [r7, #12]
                    pxBlock->pxNextFreeBlock = NULL;
 5108154:	e3a01000 	mov	r1, #0
                    xNumberOfSuccessfulAllocations++;
 5108158:	e5972014 	ldr	r2, [r7, #20]
                    heapALLOCATE_BLOCK( pxBlock );
 510815c:	e5853004 	str	r3, [r5, #4]
            mtCOVERAGE_TEST_MARKER();
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
 5108160:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xNumberOfSuccessfulAllocations++;
 5108164:	e2822001 	add	r2, r2, #1
                    pxBlock->pxNextFreeBlock = NULL;
 5108168:	e5851000 	str	r1, [r5]
    ( void ) xTaskResumeAll();
 510816c:	e3403510 	movt	r3, #1296	; 0x510
                    xNumberOfSuccessfulAllocations++;
 5108170:	e5872014 	str	r2, [r7, #20]
    ( void ) xTaskResumeAll();
 5108174:	e12fff33 	blx	r3
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* if ( configUSE_MALLOC_FAILED_HOOK == 1 ) */

    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 5108178:	e3140007 	tst	r4, #7
 510817c:	0a00001e 	beq	51081fc <pvPortMalloc+0x288>
 5108180:	e30d0b14 	movw	r0, #56084	; 0xdb14
 5108184:	e3003900 	movw	r3, #2304	; 0x900
 5108188:	e300117a 	movw	r1, #378	; 0x17a
 510818c:	e3403511 	movt	r3, #1297	; 0x511
 5108190:	e3400512 	movt	r0, #1298	; 0x512
 5108194:	e12fff33 	blx	r3
    return pvReturn;
}
 5108198:	e1a00004 	mov	r0, r4
 510819c:	e28dd00c 	add	sp, sp, #12
 51081a0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
*pp = 0x1241;
 51081a4:	e3012241 	movw	r2, #4673	; 0x1241
 51081a8:	e583204c 	str	r2, [r3, #76]	; 0x4c
        if( pxEnd == NULL )
 51081ac:	e30c7f8c 	movw	r7, #53132	; 0xcf8c
    vTaskSuspendAll();
 51081b0:	e30532a0 	movw	r3, #21152	; 0x52a0
        if( pxEnd == NULL )
 51081b4:	e3407511 	movt	r7, #1297	; 0x511
    vTaskSuspendAll();
 51081b8:	e3403510 	movt	r3, #1296	; 0x510
 51081bc:	e12fff33 	blx	r3
        if( pxEnd == NULL )
 51081c0:	e5973008 	ldr	r3, [r7, #8]
 51081c4:	e3530000 	cmp	r3, #0
 51081c8:	0a000023 	beq	510825c <pvPortMalloc+0x2e8>
*pp1=xWantedSize;
 51081cc:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
 51081d0:	e3a01000 	mov	r1, #0
*pp2 = xFreeBytesRemaining;
 51081d4:	e5972010 	ldr	r2, [r7, #16]
 51081d8:	e5832054 	str	r2, [r3, #84]	; 0x54
*pp1=xWantedSize;
 51081dc:	e5831050 	str	r1, [r3, #80]	; 0x50
    ( void ) xTaskResumeAll();
 51081e0:	e3053efc 	movw	r3, #24316	; 0x5efc
            vApplicationMallocFailedHook();
 51081e4:	e3a04000 	mov	r4, #0
    ( void ) xTaskResumeAll();
 51081e8:	e3403510 	movt	r3, #1296	; 0x510
 51081ec:	e12fff33 	blx	r3
            vApplicationMallocFailedHook();
 51081f0:	e300386c 	movw	r3, #2156	; 0x86c
 51081f4:	e3403511 	movt	r3, #1297	; 0x511
 51081f8:	e12fff33 	blx	r3
}
 51081fc:	e1a00004 	mov	r0, r4
 5108200:	e28dd00c 	add	sp, sp, #12
 5108204:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
*pp = 0x1240;
 5108208:	e3a02d49 	mov	r2, #4672	; 0x1240
 510820c:	e583204c 	str	r2, [r3, #76]	; 0x4c
            xWantedSize = 0;
 5108210:	eaffffe5 	b	51081ac <pvPortMalloc+0x238>
                xAdditionalRequiredSize = portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );
 5108214:	e2622008 	rsb	r2, r2, #8
                if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
 5108218:	e1e01002 	mvn	r1, r2
 510821c:	e1510006 	cmp	r1, r6
 5108220:	3a00002e 	bcc	51082e0 <pvPortMalloc+0x36c>
*pp = 0x1236;
 5108224:	e3011236 	movw	r1, #4662	; 0x1236
                    xWantedSize += xAdditionalRequiredSize;
 5108228:	e0866002 	add	r6, r6, r2
*pp = 0x1236;
 510822c:	e583104c 	str	r1, [r3, #76]	; 0x4c
                    xWantedSize += xAdditionalRequiredSize;
 5108230:	eaffff5c 	b	5107fa8 <pvPortMalloc+0x34>
 5108234:	e1a05004 	mov	r5, r4
 5108238:	eaffff9c 	b	51080b0 <pvPortMalloc+0x13c>
                    configASSERT( heapSUBTRACT_WILL_UNDERFLOW( pxBlock->xBlockSize, xWantedSize ) == 0 );
 510823c:	e30d0b14 	movw	r0, #56084	; 0xdb14
 5108240:	e3003900 	movw	r3, #2304	; 0x900
 5108244:	e3403511 	movt	r3, #1297	; 0x511
 5108248:	e3001129 	movw	r1, #297	; 0x129
 510824c:	e3400512 	movt	r0, #1298	; 0x512
 5108250:	e12fff33 	blx	r3
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5108254:	e5953004 	ldr	r3, [r5, #4]
 5108258:	eaffffab 	b	510810c <pvPortMalloc+0x198>
        if( pxEnd == NULL )
 510825c:	e1a06003 	mov	r6, r3
    BlockLink_t * pxFirstFreeBlock;
    portPOINTER_SIZE_TYPE uxStartAddress, uxEndAddress;
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;

    /* Ensure the heap starts on a correctly aligned boundary. */
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
 5108260:	e30c8fa8 	movw	r8, #53160	; 0xcfa8
    #endif

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
    xStart.xBlockSize = ( size_t ) 0;
 5108264:	e3a00000 	mov	r0, #0
    uxStartAddress = ( portPOINTER_SIZE_TYPE ) ucHeap;
 5108268:	e3408511 	movt	r8, #1297	; 0x511
    xStart.xBlockSize = ( size_t ) 0;
 510826c:	e5870004 	str	r0, [r7, #4]
    if( ( uxStartAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 5108270:	e3180007 	tst	r8, #7
        uxStartAddress += ( portBYTE_ALIGNMENT - 1 );
 5108274:	12881007 	addne	r1, r8, #7
 5108278:	12882a0a 	addne	r2, r8, #40960	; 0xa000

    /* pxEnd is used to mark the end of the list of free blocks and is inserted
     * at the end of the heap space. */
    uxEndAddress = uxStartAddress + ( portPOINTER_SIZE_TYPE ) xTotalHeapSize;
 510827c:	02882a0a 	addeq	r2, r8, #40960	; 0xa000
        uxStartAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
 5108280:	13c18007 	bicne	r8, r1, #7
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
 5108284:	e1a01008 	mov	r1, r8
    uxEndAddress -= ( portPOINTER_SIZE_TYPE ) xHeapStructSize;
 5108288:	e2422008 	sub	r2, r2, #8
    xStart.pxNextFreeBlock = ( void * ) heapPROTECT_BLOCK_POINTER( uxStartAddress );
 510828c:	e5878000 	str	r8, [r7]
    uxEndAddress &= ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK );
 5108290:	e3c22007 	bic	r2, r2, #7
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );

    /* To start with there is a single free block that is sized to take up the
     * entire heap space, minus the space taken by pxEnd. */
    pxFirstFreeBlock = ( BlockLink_t * ) uxStartAddress;
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
 5108294:	e0428008 	sub	r8, r2, r8
    pxEnd = ( BlockLink_t * ) uxEndAddress;
 5108298:	e5872008 	str	r2, [r7, #8]
    pxEnd->xBlockSize = 0;
 510829c:	e5820004 	str	r0, [r2, #4]
    pxEnd->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( NULL );
 51082a0:	e5820000 	str	r0, [r2]
    pxFirstFreeBlock->xBlockSize = ( size_t ) ( uxEndAddress - ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock );
 51082a4:	e8810104 	stm	r1, {r2, r8}
    /* Only one block exists - and it covers the entire usable heap space. */
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;

    uint32_t* pp = 0xb7000058;
    *pp = xFreeBytesRemaining;
 51082a8:	e3a024b7 	mov	r2, #-1224736768	; 0xb7000000
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 51082ac:	e587800c 	str	r8, [r7, #12]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 51082b0:	e5878010 	str	r8, [r7, #16]
    *pp = xFreeBytesRemaining;
 51082b4:	e5828058 	str	r8, [r2, #88]	; 0x58
}
 51082b8:	eaffff43 	b	5107fcc <pvPortMalloc+0x58>
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 51082bc:	e30d0b14 	movw	r0, #56084	; 0xdb14
 51082c0:	e3003900 	movw	r3, #2304	; 0x900
 51082c4:	e3400512 	movt	r0, #1298	; 0x512
 51082c8:	e3001133 	movw	r1, #307	; 0x133
 51082cc:	e3403511 	movt	r3, #1297	; 0x511
 51082d0:	e12fff33 	blx	r3
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 51082d4:	e5952004 	ldr	r2, [r5, #4]
 51082d8:	e0422006 	sub	r2, r2, r6
 51082dc:	eaffff90 	b	5108124 <pvPortMalloc+0x1b0>
*pp = 0x1238;
 51082e0:	e3012238 	movw	r2, #4664	; 0x1238
 51082e4:	e583204c 	str	r2, [r3, #76]	; 0x4c
                    xWantedSize = 0;
 51082e8:	eaffffaf 	b	51081ac <pvPortMalloc+0x238>
 51082ec:	05126fa7 	.word	0x05126fa7

051082f0 <pvPortCalloc>:
    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
 51082f0:	e3500000 	cmp	r0, #0
{
 51082f4:	e92d4070 	push	{r4, r5, r6, lr}
    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
 51082f8:	0a000003 	beq	510830c <pvPortCalloc+0x1c>
 51082fc:	e0832190 	umull	r2, r3, r0, r1
 5108300:	e3530000 	cmp	r3, #0
    void * pv = NULL;
 5108304:	13a05000 	movne	r5, #0
 5108308:	1a000009 	bne	5108334 <pvPortCalloc+0x44>
        pv = pvPortMalloc( xNum * xSize );
 510830c:	e0040091 	mul	r4, r1, r0
 5108310:	e1a00004 	mov	r0, r4
 5108314:	ebffff16 	bl	5107f74 <pvPortMalloc>
        if( pv != NULL )
 5108318:	e2505000 	subs	r5, r0, #0
 510831c:	0a000004 	beq	5108334 <pvPortCalloc+0x44>
            ( void ) memset( pv, 0, xNum * xSize );
 5108320:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5108324:	e1a02004 	mov	r2, r4
 5108328:	e3a01000 	mov	r1, #0
 510832c:	e3403511 	movt	r3, #1297	; 0x511
 5108330:	e12fff33 	blx	r3
}
 5108334:	e1a00005 	mov	r0, r5
 5108338:	e8bd8070 	pop	{r4, r5, r6, pc}

0510833c <vPortFree>:
{
 510833c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    if( pv != NULL )
 5108340:	e2504000 	subs	r4, r0, #0
 5108344:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
        heapVALIDATE_BLOCK_POINTER( pxLink );
 5108348:	e30c6fa8 	movw	r6, #53160	; 0xcfa8
        puc -= xHeapStructSize;
 510834c:	e2445008 	sub	r5, r4, #8
        heapVALIDATE_BLOCK_POINTER( pxLink );
 5108350:	e59f71a8 	ldr	r7, [pc, #424]	; 5108500 <vPortFree+0x1c4>
 5108354:	e3406511 	movt	r6, #1297	; 0x511
 5108358:	e1550006 	cmp	r5, r6
 510835c:	33a03000 	movcc	r3, #0
 5108360:	23a03001 	movcs	r3, #1
 5108364:	e1550007 	cmp	r5, r7
 5108368:	83a03000 	movhi	r3, #0
 510836c:	e3530000 	cmp	r3, #0
 5108370:	1a000005 	bne	510838c <vPortFree+0x50>
 5108374:	e30d0b14 	movw	r0, #56084	; 0xdb14
 5108378:	e3003900 	movw	r3, #2304	; 0x900
 510837c:	e300118d 	movw	r1, #397	; 0x18d
 5108380:	e3400512 	movt	r0, #1298	; 0x512
 5108384:	e3403511 	movt	r3, #1297	; 0x511
 5108388:	e12fff33 	blx	r3
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
 510838c:	e5143004 	ldr	r3, [r4, #-4]
 5108390:	e3530000 	cmp	r3, #0
 5108394:	aa000046 	bge	51084b4 <vPortFree+0x178>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 5108398:	e5143008 	ldr	r3, [r4, #-8]
 510839c:	e3530000 	cmp	r3, #0
 51083a0:	0a00003f 	beq	51084a4 <vPortFree+0x168>
 51083a4:	e30d0b14 	movw	r0, #56084	; 0xdb14
 51083a8:	e3003900 	movw	r3, #2304	; 0x900
 51083ac:	e300118f 	movw	r1, #399	; 0x18f
 51083b0:	e3403511 	movt	r3, #1297	; 0x511
 51083b4:	e3400512 	movt	r0, #1298	; 0x512
 51083b8:	e12fff33 	blx	r3
        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
 51083bc:	e5143004 	ldr	r3, [r4, #-4]
 51083c0:	e3530000 	cmp	r3, #0
 51083c4:	a8bd87f0 	popge	{r4, r5, r6, r7, r8, r9, sl, pc}
            if( pxLink->pxNextFreeBlock == NULL )
 51083c8:	e5142008 	ldr	r2, [r4, #-8]
 51083cc:	e3520000 	cmp	r2, #0
 51083d0:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
                    xFreeBytesRemaining += pxLink->xBlockSize;
 51083d4:	e30c9f8c 	movw	r9, #53132	; 0xcf8c
                heapFREE_BLOCK( pxLink );
 51083d8:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
                    xFreeBytesRemaining += pxLink->xBlockSize;
 51083dc:	e3409511 	movt	r9, #1297	; 0x511
                heapFREE_BLOCK( pxLink );
 51083e0:	e5043004 	str	r3, [r4, #-4]
                vTaskSuspendAll();
 51083e4:	e30532a0 	movw	r3, #21152	; 0x52a0
 51083e8:	e3403510 	movt	r3, #1296	; 0x510
 51083ec:	e12fff33 	blx	r3
                    xFreeBytesRemaining += pxLink->xBlockSize;
 51083f0:	e5991010 	ldr	r1, [r9, #16]
 51083f4:	e5142004 	ldr	r2, [r4, #-4]
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 51083f8:	e1a03009 	mov	r3, r9
                    xFreeBytesRemaining += pxLink->xBlockSize;
 51083fc:	e0821001 	add	r1, r2, r1
 5108400:	e5891010 	str	r1, [r9, #16]
    for( pxIterator = &xStart; heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) < pxBlockToInsert; pxIterator = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 5108404:	e1a08003 	mov	r8, r3
 5108408:	e5933000 	ldr	r3, [r3]
 510840c:	e1550003 	cmp	r5, r3
 5108410:	8afffffb 	bhi	5108404 <vPortFree+0xc8>
    {
        /* Nothing to do here, just iterate to the right position. */
    }

    if( pxIterator != &xStart )
 5108414:	e1580009 	cmp	r8, r9
 5108418:	0a00000e 	beq	5108458 <vPortFree+0x11c>
    {
        heapVALIDATE_BLOCK_POINTER( pxIterator );
 510841c:	e1580007 	cmp	r8, r7
 5108420:	83a07000 	movhi	r7, #0
 5108424:	93a07001 	movls	r7, #1
 5108428:	e1580006 	cmp	r8, r6
 510842c:	33a07000 	movcc	r7, #0
 5108430:	e3570000 	cmp	r7, #0
 5108434:	1a000007 	bne	5108458 <vPortFree+0x11c>
 5108438:	e30d0b14 	movw	r0, #56084	; 0xdb14
 510843c:	e3003900 	movw	r3, #2304	; 0x900
 5108440:	e3a01e22 	mov	r1, #544	; 0x220
 5108444:	e3403511 	movt	r3, #1297	; 0x511
 5108448:	e3400512 	movt	r0, #1298	; 0x512
 510844c:	e12fff33 	blx	r3

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 5108450:	e5983000 	ldr	r3, [r8]
 5108454:	e5142004 	ldr	r2, [r4, #-4]
    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 5108458:	e5981004 	ldr	r1, [r8, #4]
 510845c:	e0880001 	add	r0, r8, r1
 5108460:	e1550000 	cmp	r5, r0
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 5108464:	01a05008 	moveq	r5, r8
 5108468:	00812002 	addeq	r2, r1, r2
    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 510846c:	e0851002 	add	r1, r5, r2
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 5108470:	05882004 	streq	r2, [r8, #4]
    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) )
 5108474:	e1530001 	cmp	r3, r1
 5108478:	0a000017 	beq	51084dc <vPortFree+0x1a0>
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxEnd );
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 510847c:	e5853000 	str	r3, [r5]
                    xNumberOfSuccessfulFrees++;
 5108480:	e5992018 	ldr	r2, [r9, #24]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 5108484:	e1580005 	cmp	r8, r5
                ( void ) xTaskResumeAll();
 5108488:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xNumberOfSuccessfulFrees++;
 510848c:	e2822001 	add	r2, r2, #1
    {
        pxIterator->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxBlockToInsert );
 5108490:	15885000 	strne	r5, [r8]
                ( void ) xTaskResumeAll();
 5108494:	e3403510 	movt	r3, #1296	; 0x510
                    xNumberOfSuccessfulFrees++;
 5108498:	e5892018 	str	r2, [r9, #24]
                ( void ) xTaskResumeAll();
 510849c:	e12fff33 	blx	r3
}
 51084a0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
 51084a4:	e5143004 	ldr	r3, [r4, #-4]
 51084a8:	e3530000 	cmp	r3, #0
 51084ac:	a8bd87f0 	popge	{r4, r5, r6, r7, r8, r9, sl, pc}
 51084b0:	eaffffc7 	b	51083d4 <vPortFree+0x98>
        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
 51084b4:	e30d0b14 	movw	r0, #56084	; 0xdb14
 51084b8:	e3003900 	movw	r3, #2304	; 0x900
 51084bc:	e300118e 	movw	r1, #398	; 0x18e
 51084c0:	e3403511 	movt	r3, #1297	; 0x511
 51084c4:	e3400512 	movt	r0, #1298	; 0x512
 51084c8:	e12fff33 	blx	r3
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 51084cc:	e5143008 	ldr	r3, [r4, #-8]
 51084d0:	e3530000 	cmp	r3, #0
 51084d4:	1affffb2 	bne	51083a4 <vPortFree+0x68>
 51084d8:	eafffff1 	b	51084a4 <vPortFree+0x168>
        if( heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock ) != pxEnd )
 51084dc:	e5991008 	ldr	r1, [r9, #8]
 51084e0:	e1510003 	cmp	r1, r3
 51084e4:	0affffe4 	beq	510847c <vPortFree+0x140>
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
 51084e8:	e5931004 	ldr	r1, [r3, #4]
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
 51084ec:	e5933000 	ldr	r3, [r3]
 51084f0:	e5853000 	str	r3, [r5]
            pxBlockToInsert->xBlockSize += heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->xBlockSize;
 51084f4:	e0812002 	add	r2, r1, r2
 51084f8:	e5852004 	str	r2, [r5, #4]
            pxBlockToInsert->pxNextFreeBlock = heapPROTECT_BLOCK_POINTER( pxIterator->pxNextFreeBlock )->pxNextFreeBlock;
 51084fc:	eaffffdf 	b	5108480 <vPortFree+0x144>
 5108500:	05126fa7 	.word	0x05126fa7

05108504 <vPortInitialiseBlocks>:
}
 5108504:	e12fff1e 	bx	lr

05108508 <xPortGetFreeHeapSize>:
    return xFreeBytesRemaining;
 5108508:	e30c3f8c 	movw	r3, #53132	; 0xcf8c
 510850c:	e3403511 	movt	r3, #1297	; 0x511
}
 5108510:	e5930010 	ldr	r0, [r3, #16]
 5108514:	e12fff1e 	bx	lr

05108518 <xPortGetMinimumEverFreeHeapSize>:
    return xMinimumEverFreeBytesRemaining;
 5108518:	e30c3f8c 	movw	r3, #53132	; 0xcf8c
 510851c:	e3403511 	movt	r3, #1297	; 0x511
}
 5108520:	e593000c 	ldr	r0, [r3, #12]
 5108524:	e12fff1e 	bx	lr

05108528 <vPortHeapResetState>:
 * This function must be called by the application before restarting the
 * scheduler.
 */
void vPortHeapResetState( void )
{
    pxEnd = NULL;
 5108528:	e30c3f8c 	movw	r3, #53132	; 0xcf8c
 510852c:	e3a02000 	mov	r2, #0
 5108530:	e3403511 	movt	r3, #1297	; 0x511
 5108534:	e5832008 	str	r2, [r3, #8]

    xFreeBytesRemaining = ( size_t ) 0U;
 5108538:	e5832010 	str	r2, [r3, #16]
    xMinimumEverFreeBytesRemaining = ( size_t ) 0U;
 510853c:	e583200c 	str	r2, [r3, #12]
    xNumberOfSuccessfulAllocations = ( size_t ) 0U;
 5108540:	e5832014 	str	r2, [r3, #20]
    xNumberOfSuccessfulFrees = ( size_t ) 0U;
 5108544:	e5832018 	str	r2, [r3, #24]
}
 5108548:	e12fff1e 	bx	lr

0510854c <MPU_xTaskDelayUntilImpl>:
                                            TickType_t xTimeIncrement ) /* PRIVILEGED_FUNCTION */
        {
            BaseType_t xReturn = pdFAIL;
            BaseType_t xIsPreviousWakeTimeAccessible = pdFALSE;

            if( ( pxPreviousWakeTime != NULL ) && ( xTimeIncrement > 0U ) )
 510854c:	e3500000 	cmp	r0, #0
 5108550:	13510000 	cmpne	r1, #0
 5108554:	1a000001 	bne	5108560 <MPU_xTaskDelayUntilImpl+0x14>
            BaseType_t xReturn = pdFAIL;
 5108558:	e3a00000 	mov	r0, #0
                    xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
                }
            }

            return xReturn;
        }
 510855c:	e12fff1e 	bx	lr
                xIsPreviousWakeTimeAccessible = xPortIsAuthorizedToAccessBuffer( pxPreviousWakeTime,
 5108560:	e30c3824 	movw	r3, #51236	; 0xc824
 5108564:	e3a02003 	mov	r2, #3
        {
 5108568:	e92d4070 	push	{r4, r5, r6, lr}
 510856c:	e1a05001 	mov	r5, r1
                xIsPreviousWakeTimeAccessible = xPortIsAuthorizedToAccessBuffer( pxPreviousWakeTime,
 5108570:	e3403510 	movt	r3, #1296	; 0x510
 5108574:	e3a01004 	mov	r1, #4
 5108578:	e1a04000 	mov	r4, r0
 510857c:	e12fff33 	blx	r3
                if( xIsPreviousWakeTimeAccessible == pdTRUE )
 5108580:	e3500001 	cmp	r0, #1
 5108584:	0a000001 	beq	5108590 <MPU_xTaskDelayUntilImpl+0x44>
            BaseType_t xReturn = pdFAIL;
 5108588:	e3a00000 	mov	r0, #0
 510858c:	e8bd8070 	pop	{r4, r5, r6, pc}
                    xReturn = xTaskDelayUntil( pxPreviousWakeTime, xTimeIncrement );
 5108590:	e3063150 	movw	r3, #24912	; 0x6150
 5108594:	e1a01005 	mov	r1, r5
 5108598:	e1a00004 	mov	r0, r4
 510859c:	e3403510 	movt	r3, #1296	; 0x510
 51085a0:	e12fff33 	blx	r3
        }
 51085a4:	e8bd8070 	pop	{r4, r5, r6, pc}

051085a8 <MPU_vTaskDelayImpl>:

        void MPU_vTaskDelayImpl( TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;

        void MPU_vTaskDelayImpl( TickType_t xTicksToDelay ) /* PRIVILEGED_FUNCTION */
        {
            vTaskDelay( xTicksToDelay );
 51085a8:	e30630e0 	movw	r3, #24800	; 0x60e0
 51085ac:	e3403510 	movt	r3, #1296	; 0x510
        {
 51085b0:	e92d4010 	push	{r4, lr}
            vTaskDelay( xTicksToDelay );
 51085b4:	e12fff33 	blx	r3
        }
 51085b8:	e8bd8010 	pop	{r4, pc}

051085bc <MPU_xTaskGetTickCountImpl>:

    TickType_t MPU_xTaskGetTickCountImpl( void ) /* PRIVILEGED_FUNCTION */
    {
        TickType_t xReturn;

        xReturn = xTaskGetTickCount();
 51085bc:	e30532b8 	movw	r3, #21176	; 0x52b8
 51085c0:	e3403510 	movt	r3, #1296	; 0x510
    {
 51085c4:	e92d4010 	push	{r4, lr}
        xReturn = xTaskGetTickCount();
 51085c8:	e12fff33 	blx	r3

        return xReturn;
    }
 51085cc:	e8bd8010 	pop	{r4, pc}

051085d0 <MPU_uxTaskGetNumberOfTasksImpl>:

    UBaseType_t MPU_uxTaskGetNumberOfTasksImpl( void ) /* PRIVILEGED_FUNCTION */
    {
        UBaseType_t uxReturn;

        uxReturn = uxTaskGetNumberOfTasks();
 51085d0:	e30532d8 	movw	r3, #21208	; 0x52d8
 51085d4:	e3403510 	movt	r3, #1296	; 0x510
    {
 51085d8:	e92d4010 	push	{r4, lr}
        uxReturn = uxTaskGetNumberOfTasks();
 51085dc:	e12fff33 	blx	r3

        return uxReturn;
    }
 51085e0:	e8bd8010 	pop	{r4, pc}

051085e4 <MPU_xTaskGetSchedulerStateImpl>:

        BaseType_t MPU_xTaskGetSchedulerStateImpl( void ) /* PRIVILEGED_FUNCTION */
        {
            BaseType_t xReturn = taskSCHEDULER_NOT_STARTED;

            xReturn = xTaskGetSchedulerState();
 51085e4:	e3063e28 	movw	r3, #28200	; 0x6e28
 51085e8:	e3403510 	movt	r3, #1296	; 0x510
        {
 51085ec:	e92d4010 	push	{r4, lr}
            xReturn = xTaskGetSchedulerState();
 51085f0:	e12fff33 	blx	r3

            return xReturn;
        }
 51085f4:	e8bd8010 	pop	{r4, pc}

051085f8 <MPU_vTaskSetTimeOutStateImpl>:
/*-----------------------------------------------------------*/

    void MPU_vTaskSetTimeOutStateImpl( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;

    void MPU_vTaskSetTimeOutStateImpl( TimeOut_t * const pxTimeOut ) /* PRIVILEGED_FUNCTION */
    {
 51085f8:	e92d4010 	push	{r4, lr}
        BaseType_t xIsTimeOutWriteable = pdFALSE;

        if( pxTimeOut != NULL )
 51085fc:	e2504000 	subs	r4, r0, #0
 5108600:	08bd8010 	popeq	{r4, pc}
        {
            xIsTimeOutWriteable = xPortIsAuthorizedToAccessBuffer( pxTimeOut,
 5108604:	e30c3824 	movw	r3, #51236	; 0xc824
 5108608:	e3a02002 	mov	r2, #2
 510860c:	e3a01008 	mov	r1, #8
 5108610:	e3403510 	movt	r3, #1296	; 0x510
 5108614:	e12fff33 	blx	r3
                                                                   sizeof( TimeOut_t ),
                                                                   tskMPU_WRITE_PERMISSION );

            if( xIsTimeOutWriteable == pdTRUE )
 5108618:	e3500001 	cmp	r0, #1
 510861c:	18bd8010 	popne	{r4, pc}
            {
                vTaskSetTimeOutState( pxTimeOut );
 5108620:	e3053b34 	movw	r3, #23348	; 0x5b34
 5108624:	e1a00004 	mov	r0, r4
 5108628:	e3403510 	movt	r3, #1296	; 0x510
 510862c:	e12fff33 	blx	r3
            }
        }
    }
 5108630:	e8bd8010 	pop	{r4, pc}

05108634 <MPU_xTaskCheckForTimeOutImpl>:
    {
        BaseType_t xReturn = pdFALSE;
        BaseType_t xIsTimeOutWriteable = pdFALSE;
        BaseType_t xIsTicksToWaitWriteable = pdFALSE;

        if( ( pxTimeOut != NULL ) && ( pxTicksToWait != NULL ) )
 5108634:	e3500000 	cmp	r0, #0
 5108638:	13510000 	cmpne	r1, #0
 510863c:	1a000001 	bne	5108648 <MPU_xTaskCheckForTimeOutImpl+0x14>
        BaseType_t xReturn = pdFALSE;
 5108640:	e3a00000 	mov	r0, #0
                xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
            }
        }

        return xReturn;
    }
 5108644:	e12fff1e 	bx	lr
    {
 5108648:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            xIsTimeOutWriteable = xPortIsAuthorizedToAccessBuffer( pxTimeOut,
 510864c:	e30c6824 	movw	r6, #51236	; 0xc824
 5108650:	e1a04001 	mov	r4, r1
 5108654:	e3a02002 	mov	r2, #2
 5108658:	e3a01008 	mov	r1, #8
 510865c:	e1a05000 	mov	r5, r0
 5108660:	e3406510 	movt	r6, #1296	; 0x510
 5108664:	e12fff36 	blx	r6
            xIsTicksToWaitWriteable = xPortIsAuthorizedToAccessBuffer( pxTicksToWait,
 5108668:	e3a02002 	mov	r2, #2
 510866c:	e3a01004 	mov	r1, #4
            xIsTimeOutWriteable = xPortIsAuthorizedToAccessBuffer( pxTimeOut,
 5108670:	e1a07000 	mov	r7, r0
            xIsTicksToWaitWriteable = xPortIsAuthorizedToAccessBuffer( pxTicksToWait,
 5108674:	e1a00004 	mov	r0, r4
 5108678:	e12fff36 	blx	r6
            if( ( xIsTimeOutWriteable == pdTRUE ) && ( xIsTicksToWaitWriteable == pdTRUE ) )
 510867c:	e3570001 	cmp	r7, #1
 5108680:	03500001 	cmpeq	r0, #1
 5108684:	0a000001 	beq	5108690 <MPU_xTaskCheckForTimeOutImpl+0x5c>
        BaseType_t xReturn = pdFALSE;
 5108688:	e3a00000 	mov	r0, #0
 510868c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                xReturn = xTaskCheckForTimeOut( pxTimeOut, pxTicksToWait );
 5108690:	e3053b8c 	movw	r3, #23436	; 0x5b8c
 5108694:	e1a01004 	mov	r1, r4
 5108698:	e1a00005 	mov	r0, r5
 510869c:	e3403510 	movt	r3, #1296	; 0x510
 51086a0:	e12fff33 	blx	r3
    }
 51086a4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

051086a8 <MPU_xTaskGenericNotifyWaitImpl>:
        }

        BaseType_t MPU_xTaskGenericNotifyWaitImpl( const xTaskGenericNotifyWaitParams_t * pxParams ) PRIVILEGED_FUNCTION;

        BaseType_t MPU_xTaskGenericNotifyWaitImpl( const xTaskGenericNotifyWaitParams_t * pxParams ) /* PRIVILEGED_FUNCTION */
        {
 51086a8:	e92d4030 	push	{r4, r5, lr}
            BaseType_t xReturn = pdFAIL;
            BaseType_t xIsNotificationValueWritable = pdFALSE;
            BaseType_t xAreParamsReadable = pdFALSE;

            if( pxParams != NULL )
 51086ac:	e2504000 	subs	r4, r0, #0
        {
 51086b0:	e24dd00c 	sub	sp, sp, #12
            if( pxParams != NULL )
 51086b4:	0a000006 	beq	51086d4 <MPU_xTaskGenericNotifyWaitImpl+0x2c>
            {
                xAreParamsReadable = xPortIsAuthorizedToAccessBuffer( pxParams,
 51086b8:	e30c5824 	movw	r5, #51236	; 0xc824
 51086bc:	e3a02001 	mov	r2, #1
 51086c0:	e3a01014 	mov	r1, #20
 51086c4:	e3405510 	movt	r5, #1296	; 0x510
 51086c8:	e12fff35 	blx	r5
                                                                      sizeof( xTaskGenericNotifyWaitParams_t ),
                                                                      tskMPU_READ_PERMISSION );
            }

            if( xAreParamsReadable == pdTRUE )
 51086cc:	e3500001 	cmp	r0, #1
 51086d0:	0a000002 	beq	51086e0 <MPU_xTaskGenericNotifyWaitImpl+0x38>
            BaseType_t xReturn = pdFAIL;
 51086d4:	e3a00000 	mov	r0, #0
                    }
                }
            }

            return xReturn;
        }
 51086d8:	e28dd00c 	add	sp, sp, #12
 51086dc:	e8bd8030 	pop	{r4, r5, pc}
                if( pxParams->uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES )
 51086e0:	e5940000 	ldr	r0, [r4]
 51086e4:	e3500000 	cmp	r0, #0
 51086e8:	1afffff9 	bne	51086d4 <MPU_xTaskGenericNotifyWaitImpl+0x2c>
                    if( pxParams->pulNotificationValue != NULL )
 51086ec:	e594300c 	ldr	r3, [r4, #12]
 51086f0:	e3530000 	cmp	r3, #0
 51086f4:	0a000009 	beq	5108720 <MPU_xTaskGenericNotifyWaitImpl+0x78>
                        xIsNotificationValueWritable = xPortIsAuthorizedToAccessBuffer( pxParams->pulNotificationValue,
 51086f8:	e1a00003 	mov	r0, r3
 51086fc:	e3a02002 	mov	r2, #2
 5108700:	e3a01004 	mov	r1, #4
 5108704:	e12fff35 	blx	r5
                    if( ( pxParams->pulNotificationValue == NULL ) ||
 5108708:	e594300c 	ldr	r3, [r4, #12]
 510870c:	e3530000 	cmp	r3, #0
 5108710:	0a000001 	beq	510871c <MPU_xTaskGenericNotifyWaitImpl+0x74>
 5108714:	e3500001 	cmp	r0, #1
 5108718:	1affffed 	bne	51086d4 <MPU_xTaskGenericNotifyWaitImpl+0x2c>
                        xReturn = xTaskGenericNotifyWait( pxParams->uxIndexToWaitOn,
 510871c:	e5940000 	ldr	r0, [r4]
 5108720:	e594e010 	ldr	lr, [r4, #16]
 5108724:	e9940006 	ldmib	r4, {r1, r2}
 5108728:	e3064450 	movw	r4, #25680	; 0x6450
 510872c:	e58de000 	str	lr, [sp]
 5108730:	e3404510 	movt	r4, #1296	; 0x510
 5108734:	e12fff34 	blx	r4
            return xReturn;
 5108738:	eaffffe6 	b	51086d8 <MPU_xTaskGenericNotifyWaitImpl+0x30>

0510873c <MPU_ulTaskGenericNotifyTakeImpl>:
                                                  BaseType_t xClearCountOnExit,
                                                  TickType_t xTicksToWait ) /* PRIVILEGED_FUNCTION */
        {
            uint32_t ulReturn = 0;

            if( uxIndexToWaitOn < configTASK_NOTIFICATION_ARRAY_ENTRIES )
 510873c:	e3500000 	cmp	r0, #0
 5108740:	0a000001 	beq	510874c <MPU_ulTaskGenericNotifyTakeImpl+0x10>
            uint32_t ulReturn = 0;
 5108744:	e3a00000 	mov	r0, #0
            {
                ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
            }

            return ulReturn;
        }
 5108748:	e12fff1e 	bx	lr
                ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 510874c:	e306359c 	movw	r3, #26012	; 0x659c
 5108750:	e3403510 	movt	r3, #1296	; 0x510
        {
 5108754:	e92d4010 	push	{r4, lr}
                ulReturn = ulTaskGenericNotifyTake( uxIndexToWaitOn, xClearCountOnExit, xTicksToWait );
 5108758:	e12fff33 	blx	r3
        }
 510875c:	e8bd8010 	pop	{r4, pc}

05108760 <MPU_xTimerGetTimerDaemonTaskHandleImpl>:

        TaskHandle_t MPU_xTimerGetTimerDaemonTaskHandleImpl( void ) /* PRIVILEGED_FUNCTION */
        {
            TaskHandle_t xReturn;

            xReturn = xTimerGetTimerDaemonTaskHandle();
 5108760:	e3073a30 	movw	r3, #31280	; 0x7a30
 5108764:	e3403510 	movt	r3, #1296	; 0x510
        {
 5108768:	e92d4010 	push	{r4, lr}
            xReturn = xTimerGetTimerDaemonTaskHandle();
 510876c:	e12fff33 	blx	r3

            return xReturn;
        }
 5108770:	e8bd8010 	pop	{r4, pc}

05108774 <MPU_xTaskGenericNotifyImpl>:
        {
 5108774:	e92d4030 	push	{r4, r5, lr}
            if( pxParams != NULL )
 5108778:	e2504000 	subs	r4, r0, #0
        {
 510877c:	e24dd00c 	sub	sp, sp, #12
            if( pxParams != NULL )
 5108780:	0a000006 	beq	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
                xAreParamsReadable = xPortIsAuthorizedToAccessBuffer( pxParams,
 5108784:	e30c5824 	movw	r5, #51236	; 0xc824
 5108788:	e3a02001 	mov	r2, #1
 510878c:	e3a01014 	mov	r1, #20
 5108790:	e3405510 	movt	r5, #1296	; 0x510
 5108794:	e12fff35 	blx	r5
            if( xAreParamsReadable == pdTRUE )
 5108798:	e3500001 	cmp	r0, #1
 510879c:	0a000002 	beq	51087ac <MPU_xTaskGenericNotifyImpl+0x38>
            BaseType_t xReturn = pdFAIL;
 51087a0:	e3a00000 	mov	r0, #0
        }
 51087a4:	e28dd00c 	add	sp, sp, #12
 51087a8:	e8bd8030 	pop	{r4, r5, pc}
                if( ( pxParams->uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES ) &&
 51087ac:	e5943004 	ldr	r3, [r4, #4]
 51087b0:	e3530000 	cmp	r3, #0
 51087b4:	1afffff9 	bne	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
 51087b8:	e5d4300c 	ldrb	r3, [r4, #12]
 51087bc:	e3530004 	cmp	r3, #4
 51087c0:	8afffff6 	bhi	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
                    if( pxParams->pulPreviousNotificationValue != NULL )
 51087c4:	e5940010 	ldr	r0, [r4, #16]
 51087c8:	e3500000 	cmp	r0, #0
 51087cc:	0a000006 	beq	51087ec <MPU_xTaskGenericNotifyImpl+0x78>
                        xIsPreviousNotificationValueWriteable = xPortIsAuthorizedToAccessBuffer( pxParams->pulPreviousNotificationValue,
 51087d0:	e3a02002 	mov	r2, #2
 51087d4:	e3a01004 	mov	r1, #4
 51087d8:	e12fff35 	blx	r5
                    if( ( pxParams->pulPreviousNotificationValue == NULL ) ||
 51087dc:	e5943010 	ldr	r3, [r4, #16]
 51087e0:	e3500001 	cmp	r0, #1
 51087e4:	13530000 	cmpne	r3, #0
 51087e8:	1affffec 	bne	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
                        lIndex = ( int32_t ) ( pxParams->xTaskToNotify );
 51087ec:	e5945000 	ldr	r5, [r4]
                        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51087f0:	e2455001 	sub	r5, r5, #1
 51087f4:	e355007f 	cmp	r5, #127	; 0x7f
 51087f8:	8affffe8 	bhi	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
                            xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51087fc:	e30c3928 	movw	r3, #51496	; 0xc928
 5108800:	e1a00005 	mov	r0, r5
 5108804:	e3403510 	movt	r3, #1296	; 0x510
 5108808:	e12fff33 	blx	r3
                            if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 510880c:	e3500001 	cmp	r0, #1
 5108810:	1affffe2 	bne	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108814:	e3062fa8 	movw	r2, #28584	; 0x6fa8
 5108818:	e0853085 	add	r3, r5, r5, lsl #1
 510881c:	e3402512 	movt	r2, #1298	; 0x512
 5108820:	e0823103 	add	r3, r2, r3, lsl #2
 5108824:	e5933004 	ldr	r3, [r3, #4]
 5108828:	e3530002 	cmp	r3, #2
 510882c:	1affffdb 	bne	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108830:	e3a0300c 	mov	r3, #12
 5108834:	e0050395 	mul	r5, r5, r3
 5108838:	e7920005 	ldr	r0, [r2, r5]
                                if( xInternalTaskHandle != NULL )
 510883c:	e3500000 	cmp	r0, #0
 5108840:	0affffd6 	beq	51087a0 <MPU_xTaskGenericNotifyImpl+0x2c>
                                    xReturn = xTaskGenericNotify( xInternalTaskHandle,
 5108844:	e5943010 	ldr	r3, [r4, #16]
 5108848:	e9940006 	ldmib	r4, {r1, r2}
 510884c:	e58d3000 	str	r3, [sp]
 5108850:	e5d4300c 	ldrb	r3, [r4, #12]
 5108854:	e3054414 	movw	r4, #21524	; 0x5414
 5108858:	e3404510 	movt	r4, #1296	; 0x510
 510885c:	e12fff34 	blx	r4
            return xReturn;
 5108860:	eaffffcf 	b	51087a4 <MPU_xTaskGenericNotifyImpl+0x30>

05108864 <MPU_TimerCallback>:
        {
 5108864:	e92d4070 	push	{r4, r5, r6, lr}
            configASSERT( xInternalHandle != NULL );
 5108868:	e2504000 	subs	r4, r0, #0
 510886c:	0a00001d 	beq	51088e8 <MPU_TimerCallback+0x84>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 5108870:	e3065fa8 	movw	r5, #28584	; 0x6fa8
 5108874:	e3a02000 	mov	r2, #0
 5108878:	e3405512 	movt	r5, #1298	; 0x512
 510887c:	e1a03005 	mov	r3, r5
 5108880:	ea000003 	b	5108894 <MPU_TimerCallback+0x30>
 5108884:	e2822001 	add	r2, r2, #1
 5108888:	e3520080 	cmp	r2, #128	; 0x80
 510888c:	e283300c 	add	r3, r3, #12
 5108890:	0a00000b 	beq	51088c4 <MPU_TimerCallback+0x60>
                if( ( ( TimerHandle_t ) xKernelObjectPool[ i ].xInternalObjectHandle == xInternalHandle ) &&
 5108894:	e5931000 	ldr	r1, [r3]
 5108898:	e1510004 	cmp	r1, r4
 510889c:	1afffff8 	bne	5108884 <MPU_TimerCallback+0x20>
 51088a0:	e5931004 	ldr	r1, [r3, #4]
 51088a4:	e3510005 	cmp	r1, #5
 51088a8:	1afffff5 	bne	5108884 <MPU_TimerCallback+0x20>
            xExternalHandle = ( TimerHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 51088ac:	e2820001 	add	r0, r2, #1
            pxApplicationCallBack = ( TimerCallbackFunction_t ) xKernelObjectPool[ lIndex ].pvKernelObjectData;
 51088b0:	e0822082 	add	r2, r2, r2, lsl #1
 51088b4:	e0852102 	add	r2, r5, r2, lsl #2
            pxApplicationCallBack( xExternalHandle );
 51088b8:	e5923008 	ldr	r3, [r2, #8]
 51088bc:	e12fff33 	blx	r3
        }
 51088c0:	e8bd8070 	pop	{r4, r5, r6, pc}
            configASSERT( lIndex != -1 );
 51088c4:	e30d0b50 	movw	r0, #56144	; 0xdb50
 51088c8:	e3003900 	movw	r3, #2304	; 0x900
 51088cc:	e30011b5 	movw	r1, #437	; 0x1b5
 51088d0:	e3400512 	movt	r0, #1298	; 0x512
 51088d4:	e3403511 	movt	r3, #1297	; 0x511
 51088d8:	e12fff33 	blx	r3
 51088dc:	e3a00000 	mov	r0, #0
            int32_t i, lIndex = -1;
 51088e0:	e3e02000 	mvn	r2, #0
 51088e4:	eafffff1 	b	51088b0 <MPU_TimerCallback+0x4c>
            configASSERT( xInternalHandle != NULL );
 51088e8:	e30d0b50 	movw	r0, #56144	; 0xdb50
 51088ec:	e3003900 	movw	r3, #2304	; 0x900
 51088f0:	e30011a9 	movw	r1, #425	; 0x1a9
 51088f4:	e3403511 	movt	r3, #1297	; 0x511
 51088f8:	e3400512 	movt	r0, #1298	; 0x512
 51088fc:	e12fff33 	blx	r3
 5108900:	eaffffda 	b	5108870 <MPU_TimerCallback+0xc>

05108904 <MPU_xTaskGetCurrentTaskHandleImpl>:
            xInternalTaskHandle = xTaskGetCurrentTaskHandle();
 5108904:	e3063dec 	movw	r3, #28140	; 0x6dec
        {
 5108908:	e92d4010 	push	{r4, lr}
            xInternalTaskHandle = xTaskGetCurrentTaskHandle();
 510890c:	e3403510 	movt	r3, #1296	; 0x510
 5108910:	e12fff33 	blx	r3
            if( xInternalTaskHandle != NULL )
 5108914:	e3500000 	cmp	r0, #0
 5108918:	08bd8010 	popeq	{r4, pc}
 510891c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 5108920:	e3a02000 	mov	r2, #0
 5108924:	e3403512 	movt	r3, #1298	; 0x512
 5108928:	ea000003 	b	510893c <MPU_xTaskGetCurrentTaskHandleImpl+0x38>
 510892c:	e2822001 	add	r2, r2, #1
 5108930:	e3520080 	cmp	r2, #128	; 0x80
 5108934:	e283300c 	add	r3, r3, #12
 5108938:	0a000007 	beq	510895c <MPU_xTaskGetCurrentTaskHandleImpl+0x58>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 510893c:	e5931000 	ldr	r1, [r3]
 5108940:	e1500001 	cmp	r0, r1
 5108944:	1afffff8 	bne	510892c <MPU_xTaskGetCurrentTaskHandleImpl+0x28>
 5108948:	e5931004 	ldr	r1, [r3, #4]
 510894c:	e3510002 	cmp	r1, #2
 5108950:	1afffff5 	bne	510892c <MPU_xTaskGetCurrentTaskHandleImpl+0x28>
                    xExternalTaskHandle = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 5108954:	e2820001 	add	r0, r2, #1
        }
 5108958:	e8bd8010 	pop	{r4, pc}
            TaskHandle_t xExternalTaskHandle = NULL;
 510895c:	e3a00000 	mov	r0, #0
            return xExternalTaskHandle;
 5108960:	e8bd8010 	pop	{r4, pc}

05108964 <MPU_pcQueueGetNameImpl>:
        {
 5108964:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108968:	e2404001 	sub	r4, r0, #1
 510896c:	e354007f 	cmp	r4, #127	; 0x7f
 5108970:	8a000005 	bhi	510898c <MPU_pcQueueGetNameImpl+0x28>
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108974:	e30c3928 	movw	r3, #51496	; 0xc928
 5108978:	e1a00004 	mov	r0, r4
 510897c:	e3403510 	movt	r3, #1296	; 0x510
 5108980:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5108984:	e3500001 	cmp	r0, #1
 5108988:	0a000001 	beq	5108994 <MPU_pcQueueGetNameImpl+0x30>
            const char * pcReturn = NULL;
 510898c:	e3a00000 	mov	r0, #0
 5108990:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108994:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108998:	e0844084 	add	r4, r4, r4, lsl #1
 510899c:	e3403512 	movt	r3, #1298	; 0x512
 51089a0:	e0832104 	add	r2, r3, r4, lsl #2
 51089a4:	e1a04104 	lsl	r4, r4, #2
 51089a8:	e5922004 	ldr	r2, [r2, #4]
 51089ac:	e3520001 	cmp	r2, #1
 51089b0:	1afffff5 	bne	510898c <MPU_pcQueueGetNameImpl+0x28>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51089b4:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalQueueHandle != NULL )
 51089b8:	e3500000 	cmp	r0, #0
 51089bc:	0afffff2 	beq	510898c <MPU_pcQueueGetNameImpl+0x28>
                        pcReturn = pcQueueGetName( xInternalQueueHandle );
 51089c0:	e302351c 	movw	r3, #9500	; 0x251c
 51089c4:	e3403510 	movt	r3, #1296	; 0x510
 51089c8:	e12fff33 	blx	r3
        }
 51089cc:	e8bd8010 	pop	{r4, pc}

051089d0 <MPU_pvTimerGetTimerIDImpl>:
        {
 51089d0:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51089d4:	e2404001 	sub	r4, r0, #1
 51089d8:	e354007f 	cmp	r4, #127	; 0x7f
 51089dc:	8a000005 	bhi	51089f8 <MPU_pvTimerGetTimerIDImpl+0x28>
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51089e0:	e30c3928 	movw	r3, #51496	; 0xc928
 51089e4:	e1a00004 	mov	r0, r4
 51089e8:	e3403510 	movt	r3, #1296	; 0x510
 51089ec:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 51089f0:	e3500001 	cmp	r0, #1
 51089f4:	0a000001 	beq	5108a00 <MPU_pvTimerGetTimerIDImpl+0x30>
            void * pvReturn = NULL;
 51089f8:	e3a00000 	mov	r0, #0
 51089fc:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108a00:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108a04:	e0844084 	add	r4, r4, r4, lsl #1
 5108a08:	e3403512 	movt	r3, #1298	; 0x512
 5108a0c:	e0832104 	add	r2, r3, r4, lsl #2
 5108a10:	e1a04104 	lsl	r4, r4, #2
 5108a14:	e5922004 	ldr	r2, [r2, #4]
 5108a18:	e3520005 	cmp	r2, #5
 5108a1c:	1afffff5 	bne	51089f8 <MPU_pvTimerGetTimerIDImpl+0x28>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108a20:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5108a24:	e3500000 	cmp	r0, #0
 5108a28:	0afffff2 	beq	51089f8 <MPU_pvTimerGetTimerIDImpl+0x28>
                        pvReturn = pvTimerGetTimerID( xInternalTimerHandle );
 5108a2c:	e3073930 	movw	r3, #31024	; 0x7930
 5108a30:	e3403510 	movt	r3, #1296	; 0x510
 5108a34:	e12fff33 	blx	r3
        }
 5108a38:	e8bd8010 	pop	{r4, pc}

05108a3c <MPU_pcTimerGetNameImpl>:
    #if ( configUSE_TIMERS == 1 )

        const char * MPU_pcTimerGetNameImpl( TimerHandle_t xTimer ) PRIVILEGED_FUNCTION;

        const char * MPU_pcTimerGetNameImpl( TimerHandle_t xTimer ) /* PRIVILEGED_FUNCTION */
        {
 5108a3c:	e92d4010 	push	{r4, lr}
            int32_t lIndex;
            BaseType_t xCallingTaskIsAuthorizedToAccessTimer = pdFALSE;

            lIndex = ( int32_t ) xTimer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108a40:	e2404001 	sub	r4, r0, #1
 5108a44:	e354007f 	cmp	r4, #127	; 0x7f
 5108a48:	8a000005 	bhi	5108a64 <MPU_pcTimerGetNameImpl+0x28>
            {
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108a4c:	e30c3928 	movw	r3, #51496	; 0xc928
 5108a50:	e1a00004 	mov	r0, r4
 5108a54:	e3403510 	movt	r3, #1296	; 0x510
 5108a58:	e12fff33 	blx	r3

                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5108a5c:	e3500001 	cmp	r0, #1
 5108a60:	0a000001 	beq	5108a6c <MPU_pcTimerGetNameImpl+0x30>
            const char * pcReturn = NULL;
 5108a64:	e3a00000 	mov	r0, #0
 5108a68:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108a6c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108a70:	e0844084 	add	r4, r4, r4, lsl #1
 5108a74:	e3403512 	movt	r3, #1298	; 0x512
 5108a78:	e0832104 	add	r2, r3, r4, lsl #2
 5108a7c:	e1a04104 	lsl	r4, r4, #2
 5108a80:	e5922004 	ldr	r2, [r2, #4]
 5108a84:	e3520005 	cmp	r2, #5
 5108a88:	1afffff5 	bne	5108a64 <MPU_pcTimerGetNameImpl+0x28>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108a8c:	e7930004 	ldr	r0, [r3, r4]
                {
                    xInternalTimerHandle = MPU_GetTimerHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );

                    if( xInternalTimerHandle != NULL )
 5108a90:	e3500000 	cmp	r0, #0
 5108a94:	0afffff2 	beq	5108a64 <MPU_pcTimerGetNameImpl+0x28>
                    {
                        pcReturn = pcTimerGetName( xInternalTimerHandle );
 5108a98:	e3073b38 	movw	r3, #31544	; 0x7b38
 5108a9c:	e3403510 	movt	r3, #1296	; 0x510
 5108aa0:	e12fff33 	blx	r3
                    }
                }
            }

            return pcReturn;
        }
 5108aa4:	e8bd8010 	pop	{r4, pc}

05108aa8 <MPU_eTaskGetStateImpl>:
        {
 5108aa8:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108aac:	e2404001 	sub	r4, r0, #1
 5108ab0:	e354007f 	cmp	r4, #127	; 0x7f
 5108ab4:	9a000001 	bls	5108ac0 <MPU_eTaskGetStateImpl+0x18>
            eTaskState eReturn = eInvalid;
 5108ab8:	e3a00005 	mov	r0, #5
 5108abc:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108ac0:	e30c3928 	movw	r3, #51496	; 0xc928
 5108ac4:	e1a00004 	mov	r0, r4
 5108ac8:	e3403510 	movt	r3, #1296	; 0x510
 5108acc:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5108ad0:	e3500001 	cmp	r0, #1
 5108ad4:	1afffff7 	bne	5108ab8 <MPU_eTaskGetStateImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108ad8:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108adc:	e0844084 	add	r4, r4, r4, lsl #1
 5108ae0:	e3403512 	movt	r3, #1298	; 0x512
 5108ae4:	e0832104 	add	r2, r3, r4, lsl #2
 5108ae8:	e1a04104 	lsl	r4, r4, #2
 5108aec:	e5922004 	ldr	r2, [r2, #4]
 5108af0:	e3520002 	cmp	r2, #2
 5108af4:	1affffef 	bne	5108ab8 <MPU_eTaskGetStateImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108af8:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTaskHandle != NULL )
 5108afc:	e3500000 	cmp	r0, #0
 5108b00:	0affffec 	beq	5108ab8 <MPU_eTaskGetStateImpl+0x10>
                        eReturn = eTaskGetState( xInternalTaskHandle );
 5108b04:	e3043c84 	movw	r3, #19588	; 0x4c84
 5108b08:	e3403510 	movt	r3, #1296	; 0x510
 5108b0c:	e12fff33 	blx	r3
        }
 5108b10:	e8bd8010 	pop	{r4, pc}

05108b14 <MPU_xQueueGetMutexHolderImpl>:
        {
 5108b14:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108b18:	e2404001 	sub	r4, r0, #1
 5108b1c:	e354007f 	cmp	r4, #127	; 0x7f
 5108b20:	8a000005 	bhi	5108b3c <MPU_xQueueGetMutexHolderImpl+0x28>
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108b24:	e30c3928 	movw	r3, #51496	; 0xc928
 5108b28:	e1a00004 	mov	r0, r4
 5108b2c:	e3403510 	movt	r3, #1296	; 0x510
 5108b30:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5108b34:	e3500001 	cmp	r0, #1
 5108b38:	0a000001 	beq	5108b44 <MPU_xQueueGetMutexHolderImpl+0x30>
            TaskHandle_t xMutexHolderTaskExternalHandle = NULL;
 5108b3c:	e3a00000 	mov	r0, #0
            return xMutexHolderTaskExternalHandle;
 5108b40:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108b44:	e0840084 	add	r0, r4, r4, lsl #1
 5108b48:	e3064fa8 	movw	r4, #28584	; 0x6fa8
 5108b4c:	e3404512 	movt	r4, #1298	; 0x512
 5108b50:	e0843100 	add	r3, r4, r0, lsl #2
 5108b54:	e1a00100 	lsl	r0, r0, #2
 5108b58:	e5933004 	ldr	r3, [r3, #4]
 5108b5c:	e3530001 	cmp	r3, #1
 5108b60:	1afffff5 	bne	5108b3c <MPU_xQueueGetMutexHolderImpl+0x28>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108b64:	e7940000 	ldr	r0, [r4, r0]
                    if( xInternalQueueHandle != NULL )
 5108b68:	e3500000 	cmp	r0, #0
 5108b6c:	0afffff2 	beq	5108b3c <MPU_xQueueGetMutexHolderImpl+0x28>
                        xMutexHolderTaskInternalHandle = xQueueGetMutexHolder( xInternalQueueHandle );
 5108b70:	e3023268 	movw	r3, #8808	; 0x2268
 5108b74:	e3403510 	movt	r3, #1296	; 0x510
 5108b78:	e12fff33 	blx	r3
                        if( xMutexHolderTaskInternalHandle != NULL )
 5108b7c:	e3500000 	cmp	r0, #0
 5108b80:	0affffed 	beq	5108b3c <MPU_xQueueGetMutexHolderImpl+0x28>
 5108b84:	e1a03004 	mov	r3, r4
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 5108b88:	e3a02000 	mov	r2, #0
 5108b8c:	ea000003 	b	5108ba0 <MPU_xQueueGetMutexHolderImpl+0x8c>
 5108b90:	e2822001 	add	r2, r2, #1
 5108b94:	e3520080 	cmp	r2, #128	; 0x80
 5108b98:	e283300c 	add	r3, r3, #12
 5108b9c:	0affffe6 	beq	5108b3c <MPU_xQueueGetMutexHolderImpl+0x28>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 5108ba0:	e5931000 	ldr	r1, [r3]
 5108ba4:	e1500001 	cmp	r0, r1
 5108ba8:	1afffff8 	bne	5108b90 <MPU_xQueueGetMutexHolderImpl+0x7c>
 5108bac:	e5931004 	ldr	r1, [r3, #4]
 5108bb0:	e3510002 	cmp	r1, #2
 5108bb4:	1afffff5 	bne	5108b90 <MPU_xQueueGetMutexHolderImpl+0x7c>
                                xMutexHolderTaskExternalHandle = ( TaskHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lMutexHolderTaskIndex ) );
 5108bb8:	e2820001 	add	r0, r2, #1
        }
 5108bbc:	e8bd8010 	pop	{r4, pc}

05108bc0 <MPU_xQueueSelectFromSetImpl>:
        {
 5108bc0:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE )
 5108bc4:	e2404001 	sub	r4, r0, #1
 5108bc8:	e354007f 	cmp	r4, #127	; 0x7f
 5108bcc:	8a000006 	bhi	5108bec <MPU_xQueueSelectFromSetImpl+0x2c>
                xCallingTaskIsAuthorizedToAccessQueueSet = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet ) );
 5108bd0:	e30c3928 	movw	r3, #51496	; 0xc928
 5108bd4:	e1a00004 	mov	r0, r4
 5108bd8:	e1a05001 	mov	r5, r1
 5108bdc:	e3403510 	movt	r3, #1296	; 0x510
 5108be0:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueueSet == pdTRUE )
 5108be4:	e3500001 	cmp	r0, #1
 5108be8:	0a000001 	beq	5108bf4 <MPU_xQueueSelectFromSetImpl+0x34>
            QueueSetMemberHandle_t xSelectedMemberExternal = NULL;
 5108bec:	e3a00000 	mov	r0, #0
            return xSelectedMemberExternal;
 5108bf0:	e8bd8070 	pop	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108bf4:	e0840084 	add	r0, r4, r4, lsl #1
 5108bf8:	e3064fa8 	movw	r4, #28584	; 0x6fa8
 5108bfc:	e3404512 	movt	r4, #1298	; 0x512
 5108c00:	e0843100 	add	r3, r4, r0, lsl #2
 5108c04:	e1a00100 	lsl	r0, r0, #2
 5108c08:	e5933004 	ldr	r3, [r3, #4]
 5108c0c:	e3530001 	cmp	r3, #1
 5108c10:	1afffff5 	bne	5108bec <MPU_xQueueSelectFromSetImpl+0x2c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108c14:	e7940000 	ldr	r0, [r4, r0]
                    if( xInternalQueueSetHandle != NULL )
 5108c18:	e3500000 	cmp	r0, #0
 5108c1c:	0afffff2 	beq	5108bec <MPU_xQueueSelectFromSetImpl+0x2c>
                        xSelectedMemberInternal = xQueueSelectFromSet( xInternalQueueSetHandle, xBlockTimeTicks );
 5108c20:	e30236b8 	movw	r3, #9912	; 0x26b8
 5108c24:	e1a01005 	mov	r1, r5
 5108c28:	e3403510 	movt	r3, #1296	; 0x510
 5108c2c:	e12fff33 	blx	r3
                        if( xSelectedMemberInternal != NULL )
 5108c30:	e3500000 	cmp	r0, #0
 5108c34:	0affffec 	beq	5108bec <MPU_xQueueSelectFromSetImpl+0x2c>
 5108c38:	e1a03004 	mov	r3, r4
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 5108c3c:	e3a02000 	mov	r2, #0
 5108c40:	ea000003 	b	5108c54 <MPU_xQueueSelectFromSetImpl+0x94>
 5108c44:	e2822001 	add	r2, r2, #1
 5108c48:	e3520080 	cmp	r2, #128	; 0x80
 5108c4c:	e283300c 	add	r3, r3, #12
 5108c50:	0affffe5 	beq	5108bec <MPU_xQueueSelectFromSetImpl+0x2c>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 5108c54:	e5931000 	ldr	r1, [r3]
 5108c58:	e1500001 	cmp	r0, r1
 5108c5c:	1afffff8 	bne	5108c44 <MPU_xQueueSelectFromSetImpl+0x84>
 5108c60:	e5931004 	ldr	r1, [r3, #4]
 5108c64:	e3510001 	cmp	r1, #1
 5108c68:	1afffff5 	bne	5108c44 <MPU_xQueueSelectFromSetImpl+0x84>
                                xSelectedMemberExternal = ( QueueSetMemberHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lIndexSelectedMember ) );
 5108c6c:	e2820001 	add	r0, r2, #1
        }
 5108c70:	e8bd8070 	pop	{r4, r5, r6, pc}

05108c74 <MPU_uxTaskPriorityGetImpl>:
        {
 5108c74:	e92d4010 	push	{r4, lr}
            if( pxTask == NULL )
 5108c78:	e2504000 	subs	r4, r0, #0
 5108c7c:	0a000015 	beq	5108cd8 <MPU_uxTaskPriorityGetImpl+0x64>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108c80:	e2444001 	sub	r4, r4, #1
 5108c84:	e354007f 	cmp	r4, #127	; 0x7f
 5108c88:	9a000001 	bls	5108c94 <MPU_uxTaskPriorityGetImpl+0x20>
            UBaseType_t uxReturn = configMAX_PRIORITIES;
 5108c8c:	e3a00007 	mov	r0, #7
 5108c90:	e8bd8010 	pop	{r4, pc}
                    xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108c94:	e30c3928 	movw	r3, #51496	; 0xc928
 5108c98:	e1a00004 	mov	r0, r4
 5108c9c:	e3403510 	movt	r3, #1296	; 0x510
 5108ca0:	e12fff33 	blx	r3
                    if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5108ca4:	e3500001 	cmp	r0, #1
 5108ca8:	1afffff7 	bne	5108c8c <MPU_uxTaskPriorityGetImpl+0x18>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108cac:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108cb0:	e0844084 	add	r4, r4, r4, lsl #1
 5108cb4:	e3403512 	movt	r3, #1298	; 0x512
 5108cb8:	e0832104 	add	r2, r3, r4, lsl #2
 5108cbc:	e1a04104 	lsl	r4, r4, #2
 5108cc0:	e5922004 	ldr	r2, [r2, #4]
 5108cc4:	e3520002 	cmp	r2, #2
 5108cc8:	1affffef 	bne	5108c8c <MPU_uxTaskPriorityGetImpl+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108ccc:	e7930004 	ldr	r0, [r3, r4]
                        if( xInternalTaskHandle != NULL )
 5108cd0:	e3500000 	cmp	r0, #0
 5108cd4:	0affffec 	beq	5108c8c <MPU_uxTaskPriorityGetImpl+0x18>
                            uxReturn = uxTaskPriorityGet( xInternalTaskHandle );
 5108cd8:	e3043bc4 	movw	r3, #19396	; 0x4bc4
 5108cdc:	e3403510 	movt	r3, #1296	; 0x510
 5108ce0:	e12fff33 	blx	r3
        }
 5108ce4:	e8bd8010 	pop	{r4, pc}

05108ce8 <MPU_vTaskResumeImpl>:
        {
 5108ce8:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108cec:	e2404001 	sub	r4, r0, #1
 5108cf0:	e354007f 	cmp	r4, #127	; 0x7f
 5108cf4:	88bd8010 	pophi	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108cf8:	e30c3928 	movw	r3, #51496	; 0xc928
 5108cfc:	e1a00004 	mov	r0, r4
 5108d00:	e3403510 	movt	r3, #1296	; 0x510
 5108d04:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5108d08:	e3500001 	cmp	r0, #1
 5108d0c:	18bd8010 	popne	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108d10:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108d14:	e0844084 	add	r4, r4, r4, lsl #1
 5108d18:	e3403512 	movt	r3, #1298	; 0x512
 5108d1c:	e0832104 	add	r2, r3, r4, lsl #2
 5108d20:	e1a04104 	lsl	r4, r4, #2
 5108d24:	e5922004 	ldr	r2, [r2, #4]
 5108d28:	e3520002 	cmp	r2, #2
 5108d2c:	18bd8010 	popne	{r4, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108d30:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTaskHandle != NULL )
 5108d34:	e3500000 	cmp	r0, #0
 5108d38:	08bd8010 	popeq	{r4, pc}
                        vTaskResume( xInternalTaskHandle );
 5108d3c:	e3043eec 	movw	r3, #20204	; 0x4eec
 5108d40:	e3403510 	movt	r3, #1296	; 0x510
 5108d44:	e12fff33 	blx	r3
        }
 5108d48:	e8bd8010 	pop	{r4, pc}

05108d4c <MPU_vQueueUnregisterQueueImpl>:
        {
 5108d4c:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108d50:	e2404001 	sub	r4, r0, #1
 5108d54:	e354007f 	cmp	r4, #127	; 0x7f
 5108d58:	88bd8010 	pophi	{r4, pc}
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108d5c:	e30c3928 	movw	r3, #51496	; 0xc928
 5108d60:	e1a00004 	mov	r0, r4
 5108d64:	e3403510 	movt	r3, #1296	; 0x510
 5108d68:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5108d6c:	e3500001 	cmp	r0, #1
 5108d70:	18bd8010 	popne	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108d74:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108d78:	e0844084 	add	r4, r4, r4, lsl #1
 5108d7c:	e3403512 	movt	r3, #1298	; 0x512
 5108d80:	e0832104 	add	r2, r3, r4, lsl #2
 5108d84:	e1a04104 	lsl	r4, r4, #2
 5108d88:	e5922004 	ldr	r2, [r2, #4]
 5108d8c:	e3520001 	cmp	r2, #1
 5108d90:	18bd8010 	popne	{r4, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108d94:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalQueueHandle != NULL )
 5108d98:	e3500000 	cmp	r0, #0
 5108d9c:	08bd8010 	popeq	{r4, pc}
                        vQueueUnregisterQueue( xInternalQueueHandle );
 5108da0:	e30234b8 	movw	r3, #9400	; 0x24b8
 5108da4:	e3403510 	movt	r3, #1296	; 0x510
 5108da8:	e12fff33 	blx	r3
        }
 5108dac:	e8bd8010 	pop	{r4, pc}

05108db0 <MPU_xQueueGiveMutexRecursiveImpl>:
        {
 5108db0:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108db4:	e2404001 	sub	r4, r0, #1
 5108db8:	e354007f 	cmp	r4, #127	; 0x7f
 5108dbc:	9a000001 	bls	5108dc8 <MPU_xQueueGiveMutexRecursiveImpl+0x18>
            BaseType_t xReturn = pdFAIL;
 5108dc0:	e3a00000 	mov	r0, #0
 5108dc4:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108dc8:	e30c3928 	movw	r3, #51496	; 0xc928
 5108dcc:	e1a00004 	mov	r0, r4
 5108dd0:	e3403510 	movt	r3, #1296	; 0x510
 5108dd4:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5108dd8:	e3500001 	cmp	r0, #1
 5108ddc:	1afffff7 	bne	5108dc0 <MPU_xQueueGiveMutexRecursiveImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108de0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108de4:	e0844084 	add	r4, r4, r4, lsl #1
 5108de8:	e3403512 	movt	r3, #1298	; 0x512
 5108dec:	e0832104 	add	r2, r3, r4, lsl #2
 5108df0:	e1a04104 	lsl	r4, r4, #2
 5108df4:	e5922004 	ldr	r2, [r2, #4]
 5108df8:	e3520001 	cmp	r2, #1
 5108dfc:	1affffef 	bne	5108dc0 <MPU_xQueueGiveMutexRecursiveImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108e00:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalQueueHandle != NULL )
 5108e04:	e3500000 	cmp	r0, #0
 5108e08:	0affffec 	beq	5108dc0 <MPU_xQueueGiveMutexRecursiveImpl+0x10>
                        xReturn = xQueueGiveMutexRecursive( xInternalQueueHandle );
 5108e0c:	e3023380 	movw	r3, #9088	; 0x2380
 5108e10:	e3403510 	movt	r3, #1296	; 0x510
 5108e14:	e12fff33 	blx	r3
        }
 5108e18:	e8bd8010 	pop	{r4, pc}

05108e1c <MPU_vQueueAddToRegistryImpl>:
        {
 5108e1c:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108e20:	e2404001 	sub	r4, r0, #1
 5108e24:	e354007f 	cmp	r4, #127	; 0x7f
 5108e28:	88bd8070 	pophi	{r4, r5, r6, pc}
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108e2c:	e30c3928 	movw	r3, #51496	; 0xc928
 5108e30:	e1a00004 	mov	r0, r4
 5108e34:	e1a05001 	mov	r5, r1
 5108e38:	e3403510 	movt	r3, #1296	; 0x510
 5108e3c:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5108e40:	e3500001 	cmp	r0, #1
 5108e44:	18bd8070 	popne	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108e48:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108e4c:	e0844084 	add	r4, r4, r4, lsl #1
 5108e50:	e3403512 	movt	r3, #1298	; 0x512
 5108e54:	e0832104 	add	r2, r3, r4, lsl #2
 5108e58:	e1a04104 	lsl	r4, r4, #2
 5108e5c:	e5922004 	ldr	r2, [r2, #4]
 5108e60:	e3520001 	cmp	r2, #1
 5108e64:	18bd8070 	popne	{r4, r5, r6, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108e68:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalQueueHandle != NULL )
 5108e6c:	e3500000 	cmp	r0, #0
 5108e70:	08bd8070 	popeq	{r4, r5, r6, pc}
                        vQueueAddToRegistry( xInternalQueueHandle, pcName );
 5108e74:	e30233fc 	movw	r3, #9212	; 0x23fc
 5108e78:	e1a01005 	mov	r1, r5
 5108e7c:	e3403510 	movt	r3, #1296	; 0x510
 5108e80:	e12fff33 	blx	r3
        }
 5108e84:	e8bd8070 	pop	{r4, r5, r6, pc}

05108e88 <MPU_xTaskAbortDelayImpl>:
        {
 5108e88:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108e8c:	e2404001 	sub	r4, r0, #1
 5108e90:	e354007f 	cmp	r4, #127	; 0x7f
 5108e94:	9a000001 	bls	5108ea0 <MPU_xTaskAbortDelayImpl+0x18>
            BaseType_t xReturn = pdFAIL;
 5108e98:	e3a00000 	mov	r0, #0
 5108e9c:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108ea0:	e30c3928 	movw	r3, #51496	; 0xc928
 5108ea4:	e1a00004 	mov	r0, r4
 5108ea8:	e3403510 	movt	r3, #1296	; 0x510
 5108eac:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5108eb0:	e3500001 	cmp	r0, #1
 5108eb4:	1afffff7 	bne	5108e98 <MPU_xTaskAbortDelayImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108eb8:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108ebc:	e0844084 	add	r4, r4, r4, lsl #1
 5108ec0:	e3403512 	movt	r3, #1298	; 0x512
 5108ec4:	e0832104 	add	r2, r3, r4, lsl #2
 5108ec8:	e1a04104 	lsl	r4, r4, #2
 5108ecc:	e5922004 	ldr	r2, [r2, #4]
 5108ed0:	e3520002 	cmp	r2, #2
 5108ed4:	1affffef 	bne	5108e98 <MPU_xTaskAbortDelayImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108ed8:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTaskHandle != NULL )
 5108edc:	e3500000 	cmp	r0, #0
 5108ee0:	0affffec 	beq	5108e98 <MPU_xTaskAbortDelayImpl+0x10>
                        xReturn = xTaskAbortDelay( xInternalTaskHandle );
 5108ee4:	e3063268 	movw	r3, #25192	; 0x6268
 5108ee8:	e3403510 	movt	r3, #1296	; 0x510
 5108eec:	e12fff33 	blx	r3
        }
 5108ef0:	e8bd8010 	pop	{r4, pc}

05108ef4 <MPU_xStreamBufferNextMessageLengthBytesImpl>:
    #if ( configUSE_STREAM_BUFFERS == 1 )

        size_t MPU_xStreamBufferNextMessageLengthBytesImpl( StreamBufferHandle_t xStreamBuffer ) PRIVILEGED_FUNCTION;

        size_t MPU_xStreamBufferNextMessageLengthBytesImpl( StreamBufferHandle_t xStreamBuffer ) /* PRIVILEGED_FUNCTION */
        {
 5108ef4:	e92d4010 	push	{r4, lr}
            int32_t lIndex;
            BaseType_t xCallingTaskIsAuthorizedToAccessStreamBuffer = pdFALSE;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108ef8:	e2404001 	sub	r4, r0, #1
 5108efc:	e354007f 	cmp	r4, #127	; 0x7f
 5108f00:	9a000001 	bls	5108f0c <MPU_xStreamBufferNextMessageLengthBytesImpl+0x18>
            size_t xReturn = 0;
 5108f04:	e3a00000 	mov	r0, #0
 5108f08:	e8bd8010 	pop	{r4, pc}
            {
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108f0c:	e30c3928 	movw	r3, #51496	; 0xc928
 5108f10:	e1a00004 	mov	r0, r4
 5108f14:	e3403510 	movt	r3, #1296	; 0x510
 5108f18:	e12fff33 	blx	r3

                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5108f1c:	e3500001 	cmp	r0, #1
 5108f20:	1afffff7 	bne	5108f04 <MPU_xStreamBufferNextMessageLengthBytesImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108f24:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108f28:	e0844084 	add	r4, r4, r4, lsl #1
 5108f2c:	e3403512 	movt	r3, #1298	; 0x512
 5108f30:	e0832104 	add	r2, r3, r4, lsl #2
 5108f34:	e1a04104 	lsl	r4, r4, #2
 5108f38:	e5922004 	ldr	r2, [r2, #4]
 5108f3c:	e3520003 	cmp	r2, #3
 5108f40:	1affffef 	bne	5108f04 <MPU_xStreamBufferNextMessageLengthBytesImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108f44:	e7930004 	ldr	r0, [r3, r4]
                {
                    xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );

                    if( xInternalStreamBufferHandle != NULL )
 5108f48:	e3500000 	cmp	r0, #0
 5108f4c:	0affffec 	beq	5108f04 <MPU_xStreamBufferNextMessageLengthBytesImpl+0x10>
                    {
                        xReturn = xStreamBufferNextMessageLengthBytes( xInternalStreamBufferHandle );
 5108f50:	e3043014 	movw	r3, #16404	; 0x4014
 5108f54:	e3403510 	movt	r3, #1296	; 0x510
 5108f58:	e12fff33 	blx	r3
                    }
                }
            }

            return xReturn;
        }
 5108f5c:	e8bd8010 	pop	{r4, pc}

05108f60 <MPU_vTimerSetReloadModeImpl>:
        {
 5108f60:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108f64:	e2404001 	sub	r4, r0, #1
 5108f68:	e354007f 	cmp	r4, #127	; 0x7f
 5108f6c:	88bd8070 	pophi	{r4, r5, r6, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108f70:	e30c3928 	movw	r3, #51496	; 0xc928
 5108f74:	e1a00004 	mov	r0, r4
 5108f78:	e1a05001 	mov	r5, r1
 5108f7c:	e3403510 	movt	r3, #1296	; 0x510
 5108f80:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5108f84:	e3500001 	cmp	r0, #1
 5108f88:	18bd8070 	popne	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108f8c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5108f90:	e0844084 	add	r4, r4, r4, lsl #1
 5108f94:	e3403512 	movt	r3, #1298	; 0x512
 5108f98:	e0832104 	add	r2, r3, r4, lsl #2
 5108f9c:	e1a04104 	lsl	r4, r4, #2
 5108fa0:	e5922004 	ldr	r2, [r2, #4]
 5108fa4:	e3520005 	cmp	r2, #5
 5108fa8:	18bd8070 	popne	{r4, r5, r6, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5108fac:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5108fb0:	e3500000 	cmp	r0, #0
 5108fb4:	08bd8070 	popeq	{r4, r5, r6, pc}
                        vTimerSetReloadMode( xInternalTimerHandle, uxAutoReload );
 5108fb8:	e3073b6c 	movw	r3, #31596	; 0x7b6c
 5108fbc:	e1a01005 	mov	r1, r5
 5108fc0:	e3403510 	movt	r3, #1296	; 0x510
 5108fc4:	e12fff33 	blx	r3
        }
 5108fc8:	e8bd8070 	pop	{r4, r5, r6, pc}

05108fcc <MPU_xTimerGetReloadModeImpl>:
        {
 5108fcc:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5108fd0:	e2404001 	sub	r4, r0, #1
 5108fd4:	e354007f 	cmp	r4, #127	; 0x7f
 5108fd8:	9a000001 	bls	5108fe4 <MPU_xTimerGetReloadModeImpl+0x18>
            BaseType_t xReturn = pdFALSE;
 5108fdc:	e3a00000 	mov	r0, #0
 5108fe0:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5108fe4:	e30c3928 	movw	r3, #51496	; 0xc928
 5108fe8:	e1a00004 	mov	r0, r4
 5108fec:	e3403510 	movt	r3, #1296	; 0x510
 5108ff0:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5108ff4:	e3500001 	cmp	r0, #1
 5108ff8:	1afffff7 	bne	5108fdc <MPU_xTimerGetReloadModeImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5108ffc:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109000:	e0844084 	add	r4, r4, r4, lsl #1
 5109004:	e3403512 	movt	r3, #1298	; 0x512
 5109008:	e0832104 	add	r2, r3, r4, lsl #2
 510900c:	e1a04104 	lsl	r4, r4, #2
 5109010:	e5922004 	ldr	r2, [r2, #4]
 5109014:	e3520005 	cmp	r2, #5
 5109018:	1affffef 	bne	5108fdc <MPU_xTimerGetReloadModeImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510901c:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5109020:	e3500000 	cmp	r0, #0
 5109024:	0affffec 	beq	5108fdc <MPU_xTimerGetReloadModeImpl+0x10>
                        xReturn = xTimerGetReloadMode( xInternalTimerHandle );
 5109028:	e3073bc8 	movw	r3, #31688	; 0x7bc8
 510902c:	e3403510 	movt	r3, #1296	; 0x510
 5109030:	e12fff33 	blx	r3
        }
 5109034:	e8bd8010 	pop	{r4, pc}

05109038 <MPU_xStreamBufferBytesAvailableImpl>:
        {
 5109038:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510903c:	e2404001 	sub	r4, r0, #1
 5109040:	e354007f 	cmp	r4, #127	; 0x7f
 5109044:	9a000001 	bls	5109050 <MPU_xStreamBufferBytesAvailableImpl+0x18>
            size_t xReturn = 0;
 5109048:	e3a00000 	mov	r0, #0
 510904c:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109050:	e30c3928 	movw	r3, #51496	; 0xc928
 5109054:	e1a00004 	mov	r0, r4
 5109058:	e3403510 	movt	r3, #1296	; 0x510
 510905c:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5109060:	e3500001 	cmp	r0, #1
 5109064:	1afffff7 	bne	5109048 <MPU_xStreamBufferBytesAvailableImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109068:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510906c:	e0844084 	add	r4, r4, r4, lsl #1
 5109070:	e3403512 	movt	r3, #1298	; 0x512
 5109074:	e0832104 	add	r2, r3, r4, lsl #2
 5109078:	e1a04104 	lsl	r4, r4, #2
 510907c:	e5922004 	ldr	r2, [r2, #4]
 5109080:	e3520003 	cmp	r2, #3
 5109084:	1affffef 	bne	5109048 <MPU_xStreamBufferBytesAvailableImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109088:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalStreamBufferHandle != NULL )
 510908c:	e3500000 	cmp	r0, #0
 5109090:	0affffec 	beq	5109048 <MPU_xStreamBufferBytesAvailableImpl+0x10>
                        xReturn = xStreamBufferBytesAvailable( xInternalStreamBufferHandle );
 5109094:	e3033ac0 	movw	r3, #15040	; 0x3ac0
 5109098:	e3403510 	movt	r3, #1296	; 0x510
 510909c:	e12fff33 	blx	r3
        }
 51090a0:	e8bd8010 	pop	{r4, pc}

051090a4 <MPU_xStreamBufferIsFullImpl>:
        {
 51090a4:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51090a8:	e2404001 	sub	r4, r0, #1
 51090ac:	e354007f 	cmp	r4, #127	; 0x7f
 51090b0:	9a000001 	bls	51090bc <MPU_xStreamBufferIsFullImpl+0x18>
            BaseType_t xReturn = pdFALSE;
 51090b4:	e3a00000 	mov	r0, #0
 51090b8:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51090bc:	e30c3928 	movw	r3, #51496	; 0xc928
 51090c0:	e1a00004 	mov	r0, r4
 51090c4:	e3403510 	movt	r3, #1296	; 0x510
 51090c8:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 51090cc:	e3500001 	cmp	r0, #1
 51090d0:	1afffff7 	bne	51090b4 <MPU_xStreamBufferIsFullImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51090d4:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51090d8:	e0844084 	add	r4, r4, r4, lsl #1
 51090dc:	e3403512 	movt	r3, #1298	; 0x512
 51090e0:	e0832104 	add	r2, r3, r4, lsl #2
 51090e4:	e1a04104 	lsl	r4, r4, #2
 51090e8:	e5922004 	ldr	r2, [r2, #4]
 51090ec:	e3520003 	cmp	r2, #3
 51090f0:	1affffef 	bne	51090b4 <MPU_xStreamBufferIsFullImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51090f4:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalStreamBufferHandle != NULL )
 51090f8:	e3500000 	cmp	r0, #0
 51090fc:	0affffec 	beq	51090b4 <MPU_xStreamBufferIsFullImpl+0x10>
                        xReturn = xStreamBufferIsFull( xInternalStreamBufferHandle );
 5109100:	e3033814 	movw	r3, #14356	; 0x3814
 5109104:	e3403510 	movt	r3, #1296	; 0x510
 5109108:	e12fff33 	blx	r3
        }
 510910c:	e8bd8010 	pop	{r4, pc}

05109110 <MPU_xStreamBufferIsEmptyImpl>:
        {
 5109110:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109114:	e2404001 	sub	r4, r0, #1
 5109118:	e354007f 	cmp	r4, #127	; 0x7f
 510911c:	9a000001 	bls	5109128 <MPU_xStreamBufferIsEmptyImpl+0x18>
            BaseType_t xReturn = pdFALSE;
 5109120:	e3a00000 	mov	r0, #0
 5109124:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109128:	e30c3928 	movw	r3, #51496	; 0xc928
 510912c:	e1a00004 	mov	r0, r4
 5109130:	e3403510 	movt	r3, #1296	; 0x510
 5109134:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5109138:	e3500001 	cmp	r0, #1
 510913c:	1afffff7 	bne	5109120 <MPU_xStreamBufferIsEmptyImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109140:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109144:	e0844084 	add	r4, r4, r4, lsl #1
 5109148:	e3403512 	movt	r3, #1298	; 0x512
 510914c:	e0832104 	add	r2, r3, r4, lsl #2
 5109150:	e1a04104 	lsl	r4, r4, #2
 5109154:	e5922004 	ldr	r2, [r2, #4]
 5109158:	e3520003 	cmp	r2, #3
 510915c:	1affffef 	bne	5109120 <MPU_xStreamBufferIsEmptyImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109160:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalStreamBufferHandle != NULL )
 5109164:	e3500000 	cmp	r0, #0
 5109168:	0affffec 	beq	5109120 <MPU_xStreamBufferIsEmptyImpl+0x10>
                        xReturn = xStreamBufferIsEmpty( xInternalStreamBufferHandle );
 510916c:	e303388c 	movw	r3, #14476	; 0x388c
 5109170:	e3403510 	movt	r3, #1296	; 0x510
 5109174:	e12fff33 	blx	r3
        }
 5109178:	e8bd8010 	pop	{r4, pc}

0510917c <MPU_xStreamBufferSpacesAvailableImpl>:
        {
 510917c:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109180:	e2404001 	sub	r4, r0, #1
 5109184:	e354007f 	cmp	r4, #127	; 0x7f
 5109188:	9a000001 	bls	5109194 <MPU_xStreamBufferSpacesAvailableImpl+0x18>
            size_t xReturn = 0;
 510918c:	e3a00000 	mov	r0, #0
 5109190:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109194:	e30c3928 	movw	r3, #51496	; 0xc928
 5109198:	e1a00004 	mov	r0, r4
 510919c:	e3403510 	movt	r3, #1296	; 0x510
 51091a0:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 51091a4:	e3500001 	cmp	r0, #1
 51091a8:	1afffff7 	bne	510918c <MPU_xStreamBufferSpacesAvailableImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51091ac:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51091b0:	e0844084 	add	r4, r4, r4, lsl #1
 51091b4:	e3403512 	movt	r3, #1298	; 0x512
 51091b8:	e0832104 	add	r2, r3, r4, lsl #2
 51091bc:	e1a04104 	lsl	r4, r4, #2
 51091c0:	e5922004 	ldr	r2, [r2, #4]
 51091c4:	e3520003 	cmp	r2, #3
 51091c8:	1affffef 	bne	510918c <MPU_xStreamBufferSpacesAvailableImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51091cc:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalStreamBufferHandle != NULL )
 51091d0:	e3500000 	cmp	r0, #0
 51091d4:	0affffec 	beq	510918c <MPU_xStreamBufferSpacesAvailableImpl+0x10>
                        xReturn = xStreamBufferSpacesAvailable( xInternalStreamBufferHandle );
 51091d8:	e3033a64 	movw	r3, #14948	; 0x3a64
 51091dc:	e3403510 	movt	r3, #1296	; 0x510
 51091e0:	e12fff33 	blx	r3
        }
 51091e4:	e8bd8010 	pop	{r4, pc}

051091e8 <MPU_uxQueueMessagesWaitingImpl>:
    {
 51091e8:	e92d4010 	push	{r4, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51091ec:	e2404001 	sub	r4, r0, #1
 51091f0:	e354007f 	cmp	r4, #127	; 0x7f
 51091f4:	9a000001 	bls	5109200 <MPU_uxQueueMessagesWaitingImpl+0x18>
        UBaseType_t uxReturn = 0;
 51091f8:	e3a00000 	mov	r0, #0
 51091fc:	e8bd8010 	pop	{r4, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109200:	e30c3928 	movw	r3, #51496	; 0xc928
 5109204:	e1a00004 	mov	r0, r4
 5109208:	e3403510 	movt	r3, #1296	; 0x510
 510920c:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5109210:	e3500001 	cmp	r0, #1
 5109214:	1afffff7 	bne	51091f8 <MPU_uxQueueMessagesWaitingImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109218:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510921c:	e0844084 	add	r4, r4, r4, lsl #1
 5109220:	e3403512 	movt	r3, #1298	; 0x512
 5109224:	e0832104 	add	r2, r3, r4, lsl #2
 5109228:	e1a04104 	lsl	r4, r4, #2
 510922c:	e5922004 	ldr	r2, [r2, #4]
 5109230:	e3520001 	cmp	r2, #1
 5109234:	1affffef 	bne	51091f8 <MPU_uxQueueMessagesWaitingImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109238:	e7930004 	ldr	r0, [r3, r4]
                if( xInternalQueueHandle != NULL )
 510923c:	e3500000 	cmp	r0, #0
 5109240:	0affffec 	beq	51091f8 <MPU_uxQueueMessagesWaitingImpl+0x10>
                    uxReturn = uxQueueMessagesWaiting( xInternalQueueHandle );
 5109244:	e3013900 	movw	r3, #6400	; 0x1900
 5109248:	e3403510 	movt	r3, #1296	; 0x510
 510924c:	e12fff33 	blx	r3
    }
 5109250:	e8bd8010 	pop	{r4, pc}

05109254 <MPU_uxQueueSpacesAvailableImpl>:
    {
 5109254:	e92d4010 	push	{r4, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109258:	e2404001 	sub	r4, r0, #1
 510925c:	e354007f 	cmp	r4, #127	; 0x7f
 5109260:	9a000001 	bls	510926c <MPU_uxQueueSpacesAvailableImpl+0x18>
        UBaseType_t uxReturn = 0;
 5109264:	e3a00000 	mov	r0, #0
 5109268:	e8bd8010 	pop	{r4, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 510926c:	e30c3928 	movw	r3, #51496	; 0xc928
 5109270:	e1a00004 	mov	r0, r4
 5109274:	e3403510 	movt	r3, #1296	; 0x510
 5109278:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 510927c:	e3500001 	cmp	r0, #1
 5109280:	1afffff7 	bne	5109264 <MPU_uxQueueSpacesAvailableImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109284:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109288:	e0844084 	add	r4, r4, r4, lsl #1
 510928c:	e3403512 	movt	r3, #1298	; 0x512
 5109290:	e0832104 	add	r2, r3, r4, lsl #2
 5109294:	e1a04104 	lsl	r4, r4, #2
 5109298:	e5922004 	ldr	r2, [r2, #4]
 510929c:	e3520001 	cmp	r2, #1
 51092a0:	1affffef 	bne	5109264 <MPU_uxQueueSpacesAvailableImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51092a4:	e7930004 	ldr	r0, [r3, r4]
                if( xInternalQueueHandle != NULL )
 51092a8:	e3500000 	cmp	r0, #0
 51092ac:	0affffec 	beq	5109264 <MPU_uxQueueSpacesAvailableImpl+0x10>
                    uxReturn = uxQueueSpacesAvailable( xInternalQueueHandle );
 51092b0:	e3013958 	movw	r3, #6488	; 0x1958
 51092b4:	e3403510 	movt	r3, #1296	; 0x510
 51092b8:	e12fff33 	blx	r3
    }
 51092bc:	e8bd8010 	pop	{r4, pc}

051092c0 <MPU_uxTimerGetReloadModeImpl>:
        {
 51092c0:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51092c4:	e2404001 	sub	r4, r0, #1
 51092c8:	e354007f 	cmp	r4, #127	; 0x7f
 51092cc:	9a000001 	bls	51092d8 <MPU_uxTimerGetReloadModeImpl+0x18>
            UBaseType_t uxReturn = 0;
 51092d0:	e3a00000 	mov	r0, #0
 51092d4:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51092d8:	e30c3928 	movw	r3, #51496	; 0xc928
 51092dc:	e1a00004 	mov	r0, r4
 51092e0:	e3403510 	movt	r3, #1296	; 0x510
 51092e4:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 51092e8:	e3500001 	cmp	r0, #1
 51092ec:	1afffff7 	bne	51092d0 <MPU_uxTimerGetReloadModeImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51092f0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51092f4:	e0844084 	add	r4, r4, r4, lsl #1
 51092f8:	e3403512 	movt	r3, #1298	; 0x512
 51092fc:	e0832104 	add	r2, r3, r4, lsl #2
 5109300:	e1a04104 	lsl	r4, r4, #2
 5109304:	e5922004 	ldr	r2, [r2, #4]
 5109308:	e3520005 	cmp	r2, #5
 510930c:	1affffef 	bne	51092d0 <MPU_uxTimerGetReloadModeImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109310:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5109314:	e3500000 	cmp	r0, #0
 5109318:	0affffec 	beq	51092d0 <MPU_uxTimerGetReloadModeImpl+0x10>
                        uxReturn = uxTimerGetReloadMode( xInternalTimerHandle );
 510931c:	e3073c24 	movw	r3, #31780	; 0x7c24
 5109320:	e3403510 	movt	r3, #1296	; 0x510
 5109324:	e12fff33 	blx	r3
        }
 5109328:	e8bd8010 	pop	{r4, pc}

0510932c <MPU_xTimerGetPeriodImpl>:
        {
 510932c:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109330:	e2404001 	sub	r4, r0, #1
 5109334:	e354007f 	cmp	r4, #127	; 0x7f
 5109338:	9a000001 	bls	5109344 <MPU_xTimerGetPeriodImpl+0x18>
            TickType_t xReturn = 0;
 510933c:	e3a00000 	mov	r0, #0
 5109340:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109344:	e30c3928 	movw	r3, #51496	; 0xc928
 5109348:	e1a00004 	mov	r0, r4
 510934c:	e3403510 	movt	r3, #1296	; 0x510
 5109350:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5109354:	e3500001 	cmp	r0, #1
 5109358:	1afffff7 	bne	510933c <MPU_xTimerGetPeriodImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510935c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109360:	e0844084 	add	r4, r4, r4, lsl #1
 5109364:	e3403512 	movt	r3, #1298	; 0x512
 5109368:	e0832104 	add	r2, r3, r4, lsl #2
 510936c:	e1a04104 	lsl	r4, r4, #2
 5109370:	e5922004 	ldr	r2, [r2, #4]
 5109374:	e3520005 	cmp	r2, #5
 5109378:	1affffef 	bne	510933c <MPU_xTimerGetPeriodImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510937c:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5109380:	e3500000 	cmp	r0, #0
 5109384:	0affffec 	beq	510933c <MPU_xTimerGetPeriodImpl+0x10>
                        xReturn = xTimerGetPeriod( xInternalTimerHandle );
 5109388:	e3073c80 	movw	r3, #31872	; 0x7c80
 510938c:	e3403510 	movt	r3, #1296	; 0x510
 5109390:	e12fff33 	blx	r3
        }
 5109394:	e8bd8010 	pop	{r4, pc}

05109398 <MPU_xTimerGetExpiryTimeImpl>:
        {
 5109398:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510939c:	e2404001 	sub	r4, r0, #1
 51093a0:	e354007f 	cmp	r4, #127	; 0x7f
 51093a4:	9a000001 	bls	51093b0 <MPU_xTimerGetExpiryTimeImpl+0x18>
            TickType_t xReturn = 0;
 51093a8:	e3a00000 	mov	r0, #0
 51093ac:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51093b0:	e30c3928 	movw	r3, #51496	; 0xc928
 51093b4:	e1a00004 	mov	r0, r4
 51093b8:	e3403510 	movt	r3, #1296	; 0x510
 51093bc:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 51093c0:	e3500001 	cmp	r0, #1
 51093c4:	1afffff7 	bne	51093a8 <MPU_xTimerGetExpiryTimeImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51093c8:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51093cc:	e0844084 	add	r4, r4, r4, lsl #1
 51093d0:	e3403512 	movt	r3, #1298	; 0x512
 51093d4:	e0832104 	add	r2, r3, r4, lsl #2
 51093d8:	e1a04104 	lsl	r4, r4, #2
 51093dc:	e5922004 	ldr	r2, [r2, #4]
 51093e0:	e3520005 	cmp	r2, #5
 51093e4:	1affffef 	bne	51093a8 <MPU_xTimerGetExpiryTimeImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51093e8:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 51093ec:	e3500000 	cmp	r0, #0
 51093f0:	0affffec 	beq	51093a8 <MPU_xTimerGetExpiryTimeImpl+0x10>
                        xReturn = xTimerGetExpiryTime( xInternalTimerHandle );
 51093f4:	e3073cb4 	movw	r3, #31924	; 0x7cb4
 51093f8:	e3403510 	movt	r3, #1296	; 0x510
 51093fc:	e12fff33 	blx	r3
        }
 5109400:	e8bd8010 	pop	{r4, pc}

05109404 <MPU_vTimerSetTimerIDImpl>:
        {
 5109404:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109408:	e2404001 	sub	r4, r0, #1
 510940c:	e354007f 	cmp	r4, #127	; 0x7f
 5109410:	88bd8070 	pophi	{r4, r5, r6, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109414:	e30c3928 	movw	r3, #51496	; 0xc928
 5109418:	e1a00004 	mov	r0, r4
 510941c:	e1a05001 	mov	r5, r1
 5109420:	e3403510 	movt	r3, #1296	; 0x510
 5109424:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5109428:	e3500001 	cmp	r0, #1
 510942c:	18bd8070 	popne	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109430:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109434:	e0844084 	add	r4, r4, r4, lsl #1
 5109438:	e3403512 	movt	r3, #1298	; 0x512
 510943c:	e0832104 	add	r2, r3, r4, lsl #2
 5109440:	e1a04104 	lsl	r4, r4, #2
 5109444:	e5922004 	ldr	r2, [r2, #4]
 5109448:	e3520005 	cmp	r2, #5
 510944c:	18bd8070 	popne	{r4, r5, r6, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109450:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 5109454:	e3500000 	cmp	r0, #0
 5109458:	08bd8070 	popeq	{r4, r5, r6, pc}
                        vTimerSetTimerID( xInternalTimerHandle, pvNewID );
 510945c:	e3073988 	movw	r3, #31112	; 0x7988
 5109460:	e1a01005 	mov	r1, r5
 5109464:	e3403510 	movt	r3, #1296	; 0x510
 5109468:	e12fff33 	blx	r3
        }
 510946c:	e8bd8070 	pop	{r4, r5, r6, pc}

05109470 <MPU_xTimerIsTimerActiveImpl>:
        {
 5109470:	e92d4010 	push	{r4, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109474:	e2404001 	sub	r4, r0, #1
 5109478:	e354007f 	cmp	r4, #127	; 0x7f
 510947c:	9a000001 	bls	5109488 <MPU_xTimerIsTimerActiveImpl+0x18>
            BaseType_t xReturn = pdFALSE;
 5109480:	e3a00000 	mov	r0, #0
 5109484:	e8bd8010 	pop	{r4, pc}
                xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109488:	e30c3928 	movw	r3, #51496	; 0xc928
 510948c:	e1a00004 	mov	r0, r4
 5109490:	e3403510 	movt	r3, #1296	; 0x510
 5109494:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 5109498:	e3500001 	cmp	r0, #1
 510949c:	1afffff7 	bne	5109480 <MPU_xTimerIsTimerActiveImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51094a0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51094a4:	e0844084 	add	r4, r4, r4, lsl #1
 51094a8:	e3403512 	movt	r3, #1298	; 0x512
 51094ac:	e0832104 	add	r2, r3, r4, lsl #2
 51094b0:	e1a04104 	lsl	r4, r4, #2
 51094b4:	e5922004 	ldr	r2, [r2, #4]
 51094b8:	e3520005 	cmp	r2, #5
 51094bc:	1affffef 	bne	5109480 <MPU_xTimerIsTimerActiveImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51094c0:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalTimerHandle != NULL )
 51094c4:	e3500000 	cmp	r0, #0
 51094c8:	0affffec 	beq	5109480 <MPU_xTimerIsTimerActiveImpl+0x10>
                        xReturn = xTimerIsTimerActive( xInternalTimerHandle );
 51094cc:	e30739d4 	movw	r3, #31188	; 0x79d4
 51094d0:	e3403510 	movt	r3, #1296	; 0x510
 51094d4:	e12fff33 	blx	r3
        }
 51094d8:	e8bd8010 	pop	{r4, pc}

051094dc <MPU_xStreamBufferSetTriggerLevelImpl>:
        {
 51094dc:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51094e0:	e2404001 	sub	r4, r0, #1
 51094e4:	e354007f 	cmp	r4, #127	; 0x7f
 51094e8:	9a000001 	bls	51094f4 <MPU_xStreamBufferSetTriggerLevelImpl+0x18>
            BaseType_t xReturn = pdFALSE;
 51094ec:	e3a00000 	mov	r0, #0
 51094f0:	e8bd8070 	pop	{r4, r5, r6, pc}
                xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 51094f4:	e30c3928 	movw	r3, #51496	; 0xc928
 51094f8:	e1a00004 	mov	r0, r4
 51094fc:	e1a05001 	mov	r5, r1
 5109500:	e3403510 	movt	r3, #1296	; 0x510
 5109504:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5109508:	e3500001 	cmp	r0, #1
 510950c:	1afffff6 	bne	51094ec <MPU_xStreamBufferSetTriggerLevelImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109510:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109514:	e0844084 	add	r4, r4, r4, lsl #1
 5109518:	e3403512 	movt	r3, #1298	; 0x512
 510951c:	e0832104 	add	r2, r3, r4, lsl #2
 5109520:	e1a04104 	lsl	r4, r4, #2
 5109524:	e5922004 	ldr	r2, [r2, #4]
 5109528:	e3520003 	cmp	r2, #3
 510952c:	1affffee 	bne	51094ec <MPU_xStreamBufferSetTriggerLevelImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109530:	e7930004 	ldr	r0, [r3, r4]
                    if( xInternalStreamBufferHandle != NULL )
 5109534:	e3500000 	cmp	r0, #0
 5109538:	0affffeb 	beq	51094ec <MPU_xStreamBufferSetTriggerLevelImpl+0x10>
                        xReturn = xStreamBufferSetTriggerLevel( xInternalStreamBufferHandle, xTriggerLevel );
 510953c:	e3033b08 	movw	r3, #15112	; 0x3b08
 5109540:	e1a01005 	mov	r1, r5
 5109544:	e3403510 	movt	r3, #1296	; 0x510
 5109548:	e12fff33 	blx	r3
        }
 510954c:	e8bd8070 	pop	{r4, r5, r6, pc}

05109550 <MPU_xQueueTakeMutexRecursiveImpl>:
        {
 5109550:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109554:	e2404001 	sub	r4, r0, #1
 5109558:	e354007f 	cmp	r4, #127	; 0x7f
 510955c:	9a000001 	bls	5109568 <MPU_xQueueTakeMutexRecursiveImpl+0x18>
            BaseType_t xReturn = pdFAIL;
 5109560:	e3a00000 	mov	r0, #0
 5109564:	e8bd8070 	pop	{r4, r5, r6, pc}
                xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109568:	e30c3928 	movw	r3, #51496	; 0xc928
 510956c:	e1a00004 	mov	r0, r4
 5109570:	e1a05001 	mov	r5, r1
 5109574:	e3403510 	movt	r3, #1296	; 0x510
 5109578:	e12fff33 	blx	r3
                if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 510957c:	e3500001 	cmp	r0, #1
 5109580:	1afffff6 	bne	5109560 <MPU_xQueueTakeMutexRecursiveImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109584:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109588:	e0844084 	add	r4, r4, r4, lsl #1
 510958c:	e3403512 	movt	r3, #1298	; 0x512
 5109590:	e0832104 	add	r2, r3, r4, lsl #2
 5109594:	e1a04104 	lsl	r4, r4, #2
 5109598:	e5922004 	ldr	r2, [r2, #4]
 510959c:	e3520001 	cmp	r2, #1
 51095a0:	1affffee 	bne	5109560 <MPU_xQueueTakeMutexRecursiveImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51095a4:	e7934004 	ldr	r4, [r3, r4]
                    if( xInternalQueueHandle != NULL )
 51095a8:	e3540000 	cmp	r4, #0
 51095ac:	0affffeb 	beq	5109560 <MPU_xQueueTakeMutexRecursiveImpl+0x10>
                        uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 51095b0:	e3023d30 	movw	r3, #11568	; 0x2d30
 51095b4:	e1a00004 	mov	r0, r4
 51095b8:	e3403510 	movt	r3, #1296	; 0x510
 51095bc:	e12fff33 	blx	r3
                        if( uxQueueItemSize == 0 )
 51095c0:	e3500000 	cmp	r0, #0
 51095c4:	1affffe5 	bne	5109560 <MPU_xQueueTakeMutexRecursiveImpl+0x10>
                            xReturn = xQueueTakeMutexRecursive( xInternalQueueHandle, xBlockTime );
 51095c8:	e3023308 	movw	r3, #8968	; 0x2308
 51095cc:	e1a01005 	mov	r1, r5
 51095d0:	e1a00004 	mov	r0, r4
 51095d4:	e3403510 	movt	r3, #1296	; 0x510
 51095d8:	e12fff33 	blx	r3
        }
 51095dc:	e8bd8070 	pop	{r4, r5, r6, pc}

051095e0 <MPU_uxTaskGetStackHighWaterMarkImpl>:
        {
 51095e0:	e92d4010 	push	{r4, lr}
            if( xTask == NULL )
 51095e4:	e2504000 	subs	r4, r0, #0
 51095e8:	0a000015 	beq	5109644 <MPU_uxTaskGetStackHighWaterMarkImpl+0x64>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51095ec:	e2444001 	sub	r4, r4, #1
 51095f0:	e354007f 	cmp	r4, #127	; 0x7f
 51095f4:	9a000001 	bls	5109600 <MPU_uxTaskGetStackHighWaterMarkImpl+0x20>
            UBaseType_t uxReturn = 0;
 51095f8:	e3a00000 	mov	r0, #0
 51095fc:	e8bd8010 	pop	{r4, pc}
                    xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109600:	e30c3928 	movw	r3, #51496	; 0xc928
 5109604:	e1a00004 	mov	r0, r4
 5109608:	e3403510 	movt	r3, #1296	; 0x510
 510960c:	e12fff33 	blx	r3
                    if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5109610:	e3500001 	cmp	r0, #1
 5109614:	1afffff7 	bne	51095f8 <MPU_uxTaskGetStackHighWaterMarkImpl+0x18>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109618:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510961c:	e0844084 	add	r4, r4, r4, lsl #1
 5109620:	e3403512 	movt	r3, #1298	; 0x512
 5109624:	e0832104 	add	r2, r3, r4, lsl #2
 5109628:	e1a04104 	lsl	r4, r4, #2
 510962c:	e5922004 	ldr	r2, [r2, #4]
 5109630:	e3520002 	cmp	r2, #2
 5109634:	1affffef 	bne	51095f8 <MPU_uxTaskGetStackHighWaterMarkImpl+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109638:	e7930004 	ldr	r0, [r3, r4]
                        if( xInternalTaskHandle != NULL )
 510963c:	e3500000 	cmp	r0, #0
 5109640:	0affffec 	beq	51095f8 <MPU_uxTaskGetStackHighWaterMarkImpl+0x18>
                            uxReturn = uxTaskGetStackHighWaterMark( xInternalTaskHandle );
 5109644:	e30533d0 	movw	r3, #21456	; 0x53d0
 5109648:	e3403510 	movt	r3, #1296	; 0x510
 510964c:	e12fff33 	blx	r3
        }
 5109650:	e8bd8010 	pop	{r4, pc}

05109654 <MPU_xQueueSemaphoreTakeImpl>:
    {
 5109654:	e92d4070 	push	{r4, r5, r6, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109658:	e2404001 	sub	r4, r0, #1
 510965c:	e354007f 	cmp	r4, #127	; 0x7f
 5109660:	9a000001 	bls	510966c <MPU_xQueueSemaphoreTakeImpl+0x18>
        BaseType_t xReturn = pdFAIL;
 5109664:	e3a00000 	mov	r0, #0
 5109668:	e8bd8070 	pop	{r4, r5, r6, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 510966c:	e30c3928 	movw	r3, #51496	; 0xc928
 5109670:	e1a00004 	mov	r0, r4
 5109674:	e1a05001 	mov	r5, r1
 5109678:	e3403510 	movt	r3, #1296	; 0x510
 510967c:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5109680:	e3500001 	cmp	r0, #1
 5109684:	1afffff6 	bne	5109664 <MPU_xQueueSemaphoreTakeImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109688:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510968c:	e0844084 	add	r4, r4, r4, lsl #1
 5109690:	e3403512 	movt	r3, #1298	; 0x512
 5109694:	e0832104 	add	r2, r3, r4, lsl #2
 5109698:	e1a04104 	lsl	r4, r4, #2
 510969c:	e5922004 	ldr	r2, [r2, #4]
 51096a0:	e3520001 	cmp	r2, #1
 51096a4:	1affffee 	bne	5109664 <MPU_xQueueSemaphoreTakeImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51096a8:	e7934004 	ldr	r4, [r3, r4]
                if( xInternalQueueHandle != NULL )
 51096ac:	e3540000 	cmp	r4, #0
 51096b0:	0affffeb 	beq	5109664 <MPU_xQueueSemaphoreTakeImpl+0x10>
                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 51096b4:	e3023d30 	movw	r3, #11568	; 0x2d30
 51096b8:	e1a00004 	mov	r0, r4
 51096bc:	e3403510 	movt	r3, #1296	; 0x510
 51096c0:	e12fff33 	blx	r3
                    if( ( uxQueueItemSize == 0U )
 51096c4:	e3500000 	cmp	r0, #0
 51096c8:	1affffe5 	bne	5109664 <MPU_xQueueSemaphoreTakeImpl+0x10>
                            && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0U ) ) )
 51096cc:	e3063e28 	movw	r3, #28200	; 0x6e28
 51096d0:	e3403510 	movt	r3, #1296	; 0x510
 51096d4:	e12fff33 	blx	r3
 51096d8:	e2503000 	subs	r3, r0, #0
 51096dc:	13a03001 	movne	r3, #1
 51096e0:	e3550000 	cmp	r5, #0
 51096e4:	03833001 	orreq	r3, r3, #1
 51096e8:	e3530000 	cmp	r3, #0
 51096ec:	0affffdc 	beq	5109664 <MPU_xQueueSemaphoreTakeImpl+0x10>
                        xReturn = xQueueSemaphoreTake( xInternalQueueHandle, xTicksToWait );
 51096f0:	e3013f74 	movw	r3, #8052	; 0x1f74
 51096f4:	e1a01005 	mov	r1, r5
 51096f8:	e1a00004 	mov	r0, r4
 51096fc:	e3403510 	movt	r3, #1296	; 0x510
 5109700:	e12fff33 	blx	r3
    }
 5109704:	e8bd8070 	pop	{r4, r5, r6, pc}

05109708 <MPU_xQueuePeekImpl>:
    {
 5109708:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510970c:	e2404001 	sub	r4, r0, #1
 5109710:	e354007f 	cmp	r4, #127	; 0x7f
 5109714:	9a000001 	bls	5109720 <MPU_xQueuePeekImpl+0x18>
        BaseType_t xReturn = pdFAIL;
 5109718:	e3a00000 	mov	r0, #0
 510971c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109720:	e30c3928 	movw	r3, #51496	; 0xc928
 5109724:	e1a00004 	mov	r0, r4
 5109728:	e1a06001 	mov	r6, r1
 510972c:	e3403510 	movt	r3, #1296	; 0x510
 5109730:	e1a05002 	mov	r5, r2
 5109734:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5109738:	e3500001 	cmp	r0, #1
 510973c:	1afffff5 	bne	5109718 <MPU_xQueuePeekImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109740:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109744:	e0844084 	add	r4, r4, r4, lsl #1
 5109748:	e3403512 	movt	r3, #1298	; 0x512
 510974c:	e1a01104 	lsl	r1, r4, #2
 5109750:	e0834104 	add	r4, r3, r4, lsl #2
 5109754:	e5942004 	ldr	r2, [r4, #4]
 5109758:	e3520001 	cmp	r2, #1
 510975c:	1affffed 	bne	5109718 <MPU_xQueuePeekImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109760:	e7937001 	ldr	r7, [r3, r1]
                if( xInternalQueueHandle != NULL )
 5109764:	e3570000 	cmp	r7, #0
 5109768:	0affffea 	beq	5109718 <MPU_xQueuePeekImpl+0x10>
                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 510976c:	e3023d30 	movw	r3, #11568	; 0x2d30
 5109770:	e1a00007 	mov	r0, r7
 5109774:	e3403510 	movt	r3, #1296	; 0x510
 5109778:	e12fff33 	blx	r3
                    if( ( !( ( ( pvBuffer ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) )
 510977c:	e1a04000 	mov	r4, r0
 5109780:	e16f3f10 	clz	r3, r0
 5109784:	e1a032a3 	lsr	r3, r3, #5
 5109788:	e3560000 	cmp	r6, #0
 510978c:	13833001 	orrne	r3, r3, #1
 5109790:	e3530000 	cmp	r3, #0
 5109794:	0affffdf 	beq	5109718 <MPU_xQueuePeekImpl+0x10>
                            && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0U ) ) )
 5109798:	e3063e28 	movw	r3, #28200	; 0x6e28
 510979c:	e3403510 	movt	r3, #1296	; 0x510
 51097a0:	e12fff33 	blx	r3
 51097a4:	e2503000 	subs	r3, r0, #0
 51097a8:	13a03001 	movne	r3, #1
 51097ac:	e3550000 	cmp	r5, #0
 51097b0:	03833001 	orreq	r3, r3, #1
 51097b4:	e3530000 	cmp	r3, #0
 51097b8:	0affffd6 	beq	5109718 <MPU_xQueuePeekImpl+0x10>
                        xIsReceiveBufferWritable = xPortIsAuthorizedToAccessBuffer( pvBuffer,
 51097bc:	e30c3824 	movw	r3, #51236	; 0xc824
 51097c0:	e3a02002 	mov	r2, #2
 51097c4:	e1a01004 	mov	r1, r4
 51097c8:	e3403510 	movt	r3, #1296	; 0x510
 51097cc:	e1a00006 	mov	r0, r6
 51097d0:	e12fff33 	blx	r3
                        if( xIsReceiveBufferWritable == pdTRUE )
 51097d4:	e3500001 	cmp	r0, #1
 51097d8:	1affffce 	bne	5109718 <MPU_xQueuePeekImpl+0x10>
                            xReturn = xQueuePeek( xInternalQueueHandle, pvBuffer, xTicksToWait );
 51097dc:	e301330c 	movw	r3, #4876	; 0x130c
 51097e0:	e1a02005 	mov	r2, r5
 51097e4:	e1a01006 	mov	r1, r6
 51097e8:	e1a00007 	mov	r0, r7
 51097ec:	e3403510 	movt	r3, #1296	; 0x510
 51097f0:	e12fff33 	blx	r3
    }
 51097f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

051097f8 <MPU_xQueueReceiveImpl>:
    {
 51097f8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51097fc:	e2404001 	sub	r4, r0, #1
 5109800:	e354007f 	cmp	r4, #127	; 0x7f
 5109804:	9a000001 	bls	5109810 <MPU_xQueueReceiveImpl+0x18>
        BaseType_t xReturn = pdFAIL;
 5109808:	e3a00000 	mov	r0, #0
 510980c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109810:	e30c3928 	movw	r3, #51496	; 0xc928
 5109814:	e1a00004 	mov	r0, r4
 5109818:	e1a06001 	mov	r6, r1
 510981c:	e3403510 	movt	r3, #1296	; 0x510
 5109820:	e1a05002 	mov	r5, r2
 5109824:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5109828:	e3500001 	cmp	r0, #1
 510982c:	1afffff5 	bne	5109808 <MPU_xQueueReceiveImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109830:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109834:	e0844084 	add	r4, r4, r4, lsl #1
 5109838:	e3403512 	movt	r3, #1298	; 0x512
 510983c:	e1a01104 	lsl	r1, r4, #2
 5109840:	e0834104 	add	r4, r3, r4, lsl #2
 5109844:	e5942004 	ldr	r2, [r4, #4]
 5109848:	e3520001 	cmp	r2, #1
 510984c:	1affffed 	bne	5109808 <MPU_xQueueReceiveImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109850:	e7937001 	ldr	r7, [r3, r1]
                if( xInternalQueueHandle != NULL )
 5109854:	e3570000 	cmp	r7, #0
 5109858:	0affffea 	beq	5109808 <MPU_xQueueReceiveImpl+0x10>
                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 510985c:	e3023d30 	movw	r3, #11568	; 0x2d30
 5109860:	e1a00007 	mov	r0, r7
 5109864:	e3403510 	movt	r3, #1296	; 0x510
 5109868:	e12fff33 	blx	r3
                    if( ( !( ( ( pvBuffer ) == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) )
 510986c:	e1a04000 	mov	r4, r0
 5109870:	e16f3f10 	clz	r3, r0
 5109874:	e1a032a3 	lsr	r3, r3, #5
 5109878:	e3560000 	cmp	r6, #0
 510987c:	13833001 	orrne	r3, r3, #1
 5109880:	e3530000 	cmp	r3, #0
 5109884:	0affffdf 	beq	5109808 <MPU_xQueueReceiveImpl+0x10>
                            && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0U ) ) )
 5109888:	e3063e28 	movw	r3, #28200	; 0x6e28
 510988c:	e3403510 	movt	r3, #1296	; 0x510
 5109890:	e12fff33 	blx	r3
 5109894:	e2503000 	subs	r3, r0, #0
 5109898:	13a03001 	movne	r3, #1
 510989c:	e3550000 	cmp	r5, #0
 51098a0:	03833001 	orreq	r3, r3, #1
 51098a4:	e3530000 	cmp	r3, #0
 51098a8:	0affffd6 	beq	5109808 <MPU_xQueueReceiveImpl+0x10>
                        xIsReceiveBufferWritable = xPortIsAuthorizedToAccessBuffer( pvBuffer,
 51098ac:	e30c3824 	movw	r3, #51236	; 0xc824
 51098b0:	e3a02002 	mov	r2, #2
 51098b4:	e1a01004 	mov	r1, r4
 51098b8:	e3403510 	movt	r3, #1296	; 0x510
 51098bc:	e1a00006 	mov	r0, r6
 51098c0:	e12fff33 	blx	r3
                        if( xIsReceiveBufferWritable == pdTRUE )
 51098c4:	e3500001 	cmp	r0, #1
 51098c8:	1affffce 	bne	5109808 <MPU_xQueueReceiveImpl+0x10>
                            xReturn = xQueueReceive( xInternalQueueHandle, pvBuffer, xTicksToWait );
 51098cc:	e3013674 	movw	r3, #5748	; 0x1674
 51098d0:	e1a02005 	mov	r2, r5
 51098d4:	e1a01006 	mov	r1, r6
 51098d8:	e1a00007 	mov	r0, r7
 51098dc:	e3403510 	movt	r3, #1296	; 0x510
 51098e0:	e12fff33 	blx	r3
    }
 51098e4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

051098e8 <MPU_xEventGroupClearBitsImpl>:
            if( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0U )
 51098e8:	e31104ff 	tst	r1, #-16777216	; 0xff000000
 51098ec:	1a000005 	bne	5109908 <MPU_xEventGroupClearBitsImpl+0x20>
        {
 51098f0:	e92d4070 	push	{r4, r5, r6, lr}
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51098f4:	e2404001 	sub	r4, r0, #1
 51098f8:	e354007f 	cmp	r4, #127	; 0x7f
 51098fc:	9a000003 	bls	5109910 <MPU_xEventGroupClearBitsImpl+0x28>
            EventBits_t xReturn = 0;
 5109900:	e3a00000 	mov	r0, #0
 5109904:	e8bd8070 	pop	{r4, r5, r6, pc}
 5109908:	e3a00000 	mov	r0, #0
        }
 510990c:	e12fff1e 	bx	lr
                    xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109910:	e30c3928 	movw	r3, #51496	; 0xc928
 5109914:	e1a00004 	mov	r0, r4
 5109918:	e1a05001 	mov	r5, r1
 510991c:	e3403510 	movt	r3, #1296	; 0x510
 5109920:	e12fff33 	blx	r3
                    if( xCallingTaskIsAuthorizedToAccessEventGroup == pdTRUE )
 5109924:	e3500001 	cmp	r0, #1
 5109928:	1afffff4 	bne	5109900 <MPU_xEventGroupClearBitsImpl+0x18>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510992c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109930:	e0840084 	add	r0, r4, r4, lsl #1
 5109934:	e3403512 	movt	r3, #1298	; 0x512
 5109938:	e0832100 	add	r2, r3, r0, lsl #2
 510993c:	e1a00100 	lsl	r0, r0, #2
 5109940:	e5922004 	ldr	r2, [r2, #4]
 5109944:	e3520004 	cmp	r2, #4
 5109948:	1affffec 	bne	5109900 <MPU_xEventGroupClearBitsImpl+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510994c:	e7930000 	ldr	r0, [r3, r0]
                        if( xInternalEventGroupHandle != NULL )
 5109950:	e3500000 	cmp	r0, #0
 5109954:	0affffe9 	beq	5109900 <MPU_xEventGroupClearBitsImpl+0x18>
                            xReturn = xEventGroupClearBits( xInternalEventGroupHandle, uxBitsToClear );
 5109958:	e30036f8 	movw	r3, #1784	; 0x6f8
 510995c:	e1a01005 	mov	r1, r5
 5109960:	e3403510 	movt	r3, #1296	; 0x510
 5109964:	e12fff33 	blx	r3
        }
 5109968:	e8bd8070 	pop	{r4, r5, r6, pc}

0510996c <MPU_xEventGroupSetBitsImpl>:
            if( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0U )
 510996c:	e31104ff 	tst	r1, #-16777216	; 0xff000000
 5109970:	1a000005 	bne	510998c <MPU_xEventGroupSetBitsImpl+0x20>
        {
 5109974:	e92d4070 	push	{r4, r5, r6, lr}
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109978:	e2404001 	sub	r4, r0, #1
 510997c:	e354007f 	cmp	r4, #127	; 0x7f
 5109980:	9a000003 	bls	5109994 <MPU_xEventGroupSetBitsImpl+0x28>
            EventBits_t xReturn = 0;
 5109984:	e3a00000 	mov	r0, #0
 5109988:	e8bd8070 	pop	{r4, r5, r6, pc}
 510998c:	e3a00000 	mov	r0, #0
        }
 5109990:	e12fff1e 	bx	lr
                    xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109994:	e30c3928 	movw	r3, #51496	; 0xc928
 5109998:	e1a00004 	mov	r0, r4
 510999c:	e1a05001 	mov	r5, r1
 51099a0:	e3403510 	movt	r3, #1296	; 0x510
 51099a4:	e12fff33 	blx	r3
                    if( xCallingTaskIsAuthorizedToAccessEventGroup == pdTRUE )
 51099a8:	e3500001 	cmp	r0, #1
 51099ac:	1afffff4 	bne	5109984 <MPU_xEventGroupSetBitsImpl+0x18>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 51099b0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 51099b4:	e0840084 	add	r0, r4, r4, lsl #1
 51099b8:	e3403512 	movt	r3, #1298	; 0x512
 51099bc:	e0832100 	add	r2, r3, r0, lsl #2
 51099c0:	e1a00100 	lsl	r0, r0, #2
 51099c4:	e5922004 	ldr	r2, [r2, #4]
 51099c8:	e3520004 	cmp	r2, #4
 51099cc:	1affffec 	bne	5109984 <MPU_xEventGroupSetBitsImpl+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 51099d0:	e7930000 	ldr	r0, [r3, r0]
                        if( xInternalEventGroupHandle != NULL )
 51099d4:	e3500000 	cmp	r0, #0
 51099d8:	0affffe9 	beq	5109984 <MPU_xEventGroupSetBitsImpl+0x18>
                            xReturn = xEventGroupSetBits( xInternalEventGroupHandle, uxBitsToSet );
 51099dc:	e3003774 	movw	r3, #1908	; 0x774
 51099e0:	e1a01005 	mov	r1, r5
 51099e4:	e3403510 	movt	r3, #1296	; 0x510
 51099e8:	e12fff33 	blx	r3
        }
 51099ec:	e8bd8070 	pop	{r4, r5, r6, pc}

051099f0 <MPU_xQueueGenericSendImpl>:
    {
 51099f0:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 51099f4:	e2404001 	sub	r4, r0, #1
 51099f8:	e354007f 	cmp	r4, #127	; 0x7f
 51099fc:	9a000001 	bls	5109a08 <MPU_xQueueGenericSendImpl+0x18>
        BaseType_t xReturn = pdFAIL;
 5109a00:	e3a00000 	mov	r0, #0
 5109a04:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            xCallingTaskIsAuthorizedToAccessQueue = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109a08:	e1a05003 	mov	r5, r3
 5109a0c:	e30c3928 	movw	r3, #51496	; 0xc928
 5109a10:	e1a00004 	mov	r0, r4
 5109a14:	e3403510 	movt	r3, #1296	; 0x510
 5109a18:	e1a07001 	mov	r7, r1
 5109a1c:	e1a06002 	mov	r6, r2
 5109a20:	e12fff33 	blx	r3
            if( xCallingTaskIsAuthorizedToAccessQueue == pdTRUE )
 5109a24:	e3500001 	cmp	r0, #1
 5109a28:	1afffff4 	bne	5109a00 <MPU_xQueueGenericSendImpl+0x10>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109a2c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109a30:	e0844084 	add	r4, r4, r4, lsl #1
 5109a34:	e3403512 	movt	r3, #1298	; 0x512
 5109a38:	e0832104 	add	r2, r3, r4, lsl #2
 5109a3c:	e1a04104 	lsl	r4, r4, #2
 5109a40:	e5929004 	ldr	r9, [r2, #4]
 5109a44:	e3590001 	cmp	r9, #1
 5109a48:	1affffec 	bne	5109a00 <MPU_xQueueGenericSendImpl+0x10>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109a4c:	e7934004 	ldr	r4, [r3, r4]
                if( xInternalQueueHandle != NULL )
 5109a50:	e3540000 	cmp	r4, #0
 5109a54:	0affffe9 	beq	5109a00 <MPU_xQueueGenericSendImpl+0x10>
                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 5109a58:	e3023d30 	movw	r3, #11568	; 0x2d30
 5109a5c:	e1a00004 	mov	r0, r4
 5109a60:	e3403510 	movt	r3, #1296	; 0x510
 5109a64:	e12fff33 	blx	r3
                    uxQueueLength = uxQueueGetQueueLength( xInternalQueueHandle );
 5109a68:	e3023d38 	movw	r3, #11576	; 0x2d38
 5109a6c:	e3403510 	movt	r3, #1296	; 0x510
                    uxQueueItemSize = uxQueueGetQueueItemSize( xInternalQueueHandle );
 5109a70:	e1a08000 	mov	r8, r0
                    uxQueueLength = uxQueueGetQueueLength( xInternalQueueHandle );
 5109a74:	e1a00004 	mov	r0, r4
 5109a78:	e12fff33 	blx	r3
                    if( ( !( ( pvItemToQueue == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) ) &&
 5109a7c:	e16f3f18 	clz	r3, r8
 5109a80:	e1a032a3 	lsr	r3, r3, #5
 5109a84:	e3570000 	cmp	r7, #0
 5109a88:	13833001 	orrne	r3, r3, #1
 5109a8c:	e3530000 	cmp	r3, #0
 5109a90:	0affffda 	beq	5109a00 <MPU_xQueueGenericSendImpl+0x10>
                        ( !( ( xCopyPosition == queueOVERWRITE ) && ( uxQueueLength != ( UBaseType_t ) 1U ) ) )
 5109a94:	e2400001 	sub	r0, r0, #1
 5109a98:	e16f0f10 	clz	r0, r0
 5109a9c:	e1a002a0 	lsr	r0, r0, #5
                    if( ( !( ( pvItemToQueue == NULL ) && ( uxQueueItemSize != ( UBaseType_t ) 0U ) ) ) &&
 5109aa0:	e3550002 	cmp	r5, #2
 5109aa4:	13800001 	orrne	r0, r0, #1
 5109aa8:	e3500000 	cmp	r0, #0
 5109aac:	0affffd3 	beq	5109a00 <MPU_xQueueGenericSendImpl+0x10>
                            && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0U ) ) )
 5109ab0:	e3063e28 	movw	r3, #28200	; 0x6e28
 5109ab4:	e3403510 	movt	r3, #1296	; 0x510
 5109ab8:	e12fff33 	blx	r3
 5109abc:	e16f3f16 	clz	r3, r6
 5109ac0:	e1a032a3 	lsr	r3, r3, #5
 5109ac4:	e3500000 	cmp	r0, #0
 5109ac8:	13833001 	orrne	r3, r3, #1
 5109acc:	e3530000 	cmp	r3, #0
 5109ad0:	0affffca 	beq	5109a00 <MPU_xQueueGenericSendImpl+0x10>
                        if( pvItemToQueue != NULL )
 5109ad4:	e3570000 	cmp	r7, #0
 5109ad8:	0a000007 	beq	5109afc <MPU_xQueueGenericSendImpl+0x10c>
                            xIsItemToQueueReadable = xPortIsAuthorizedToAccessBuffer( pvItemToQueue,
 5109adc:	e30c3824 	movw	r3, #51236	; 0xc824
 5109ae0:	e1a02009 	mov	r2, r9
 5109ae4:	e1a01008 	mov	r1, r8
 5109ae8:	e3403510 	movt	r3, #1296	; 0x510
 5109aec:	e1a00007 	mov	r0, r7
 5109af0:	e12fff33 	blx	r3
                        if( ( pvItemToQueue == NULL ) || ( xIsItemToQueueReadable == pdTRUE ) )
 5109af4:	e3500001 	cmp	r0, #1
 5109af8:	1affffc0 	bne	5109a00 <MPU_xQueueGenericSendImpl+0x10>
                            xReturn = xQueueGenericSend( xInternalQueueHandle, pvItemToQueue, xTicksToWait, xCopyPosition );
 5109afc:	e3018030 	movw	r8, #4144	; 0x1030
 5109b00:	e1a03005 	mov	r3, r5
 5109b04:	e1a02006 	mov	r2, r6
 5109b08:	e1a01007 	mov	r1, r7
 5109b0c:	e1a00004 	mov	r0, r4
 5109b10:	e3408510 	movt	r8, #1296	; 0x510
 5109b14:	e12fff38 	blx	r8
    }
 5109b18:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

05109b1c <MPU_xQueueAddToSetImpl>:
        {
 5109b1c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            if( ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE ) &&
 5109b20:	e2414001 	sub	r4, r1, #1
 5109b24:	e354007f 	cmp	r4, #127	; 0x7f
 5109b28:	8a000002 	bhi	5109b38 <MPU_xQueueAddToSetImpl+0x1c>
                ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSetMember ) != pdFALSE ) )
 5109b2c:	e2405001 	sub	r5, r0, #1
            if( ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE ) &&
 5109b30:	e355007f 	cmp	r5, #127	; 0x7f
 5109b34:	9a000001 	bls	5109b40 <MPU_xQueueAddToSetImpl+0x24>
            BaseType_t xReturn = pdFAIL;
 5109b38:	e3a00000 	mov	r0, #0
 5109b3c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                xCallingTaskIsAuthorizedToAccessQueueSet = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSet ) );
 5109b40:	e30c6928 	movw	r6, #51496	; 0xc928
 5109b44:	e1a00004 	mov	r0, r4
 5109b48:	e3406510 	movt	r6, #1296	; 0x510
 5109b4c:	e12fff36 	blx	r6
 5109b50:	e1a07000 	mov	r7, r0
                xCallingTaskIsAuthorizedToAccessQueueSetMember = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndexQueueSetMember ) );
 5109b54:	e1a00005 	mov	r0, r5
 5109b58:	e12fff36 	blx	r6
                if( ( xCallingTaskIsAuthorizedToAccessQueueSet == pdTRUE ) && ( xCallingTaskIsAuthorizedToAccessQueueSetMember == pdTRUE ) )
 5109b5c:	e3570001 	cmp	r7, #1
 5109b60:	03500001 	cmpeq	r0, #1
 5109b64:	1afffff3 	bne	5109b38 <MPU_xQueueAddToSetImpl+0x1c>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109b68:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 5109b6c:	e0844084 	add	r4, r4, r4, lsl #1
 5109b70:	e3406512 	movt	r6, #1298	; 0x512
 5109b74:	e0863104 	add	r3, r6, r4, lsl #2
 5109b78:	e1a04104 	lsl	r4, r4, #2
 5109b7c:	e5933004 	ldr	r3, [r3, #4]
 5109b80:	e3530001 	cmp	r3, #1
        OpaqueObjectHandle_t xObjectHandle = NULL;
 5109b84:	13a04000 	movne	r4, #0
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109b88:	07964004 	ldreq	r4, [r6, r4]
        configASSERT( IS_INTERNAL_INDEX_VALID( lIndex ) != pdFALSE );
 5109b8c:	e355007f 	cmp	r5, #127	; 0x7f
 5109b90:	8a00000e 	bhi	5109bd0 <MPU_xQueueAddToSetImpl+0xb4>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109b94:	e0850085 	add	r0, r5, r5, lsl #1
 5109b98:	e0863100 	add	r3, r6, r0, lsl #2
 5109b9c:	e1a00100 	lsl	r0, r0, #2
 5109ba0:	e5933004 	ldr	r3, [r3, #4]
 5109ba4:	e3530001 	cmp	r3, #1
 5109ba8:	1affffe2 	bne	5109b38 <MPU_xQueueAddToSetImpl+0x1c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109bac:	e7960000 	ldr	r0, [r6, r0]
                    if( ( xInternalQueueSetHandle != NULL ) && ( xInternalQueueSetMemberHandle != NULL ) )
 5109bb0:	e3540000 	cmp	r4, #0
 5109bb4:	13500000 	cmpne	r0, #0
 5109bb8:	0affffde 	beq	5109b38 <MPU_xQueueAddToSetImpl+0x1c>
                        xReturn = xQueueAddToSet( xInternalQueueSetMemberHandle, xInternalQueueSetHandle );
 5109bbc:	e30235fc 	movw	r3, #9724	; 0x25fc
 5109bc0:	e1a01004 	mov	r1, r4
 5109bc4:	e3403510 	movt	r3, #1296	; 0x510
 5109bc8:	e12fff33 	blx	r3
        }
 5109bcc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( IS_INTERNAL_INDEX_VALID( lIndex ) != pdFALSE );
 5109bd0:	e30d0b50 	movw	r0, #56144	; 0xdb50
 5109bd4:	e3003900 	movw	r3, #2304	; 0x900
 5109bd8:	e300114f 	movw	r1, #335	; 0x14f
 5109bdc:	e3403511 	movt	r3, #1297	; 0x511
 5109be0:	e3400512 	movt	r0, #1298	; 0x512
 5109be4:	e12fff33 	blx	r3
 5109be8:	eaffffe9 	b	5109b94 <MPU_xQueueAddToSetImpl+0x78>

05109bec <MPU_vTaskSuspendImpl>:
        {
 5109bec:	e92d4010 	push	{r4, lr}
            if( pxTaskToSuspend == NULL )
 5109bf0:	e2504000 	subs	r4, r0, #0
 5109bf4:	0a000018 	beq	5109c5c <MPU_vTaskSuspendImpl+0x70>
                    if( ( xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED ) || ( portIS_TASK_PRIVILEGED() == pdTRUE ) )
 5109bf8:	e3063e28 	movw	r3, #28200	; 0x6e28
 5109bfc:	e3403510 	movt	r3, #1296	; 0x510
 5109c00:	e12fff33 	blx	r3
 5109c04:	e3500001 	cmp	r0, #1
 5109c08:	1a000017 	bne	5109c6c <MPU_vTaskSuspendImpl+0x80>
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109c0c:	e2444001 	sub	r4, r4, #1
 5109c10:	e354007f 	cmp	r4, #127	; 0x7f
 5109c14:	88bd8010 	pophi	{r4, pc}
                        xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109c18:	e30c3928 	movw	r3, #51496	; 0xc928
 5109c1c:	e1a00004 	mov	r0, r4
 5109c20:	e3403510 	movt	r3, #1296	; 0x510
 5109c24:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5109c28:	e3500001 	cmp	r0, #1
 5109c2c:	18bd8010 	popne	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109c30:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109c34:	e0844084 	add	r4, r4, r4, lsl #1
 5109c38:	e3403512 	movt	r3, #1298	; 0x512
 5109c3c:	e0832104 	add	r2, r3, r4, lsl #2
 5109c40:	e1a04104 	lsl	r4, r4, #2
 5109c44:	e5922004 	ldr	r2, [r2, #4]
 5109c48:	e3520002 	cmp	r2, #2
 5109c4c:	18bd8010 	popne	{r4, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109c50:	e7930004 	ldr	r0, [r3, r4]
                            if( xInternalTaskHandle != NULL )
 5109c54:	e3500000 	cmp	r0, #0
 5109c58:	08bd8010 	popeq	{r4, pc}
                                vTaskSuspend( xInternalTaskHandle );
 5109c5c:	e3063c70 	movw	r3, #27760	; 0x6c70
 5109c60:	e3403510 	movt	r3, #1296	; 0x510
 5109c64:	e12fff33 	blx	r3
        }
 5109c68:	e8bd8010 	pop	{r4, pc}
                    if( ( xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED ) || ( portIS_TASK_PRIVILEGED() == pdTRUE ) )
 5109c6c:	e3083c34 	movw	r3, #35892	; 0x8c34
 5109c70:	e3403511 	movt	r3, #1297	; 0x511
 5109c74:	e12fff33 	blx	r3
 5109c78:	e3500001 	cmp	r0, #1
 5109c7c:	18bd8010 	popne	{r4, pc}
 5109c80:	eaffffe1 	b	5109c0c <MPU_vTaskSuspendImpl+0x20>

05109c84 <MPU_xTaskGenericNotifyStateClearImpl>:
        {
 5109c84:	e92d4070 	push	{r4, r5, r6, lr}
            if( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES )
 5109c88:	e2515000 	subs	r5, r1, #0
 5109c8c:	1a000004 	bne	5109ca4 <MPU_xTaskGenericNotifyStateClearImpl+0x20>
                if( xTask == NULL )
 5109c90:	e3500000 	cmp	r0, #0
 5109c94:	0a00001a 	beq	5109d04 <MPU_xTaskGenericNotifyStateClearImpl+0x80>
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109c98:	e2404001 	sub	r4, r0, #1
 5109c9c:	e354007f 	cmp	r4, #127	; 0x7f
 5109ca0:	9a000001 	bls	5109cac <MPU_xTaskGenericNotifyStateClearImpl+0x28>
            BaseType_t xReturn = pdFAIL;
 5109ca4:	e3a00000 	mov	r0, #0
 5109ca8:	e8bd8070 	pop	{r4, r5, r6, pc}
                        xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109cac:	e30c3928 	movw	r3, #51496	; 0xc928
 5109cb0:	e1a00004 	mov	r0, r4
 5109cb4:	e3403510 	movt	r3, #1296	; 0x510
 5109cb8:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5109cbc:	e3500001 	cmp	r0, #1
 5109cc0:	1afffff7 	bne	5109ca4 <MPU_xTaskGenericNotifyStateClearImpl+0x20>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109cc4:	e3062fa8 	movw	r2, #28584	; 0x6fa8
 5109cc8:	e0843084 	add	r3, r4, r4, lsl #1
 5109ccc:	e3402512 	movt	r2, #1298	; 0x512
 5109cd0:	e0821103 	add	r1, r2, r3, lsl #2
 5109cd4:	e1a03103 	lsl	r3, r3, #2
 5109cd8:	e5911004 	ldr	r1, [r1, #4]
 5109cdc:	e3510002 	cmp	r1, #2
 5109ce0:	1affffef 	bne	5109ca4 <MPU_xTaskGenericNotifyStateClearImpl+0x20>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109ce4:	e7920003 	ldr	r0, [r2, r3]
                            if( xInternalTaskHandle != NULL )
 5109ce8:	e3500000 	cmp	r0, #0
 5109cec:	0affffec 	beq	5109ca4 <MPU_xTaskGenericNotifyStateClearImpl+0x20>
                                xReturn = xTaskGenericNotifyStateClear( xInternalTaskHandle, uxIndexToClear );
 5109cf0:	e3053a30 	movw	r3, #23088	; 0x5a30
 5109cf4:	e1a01005 	mov	r1, r5
 5109cf8:	e3403510 	movt	r3, #1296	; 0x510
 5109cfc:	e12fff33 	blx	r3
        }
 5109d00:	e8bd8070 	pop	{r4, r5, r6, pc}
                    xReturn = xTaskGenericNotifyStateClear( xTask, uxIndexToClear );
 5109d04:	e3053a30 	movw	r3, #23088	; 0x5a30
 5109d08:	e3403510 	movt	r3, #1296	; 0x510
 5109d0c:	e12fff33 	blx	r3
 5109d10:	e8bd8070 	pop	{r4, r5, r6, pc}

05109d14 <MPU_ulTaskGenericNotifyValueClearImpl>:
        {
 5109d14:	e92d4070 	push	{r4, r5, r6, lr}
            if( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES )
 5109d18:	e2515000 	subs	r5, r1, #0
 5109d1c:	1a000004 	bne	5109d34 <MPU_ulTaskGenericNotifyValueClearImpl+0x20>
                if( xTask == NULL )
 5109d20:	e3500000 	cmp	r0, #0
 5109d24:	0a00001c 	beq	5109d9c <MPU_ulTaskGenericNotifyValueClearImpl+0x88>
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109d28:	e2404001 	sub	r4, r0, #1
 5109d2c:	e354007f 	cmp	r4, #127	; 0x7f
 5109d30:	9a000001 	bls	5109d3c <MPU_ulTaskGenericNotifyValueClearImpl+0x28>
            uint32_t ulReturn = 0;
 5109d34:	e3a00000 	mov	r0, #0
 5109d38:	e8bd8070 	pop	{r4, r5, r6, pc}
                        xCallingTaskIsAuthorizedToAccessTask = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109d3c:	e30c3928 	movw	r3, #51496	; 0xc928
 5109d40:	e1a00004 	mov	r0, r4
 5109d44:	e1a06002 	mov	r6, r2
 5109d48:	e3403510 	movt	r3, #1296	; 0x510
 5109d4c:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessTask == pdTRUE )
 5109d50:	e3500001 	cmp	r0, #1
 5109d54:	1afffff6 	bne	5109d34 <MPU_ulTaskGenericNotifyValueClearImpl+0x20>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109d58:	e3062fa8 	movw	r2, #28584	; 0x6fa8
 5109d5c:	e0843084 	add	r3, r4, r4, lsl #1
 5109d60:	e3402512 	movt	r2, #1298	; 0x512
 5109d64:	e1a01103 	lsl	r1, r3, #2
 5109d68:	e0823103 	add	r3, r2, r3, lsl #2
 5109d6c:	e5933004 	ldr	r3, [r3, #4]
 5109d70:	e3530002 	cmp	r3, #2
 5109d74:	1affffee 	bne	5109d34 <MPU_ulTaskGenericNotifyValueClearImpl+0x20>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109d78:	e7920001 	ldr	r0, [r2, r1]
                            if( xInternalTaskHandle != NULL )
 5109d7c:	e3500000 	cmp	r0, #0
 5109d80:	0affffeb 	beq	5109d34 <MPU_ulTaskGenericNotifyValueClearImpl+0x20>
                                ulReturn = ulTaskGenericNotifyValueClear( xInternalTaskHandle, uxIndexToClear, ulBitsToClear );
 5109d84:	e3053ab4 	movw	r3, #23220	; 0x5ab4
 5109d88:	e1a02006 	mov	r2, r6
 5109d8c:	e1a01005 	mov	r1, r5
 5109d90:	e3403510 	movt	r3, #1296	; 0x510
 5109d94:	e12fff33 	blx	r3
        }
 5109d98:	e8bd8070 	pop	{r4, r5, r6, pc}
                    ulReturn = ulTaskGenericNotifyValueClear( xTask, uxIndexToClear, ulBitsToClear );
 5109d9c:	e3053ab4 	movw	r3, #23220	; 0x5ab4
 5109da0:	e3403510 	movt	r3, #1296	; 0x510
 5109da4:	e12fff33 	blx	r3
 5109da8:	e8bd8070 	pop	{r4, r5, r6, pc}

05109dac <MPU_xStreamBufferReceiveImpl>:
        {
 5109dac:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            if( pvRxData != NULL )
 5109db0:	e2515000 	subs	r5, r1, #0
 5109db4:	0a00000a 	beq	5109de4 <MPU_xStreamBufferReceiveImpl+0x38>
                xIsRxDataBufferWriteable = xPortIsAuthorizedToAccessBuffer( pvRxData,
 5109db8:	e1a08002 	mov	r8, r2
 5109dbc:	e30c6824 	movw	r6, #51236	; 0xc824
 5109dc0:	e1a04000 	mov	r4, r0
 5109dc4:	e3a02002 	mov	r2, #2
 5109dc8:	e1a01008 	mov	r1, r8
 5109dcc:	e3406510 	movt	r6, #1296	; 0x510
 5109dd0:	e1a00005 	mov	r0, r5
 5109dd4:	e1a07003 	mov	r7, r3
 5109dd8:	e12fff36 	blx	r6
                if( xIsRxDataBufferWriteable == pdTRUE )
 5109ddc:	e3500001 	cmp	r0, #1
 5109de0:	0a000001 	beq	5109dec <MPU_xStreamBufferReceiveImpl+0x40>
            size_t xReturn = 0;
 5109de4:	e3a00000 	mov	r0, #0
 5109de8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109dec:	e2444001 	sub	r4, r4, #1
 5109df0:	e354007f 	cmp	r4, #127	; 0x7f
 5109df4:	8afffffa 	bhi	5109de4 <MPU_xStreamBufferReceiveImpl+0x38>
                        xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109df8:	e30c3928 	movw	r3, #51496	; 0xc928
 5109dfc:	e1a00004 	mov	r0, r4
 5109e00:	e3403510 	movt	r3, #1296	; 0x510
 5109e04:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5109e08:	e3500001 	cmp	r0, #1
 5109e0c:	1afffff4 	bne	5109de4 <MPU_xStreamBufferReceiveImpl+0x38>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109e10:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109e14:	e0844084 	add	r4, r4, r4, lsl #1
 5109e18:	e3403512 	movt	r3, #1298	; 0x512
 5109e1c:	e0832104 	add	r2, r3, r4, lsl #2
 5109e20:	e1a04104 	lsl	r4, r4, #2
 5109e24:	e5922004 	ldr	r2, [r2, #4]
 5109e28:	e3520003 	cmp	r2, #3
 5109e2c:	1affffec 	bne	5109de4 <MPU_xStreamBufferReceiveImpl+0x38>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109e30:	e7930004 	ldr	r0, [r3, r4]
                            if( xInternalStreamBufferHandle != NULL )
 5109e34:	e3500000 	cmp	r0, #0
 5109e38:	0affffe9 	beq	5109de4 <MPU_xStreamBufferReceiveImpl+0x38>
                                xReturn = xStreamBufferReceive( xInternalStreamBufferHandle, pvRxData, xBufferLengthBytes, xTicksToWait );
 5109e3c:	e30344d0 	movw	r4, #13520	; 0x34d0
 5109e40:	e1a03007 	mov	r3, r7
 5109e44:	e1a02008 	mov	r2, r8
 5109e48:	e1a01005 	mov	r1, r5
 5109e4c:	e3404510 	movt	r4, #1296	; 0x510
 5109e50:	e12fff34 	blx	r4
        }
 5109e54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05109e58 <MPU_xStreamBufferSendImpl>:
        {
 5109e58:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            if( pvTxData != NULL )
 5109e5c:	e2515000 	subs	r5, r1, #0
 5109e60:	0a00000a 	beq	5109e90 <MPU_xStreamBufferSendImpl+0x38>
                xIsTxDataBufferReadable = xPortIsAuthorizedToAccessBuffer( pvTxData,
 5109e64:	e1a08002 	mov	r8, r2
 5109e68:	e30c6824 	movw	r6, #51236	; 0xc824
 5109e6c:	e1a04000 	mov	r4, r0
 5109e70:	e3a02001 	mov	r2, #1
 5109e74:	e1a01008 	mov	r1, r8
 5109e78:	e3406510 	movt	r6, #1296	; 0x510
 5109e7c:	e1a00005 	mov	r0, r5
 5109e80:	e1a07003 	mov	r7, r3
 5109e84:	e12fff36 	blx	r6
                if( xIsTxDataBufferReadable == pdTRUE )
 5109e88:	e3500001 	cmp	r0, #1
 5109e8c:	0a000001 	beq	5109e98 <MPU_xStreamBufferSendImpl+0x40>
            size_t xReturn = 0;
 5109e90:	e3a00000 	mov	r0, #0
 5109e94:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109e98:	e2444001 	sub	r4, r4, #1
 5109e9c:	e354007f 	cmp	r4, #127	; 0x7f
 5109ea0:	8afffffa 	bhi	5109e90 <MPU_xStreamBufferSendImpl+0x38>
                        xCallingTaskIsAuthorizedToAccessStreamBuffer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109ea4:	e30c3928 	movw	r3, #51496	; 0xc928
 5109ea8:	e1a00004 	mov	r0, r4
 5109eac:	e3403510 	movt	r3, #1296	; 0x510
 5109eb0:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessStreamBuffer == pdTRUE )
 5109eb4:	e3500001 	cmp	r0, #1
 5109eb8:	1afffff4 	bne	5109e90 <MPU_xStreamBufferSendImpl+0x38>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109ebc:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109ec0:	e0844084 	add	r4, r4, r4, lsl #1
 5109ec4:	e3403512 	movt	r3, #1298	; 0x512
 5109ec8:	e0832104 	add	r2, r3, r4, lsl #2
 5109ecc:	e1a04104 	lsl	r4, r4, #2
 5109ed0:	e5922004 	ldr	r2, [r2, #4]
 5109ed4:	e3520003 	cmp	r2, #3
 5109ed8:	1affffec 	bne	5109e90 <MPU_xStreamBufferSendImpl+0x38>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109edc:	e7930004 	ldr	r0, [r3, r4]
                            if( xInternalStreamBufferHandle != NULL )
 5109ee0:	e3500000 	cmp	r0, #0
 5109ee4:	0affffe9 	beq	5109e90 <MPU_xStreamBufferSendImpl+0x38>
                                xReturn = xStreamBufferSend( xInternalStreamBufferHandle, pvTxData, xDataLengthBytes, xTicksToWait );
 5109ee8:	e30340cc 	movw	r4, #12492	; 0x30cc
 5109eec:	e1a03007 	mov	r3, r7
 5109ef0:	e1a02008 	mov	r2, r8
 5109ef4:	e1a01005 	mov	r1, r5
 5109ef8:	e3404510 	movt	r4, #1296	; 0x510
 5109efc:	e12fff34 	blx	r4
        }
 5109f00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05109f04 <MPU_xEventGroupSyncImpl>:
            if( ( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0U ) &&
 5109f04:	e252c000 	subs	ip, r2, #0
        {
 5109f08:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            if( ( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0U ) &&
 5109f0c:	13a0c001 	movne	ip, #1
 5109f10:	e202e4ff 	and	lr, r2, #-16777216	; 0xff000000
 5109f14:	e35e0000 	cmp	lr, #0
 5109f18:	13a0c000 	movne	ip, #0
 5109f1c:	e35c0000 	cmp	ip, #0
 5109f20:	1a000001 	bne	5109f2c <MPU_xEventGroupSyncImpl+0x28>
            EventBits_t xReturn = 0;
 5109f24:	e3a00000 	mov	r0, #0
 5109f28:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5109f2c:	e1a04003 	mov	r4, r3
                    && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0U ) ) )
 5109f30:	e3063e28 	movw	r3, #28200	; 0x6e28
 5109f34:	e1a07002 	mov	r7, r2
 5109f38:	e3403510 	movt	r3, #1296	; 0x510
 5109f3c:	e1a05000 	mov	r5, r0
 5109f40:	e1a06001 	mov	r6, r1
 5109f44:	e12fff33 	blx	r3
 5109f48:	e2500000 	subs	r0, r0, #0
 5109f4c:	13a00001 	movne	r0, #1
 5109f50:	e3540000 	cmp	r4, #0
 5109f54:	03800001 	orreq	r0, r0, #1
 5109f58:	e3500000 	cmp	r0, #0
 5109f5c:	0afffff0 	beq	5109f24 <MPU_xEventGroupSyncImpl+0x20>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 5109f60:	e2455001 	sub	r5, r5, #1
 5109f64:	e355007f 	cmp	r5, #127	; 0x7f
 5109f68:	8affffed 	bhi	5109f24 <MPU_xEventGroupSyncImpl+0x20>
                    xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 5109f6c:	e30c3928 	movw	r3, #51496	; 0xc928
 5109f70:	e1a00005 	mov	r0, r5
 5109f74:	e3403510 	movt	r3, #1296	; 0x510
 5109f78:	e12fff33 	blx	r3
                    if( xCallingTaskIsAuthorizedToAccessEventGroup == pdTRUE )
 5109f7c:	e3500001 	cmp	r0, #1
 5109f80:	1affffe7 	bne	5109f24 <MPU_xEventGroupSyncImpl+0x20>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 5109f84:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 5109f88:	e0855085 	add	r5, r5, r5, lsl #1
 5109f8c:	e3403512 	movt	r3, #1298	; 0x512
 5109f90:	e0831105 	add	r1, r3, r5, lsl #2
 5109f94:	e1a05105 	lsl	r5, r5, #2
 5109f98:	e5911004 	ldr	r1, [r1, #4]
 5109f9c:	e3510004 	cmp	r1, #4
 5109fa0:	1affffdf 	bne	5109f24 <MPU_xEventGroupSyncImpl+0x20>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 5109fa4:	e7930005 	ldr	r0, [r3, r5]
                        if( xInternalEventGroupHandle != NULL )
 5109fa8:	e3500000 	cmp	r0, #0
 5109fac:	0affffdc 	beq	5109f24 <MPU_xEventGroupSyncImpl+0x20>
                            xReturn = xEventGroupSync( xInternalEventGroupHandle, uxBitsToSet, uxBitsToWaitFor, xTicksToWait );
 5109fb0:	e3005864 	movw	r5, #2148	; 0x864
 5109fb4:	e1a03004 	mov	r3, r4
 5109fb8:	e1a02007 	mov	r2, r7
 5109fbc:	e1a01006 	mov	r1, r6
 5109fc0:	e3405510 	movt	r5, #1296	; 0x510
 5109fc4:	e12fff35 	blx	r5
        }
 5109fc8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05109fcc <MPU_xTimerGenericCommandFromTaskImpl>:
        {
 5109fcc:	e92d4030 	push	{r4, r5, lr}
            if( pxParams != NULL )
 5109fd0:	e2504000 	subs	r4, r0, #0
        {
 5109fd4:	e24dd00c 	sub	sp, sp, #12
            if( pxParams != NULL )
 5109fd8:	0a000006 	beq	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
                xAreParamsReadable = xPortIsAuthorizedToAccessBuffer( pxParams,
 5109fdc:	e30c5824 	movw	r5, #51236	; 0xc824
 5109fe0:	e3a02001 	mov	r2, #1
 5109fe4:	e3a01014 	mov	r1, #20
 5109fe8:	e3405510 	movt	r5, #1296	; 0x510
 5109fec:	e12fff35 	blx	r5
            if( xAreParamsReadable == pdTRUE )
 5109ff0:	e3500001 	cmp	r0, #1
 5109ff4:	0a000002 	beq	510a004 <MPU_xTimerGenericCommandFromTaskImpl+0x38>
            BaseType_t xReturn = pdFALSE;
 5109ff8:	e3a00000 	mov	r0, #0
        }
 5109ffc:	e28dd00c 	add	sp, sp, #12
 510a000:	e8bd8030 	pop	{r4, r5, pc}
                if( pxParams->xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 510a004:	e5943004 	ldr	r3, [r4, #4]
 510a008:	e3530005 	cmp	r3, #5
 510a00c:	cafffff9 	bgt	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
                    if( pxParams->pxHigherPriorityTaskWoken != NULL )
 510a010:	e594000c 	ldr	r0, [r4, #12]
 510a014:	e3500000 	cmp	r0, #0
 510a018:	0a000006 	beq	510a038 <MPU_xTimerGenericCommandFromTaskImpl+0x6c>
                        xIsHigherPriorityTaskWokenWriteable = xPortIsAuthorizedToAccessBuffer( pxParams->pxHigherPriorityTaskWoken,
 510a01c:	e3a02002 	mov	r2, #2
 510a020:	e3a01004 	mov	r1, #4
 510a024:	e12fff35 	blx	r5
                    if( ( pxParams->pxHigherPriorityTaskWoken == NULL ) ||
 510a028:	e594300c 	ldr	r3, [r4, #12]
 510a02c:	e3500001 	cmp	r0, #1
 510a030:	13530000 	cmpne	r3, #0
 510a034:	1affffef 	bne	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
                        lIndex = ( int32_t ) ( pxParams->xTimer );
 510a038:	e5945000 	ldr	r5, [r4]
                        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a03c:	e2455001 	sub	r5, r5, #1
 510a040:	e355007f 	cmp	r5, #127	; 0x7f
 510a044:	8affffeb 	bhi	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
                            xCallingTaskIsAuthorizedToAccessTimer = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 510a048:	e30c3928 	movw	r3, #51496	; 0xc928
 510a04c:	e1a00005 	mov	r0, r5
 510a050:	e3403510 	movt	r3, #1296	; 0x510
 510a054:	e12fff33 	blx	r3
                            if( xCallingTaskIsAuthorizedToAccessTimer == pdTRUE )
 510a058:	e3500001 	cmp	r0, #1
 510a05c:	1affffe5 	bne	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a060:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a064:	e0855085 	add	r5, r5, r5, lsl #1
 510a068:	e3403512 	movt	r3, #1298	; 0x512
 510a06c:	e0832105 	add	r2, r3, r5, lsl #2
 510a070:	e1a05105 	lsl	r5, r5, #2
 510a074:	e5922004 	ldr	r2, [r2, #4]
 510a078:	e3520005 	cmp	r2, #5
 510a07c:	1affffdd 	bne	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a080:	e7930005 	ldr	r0, [r3, r5]
                                if( xInternalTimerHandle != NULL )
 510a084:	e3500000 	cmp	r0, #0
 510a088:	0affffda 	beq	5109ff8 <MPU_xTimerGenericCommandFromTaskImpl+0x2c>
                                    xReturn = xTimerGenericCommandFromTask( xInternalTimerHandle,
 510a08c:	e994100e 	ldmib	r4, {r1, r2, r3, ip}
 510a090:	e58dc000 	str	ip, [sp]
 510a094:	e3074de8 	movw	r4, #32232	; 0x7de8
 510a098:	e3404510 	movt	r4, #1296	; 0x510
 510a09c:	e12fff34 	blx	r4
            return xReturn;
 510a0a0:	eaffffd5 	b	5109ffc <MPU_xTimerGenericCommandFromTaskImpl+0x30>

0510a0a4 <MPU_xEventGroupWaitBitsImpl>:
        {
 510a0a4:	e92d4030 	push	{r4, r5, lr}
            if( pxParams != NULL )
 510a0a8:	e2504000 	subs	r4, r0, #0
        {
 510a0ac:	e24dd00c 	sub	sp, sp, #12
            if( pxParams != NULL )
 510a0b0:	0a000006 	beq	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
                xAreParamsReadable = xPortIsAuthorizedToAccessBuffer( pxParams,
 510a0b4:	e30c3824 	movw	r3, #51236	; 0xc824
 510a0b8:	e3a02001 	mov	r2, #1
 510a0bc:	e3a01014 	mov	r1, #20
 510a0c0:	e3403510 	movt	r3, #1296	; 0x510
 510a0c4:	e12fff33 	blx	r3
            if( xAreParamsReadable == pdTRUE )
 510a0c8:	e3500001 	cmp	r0, #1
 510a0cc:	0a000002 	beq	510a0dc <MPU_xEventGroupWaitBitsImpl+0x38>
            EventBits_t xReturn = 0;
 510a0d0:	e3a00000 	mov	r0, #0
        }
 510a0d4:	e28dd00c 	add	sp, sp, #12
 510a0d8:	e8bd8030 	pop	{r4, r5, pc}
                if( ( ( pxParams->uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0U ) &&
 510a0dc:	e5943004 	ldr	r3, [r4, #4]
 510a0e0:	e20324ff 	and	r2, r3, #-16777216	; 0xff000000
 510a0e4:	e2533000 	subs	r3, r3, #0
 510a0e8:	13a03001 	movne	r3, #1
 510a0ec:	e3520000 	cmp	r2, #0
 510a0f0:	13a03000 	movne	r3, #0
 510a0f4:	e3530000 	cmp	r3, #0
 510a0f8:	0afffff4 	beq	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
                        && ( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( pxParams->xTicksToWait != 0U ) ) )
 510a0fc:	e3063e28 	movw	r3, #28200	; 0x6e28
 510a100:	e3403510 	movt	r3, #1296	; 0x510
 510a104:	e12fff33 	blx	r3
 510a108:	e3500000 	cmp	r0, #0
 510a10c:	1a000002 	bne	510a11c <MPU_xEventGroupWaitBitsImpl+0x78>
 510a110:	e5943010 	ldr	r3, [r4, #16]
 510a114:	e3530000 	cmp	r3, #0
 510a118:	1affffec 	bne	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
                    lIndex = ( int32_t ) ( pxParams->xEventGroup );
 510a11c:	e5945000 	ldr	r5, [r4]
                    if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a120:	e2455001 	sub	r5, r5, #1
 510a124:	e355007f 	cmp	r5, #127	; 0x7f
 510a128:	8affffe8 	bhi	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
                        xCallingTaskIsAuthorizedToAccessEventGroup = xPortIsAuthorizedToAccessKernelObject( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
 510a12c:	e30c3928 	movw	r3, #51496	; 0xc928
 510a130:	e1a00005 	mov	r0, r5
 510a134:	e3403510 	movt	r3, #1296	; 0x510
 510a138:	e12fff33 	blx	r3
                        if( xCallingTaskIsAuthorizedToAccessEventGroup == pdTRUE )
 510a13c:	e3500001 	cmp	r0, #1
 510a140:	1affffe2 	bne	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a144:	e3062fa8 	movw	r2, #28584	; 0x6fa8
 510a148:	e0853085 	add	r3, r5, r5, lsl #1
 510a14c:	e3402512 	movt	r2, #1298	; 0x512
 510a150:	e0823103 	add	r3, r2, r3, lsl #2
 510a154:	e5933004 	ldr	r3, [r3, #4]
 510a158:	e3530004 	cmp	r3, #4
 510a15c:	1affffdb 	bne	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a160:	e3a0300c 	mov	r3, #12
 510a164:	e0050395 	mul	r5, r5, r3
 510a168:	e7920005 	ldr	r0, [r2, r5]
                            if( xInternalEventGroupHandle != NULL )
 510a16c:	e3500000 	cmp	r0, #0
 510a170:	0affffd6 	beq	510a0d0 <MPU_xEventGroupWaitBitsImpl+0x2c>
                                xReturn = xEventGroupWaitBits( xInternalEventGroupHandle,
 510a174:	e994100e 	ldmib	r4, {r1, r2, r3, ip}
 510a178:	e58dc000 	str	ip, [sp]
 510a17c:	e3004514 	movw	r4, #1300	; 0x514
 510a180:	e3404510 	movt	r4, #1296	; 0x510
 510a184:	e12fff34 	blx	r4
            return xReturn;
 510a188:	eaffffd1 	b	510a0d4 <MPU_xEventGroupWaitBitsImpl+0x30>

0510a18c <MPU_xTaskCreate>:
        {
 510a18c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
            TaskHandle_t xInternalTaskHandle = NULL;
 510a190:	e3a04000 	mov	r4, #0
        {
 510a194:	e24dd01c 	sub	sp, sp, #28
 510a198:	e1a0a003 	mov	sl, r3
        vTaskSuspendAll();
 510a19c:	e30532a0 	movw	r3, #21152	; 0x52a0
 510a1a0:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510a1a4:	e3403510 	movt	r3, #1296	; 0x510
        {
 510a1a8:	e1a07000 	mov	r7, r0
 510a1ac:	e1a08001 	mov	r8, r1
 510a1b0:	e1a09002 	mov	r9, r2
 510a1b4:	e3406512 	movt	r6, #1298	; 0x512
            TaskHandle_t xInternalTaskHandle = NULL;
 510a1b8:	e58d4014 	str	r4, [sp, #20]
        vTaskSuspendAll();
 510a1bc:	e12fff33 	blx	r3
 510a1c0:	e1a03004 	mov	r3, r4
 510a1c4:	ea000002 	b	510a1d4 <MPU_xTaskCreate+0x48>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a1c8:	e2844001 	add	r4, r4, #1
 510a1cc:	e3540080 	cmp	r4, #128	; 0x80
 510a1d0:	0a000041 	beq	510a2dc <MPU_xTaskCreate+0x150>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a1d4:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a1d8:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a1dc:	e3550000 	cmp	r5, #0
 510a1e0:	1afffff8 	bne	510a1c8 <MPU_xTaskCreate+0x3c>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a1e4:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510a1e8:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a1ec:	e3e01000 	mvn	r1, #0
 510a1f0:	e1a0b103 	lsl	fp, r3, #2
 510a1f4:	e0863103 	add	r3, r6, r3, lsl #2
 510a1f8:	e786100b 	str	r1, [r6, fp]
        ( void ) xTaskResumeAll();
 510a1fc:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a200:	e58d3008 	str	r3, [sp, #8]
        ( void ) xTaskResumeAll();
 510a204:	e12fff32 	blx	r2
                if( ( uxPriority & portPRIVILEGE_BIT ) != 0 )
 510a208:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
 510a20c:	e3530000 	cmp	r3, #0
            BaseType_t xReturn = pdFAIL;
 510a210:	a1a07005 	movge	r7, r5
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a214:	e1a03084 	lsl	r3, r4, #1
 510a218:	e58d300c 	str	r3, [sp, #12]
                if( ( uxPriority & portPRIVILEGE_BIT ) != 0 )
 510a21c:	ba000002 	blt	510a22c <MPU_xTaskCreate+0xa0>
        }
 510a220:	e1a00007 	mov	r0, r7
 510a224:	e28dd01c 	add	sp, sp, #28
 510a228:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    xReturn = xTaskCreate( pvTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, &( xInternalTaskHandle ) );
 510a22c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
 510a230:	e28dc014 	add	ip, sp, #20
 510a234:	e1a00007 	mov	r0, r7
 510a238:	e30475ec 	movw	r7, #17900	; 0x45ec
 510a23c:	e58d3000 	str	r3, [sp]
 510a240:	e3407510 	movt	r7, #1296	; 0x510
 510a244:	e1a0300a 	mov	r3, sl
 510a248:	e1a02009 	mov	r2, r9
 510a24c:	e58dc004 	str	ip, [sp, #4]
 510a250:	e1a01008 	mov	r1, r8
 510a254:	e12fff37 	blx	r7
 510a258:	e1a07000 	mov	r7, r0
                    if( ( xReturn == pdPASS ) && ( xInternalTaskHandle != NULL ) )
 510a25c:	e3500001 	cmp	r0, #1
 510a260:	1a00000c 	bne	510a298 <MPU_xTaskCreate+0x10c>
 510a264:	e59d3014 	ldr	r3, [sp, #20]
 510a268:	e3530000 	cmp	r3, #0
 510a26c:	0a000009 	beq	510a298 <MPU_xTaskCreate+0x10c>
                        if( pxCreatedTask != NULL )
 510a270:	e59d2044 	ldr	r2, [sp, #68]	; 0x44
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510a274:	e786300b 	str	r3, [r6, fp]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a278:	e3a03002 	mov	r3, #2
                        if( pxCreatedTask != NULL )
 510a27c:	e3520000 	cmp	r2, #0
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510a280:	e59d2008 	ldr	r2, [sp, #8]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a284:	e9820028 	stmib	r2, {r3, r5}
                            *pxCreatedTask = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510a288:	159d3044 	ldrne	r3, [sp, #68]	; 0x44
 510a28c:	12844001 	addne	r4, r4, #1
 510a290:	15834000 	strne	r4, [r3]
            return xReturn;
 510a294:	eaffffe1 	b	510a220 <MPU_xTaskCreate+0x94>
        taskENTER_CRITICAL();
 510a298:	e30c3930 	movw	r3, #51504	; 0xc930
 510a29c:	e3403510 	movt	r3, #1296	; 0x510
 510a2a0:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a2a4:	e3a02000 	mov	r2, #0
 510a2a8:	e1a03084 	lsl	r3, r4, #1
 510a2ac:	e0834004 	add	r4, r3, r4
 510a2b0:	e0863104 	add	r3, r6, r4, lsl #2
 510a2b4:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a2b8:	e5832004 	str	r2, [r3, #4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a2bc:	e5832008 	str	r2, [r3, #8]
        taskEXIT_CRITICAL();
 510a2c0:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a2c4:	e7862004 	str	r2, [r6, r4]
        taskEXIT_CRITICAL();
 510a2c8:	e3403510 	movt	r3, #1296	; 0x510
 510a2cc:	e12fff33 	blx	r3
        }
 510a2d0:	e1a00007 	mov	r0, r7
 510a2d4:	e28dd01c 	add	sp, sp, #28
 510a2d8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510a2dc:	e3053efc 	movw	r3, #24316	; 0x5efc
            BaseType_t xReturn = pdFAIL;
 510a2e0:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510a2e4:	e3403510 	movt	r3, #1296	; 0x510
 510a2e8:	e12fff33 	blx	r3
        }
 510a2ec:	e1a00007 	mov	r0, r7
 510a2f0:	e28dd01c 	add	sp, sp, #28
 510a2f4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510a2f8 <MPU_xTaskCreateStatic>:
        {
 510a2f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510a2fc:	e30542a0 	movw	r4, #21152	; 0x52a0
        {
 510a300:	e24dd01c 	sub	sp, sp, #28
 510a304:	e1a0a003 	mov	sl, r3
        vTaskSuspendAll();
 510a308:	e3404510 	movt	r4, #1296	; 0x510
        {
 510a30c:	e1a07000 	mov	r7, r0
 510a310:	e1a08001 	mov	r8, r1
 510a314:	e1a09002 	mov	r9, r2
 510a318:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510a31c:	e12fff34 	blx	r4
 510a320:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a324:	e1a04003 	mov	r4, r3
 510a328:	e3406512 	movt	r6, #1298	; 0x512
 510a32c:	ea000002 	b	510a33c <MPU_xTaskCreateStatic+0x44>
 510a330:	e2844001 	add	r4, r4, #1
 510a334:	e3540080 	cmp	r4, #128	; 0x80
 510a338:	0a000023 	beq	510a3cc <MPU_xTaskCreateStatic+0xd4>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a33c:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a340:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a344:	e3550000 	cmp	r5, #0
 510a348:	1afffff8 	bne	510a330 <MPU_xTaskCreateStatic+0x38>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a34c:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510a350:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a354:	e3e01000 	mvn	r1, #0
 510a358:	e1a0b103 	lsl	fp, r3, #2
 510a35c:	e0863103 	add	r3, r6, r3, lsl #2
 510a360:	e786100b 	str	r1, [r6, fp]
        ( void ) xTaskResumeAll();
 510a364:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a368:	e58d3014 	str	r3, [sp, #20]
        ( void ) xTaskResumeAll();
 510a36c:	e12fff32 	blx	r2
                xInternalTaskHandle = xTaskCreateStatic( pxTaskCode, pcName, uxStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer );
 510a370:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
 510a374:	e1a00007 	mov	r0, r7
 510a378:	e58dc008 	str	ip, [sp, #8]
 510a37c:	e30476a8 	movw	r7, #18088	; 0x46a8
 510a380:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
 510a384:	e3407510 	movt	r7, #1296	; 0x510
 510a388:	e58dc004 	str	ip, [sp, #4]
 510a38c:	e1a0300a 	mov	r3, sl
 510a390:	e59dc040 	ldr	ip, [sp, #64]	; 0x40
 510a394:	e1a02009 	mov	r2, r9
 510a398:	e58dc000 	str	ip, [sp]
 510a39c:	e1a01008 	mov	r1, r8
 510a3a0:	e12fff37 	blx	r7
                if( xInternalTaskHandle != NULL )
 510a3a4:	e2507000 	subs	r7, r0, #0
 510a3a8:	0a00000e 	beq	510a3e8 <MPU_xTaskCreateStatic+0xf0>
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510a3ac:	e59d2014 	ldr	r2, [sp, #20]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a3b0:	e3a03002 	mov	r3, #2
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510a3b4:	e786700b 	str	r7, [r6, fp]
                    xExternalTaskHandle = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510a3b8:	e2847001 	add	r7, r4, #1
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a3bc:	e9820028 	stmib	r2, {r3, r5}
        }
 510a3c0:	e1a00007 	mov	r0, r7
 510a3c4:	e28dd01c 	add	sp, sp, #28
 510a3c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510a3cc:	e3053efc 	movw	r3, #24316	; 0x5efc
            TaskHandle_t xExternalTaskHandle = NULL;
 510a3d0:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510a3d4:	e3403510 	movt	r3, #1296	; 0x510
 510a3d8:	e12fff33 	blx	r3
        }
 510a3dc:	e1a00007 	mov	r0, r7
 510a3e0:	e28dd01c 	add	sp, sp, #28
 510a3e4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510a3e8:	e30c3930 	movw	r3, #51504	; 0xc930
 510a3ec:	e3403510 	movt	r3, #1296	; 0x510
 510a3f0:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a3f4:	e59d2014 	ldr	r2, [sp, #20]
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a3f8:	e786700b 	str	r7, [r6, fp]
        taskEXIT_CRITICAL();
 510a3fc:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a400:	e5827004 	str	r7, [r2, #4]
        taskEXIT_CRITICAL();
 510a404:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a408:	e5827008 	str	r7, [r2, #8]
        taskEXIT_CRITICAL();
 510a40c:	e12fff33 	blx	r3
        }
 510a410:	e1a00007 	mov	r0, r7
 510a414:	e28dd01c 	add	sp, sp, #28
 510a418:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510a41c <MPU_vTaskDelete>:
            if( pxTaskToDelete == NULL )
 510a41c:	e3500000 	cmp	r0, #0
        {
 510a420:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
            if( pxTaskToDelete == NULL )
 510a424:	0a000020 	beq	510a4ac <MPU_vTaskDelete+0x90>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a428:	e2404001 	sub	r4, r0, #1
 510a42c:	e354007f 	cmp	r4, #127	; 0x7f
 510a430:	88bd81f0 	pophi	{r4, r5, r6, r7, r8, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a434:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510a438:	e0843084 	add	r3, r4, r4, lsl #1
 510a43c:	e3406512 	movt	r6, #1298	; 0x512
 510a440:	e1a02103 	lsl	r2, r3, #2
 510a444:	e0863103 	add	r3, r6, r3, lsl #2
 510a448:	e1a07084 	lsl	r7, r4, #1
 510a44c:	e5933004 	ldr	r3, [r3, #4]
 510a450:	e3530002 	cmp	r3, #2
 510a454:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a458:	e7965002 	ldr	r5, [r6, r2]
                    if( xInternalTaskHandle != NULL )
 510a45c:	e3550000 	cmp	r5, #0
 510a460:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
        taskENTER_CRITICAL();
 510a464:	e30c3930 	movw	r3, #51504	; 0xc930
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a468:	e0844007 	add	r4, r4, r7
        taskENTER_CRITICAL();
 510a46c:	e3403510 	movt	r3, #1296	; 0x510
 510a470:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a474:	e3a02000 	mov	r2, #0
 510a478:	e0863104 	add	r3, r6, r4, lsl #2
 510a47c:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a480:	e5832004 	str	r2, [r3, #4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a484:	e5832008 	str	r2, [r3, #8]
        taskEXIT_CRITICAL();
 510a488:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a48c:	e7862004 	str	r2, [r6, r4]
        taskEXIT_CRITICAL();
 510a490:	e3403510 	movt	r3, #1296	; 0x510
 510a494:	e12fff33 	blx	r3
                        vTaskDelete( xInternalTaskHandle );
 510a498:	e3043a08 	movw	r3, #18952	; 0x4a08
 510a49c:	e1a00005 	mov	r0, r5
 510a4a0:	e3403510 	movt	r3, #1296	; 0x510
 510a4a4:	e12fff33 	blx	r3
        }
 510a4a8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                xInternalTaskHandle = xTaskGetCurrentTaskHandle();
 510a4ac:	e3063dec 	movw	r3, #28140	; 0x6dec
 510a4b0:	e3403510 	movt	r3, #1296	; 0x510
 510a4b4:	e12fff33 	blx	r3
        configASSERT( xHandle != NULL );
 510a4b8:	e2505000 	subs	r5, r0, #0
 510a4bc:	0a000020 	beq	510a544 <MPU_vTaskDelete+0x128>
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a4c0:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510a4c4:	e3a04000 	mov	r4, #0
 510a4c8:	e3406512 	movt	r6, #1298	; 0x512
 510a4cc:	e1a03006 	mov	r3, r6
 510a4d0:	ea000003 	b	510a4e4 <MPU_vTaskDelete+0xc8>
 510a4d4:	e2844001 	add	r4, r4, #1
 510a4d8:	e3540080 	cmp	r4, #128	; 0x80
 510a4dc:	e283300c 	add	r3, r3, #12
 510a4e0:	0a000012 	beq	510a530 <MPU_vTaskDelete+0x114>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 510a4e4:	e5932000 	ldr	r2, [r3]
 510a4e8:	e1550002 	cmp	r5, r2
 510a4ec:	1afffff8 	bne	510a4d4 <MPU_vTaskDelete+0xb8>
 510a4f0:	e5932004 	ldr	r2, [r3, #4]
 510a4f4:	e3520002 	cmp	r2, #2
 510a4f8:	1afffff5 	bne	510a4d4 <MPU_vTaskDelete+0xb8>
        taskENTER_CRITICAL();
 510a4fc:	e30c3930 	movw	r3, #51504	; 0xc930
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a500:	e0844084 	add	r4, r4, r4, lsl #1
        taskENTER_CRITICAL();
 510a504:	e3403510 	movt	r3, #1296	; 0x510
 510a508:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a50c:	e3a02000 	mov	r2, #0
 510a510:	e0863104 	add	r3, r6, r4, lsl #2
 510a514:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a518:	e5832004 	str	r2, [r3, #4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a51c:	e5832008 	str	r2, [r3, #8]
        taskEXIT_CRITICAL();
 510a520:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a524:	e7862004 	str	r2, [r6, r4]
        taskEXIT_CRITICAL();
 510a528:	e3403510 	movt	r3, #1296	; 0x510
 510a52c:	e12fff33 	blx	r3
                vTaskDelete( xInternalTaskHandle );
 510a530:	e3043a08 	movw	r3, #18952	; 0x4a08
 510a534:	e1a00005 	mov	r0, r5
 510a538:	e3403510 	movt	r3, #1296	; 0x510
 510a53c:	e12fff33 	blx	r3
 510a540:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        configASSERT( xHandle != NULL );
 510a544:	e30d0b50 	movw	r0, #56144	; 0xdb50
 510a548:	e3003900 	movw	r3, #2304	; 0x900
 510a54c:	e300112e 	movw	r1, #302	; 0x12e
 510a550:	e3403511 	movt	r3, #1297	; 0x511
 510a554:	e3400512 	movt	r0, #1298	; 0x512
 510a558:	e12fff33 	blx	r3
 510a55c:	eaffffd7 	b	510a4c0 <MPU_vTaskDelete+0xa4>

0510a560 <MPU_vTaskPrioritySet>:
            if( pxTask == NULL )
 510a560:	e2503000 	subs	r3, r0, #0
        {
 510a564:	e92d4010 	push	{r4, lr}
            if( pxTask == NULL )
 510a568:	0a00000d 	beq	510a5a4 <MPU_vTaskPrioritySet+0x44>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a56c:	e2430001 	sub	r0, r3, #1
 510a570:	e350007f 	cmp	r0, #127	; 0x7f
 510a574:	88bd8010 	pophi	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a578:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a57c:	e0800080 	add	r0, r0, r0, lsl #1
 510a580:	e3403512 	movt	r3, #1298	; 0x512
 510a584:	e0832100 	add	r2, r3, r0, lsl #2
 510a588:	e1a00100 	lsl	r0, r0, #2
 510a58c:	e5922004 	ldr	r2, [r2, #4]
 510a590:	e3520002 	cmp	r2, #2
 510a594:	18bd8010 	popne	{r4, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a598:	e7930000 	ldr	r0, [r3, r0]
                    if( xInternalTaskHandle != NULL )
 510a59c:	e3500000 	cmp	r0, #0
 510a5a0:	08bd8010 	popeq	{r4, pc}
                        vTaskPrioritySet( xInternalTaskHandle, uxNewPriority );
 510a5a4:	e3043d5c 	movw	r3, #19804	; 0x4d5c
 510a5a8:	e3403510 	movt	r3, #1296	; 0x510
 510a5ac:	e12fff33 	blx	r3
        }
 510a5b0:	e8bd8010 	pop	{r4, pc}

0510a5b4 <MPU_xTaskGetHandle>:
            xInternalTaskHandle = xTaskGetHandle( pcNameToQuery );
 510a5b4:	e3063378 	movw	r3, #25464	; 0x6378
        {
 510a5b8:	e92d4010 	push	{r4, lr}
            xInternalTaskHandle = xTaskGetHandle( pcNameToQuery );
 510a5bc:	e3403510 	movt	r3, #1296	; 0x510
 510a5c0:	e12fff33 	blx	r3
            if( xInternalTaskHandle != NULL )
 510a5c4:	e3500000 	cmp	r0, #0
 510a5c8:	08bd8010 	popeq	{r4, pc}
 510a5cc:	e3063fa8 	movw	r3, #28584	; 0x6fa8
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a5d0:	e3a02000 	mov	r2, #0
 510a5d4:	e3403512 	movt	r3, #1298	; 0x512
 510a5d8:	ea000003 	b	510a5ec <MPU_xTaskGetHandle+0x38>
 510a5dc:	e2822001 	add	r2, r2, #1
 510a5e0:	e3520080 	cmp	r2, #128	; 0x80
 510a5e4:	e283300c 	add	r3, r3, #12
 510a5e8:	0a000007 	beq	510a60c <MPU_xTaskGetHandle+0x58>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 510a5ec:	e5931000 	ldr	r1, [r3]
 510a5f0:	e1500001 	cmp	r0, r1
 510a5f4:	1afffff8 	bne	510a5dc <MPU_xTaskGetHandle+0x28>
 510a5f8:	e5931004 	ldr	r1, [r3, #4]
 510a5fc:	e3510002 	cmp	r1, #2
 510a600:	1afffff5 	bne	510a5dc <MPU_xTaskGetHandle+0x28>
                    xExternalTaskHandle = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510a604:	e2820001 	add	r0, r2, #1
        }
 510a608:	e8bd8010 	pop	{r4, pc}
            TaskHandle_t xExternalTaskHandle = NULL;
 510a60c:	e3a00000 	mov	r0, #0
            return xExternalTaskHandle;
 510a610:	e8bd8010 	pop	{r4, pc}

0510a614 <MPU_pcTaskGetName>:
        if( xTaskToQuery == NULL )
 510a614:	e2503000 	subs	r3, r0, #0
    {
 510a618:	e92d4010 	push	{r4, lr}
        if( xTaskToQuery == NULL )
 510a61c:	0a00000d 	beq	510a658 <MPU_pcTaskGetName+0x44>
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a620:	e2430001 	sub	r0, r3, #1
 510a624:	e350007f 	cmp	r0, #127	; 0x7f
 510a628:	8a00000e 	bhi	510a668 <MPU_pcTaskGetName+0x54>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a62c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a630:	e0800080 	add	r0, r0, r0, lsl #1
 510a634:	e3403512 	movt	r3, #1298	; 0x512
 510a638:	e0832100 	add	r2, r3, r0, lsl #2
 510a63c:	e1a00100 	lsl	r0, r0, #2
 510a640:	e5922004 	ldr	r2, [r2, #4]
 510a644:	e3520002 	cmp	r2, #2
 510a648:	1a000006 	bne	510a668 <MPU_pcTaskGetName+0x54>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a64c:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalTaskHandle != NULL )
 510a650:	e3500000 	cmp	r0, #0
 510a654:	0a000003 	beq	510a668 <MPU_pcTaskGetName+0x54>
                    pcReturn = pcTaskGetName( xInternalTaskHandle );
 510a658:	e30532e8 	movw	r3, #21224	; 0x52e8
 510a65c:	e3403510 	movt	r3, #1296	; 0x510
 510a660:	e12fff33 	blx	r3
    }
 510a664:	e8bd8010 	pop	{r4, pc}
        char * pcReturn = NULL;
 510a668:	e3a00000 	mov	r0, #0
 510a66c:	e8bd8010 	pop	{r4, pc}

0510a670 <MPU_xTaskCreateRestricted>:
        {
 510a670:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510a674:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510a678:	e24dd00c 	sub	sp, sp, #12
            TaskHandle_t xInternalTaskHandle = NULL;
 510a67c:	e3a04000 	mov	r4, #0
        vTaskSuspendAll();
 510a680:	e3403510 	movt	r3, #1296	; 0x510
 510a684:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        {
 510a688:	e1a07000 	mov	r7, r0
 510a68c:	e1a08001 	mov	r8, r1
 510a690:	e3406512 	movt	r6, #1298	; 0x512
            TaskHandle_t xInternalTaskHandle = NULL;
 510a694:	e58d4004 	str	r4, [sp, #4]
        vTaskSuspendAll();
 510a698:	e12fff33 	blx	r3
 510a69c:	e1a03004 	mov	r3, r4
 510a6a0:	ea000002 	b	510a6b0 <MPU_xTaskCreateRestricted+0x40>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a6a4:	e2844001 	add	r4, r4, #1
 510a6a8:	e3540080 	cmp	r4, #128	; 0x80
 510a6ac:	0a00002f 	beq	510a770 <MPU_xTaskCreateRestricted+0x100>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a6b0:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a6b4:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a6b8:	e3550000 	cmp	r5, #0
 510a6bc:	1afffff8 	bne	510a6a4 <MPU_xTaskCreateRestricted+0x34>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a6c0:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510a6c4:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a6c8:	e3e01000 	mvn	r1, #0
 510a6cc:	e1a0a103 	lsl	sl, r3, #2
        ( void ) xTaskResumeAll();
 510a6d0:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a6d4:	e786100a 	str	r1, [r6, sl]
 510a6d8:	e0869103 	add	r9, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510a6dc:	e12fff32 	blx	r2
                xReturn = xTaskCreateRestricted( pxTaskDefinition, &( xInternalTaskHandle ) );
 510a6e0:	e30437f4 	movw	r3, #18420	; 0x47f4
 510a6e4:	e1a00007 	mov	r0, r7
 510a6e8:	e3403510 	movt	r3, #1296	; 0x510
 510a6ec:	e28d1004 	add	r1, sp, #4
 510a6f0:	e12fff33 	blx	r3
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a6f4:	e1a0b084 	lsl	fp, r4, #1
                xReturn = xTaskCreateRestricted( pxTaskDefinition, &( xInternalTaskHandle ) );
 510a6f8:	e1a07000 	mov	r7, r0
                if( ( xReturn == pdPASS ) && ( xInternalTaskHandle != NULL ) )
 510a6fc:	e3500001 	cmp	r0, #1
 510a700:	1a00000a 	bne	510a730 <MPU_xTaskCreateRestricted+0xc0>
 510a704:	e59d3004 	ldr	r3, [sp, #4]
 510a708:	e3530000 	cmp	r3, #0
 510a70c:	0a000007 	beq	510a730 <MPU_xTaskCreateRestricted+0xc0>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510a710:	e786300a 	str	r3, [r6, sl]
                    if( pxCreatedTask != NULL )
 510a714:	e3580000 	cmp	r8, #0
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510a718:	e5895008 	str	r5, [r9, #8]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a71c:	e3a03002 	mov	r3, #2
 510a720:	e5893004 	str	r3, [r9, #4]
                        *pxCreatedTask = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510a724:	12844001 	addne	r4, r4, #1
 510a728:	15884000 	strne	r4, [r8]
            return xReturn;
 510a72c:	ea00000c 	b	510a764 <MPU_xTaskCreateRestricted+0xf4>
        taskENTER_CRITICAL();
 510a730:	e30c3930 	movw	r3, #51504	; 0xc930
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a734:	e08b4004 	add	r4, fp, r4
        taskENTER_CRITICAL();
 510a738:	e3403510 	movt	r3, #1296	; 0x510
 510a73c:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a740:	e3a02000 	mov	r2, #0
 510a744:	e0863104 	add	r3, r6, r4, lsl #2
 510a748:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a74c:	e5832004 	str	r2, [r3, #4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a750:	e5832008 	str	r2, [r3, #8]
        taskEXIT_CRITICAL();
 510a754:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a758:	e7862004 	str	r2, [r6, r4]
        taskEXIT_CRITICAL();
 510a75c:	e3403510 	movt	r3, #1296	; 0x510
 510a760:	e12fff33 	blx	r3
        }
 510a764:	e1a00007 	mov	r0, r7
 510a768:	e28dd00c 	add	sp, sp, #12
 510a76c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510a770:	e3053efc 	movw	r3, #24316	; 0x5efc
            BaseType_t xReturn = pdFAIL;
 510a774:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510a778:	e3403510 	movt	r3, #1296	; 0x510
 510a77c:	e12fff33 	blx	r3
        }
 510a780:	e1a00007 	mov	r0, r7
 510a784:	e28dd00c 	add	sp, sp, #12
 510a788:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510a78c <MPU_xTaskCreateRestrictedStatic>:
        {
 510a78c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510a790:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510a794:	e24dd00c 	sub	sp, sp, #12
            TaskHandle_t xInternalTaskHandle = NULL;
 510a798:	e3a04000 	mov	r4, #0
        vTaskSuspendAll();
 510a79c:	e3403510 	movt	r3, #1296	; 0x510
 510a7a0:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        {
 510a7a4:	e1a07000 	mov	r7, r0
 510a7a8:	e1a08001 	mov	r8, r1
 510a7ac:	e3406512 	movt	r6, #1298	; 0x512
            TaskHandle_t xInternalTaskHandle = NULL;
 510a7b0:	e58d4004 	str	r4, [sp, #4]
        vTaskSuspendAll();
 510a7b4:	e12fff33 	blx	r3
 510a7b8:	e1a03004 	mov	r3, r4
 510a7bc:	ea000002 	b	510a7cc <MPU_xTaskCreateRestrictedStatic+0x40>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a7c0:	e2844001 	add	r4, r4, #1
 510a7c4:	e3540080 	cmp	r4, #128	; 0x80
 510a7c8:	0a00002f 	beq	510a88c <MPU_xTaskCreateRestrictedStatic+0x100>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a7cc:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510a7d0:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510a7d4:	e3550000 	cmp	r5, #0
 510a7d8:	1afffff8 	bne	510a7c0 <MPU_xTaskCreateRestrictedStatic+0x34>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a7dc:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510a7e0:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a7e4:	e3e01000 	mvn	r1, #0
 510a7e8:	e1a0a103 	lsl	sl, r3, #2
        ( void ) xTaskResumeAll();
 510a7ec:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a7f0:	e786100a 	str	r1, [r6, sl]
 510a7f4:	e0869103 	add	r9, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510a7f8:	e12fff32 	blx	r2
                xReturn = xTaskCreateRestrictedStatic( pxTaskDefinition, &( xInternalTaskHandle ) );
 510a7fc:	e30438b8 	movw	r3, #18616	; 0x48b8
 510a800:	e1a00007 	mov	r0, r7
 510a804:	e3403510 	movt	r3, #1296	; 0x510
 510a808:	e28d1004 	add	r1, sp, #4
 510a80c:	e12fff33 	blx	r3
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510a810:	e1a0b084 	lsl	fp, r4, #1
                xReturn = xTaskCreateRestrictedStatic( pxTaskDefinition, &( xInternalTaskHandle ) );
 510a814:	e1a07000 	mov	r7, r0
                if( ( xReturn == pdPASS ) && ( xInternalTaskHandle != NULL ) )
 510a818:	e3500001 	cmp	r0, #1
 510a81c:	1a00000a 	bne	510a84c <MPU_xTaskCreateRestrictedStatic+0xc0>
 510a820:	e59d3004 	ldr	r3, [sp, #4]
 510a824:	e3530000 	cmp	r3, #0
 510a828:	0a000007 	beq	510a84c <MPU_xTaskCreateRestrictedStatic+0xc0>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510a82c:	e786300a 	str	r3, [r6, sl]
                    if( pxCreatedTask != NULL )
 510a830:	e3580000 	cmp	r8, #0
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510a834:	e5895008 	str	r5, [r9, #8]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510a838:	e3a03002 	mov	r3, #2
 510a83c:	e5893004 	str	r3, [r9, #4]
                        *pxCreatedTask = ( TaskHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510a840:	12844001 	addne	r4, r4, #1
 510a844:	15884000 	strne	r4, [r8]
            return xReturn;
 510a848:	ea00000c 	b	510a880 <MPU_xTaskCreateRestrictedStatic+0xf4>
        taskENTER_CRITICAL();
 510a84c:	e30c3930 	movw	r3, #51504	; 0xc930
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a850:	e08b4004 	add	r4, fp, r4
        taskENTER_CRITICAL();
 510a854:	e3403510 	movt	r3, #1296	; 0x510
 510a858:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a85c:	e3a02000 	mov	r2, #0
 510a860:	e0863104 	add	r3, r6, r4, lsl #2
 510a864:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510a868:	e5832004 	str	r2, [r3, #4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510a86c:	e5832008 	str	r2, [r3, #8]
        taskEXIT_CRITICAL();
 510a870:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510a874:	e7862004 	str	r2, [r6, r4]
        taskEXIT_CRITICAL();
 510a878:	e3403510 	movt	r3, #1296	; 0x510
 510a87c:	e12fff33 	blx	r3
        }
 510a880:	e1a00007 	mov	r0, r7
 510a884:	e28dd00c 	add	sp, sp, #12
 510a888:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510a88c:	e3053efc 	movw	r3, #24316	; 0x5efc
            BaseType_t xReturn = pdFAIL;
 510a890:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510a894:	e3403510 	movt	r3, #1296	; 0x510
 510a898:	e12fff33 	blx	r3
        }
 510a89c:	e1a00007 	mov	r0, r7
 510a8a0:	e28dd00c 	add	sp, sp, #12
 510a8a4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510a8a8 <MPU_vTaskAllocateMPURegions>:
        if( xTaskToModify == NULL )
 510a8a8:	e2503000 	subs	r3, r0, #0
    {
 510a8ac:	e92d4010 	push	{r4, lr}
        if( xTaskToModify == NULL )
 510a8b0:	0a00000d 	beq	510a8ec <MPU_vTaskAllocateMPURegions+0x44>
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a8b4:	e2430001 	sub	r0, r3, #1
 510a8b8:	e350007f 	cmp	r0, #127	; 0x7f
 510a8bc:	88bd8010 	pophi	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a8c0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a8c4:	e0800080 	add	r0, r0, r0, lsl #1
 510a8c8:	e3403512 	movt	r3, #1298	; 0x512
 510a8cc:	e0832100 	add	r2, r3, r0, lsl #2
 510a8d0:	e1a00100 	lsl	r0, r0, #2
 510a8d4:	e5922004 	ldr	r2, [r2, #4]
 510a8d8:	e3520002 	cmp	r2, #2
 510a8dc:	18bd8010 	popne	{r4, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a8e0:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalTaskHandle != NULL )
 510a8e4:	e3500000 	cmp	r0, #0
 510a8e8:	08bd8010 	popeq	{r4, pc}
                    vTaskAllocateMPURegions( xInternalTaskHandle, xRegions );
 510a8ec:	e30439d8 	movw	r3, #18904	; 0x49d8
 510a8f0:	e3403510 	movt	r3, #1296	; 0x510
 510a8f4:	e12fff33 	blx	r3
    }
 510a8f8:	e8bd8010 	pop	{r4, pc}

0510a8fc <MPU_xTaskGetStaticBuffers>:
            if( xTask == NULL )
 510a8fc:	e3500000 	cmp	r0, #0
        {
 510a900:	e92d4070 	push	{r4, r5, r6, lr}
            if( xTask == NULL )
 510a904:	0a000013 	beq	510a958 <MPU_xTaskGetStaticBuffers+0x5c>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a908:	e2400001 	sub	r0, r0, #1
 510a90c:	e350007f 	cmp	r0, #127	; 0x7f
 510a910:	9a000001 	bls	510a91c <MPU_xTaskGetStaticBuffers+0x20>
            BaseType_t xReturn = pdFALSE;
 510a914:	e3a00000 	mov	r0, #0
 510a918:	e8bd8070 	pop	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a91c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a920:	e0800080 	add	r0, r0, r0, lsl #1
 510a924:	e3403512 	movt	r3, #1298	; 0x512
 510a928:	e1a0c100 	lsl	ip, r0, #2
 510a92c:	e0830100 	add	r0, r3, r0, lsl #2
 510a930:	e5900004 	ldr	r0, [r0, #4]
 510a934:	e3500002 	cmp	r0, #2
 510a938:	1afffff5 	bne	510a914 <MPU_xTaskGetStaticBuffers+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a93c:	e793000c 	ldr	r0, [r3, ip]
                    if( xInternalTaskHandle != NULL )
 510a940:	e3500000 	cmp	r0, #0
 510a944:	0afffff2 	beq	510a914 <MPU_xTaskGetStaticBuffers+0x18>
                        xReturn = xTaskGetStaticBuffers( xInternalTaskHandle, ppuxStackBuffer, ppxTaskBuffer );
 510a948:	e3053330 	movw	r3, #21296	; 0x5330
 510a94c:	e3403510 	movt	r3, #1296	; 0x510
 510a950:	e12fff33 	blx	r3
        }
 510a954:	e8bd8070 	pop	{r4, r5, r6, pc}
                xInternalTaskHandle = xTaskGetCurrentTaskHandle();
 510a958:	e3063dec 	movw	r3, #28140	; 0x6dec
 510a95c:	e1a04001 	mov	r4, r1
 510a960:	e1a05002 	mov	r5, r2
 510a964:	e3403510 	movt	r3, #1296	; 0x510
 510a968:	e12fff33 	blx	r3
                xReturn = xTaskGetStaticBuffers( xInternalTaskHandle, ppuxStackBuffer, ppxTaskBuffer );
 510a96c:	e3053330 	movw	r3, #21296	; 0x5330
 510a970:	e1a02005 	mov	r2, r5
 510a974:	e1a01004 	mov	r1, r4
 510a978:	e3403510 	movt	r3, #1296	; 0x510
 510a97c:	e12fff33 	blx	r3
 510a980:	e8bd8070 	pop	{r4, r5, r6, pc}

0510a984 <MPU_uxTaskPriorityGetFromISR>:
            if( xTask == NULL )
 510a984:	e2503000 	subs	r3, r0, #0
        {
 510a988:	e92d4010 	push	{r4, lr}
            if( xTask == NULL )
 510a98c:	0a00000f 	beq	510a9d0 <MPU_uxTaskPriorityGetFromISR+0x4c>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a990:	e2430001 	sub	r0, r3, #1
 510a994:	e350007f 	cmp	r0, #127	; 0x7f
 510a998:	9a000001 	bls	510a9a4 <MPU_uxTaskPriorityGetFromISR+0x20>
            UBaseType_t uxReturn = configMAX_PRIORITIES;
 510a99c:	e3a00007 	mov	r0, #7
 510a9a0:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510a9a4:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510a9a8:	e0800080 	add	r0, r0, r0, lsl #1
 510a9ac:	e3403512 	movt	r3, #1298	; 0x512
 510a9b0:	e0832100 	add	r2, r3, r0, lsl #2
 510a9b4:	e1a00100 	lsl	r0, r0, #2
 510a9b8:	e5922004 	ldr	r2, [r2, #4]
 510a9bc:	e3520002 	cmp	r2, #2
 510a9c0:	1afffff5 	bne	510a99c <MPU_uxTaskPriorityGetFromISR+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510a9c4:	e7930000 	ldr	r0, [r3, r0]
                    if( xInternalTaskHandle != NULL )
 510a9c8:	e3500000 	cmp	r0, #0
 510a9cc:	0afffff2 	beq	510a99c <MPU_uxTaskPriorityGetFromISR+0x18>
                        uxReturn = uxTaskPriorityGetFromISR( xInternalTaskHandle );
 510a9d0:	e3043c0c 	movw	r3, #19468	; 0x4c0c
 510a9d4:	e3403510 	movt	r3, #1296	; 0x510
 510a9d8:	e12fff33 	blx	r3
        }
 510a9dc:	e8bd8010 	pop	{r4, pc}

0510a9e0 <MPU_uxTaskBasePriorityGet>:
            if( xTask == NULL )
 510a9e0:	e2503000 	subs	r3, r0, #0
        {
 510a9e4:	e92d4010 	push	{r4, lr}
            if( xTask == NULL )
 510a9e8:	0a00000f 	beq	510aa2c <MPU_uxTaskBasePriorityGet+0x4c>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510a9ec:	e2430001 	sub	r0, r3, #1
 510a9f0:	e350007f 	cmp	r0, #127	; 0x7f
 510a9f4:	9a000001 	bls	510aa00 <MPU_uxTaskBasePriorityGet+0x20>
            UBaseType_t uxReturn = configMAX_PRIORITIES;
 510a9f8:	e3a00007 	mov	r0, #7
 510a9fc:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510aa00:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510aa04:	e0800080 	add	r0, r0, r0, lsl #1
 510aa08:	e3403512 	movt	r3, #1298	; 0x512
 510aa0c:	e0832100 	add	r2, r3, r0, lsl #2
 510aa10:	e1a00100 	lsl	r0, r0, #2
 510aa14:	e5922004 	ldr	r2, [r2, #4]
 510aa18:	e3520002 	cmp	r2, #2
 510aa1c:	1afffff5 	bne	510a9f8 <MPU_uxTaskBasePriorityGet+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510aa20:	e7930000 	ldr	r0, [r3, r0]
                    if( xInternalTaskHandle != NULL )
 510aa24:	e3500000 	cmp	r0, #0
 510aa28:	0afffff2 	beq	510a9f8 <MPU_uxTaskBasePriorityGet+0x18>
                        uxReturn = uxTaskBasePriorityGet( xInternalTaskHandle );
 510aa2c:	e3043c24 	movw	r3, #19492	; 0x4c24
 510aa30:	e3403510 	movt	r3, #1296	; 0x510
 510aa34:	e12fff33 	blx	r3
        }
 510aa38:	e8bd8010 	pop	{r4, pc}

0510aa3c <MPU_uxTaskBasePriorityGetFromISR>:
            if( xTask == NULL )
 510aa3c:	e2503000 	subs	r3, r0, #0
        {
 510aa40:	e92d4010 	push	{r4, lr}
            if( xTask == NULL )
 510aa44:	0a00000f 	beq	510aa88 <MPU_uxTaskBasePriorityGetFromISR+0x4c>
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510aa48:	e2430001 	sub	r0, r3, #1
 510aa4c:	e350007f 	cmp	r0, #127	; 0x7f
 510aa50:	9a000001 	bls	510aa5c <MPU_uxTaskBasePriorityGetFromISR+0x20>
            UBaseType_t uxReturn = configMAX_PRIORITIES;
 510aa54:	e3a00007 	mov	r0, #7
 510aa58:	e8bd8010 	pop	{r4, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510aa5c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510aa60:	e0800080 	add	r0, r0, r0, lsl #1
 510aa64:	e3403512 	movt	r3, #1298	; 0x512
 510aa68:	e0832100 	add	r2, r3, r0, lsl #2
 510aa6c:	e1a00100 	lsl	r0, r0, #2
 510aa70:	e5922004 	ldr	r2, [r2, #4]
 510aa74:	e3520002 	cmp	r2, #2
 510aa78:	1afffff5 	bne	510aa54 <MPU_uxTaskBasePriorityGetFromISR+0x18>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510aa7c:	e7930000 	ldr	r0, [r3, r0]
                    if( xInternalTaskHandle != NULL )
 510aa80:	e3500000 	cmp	r0, #0
 510aa84:	0afffff2 	beq	510aa54 <MPU_uxTaskBasePriorityGetFromISR+0x18>
                        uxReturn = uxTaskBasePriorityGetFromISR( xInternalTaskHandle );
 510aa88:	e3043c6c 	movw	r3, #19564	; 0x4c6c
 510aa8c:	e3403510 	movt	r3, #1296	; 0x510
 510aa90:	e12fff33 	blx	r3
        }
 510aa94:	e8bd8010 	pop	{r4, pc}

0510aa98 <MPU_xTaskResumeFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510aa98:	e2400001 	sub	r0, r0, #1
 510aa9c:	e350007f 	cmp	r0, #127	; 0x7f
 510aaa0:	9a000001 	bls	510aaac <MPU_xTaskResumeFromISR+0x14>
            BaseType_t xReturn = pdFAIL;
 510aaa4:	e3a00000 	mov	r0, #0
        }
 510aaa8:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510aaac:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510aab0:	e0800080 	add	r0, r0, r0, lsl #1
 510aab4:	e3403512 	movt	r3, #1298	; 0x512
 510aab8:	e0832100 	add	r2, r3, r0, lsl #2
 510aabc:	e1a00100 	lsl	r0, r0, #2
 510aac0:	e5922004 	ldr	r2, [r2, #4]
 510aac4:	e3520002 	cmp	r2, #2
 510aac8:	1afffff5 	bne	510aaa4 <MPU_xTaskResumeFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510aacc:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalTaskHandle != NULL )
 510aad0:	e3500000 	cmp	r0, #0
 510aad4:	0afffff2 	beq	510aaa4 <MPU_xTaskResumeFromISR+0xc>
                    xReturn = xTaskResumeFromISR( xInternalTaskHandle );
 510aad8:	e3053010 	movw	r3, #20496	; 0x5010
 510aadc:	e3403510 	movt	r3, #1296	; 0x510
        {
 510aae0:	e92d4010 	push	{r4, lr}
                    xReturn = xTaskResumeFromISR( xInternalTaskHandle );
 510aae4:	e12fff33 	blx	r3
        }
 510aae8:	e8bd8010 	pop	{r4, pc}

0510aaec <MPU_xTaskGenericNotifyFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510aaec:	e2400001 	sub	r0, r0, #1
 510aaf0:	e350007f 	cmp	r0, #127	; 0x7f
 510aaf4:	9a000001 	bls	510ab00 <MPU_xTaskGenericNotifyFromISR+0x14>
            BaseType_t xReturn = pdFAIL;
 510aaf8:	e3a00000 	mov	r0, #0
        }
 510aafc:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510ab00:	e306cfa8 	movw	ip, #28584	; 0x6fa8
 510ab04:	e0800080 	add	r0, r0, r0, lsl #1
 510ab08:	e340c512 	movt	ip, #1298	; 0x512
        {
 510ab0c:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510ab10:	e08ce100 	add	lr, ip, r0, lsl #2
        {
 510ab14:	e24dd008 	sub	sp, sp, #8
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510ab18:	e1a00100 	lsl	r0, r0, #2
 510ab1c:	e59ee004 	ldr	lr, [lr, #4]
 510ab20:	e35e0002 	cmp	lr, #2
 510ab24:	1a00000b 	bne	510ab58 <MPU_xTaskGenericNotifyFromISR+0x6c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510ab28:	e79c0000 	ldr	r0, [ip, r0]
                if( xInternalTaskHandle != NULL )
 510ab2c:	e3500000 	cmp	r0, #0
 510ab30:	0a000008 	beq	510ab58 <MPU_xTaskGenericNotifyFromISR+0x6c>
                    xReturn = xTaskGenericNotifyFromISR( xInternalTaskHandle, uxIndexToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken );
 510ab34:	e59dc014 	ldr	ip, [sp, #20]
 510ab38:	e3054640 	movw	r4, #22080	; 0x5640
 510ab3c:	e58dc004 	str	ip, [sp, #4]
 510ab40:	e3404510 	movt	r4, #1296	; 0x510
 510ab44:	e59dc010 	ldr	ip, [sp, #16]
 510ab48:	e58dc000 	str	ip, [sp]
 510ab4c:	e12fff34 	blx	r4
        }
 510ab50:	e28dd008 	add	sp, sp, #8
 510ab54:	e8bd8010 	pop	{r4, pc}
            BaseType_t xReturn = pdFAIL;
 510ab58:	e3a00000 	mov	r0, #0
        }
 510ab5c:	e28dd008 	add	sp, sp, #8
 510ab60:	e8bd8010 	pop	{r4, pc}

0510ab64 <MPU_vTaskGenericNotifyGiveFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510ab64:	e2400001 	sub	r0, r0, #1
 510ab68:	e350007f 	cmp	r0, #127	; 0x7f
 510ab6c:	812fff1e 	bxhi	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510ab70:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510ab74:	e0800080 	add	r0, r0, r0, lsl #1
 510ab78:	e3403512 	movt	r3, #1298	; 0x512
 510ab7c:	e1a0c100 	lsl	ip, r0, #2
 510ab80:	e0830100 	add	r0, r3, r0, lsl #2
 510ab84:	e5900004 	ldr	r0, [r0, #4]
 510ab88:	e3500002 	cmp	r0, #2
 510ab8c:	112fff1e 	bxne	lr
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510ab90:	e793000c 	ldr	r0, [r3, ip]
                if( xInternalTaskHandle != NULL )
 510ab94:	e3500000 	cmp	r0, #0
 510ab98:	012fff1e 	bxeq	lr
                    vTaskGenericNotifyGiveFromISR( xInternalTaskHandle, uxIndexToNotify, pxHigherPriorityTaskWoken );
 510ab9c:	e3053894 	movw	r3, #22676	; 0x5894
 510aba0:	e3403510 	movt	r3, #1296	; 0x510
        {
 510aba4:	e92d4010 	push	{r4, lr}
                    vTaskGenericNotifyGiveFromISR( xInternalTaskHandle, uxIndexToNotify, pxHigherPriorityTaskWoken );
 510aba8:	e12fff33 	blx	r3
        }
 510abac:	e8bd8010 	pop	{r4, pc}

0510abb0 <MPU_vQueueDelete>:
    {
 510abb0:	e92d4070 	push	{r4, r5, r6, lr}
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510abb4:	e2404001 	sub	r4, r0, #1
 510abb8:	e354007f 	cmp	r4, #127	; 0x7f
 510abbc:	88bd8070 	pophi	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510abc0:	e3065fa8 	movw	r5, #28584	; 0x6fa8
 510abc4:	e0843084 	add	r3, r4, r4, lsl #1
 510abc8:	e3405512 	movt	r5, #1298	; 0x512
 510abcc:	e1a02103 	lsl	r2, r3, #2
 510abd0:	e0853103 	add	r3, r5, r3, lsl #2
 510abd4:	e1a06084 	lsl	r6, r4, #1
 510abd8:	e5933004 	ldr	r3, [r3, #4]
 510abdc:	e3530001 	cmp	r3, #1
 510abe0:	18bd8070 	popne	{r4, r5, r6, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510abe4:	e7950002 	ldr	r0, [r5, r2]
            if( xInternalQueueHandle != NULL )
 510abe8:	e3500000 	cmp	r0, #0
 510abec:	08bd8070 	popeq	{r4, r5, r6, pc}
                vQueueDelete( xInternalQueueHandle );
 510abf0:	e30139b8 	movw	r3, #6584	; 0x19b8
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510abf4:	e0844006 	add	r4, r4, r6
                vQueueDelete( xInternalQueueHandle );
 510abf8:	e3403510 	movt	r3, #1296	; 0x510
 510abfc:	e12fff33 	blx	r3
        taskENTER_CRITICAL();
 510ac00:	e30c3930 	movw	r3, #51504	; 0xc930
 510ac04:	e3403510 	movt	r3, #1296	; 0x510
 510ac08:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510ac0c:	e3a02000 	mov	r2, #0
        taskEXIT_CRITICAL();
 510ac10:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510ac14:	e0851104 	add	r1, r5, r4, lsl #2
 510ac18:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510ac1c:	e5812004 	str	r2, [r1, #4]
        taskEXIT_CRITICAL();
 510ac20:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510ac24:	e7852004 	str	r2, [r5, r4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510ac28:	e5812008 	str	r2, [r1, #8]
        taskEXIT_CRITICAL();
 510ac2c:	e12fff33 	blx	r3
    }
 510ac30:	e8bd8070 	pop	{r4, r5, r6, pc}

0510ac34 <MPU_xQueueCreateMutex>:
        vTaskSuspendAll();
 510ac34:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510ac38:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510ac3c:	e1a07000 	mov	r7, r0
        vTaskSuspendAll();
 510ac40:	e3403510 	movt	r3, #1296	; 0x510
 510ac44:	e12fff33 	blx	r3
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ac48:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510ac4c:	e3a03000 	mov	r3, #0
 510ac50:	e3406512 	movt	r6, #1298	; 0x512
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ac54:	e1a04003 	mov	r4, r3
 510ac58:	ea000002 	b	510ac68 <MPU_xQueueCreateMutex+0x34>
 510ac5c:	e2844001 	add	r4, r4, #1
 510ac60:	e3540080 	cmp	r4, #128	; 0x80
 510ac64:	0a000017 	beq	510acc8 <MPU_xQueueCreateMutex+0x94>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ac68:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ac6c:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ac70:	e3550000 	cmp	r5, #0
 510ac74:	1afffff8 	bne	510ac5c <MPU_xQueueCreateMutex+0x28>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ac78:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510ac7c:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ac80:	e3e01000 	mvn	r1, #0
 510ac84:	e1a09103 	lsl	r9, r3, #2
        ( void ) xTaskResumeAll();
 510ac88:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ac8c:	e7861009 	str	r1, [r6, r9]
 510ac90:	e0868103 	add	r8, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510ac94:	e12fff32 	blx	r2
                xInternalQueueHandle = xQueueCreateMutex( ucQueueType );
 510ac98:	e3023b50 	movw	r3, #11088	; 0x2b50
 510ac9c:	e1a00007 	mov	r0, r7
 510aca0:	e3403510 	movt	r3, #1296	; 0x510
 510aca4:	e12fff33 	blx	r3
                if( xInternalQueueHandle != NULL )
 510aca8:	e2507000 	subs	r7, r0, #0
 510acac:	0a00000b 	beq	510ace0 <MPU_xQueueCreateMutex+0xac>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510acb0:	e7867009 	str	r7, [r6, r9]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510acb4:	e3a03001 	mov	r3, #1
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510acb8:	e0847003 	add	r7, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510acbc:	e9880028 	stmib	r8, {r3, r5}
        }
 510acc0:	e1a00007 	mov	r0, r7
 510acc4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510acc8:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510accc:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510acd0:	e3403510 	movt	r3, #1296	; 0x510
 510acd4:	e12fff33 	blx	r3
        }
 510acd8:	e1a00007 	mov	r0, r7
 510acdc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510ace0:	e30c3930 	movw	r3, #51504	; 0xc930
 510ace4:	e3403510 	movt	r3, #1296	; 0x510
 510ace8:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510acec:	e7867009 	str	r7, [r6, r9]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510acf0:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510acf4:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510acf8:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510acfc:	e3403510 	movt	r3, #1296	; 0x510
 510ad00:	e12fff33 	blx	r3
        }
 510ad04:	e1a00007 	mov	r0, r7
 510ad08:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510ad0c <MPU_xQueueCreateMutexStatic>:
        {
 510ad0c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
        vTaskSuspendAll();
 510ad10:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510ad14:	e24dd008 	sub	sp, sp, #8
 510ad18:	e1a07000 	mov	r7, r0
        vTaskSuspendAll();
 510ad1c:	e3403510 	movt	r3, #1296	; 0x510
        {
 510ad20:	e1a09001 	mov	r9, r1
 510ad24:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510ad28:	e58d1004 	str	r1, [sp, #4]
        vTaskSuspendAll();
 510ad2c:	e12fff33 	blx	r3
 510ad30:	e3a03000 	mov	r3, #0
 510ad34:	e3406512 	movt	r6, #1298	; 0x512
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ad38:	e1a04003 	mov	r4, r3
 510ad3c:	ea000002 	b	510ad4c <MPU_xQueueCreateMutexStatic+0x40>
 510ad40:	e2844001 	add	r4, r4, #1
 510ad44:	e3540080 	cmp	r4, #128	; 0x80
 510ad48:	0a000019 	beq	510adb4 <MPU_xQueueCreateMutexStatic+0xa8>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ad4c:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ad50:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ad54:	e3550000 	cmp	r5, #0
 510ad58:	1afffff8 	bne	510ad40 <MPU_xQueueCreateMutexStatic+0x34>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ad5c:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510ad60:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ad64:	e3e01000 	mvn	r1, #0
 510ad68:	e1a0a103 	lsl	sl, r3, #2
        ( void ) xTaskResumeAll();
 510ad6c:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ad70:	e786100a 	str	r1, [r6, sl]
 510ad74:	e0868103 	add	r8, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510ad78:	e12fff32 	blx	r2
                xInternalQueueHandle = xQueueCreateMutexStatic( ucQueueType, pxStaticQueue );
 510ad7c:	e3023a88 	movw	r3, #10888	; 0x2a88
 510ad80:	e1a00007 	mov	r0, r7
 510ad84:	e1a01009 	mov	r1, r9
 510ad88:	e3403510 	movt	r3, #1296	; 0x510
 510ad8c:	e12fff33 	blx	r3
                if( xInternalQueueHandle != NULL )
 510ad90:	e2507000 	subs	r7, r0, #0
 510ad94:	0a00000d 	beq	510add0 <MPU_xQueueCreateMutexStatic+0xc4>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510ad98:	e786700a 	str	r7, [r6, sl]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510ad9c:	e3a03001 	mov	r3, #1
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510ada0:	e0847003 	add	r7, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510ada4:	e9880028 	stmib	r8, {r3, r5}
        }
 510ada8:	e1a00007 	mov	r0, r7
 510adac:	e28dd008 	add	sp, sp, #8
 510adb0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510adb4:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510adb8:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510adbc:	e3403510 	movt	r3, #1296	; 0x510
 510adc0:	e12fff33 	blx	r3
        }
 510adc4:	e1a00007 	mov	r0, r7
 510adc8:	e28dd008 	add	sp, sp, #8
 510adcc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510add0:	e30c3930 	movw	r3, #51504	; 0xc930
 510add4:	e3403510 	movt	r3, #1296	; 0x510
 510add8:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510addc:	e786700a 	str	r7, [r6, sl]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510ade0:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510ade4:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510ade8:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510adec:	e3403510 	movt	r3, #1296	; 0x510
 510adf0:	e12fff33 	blx	r3
        }
 510adf4:	e1a00007 	mov	r0, r7
 510adf8:	e28dd008 	add	sp, sp, #8
 510adfc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510ae00 <MPU_xQueueCreateCountingSemaphore>:
        vTaskSuspendAll();
 510ae00:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510ae04:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510ae08:	e1a07000 	mov	r7, r0
        vTaskSuspendAll();
 510ae0c:	e3403510 	movt	r3, #1296	; 0x510
        {
 510ae10:	e1a09001 	mov	r9, r1
 510ae14:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510ae18:	e12fff33 	blx	r3
 510ae1c:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ae20:	e1a04003 	mov	r4, r3
 510ae24:	e3406512 	movt	r6, #1298	; 0x512
 510ae28:	ea000002 	b	510ae38 <MPU_xQueueCreateCountingSemaphore+0x38>
 510ae2c:	e2844001 	add	r4, r4, #1
 510ae30:	e3540080 	cmp	r4, #128	; 0x80
 510ae34:	0a000018 	beq	510ae9c <MPU_xQueueCreateCountingSemaphore+0x9c>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ae38:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510ae3c:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510ae40:	e3550000 	cmp	r5, #0
 510ae44:	1afffff8 	bne	510ae2c <MPU_xQueueCreateCountingSemaphore+0x2c>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ae48:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510ae4c:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ae50:	e3e01000 	mvn	r1, #0
 510ae54:	e1a0a103 	lsl	sl, r3, #2
        ( void ) xTaskResumeAll();
 510ae58:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510ae5c:	e786100a 	str	r1, [r6, sl]
 510ae60:	e0868103 	add	r8, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510ae64:	e12fff32 	blx	r2
                xInternalQueueHandle = xQueueCreateCountingSemaphore( uxCountValue, uxInitialCount );
 510ae68:	e3023934 	movw	r3, #10548	; 0x2934
 510ae6c:	e1a00007 	mov	r0, r7
 510ae70:	e1a01009 	mov	r1, r9
 510ae74:	e3403510 	movt	r3, #1296	; 0x510
 510ae78:	e12fff33 	blx	r3
                if( xInternalQueueHandle != NULL )
 510ae7c:	e2507000 	subs	r7, r0, #0
 510ae80:	0a00000b 	beq	510aeb4 <MPU_xQueueCreateCountingSemaphore+0xb4>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510ae84:	e786700a 	str	r7, [r6, sl]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510ae88:	e3a03001 	mov	r3, #1
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510ae8c:	e0847003 	add	r7, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510ae90:	e9880028 	stmib	r8, {r3, r5}
        }
 510ae94:	e1a00007 	mov	r0, r7
 510ae98:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510ae9c:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510aea0:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510aea4:	e3403510 	movt	r3, #1296	; 0x510
 510aea8:	e12fff33 	blx	r3
        }
 510aeac:	e1a00007 	mov	r0, r7
 510aeb0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510aeb4:	e30c3930 	movw	r3, #51504	; 0xc930
 510aeb8:	e3403510 	movt	r3, #1296	; 0x510
 510aebc:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510aec0:	e786700a 	str	r7, [r6, sl]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510aec4:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510aec8:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510aecc:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510aed0:	e3403510 	movt	r3, #1296	; 0x510
 510aed4:	e12fff33 	blx	r3
        }
 510aed8:	e1a00007 	mov	r0, r7
 510aedc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510aee0 <MPU_xQueueCreateCountingSemaphoreStatic>:
        {
 510aee0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510aee4:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510aee8:	e24dd00c 	sub	sp, sp, #12
 510aeec:	e1a08000 	mov	r8, r0
        vTaskSuspendAll();
 510aef0:	e3403510 	movt	r3, #1296	; 0x510
        {
 510aef4:	e1a09001 	mov	r9, r1
 510aef8:	e1a0a002 	mov	sl, r2
 510aefc:	e58d2004 	str	r2, [sp, #4]
 510af00:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510af04:	e12fff33 	blx	r3
 510af08:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510af0c:	e1a04003 	mov	r4, r3
 510af10:	e3406512 	movt	r6, #1298	; 0x512
 510af14:	ea000002 	b	510af24 <MPU_xQueueCreateCountingSemaphoreStatic+0x44>
 510af18:	e2844001 	add	r4, r4, #1
 510af1c:	e3540080 	cmp	r4, #128	; 0x80
 510af20:	0a00001a 	beq	510af90 <MPU_xQueueCreateCountingSemaphoreStatic+0xb0>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510af24:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510af28:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510af2c:	e3550000 	cmp	r5, #0
 510af30:	1afffff8 	bne	510af18 <MPU_xQueueCreateCountingSemaphoreStatic+0x38>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510af34:	e0847084 	add	r7, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510af38:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510af3c:	e3e02000 	mvn	r2, #0
 510af40:	e1a0b107 	lsl	fp, r7, #2
        ( void ) xTaskResumeAll();
 510af44:	e3403510 	movt	r3, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510af48:	e786200b 	str	r2, [r6, fp]
 510af4c:	e0867107 	add	r7, r6, r7, lsl #2
        ( void ) xTaskResumeAll();
 510af50:	e12fff33 	blx	r3
                xInternalQueueHandle = xQueueCreateCountingSemaphoreStatic( uxMaxCount, uxInitialCount, pxStaticQueue );
 510af54:	e3023bb4 	movw	r3, #11188	; 0x2bb4
 510af58:	e1a00008 	mov	r0, r8
 510af5c:	e1a0200a 	mov	r2, sl
 510af60:	e1a01009 	mov	r1, r9
 510af64:	e3403510 	movt	r3, #1296	; 0x510
 510af68:	e12fff33 	blx	r3
                if( xInternalQueueHandle != NULL )
 510af6c:	e2508000 	subs	r8, r0, #0
 510af70:	0a00000d 	beq	510afac <MPU_xQueueCreateCountingSemaphoreStatic+0xcc>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510af74:	e786800b 	str	r8, [r6, fp]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510af78:	e3a03001 	mov	r3, #1
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510af7c:	e0848003 	add	r8, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510af80:	e9870028 	stmib	r7, {r3, r5}
        }
 510af84:	e1a00008 	mov	r0, r8
 510af88:	e28dd00c 	add	sp, sp, #12
 510af8c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510af90:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510af94:	e3a08000 	mov	r8, #0
        ( void ) xTaskResumeAll();
 510af98:	e3403510 	movt	r3, #1296	; 0x510
 510af9c:	e12fff33 	blx	r3
        }
 510afa0:	e1a00008 	mov	r0, r8
 510afa4:	e28dd00c 	add	sp, sp, #12
 510afa8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510afac:	e30c3930 	movw	r3, #51504	; 0xc930
 510afb0:	e3403510 	movt	r3, #1296	; 0x510
 510afb4:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510afb8:	e786800b 	str	r8, [r6, fp]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510afbc:	e5878004 	str	r8, [r7, #4]
        taskEXIT_CRITICAL();
 510afc0:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510afc4:	e5878008 	str	r8, [r7, #8]
        taskEXIT_CRITICAL();
 510afc8:	e3403510 	movt	r3, #1296	; 0x510
 510afcc:	e12fff33 	blx	r3
        }
 510afd0:	e1a00008 	mov	r0, r8
 510afd4:	e28dd00c 	add	sp, sp, #12
 510afd8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510afdc <MPU_xQueueGenericCreate>:
        {
 510afdc:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510afe0:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510afe4:	e1a08000 	mov	r8, r0
 510afe8:	e1a09001 	mov	r9, r1
        vTaskSuspendAll();
 510afec:	e3403510 	movt	r3, #1296	; 0x510
        {
 510aff0:	e1a0a002 	mov	sl, r2
 510aff4:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510aff8:	e12fff33 	blx	r3
 510affc:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b000:	e1a04003 	mov	r4, r3
 510b004:	e3406512 	movt	r6, #1298	; 0x512
 510b008:	ea000002 	b	510b018 <MPU_xQueueGenericCreate+0x3c>
 510b00c:	e2844001 	add	r4, r4, #1
 510b010:	e3540080 	cmp	r4, #128	; 0x80
 510b014:	0a000019 	beq	510b080 <MPU_xQueueGenericCreate+0xa4>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b018:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b01c:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b020:	e3550000 	cmp	r5, #0
 510b024:	1afffff8 	bne	510b00c <MPU_xQueueGenericCreate+0x30>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b028:	e0847084 	add	r7, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510b02c:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b030:	e3e02000 	mvn	r2, #0
 510b034:	e1a0b107 	lsl	fp, r7, #2
        ( void ) xTaskResumeAll();
 510b038:	e3403510 	movt	r3, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b03c:	e786200b 	str	r2, [r6, fp]
 510b040:	e0867107 	add	r7, r6, r7, lsl #2
        ( void ) xTaskResumeAll();
 510b044:	e12fff33 	blx	r3
                xInternalQueueHandle = xQueueGenericCreate( uxQueueLength, uxItemSize, ucQueueType );
 510b048:	e3023898 	movw	r3, #10392	; 0x2898
 510b04c:	e1a00008 	mov	r0, r8
 510b050:	e1a0200a 	mov	r2, sl
 510b054:	e1a01009 	mov	r1, r9
 510b058:	e3403510 	movt	r3, #1296	; 0x510
 510b05c:	e12fff33 	blx	r3
                if( xInternalQueueHandle != NULL )
 510b060:	e2508000 	subs	r8, r0, #0
 510b064:	0a00000b 	beq	510b098 <MPU_xQueueGenericCreate+0xbc>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510b068:	e786800b 	str	r8, [r6, fp]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b06c:	e3a03001 	mov	r3, #1
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510b070:	e0848003 	add	r8, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b074:	e9870028 	stmib	r7, {r3, r5}
        }
 510b078:	e1a00008 	mov	r0, r8
 510b07c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510b080:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510b084:	e3a08000 	mov	r8, #0
        ( void ) xTaskResumeAll();
 510b088:	e3403510 	movt	r3, #1296	; 0x510
 510b08c:	e12fff33 	blx	r3
        }
 510b090:	e1a00008 	mov	r0, r8
 510b094:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510b098:	e30c3930 	movw	r3, #51504	; 0xc930
 510b09c:	e3403510 	movt	r3, #1296	; 0x510
 510b0a0:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510b0a4:	e786800b 	str	r8, [r6, fp]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b0a8:	e5878004 	str	r8, [r7, #4]
        taskEXIT_CRITICAL();
 510b0ac:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510b0b0:	e5878008 	str	r8, [r7, #8]
        taskEXIT_CRITICAL();
 510b0b4:	e3403510 	movt	r3, #1296	; 0x510
 510b0b8:	e12fff33 	blx	r3
        }
 510b0bc:	e1a00008 	mov	r0, r8
 510b0c0:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510b0c4 <MPU_xQueueGenericCreateStatic>:
        {
 510b0c4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 510b0c8:	e1a0a003 	mov	sl, r3
 510b0cc:	e24dd014 	sub	sp, sp, #20
 510b0d0:	e5dd3038 	ldrb	r3, [sp, #56]	; 0x38
 510b0d4:	e1a07000 	mov	r7, r0
 510b0d8:	e58d3008 	str	r3, [sp, #8]
        vTaskSuspendAll();
 510b0dc:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510b0e0:	e1a08001 	mov	r8, r1
        vTaskSuspendAll();
 510b0e4:	e3403510 	movt	r3, #1296	; 0x510
        {
 510b0e8:	e1a09002 	mov	r9, r2
 510b0ec:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510b0f0:	e12fff33 	blx	r3
 510b0f4:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b0f8:	e1a04003 	mov	r4, r3
 510b0fc:	e3406512 	movt	r6, #1298	; 0x512
 510b100:	ea000002 	b	510b110 <MPU_xQueueGenericCreateStatic+0x4c>
 510b104:	e2844001 	add	r4, r4, #1
 510b108:	e3540080 	cmp	r4, #128	; 0x80
 510b10c:	0a00001f 	beq	510b190 <MPU_xQueueGenericCreateStatic+0xcc>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b110:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b114:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b118:	e3550000 	cmp	r5, #0
 510b11c:	1afffff8 	bne	510b104 <MPU_xQueueGenericCreateStatic+0x40>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b120:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510b124:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b128:	e3e01000 	mvn	r1, #0
 510b12c:	e1a0b103 	lsl	fp, r3, #2
 510b130:	e0863103 	add	r3, r6, r3, lsl #2
 510b134:	e786100b 	str	r1, [r6, fp]
        ( void ) xTaskResumeAll();
 510b138:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b13c:	e58d300c 	str	r3, [sp, #12]
        ( void ) xTaskResumeAll();
 510b140:	e12fff32 	blx	r2
                xInternalQueueHandle = xQueueGenericCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxStaticQueue, ucQueueType );
 510b144:	e59d3008 	ldr	r3, [sp, #8]
 510b148:	e1a00007 	mov	r0, r7
 510b14c:	e302798c 	movw	r7, #10636	; 0x298c
 510b150:	e1a02009 	mov	r2, r9
 510b154:	e58d3000 	str	r3, [sp]
 510b158:	e3407510 	movt	r7, #1296	; 0x510
 510b15c:	e1a0300a 	mov	r3, sl
 510b160:	e1a01008 	mov	r1, r8
 510b164:	e12fff37 	blx	r7
                if( xInternalQueueHandle != NULL )
 510b168:	e2507000 	subs	r7, r0, #0
 510b16c:	0a00000e 	beq	510b1ac <MPU_xQueueGenericCreateStatic+0xe8>
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510b170:	e59d200c 	ldr	r2, [sp, #12]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b174:	e3a03001 	mov	r3, #1
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510b178:	e786700b 	str	r7, [r6, fp]
                    xExternalQueueHandle = ( QueueHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510b17c:	e0847003 	add	r7, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b180:	e9820028 	stmib	r2, {r3, r5}
        }
 510b184:	e1a00007 	mov	r0, r7
 510b188:	e28dd014 	add	sp, sp, #20
 510b18c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510b190:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueHandle_t xExternalQueueHandle = NULL;
 510b194:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510b198:	e3403510 	movt	r3, #1296	; 0x510
 510b19c:	e12fff33 	blx	r3
        }
 510b1a0:	e1a00007 	mov	r0, r7
 510b1a4:	e28dd014 	add	sp, sp, #20
 510b1a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510b1ac:	e30c3930 	movw	r3, #51504	; 0xc930
 510b1b0:	e3403510 	movt	r3, #1296	; 0x510
 510b1b4:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b1b8:	e59d200c 	ldr	r2, [sp, #12]
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510b1bc:	e786700b 	str	r7, [r6, fp]
        taskEXIT_CRITICAL();
 510b1c0:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b1c4:	e5827004 	str	r7, [r2, #4]
        taskEXIT_CRITICAL();
 510b1c8:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510b1cc:	e5827008 	str	r7, [r2, #8]
        taskEXIT_CRITICAL();
 510b1d0:	e12fff33 	blx	r3
        }
 510b1d4:	e1a00007 	mov	r0, r7
 510b1d8:	e28dd014 	add	sp, sp, #20
 510b1dc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510b1e0 <MPU_xQueueCreateSet>:
        vTaskSuspendAll();
 510b1e0:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510b1e4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510b1e8:	e1a07000 	mov	r7, r0
        vTaskSuspendAll();
 510b1ec:	e3403510 	movt	r3, #1296	; 0x510
 510b1f0:	e12fff33 	blx	r3
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b1f4:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510b1f8:	e3a03000 	mov	r3, #0
 510b1fc:	e3406512 	movt	r6, #1298	; 0x512
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b200:	e1a04003 	mov	r4, r3
 510b204:	ea000002 	b	510b214 <MPU_xQueueCreateSet+0x34>
 510b208:	e2844001 	add	r4, r4, #1
 510b20c:	e3540080 	cmp	r4, #128	; 0x80
 510b210:	0a000017 	beq	510b274 <MPU_xQueueCreateSet+0x94>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b214:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b218:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b21c:	e3550000 	cmp	r5, #0
 510b220:	1afffff8 	bne	510b208 <MPU_xQueueCreateSet+0x28>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b224:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510b228:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b22c:	e3e01000 	mvn	r1, #0
 510b230:	e1a09103 	lsl	r9, r3, #2
        ( void ) xTaskResumeAll();
 510b234:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b238:	e7861009 	str	r1, [r6, r9]
 510b23c:	e0868103 	add	r8, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510b240:	e12fff32 	blx	r2
                xInternalQueueSetHandle = xQueueCreateSet( uxEventQueueLength );
 510b244:	e3023ca8 	movw	r3, #11432	; 0x2ca8
 510b248:	e1a00007 	mov	r0, r7
 510b24c:	e3403510 	movt	r3, #1296	; 0x510
 510b250:	e12fff33 	blx	r3
                if( xInternalQueueSetHandle != NULL )
 510b254:	e2507000 	subs	r7, r0, #0
 510b258:	0a00000b 	beq	510b28c <MPU_xQueueCreateSet+0xac>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510b25c:	e7867009 	str	r7, [r6, r9]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b260:	e3a03001 	mov	r3, #1
                    xExternalQueueSetHandle = ( QueueSetHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510b264:	e0847003 	add	r7, r4, r3
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b268:	e9880028 	stmib	r8, {r3, r5}
        }
 510b26c:	e1a00007 	mov	r0, r7
 510b270:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510b274:	e3053efc 	movw	r3, #24316	; 0x5efc
            QueueSetHandle_t xExternalQueueSetHandle = NULL;
 510b278:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510b27c:	e3403510 	movt	r3, #1296	; 0x510
 510b280:	e12fff33 	blx	r3
        }
 510b284:	e1a00007 	mov	r0, r7
 510b288:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510b28c:	e30c3930 	movw	r3, #51504	; 0xc930
 510b290:	e3403510 	movt	r3, #1296	; 0x510
 510b294:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510b298:	e7867009 	str	r7, [r6, r9]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b29c:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510b2a0:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510b2a4:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510b2a8:	e3403510 	movt	r3, #1296	; 0x510
 510b2ac:	e12fff33 	blx	r3
        }
 510b2b0:	e1a00007 	mov	r0, r7
 510b2b4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510b2b8 <MPU_xQueueRemoveFromSet>:
            if( ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE ) &&
 510b2b8:	e2411001 	sub	r1, r1, #1
 510b2bc:	e351007f 	cmp	r1, #127	; 0x7f
 510b2c0:	8a000005 	bhi	510b2dc <MPU_xQueueRemoveFromSet+0x24>
        {
 510b2c4:	e92d4070 	push	{r4, r5, r6, lr}
                ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSetMember ) != pdFALSE ) )
 510b2c8:	e2404001 	sub	r4, r0, #1
            if( ( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE ) &&
 510b2cc:	e354007f 	cmp	r4, #127	; 0x7f
 510b2d0:	9a000003 	bls	510b2e4 <MPU_xQueueRemoveFromSet+0x2c>
            BaseType_t xReturn = pdFAIL;
 510b2d4:	e3a00000 	mov	r0, #0
 510b2d8:	e8bd8070 	pop	{r4, r5, r6, pc}
 510b2dc:	e3a00000 	mov	r0, #0
        }
 510b2e0:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b2e4:	e3065fa8 	movw	r5, #28584	; 0x6fa8
 510b2e8:	e0811081 	add	r1, r1, r1, lsl #1
 510b2ec:	e3405512 	movt	r5, #1298	; 0x512
 510b2f0:	e0853101 	add	r3, r5, r1, lsl #2
 510b2f4:	e1a01101 	lsl	r1, r1, #2
 510b2f8:	e5933004 	ldr	r3, [r3, #4]
 510b2fc:	e3530001 	cmp	r3, #1
        OpaqueObjectHandle_t xObjectHandle = NULL;
 510b300:	13a06000 	movne	r6, #0
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b304:	07956001 	ldreq	r6, [r5, r1]
        configASSERT( IS_INTERNAL_INDEX_VALID( lIndex ) != pdFALSE );
 510b308:	e354007f 	cmp	r4, #127	; 0x7f
 510b30c:	8a00000e 	bhi	510b34c <MPU_xQueueRemoveFromSet+0x94>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b310:	e0840084 	add	r0, r4, r4, lsl #1
 510b314:	e0853100 	add	r3, r5, r0, lsl #2
 510b318:	e1a00100 	lsl	r0, r0, #2
 510b31c:	e5933004 	ldr	r3, [r3, #4]
 510b320:	e3530001 	cmp	r3, #1
 510b324:	1affffea 	bne	510b2d4 <MPU_xQueueRemoveFromSet+0x1c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b328:	e7950000 	ldr	r0, [r5, r0]
                if( ( xInternalQueueSetHandle != NULL ) && ( xInternalQueueSetMemberHandle != NULL ) )
 510b32c:	e3560000 	cmp	r6, #0
 510b330:	13500000 	cmpne	r0, #0
 510b334:	0affffe6 	beq	510b2d4 <MPU_xQueueRemoveFromSet+0x1c>
                    xReturn = xQueueRemoveFromSet( xInternalQueueSetMemberHandle, xInternalQueueSetHandle );
 510b338:	e3023658 	movw	r3, #9816	; 0x2658
 510b33c:	e1a01006 	mov	r1, r6
 510b340:	e3403510 	movt	r3, #1296	; 0x510
 510b344:	e12fff33 	blx	r3
        }
 510b348:	e8bd8070 	pop	{r4, r5, r6, pc}
        configASSERT( IS_INTERNAL_INDEX_VALID( lIndex ) != pdFALSE );
 510b34c:	e30d0b50 	movw	r0, #56144	; 0xdb50
 510b350:	e3003900 	movw	r3, #2304	; 0x900
 510b354:	e300114f 	movw	r1, #335	; 0x14f
 510b358:	e3403511 	movt	r3, #1297	; 0x511
 510b35c:	e3400512 	movt	r0, #1298	; 0x512
 510b360:	e12fff33 	blx	r3
 510b364:	eaffffe9 	b	510b310 <MPU_xQueueRemoveFromSet+0x58>

0510b368 <MPU_xQueueGenericReset>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b368:	e2400001 	sub	r0, r0, #1
 510b36c:	e350007f 	cmp	r0, #127	; 0x7f
 510b370:	9a000001 	bls	510b37c <MPU_xQueueGenericReset+0x14>
        BaseType_t xReturn = pdFAIL;
 510b374:	e3a00000 	mov	r0, #0
    }
 510b378:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b37c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b380:	e0800080 	add	r0, r0, r0, lsl #1
 510b384:	e3403512 	movt	r3, #1298	; 0x512
 510b388:	e0832100 	add	r2, r3, r0, lsl #2
 510b38c:	e1a00100 	lsl	r0, r0, #2
 510b390:	e5922004 	ldr	r2, [r2, #4]
 510b394:	e3520001 	cmp	r2, #1
 510b398:	1afffff5 	bne	510b374 <MPU_xQueueGenericReset+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b39c:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b3a0:	e3500000 	cmp	r0, #0
 510b3a4:	0afffff2 	beq	510b374 <MPU_xQueueGenericReset+0xc>
                xReturn = xQueueGenericReset( xInternalQueueHandle, xNewQueue );
 510b3a8:	e3023780 	movw	r3, #10112	; 0x2780
 510b3ac:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b3b0:	e92d4010 	push	{r4, lr}
                xReturn = xQueueGenericReset( xInternalQueueHandle, xNewQueue );
 510b3b4:	e12fff33 	blx	r3
    }
 510b3b8:	e8bd8010 	pop	{r4, pc}

0510b3bc <MPU_xQueueGenericGetStaticBuffers>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b3bc:	e2400001 	sub	r0, r0, #1
 510b3c0:	e350007f 	cmp	r0, #127	; 0x7f
 510b3c4:	9a000001 	bls	510b3d0 <MPU_xQueueGenericGetStaticBuffers+0x14>
            BaseType_t xReturn = pdFALSE;
 510b3c8:	e3a00000 	mov	r0, #0
        }
 510b3cc:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b3d0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b3d4:	e0800080 	add	r0, r0, r0, lsl #1
 510b3d8:	e3403512 	movt	r3, #1298	; 0x512
 510b3dc:	e1a0c100 	lsl	ip, r0, #2
 510b3e0:	e0830100 	add	r0, r3, r0, lsl #2
 510b3e4:	e5900004 	ldr	r0, [r0, #4]
 510b3e8:	e3500001 	cmp	r0, #1
 510b3ec:	1afffff5 	bne	510b3c8 <MPU_xQueueGenericGetStaticBuffers+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b3f0:	e793000c 	ldr	r0, [r3, ip]
                if( xInternalQueueHandle != NULL )
 510b3f4:	e3500000 	cmp	r0, #0
 510b3f8:	0afffff2 	beq	510b3c8 <MPU_xQueueGenericGetStaticBuffers+0xc>
                    xReturn = xQueueGenericGetStaticBuffers( xInternalQueueHandle, ppucQueueStorage, ppxStaticQueue );
 510b3fc:	e302357c 	movw	r3, #9596	; 0x257c
 510b400:	e3403510 	movt	r3, #1296	; 0x510
        {
 510b404:	e92d4010 	push	{r4, lr}
                    xReturn = xQueueGenericGetStaticBuffers( xInternalQueueHandle, ppucQueueStorage, ppxStaticQueue );
 510b408:	e12fff33 	blx	r3
        }
 510b40c:	e8bd8010 	pop	{r4, pc}

0510b410 <MPU_xQueueGenericSendFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b410:	e2400001 	sub	r0, r0, #1
 510b414:	e350007f 	cmp	r0, #127	; 0x7f
 510b418:	9a000001 	bls	510b424 <MPU_xQueueGenericSendFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b41c:	e3a00000 	mov	r0, #0
    }
 510b420:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b424:	e306cfa8 	movw	ip, #28584	; 0x6fa8
 510b428:	e0800080 	add	r0, r0, r0, lsl #1
 510b42c:	e340c512 	movt	ip, #1298	; 0x512
    {
 510b430:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b434:	e08ce100 	add	lr, ip, r0, lsl #2
 510b438:	e1a00100 	lsl	r0, r0, #2
 510b43c:	e59ee004 	ldr	lr, [lr, #4]
 510b440:	e35e0001 	cmp	lr, #1
 510b444:	1a000006 	bne	510b464 <MPU_xQueueGenericSendFromISR+0x54>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b448:	e79c0000 	ldr	r0, [ip, r0]
            if( xInternalQueueHandle != NULL )
 510b44c:	e3500000 	cmp	r0, #0
 510b450:	0a000003 	beq	510b464 <MPU_xQueueGenericSendFromISR+0x54>
                xReturn = xQueueGenericSendFromISR( xInternalQueueHandle, pvItemToQueue, pxHigherPriorityTaskWoken, xCopyPosition );
 510b454:	e3014a48 	movw	r4, #6728	; 0x1a48
 510b458:	e3404510 	movt	r4, #1296	; 0x510
 510b45c:	e12fff34 	blx	r4
    }
 510b460:	e8bd8010 	pop	{r4, pc}
        BaseType_t xReturn = pdFAIL;
 510b464:	e3a00000 	mov	r0, #0
 510b468:	e8bd8010 	pop	{r4, pc}

0510b46c <MPU_xQueueGiveFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b46c:	e2400001 	sub	r0, r0, #1
 510b470:	e350007f 	cmp	r0, #127	; 0x7f
 510b474:	9a000001 	bls	510b480 <MPU_xQueueGiveFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b478:	e3a00000 	mov	r0, #0
    }
 510b47c:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b480:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b484:	e0800080 	add	r0, r0, r0, lsl #1
 510b488:	e3403512 	movt	r3, #1298	; 0x512
 510b48c:	e0832100 	add	r2, r3, r0, lsl #2
 510b490:	e1a00100 	lsl	r0, r0, #2
 510b494:	e5922004 	ldr	r2, [r2, #4]
 510b498:	e3520001 	cmp	r2, #1
 510b49c:	1afffff5 	bne	510b478 <MPU_xQueueGiveFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b4a0:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b4a4:	e3500000 	cmp	r0, #0
 510b4a8:	0afffff2 	beq	510b478 <MPU_xQueueGiveFromISR+0xc>
                xReturn = xQueueGiveFromISR( xInternalQueueHandle, pxHigherPriorityTaskWoken );
 510b4ac:	e3013be8 	movw	r3, #7144	; 0x1be8
 510b4b0:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b4b4:	e92d4010 	push	{r4, lr}
                xReturn = xQueueGiveFromISR( xInternalQueueHandle, pxHigherPriorityTaskWoken );
 510b4b8:	e12fff33 	blx	r3
    }
 510b4bc:	e8bd8010 	pop	{r4, pc}

0510b4c0 <MPU_xQueuePeekFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b4c0:	e2400001 	sub	r0, r0, #1
 510b4c4:	e350007f 	cmp	r0, #127	; 0x7f
 510b4c8:	9a000001 	bls	510b4d4 <MPU_xQueuePeekFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b4cc:	e3a00000 	mov	r0, #0
    }
 510b4d0:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b4d4:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b4d8:	e0800080 	add	r0, r0, r0, lsl #1
 510b4dc:	e3403512 	movt	r3, #1298	; 0x512
 510b4e0:	e0832100 	add	r2, r3, r0, lsl #2
 510b4e4:	e1a00100 	lsl	r0, r0, #2
 510b4e8:	e5922004 	ldr	r2, [r2, #4]
 510b4ec:	e3520001 	cmp	r2, #1
 510b4f0:	1afffff5 	bne	510b4cc <MPU_xQueuePeekFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b4f4:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b4f8:	e3500000 	cmp	r0, #0
 510b4fc:	0afffff2 	beq	510b4cc <MPU_xQueuePeekFromISR+0xc>
                xReturn = xQueuePeekFromISR( xInternalQueueHandle, pvBuffer );
 510b500:	e3013588 	movw	r3, #5512	; 0x1588
 510b504:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b508:	e92d4010 	push	{r4, lr}
                xReturn = xQueuePeekFromISR( xInternalQueueHandle, pvBuffer );
 510b50c:	e12fff33 	blx	r3
    }
 510b510:	e8bd8010 	pop	{r4, pc}

0510b514 <MPU_xQueueReceiveFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b514:	e2400001 	sub	r0, r0, #1
 510b518:	e350007f 	cmp	r0, #127	; 0x7f
 510b51c:	9a000001 	bls	510b528 <MPU_xQueueReceiveFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b520:	e3a00000 	mov	r0, #0
    }
 510b524:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b528:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b52c:	e0800080 	add	r0, r0, r0, lsl #1
 510b530:	e3403512 	movt	r3, #1298	; 0x512
 510b534:	e1a0c100 	lsl	ip, r0, #2
 510b538:	e0830100 	add	r0, r3, r0, lsl #2
 510b53c:	e5900004 	ldr	r0, [r0, #4]
 510b540:	e3500001 	cmp	r0, #1
 510b544:	1afffff5 	bne	510b520 <MPU_xQueueReceiveFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b548:	e793000c 	ldr	r0, [r3, ip]
            if( xInternalQueueHandle != NULL )
 510b54c:	e3500000 	cmp	r0, #0
 510b550:	0afffff2 	beq	510b520 <MPU_xQueueReceiveFromISR+0xc>
                xReturn = xQueueReceiveFromISR( xInternalQueueHandle, pvBuffer, pxHigherPriorityTaskWoken );
 510b554:	e3013d54 	movw	r3, #7508	; 0x1d54
 510b558:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b55c:	e92d4010 	push	{r4, lr}
                xReturn = xQueueReceiveFromISR( xInternalQueueHandle, pvBuffer, pxHigherPriorityTaskWoken );
 510b560:	e12fff33 	blx	r3
    }
 510b564:	e8bd8010 	pop	{r4, pc}

0510b568 <MPU_xQueueIsQueueEmptyFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b568:	e2400001 	sub	r0, r0, #1
 510b56c:	e350007f 	cmp	r0, #127	; 0x7f
 510b570:	9a000001 	bls	510b57c <MPU_xQueueIsQueueEmptyFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b574:	e3a00000 	mov	r0, #0
    }
 510b578:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b57c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b580:	e0800080 	add	r0, r0, r0, lsl #1
 510b584:	e3403512 	movt	r3, #1298	; 0x512
 510b588:	e0832100 	add	r2, r3, r0, lsl #2
 510b58c:	e1a00100 	lsl	r0, r0, #2
 510b590:	e5922004 	ldr	r2, [r2, #4]
 510b594:	e3520001 	cmp	r2, #1
 510b598:	1afffff5 	bne	510b574 <MPU_xQueueIsQueueEmptyFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b59c:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b5a0:	e3500000 	cmp	r0, #0
 510b5a4:	0afffff2 	beq	510b574 <MPU_xQueueIsQueueEmptyFromISR+0xc>
                xReturn = xQueueIsQueueEmptyFromISR( xInternalQueueHandle );
 510b5a8:	e3013ec8 	movw	r3, #7880	; 0x1ec8
 510b5ac:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b5b0:	e92d4010 	push	{r4, lr}
                xReturn = xQueueIsQueueEmptyFromISR( xInternalQueueHandle );
 510b5b4:	e12fff33 	blx	r3
    }
 510b5b8:	e8bd8010 	pop	{r4, pc}

0510b5bc <MPU_xQueueIsQueueFullFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b5bc:	e2400001 	sub	r0, r0, #1
 510b5c0:	e350007f 	cmp	r0, #127	; 0x7f
 510b5c4:	9a000001 	bls	510b5d0 <MPU_xQueueIsQueueFullFromISR+0x14>
        BaseType_t xReturn = pdFAIL;
 510b5c8:	e3a00000 	mov	r0, #0
    }
 510b5cc:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b5d0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b5d4:	e0800080 	add	r0, r0, r0, lsl #1
 510b5d8:	e3403512 	movt	r3, #1298	; 0x512
 510b5dc:	e0832100 	add	r2, r3, r0, lsl #2
 510b5e0:	e1a00100 	lsl	r0, r0, #2
 510b5e4:	e5922004 	ldr	r2, [r2, #4]
 510b5e8:	e3520001 	cmp	r2, #1
 510b5ec:	1afffff5 	bne	510b5c8 <MPU_xQueueIsQueueFullFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b5f0:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b5f4:	e3500000 	cmp	r0, #0
 510b5f8:	0afffff2 	beq	510b5c8 <MPU_xQueueIsQueueFullFromISR+0xc>
                xReturn = xQueueIsQueueFullFromISR( xInternalQueueHandle );
 510b5fc:	e3013f00 	movw	r3, #7936	; 0x1f00
 510b600:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b604:	e92d4010 	push	{r4, lr}
                xReturn = xQueueIsQueueFullFromISR( xInternalQueueHandle );
 510b608:	e12fff33 	blx	r3
    }
 510b60c:	e8bd8010 	pop	{r4, pc}

0510b610 <MPU_uxQueueMessagesWaitingFromISR>:
        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b610:	e2400001 	sub	r0, r0, #1
 510b614:	e350007f 	cmp	r0, #127	; 0x7f
 510b618:	9a000001 	bls	510b624 <MPU_uxQueueMessagesWaitingFromISR+0x14>
        UBaseType_t uxReturn = 0;
 510b61c:	e3a00000 	mov	r0, #0
    }
 510b620:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b624:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b628:	e0800080 	add	r0, r0, r0, lsl #1
 510b62c:	e3403512 	movt	r3, #1298	; 0x512
 510b630:	e0832100 	add	r2, r3, r0, lsl #2
 510b634:	e1a00100 	lsl	r0, r0, #2
 510b638:	e5922004 	ldr	r2, [r2, #4]
 510b63c:	e3520001 	cmp	r2, #1
 510b640:	1afffff5 	bne	510b61c <MPU_uxQueueMessagesWaitingFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b644:	e7930000 	ldr	r0, [r3, r0]
            if( xInternalQueueHandle != NULL )
 510b648:	e3500000 	cmp	r0, #0
 510b64c:	0afffff2 	beq	510b61c <MPU_uxQueueMessagesWaitingFromISR+0xc>
                uxReturn = uxQueueMessagesWaitingFromISR( xInternalQueueHandle );
 510b650:	e3013f40 	movw	r3, #8000	; 0x1f40
 510b654:	e3403510 	movt	r3, #1296	; 0x510
    {
 510b658:	e92d4010 	push	{r4, lr}
                uxReturn = uxQueueMessagesWaitingFromISR( xInternalQueueHandle );
 510b65c:	e12fff33 	blx	r3
    }
 510b660:	e8bd8010 	pop	{r4, pc}

0510b664 <MPU_xQueueGetMutexHolderFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b664:	e2400001 	sub	r0, r0, #1
 510b668:	e350007f 	cmp	r0, #127	; 0x7f
 510b66c:	8a000021 	bhi	510b6f8 <MPU_xQueueGetMutexHolderFromISR+0x94>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b670:	e0800080 	add	r0, r0, r0, lsl #1
        {
 510b674:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b678:	e3064fa8 	movw	r4, #28584	; 0x6fa8
 510b67c:	e3404512 	movt	r4, #1298	; 0x512
 510b680:	e0843100 	add	r3, r4, r0, lsl #2
 510b684:	e1a00100 	lsl	r0, r0, #2
 510b688:	e5933004 	ldr	r3, [r3, #4]
 510b68c:	e3530001 	cmp	r3, #1
 510b690:	1a000016 	bne	510b6f0 <MPU_xQueueGetMutexHolderFromISR+0x8c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b694:	e7940000 	ldr	r0, [r4, r0]
                if( xInternalSemaphoreHandle != NULL )
 510b698:	e3500000 	cmp	r0, #0
 510b69c:	0a000013 	beq	510b6f0 <MPU_xQueueGetMutexHolderFromISR+0x8c>
                    xMutexHolderTaskInternalHandle = xQueueGetMutexHolder( xInternalSemaphoreHandle );
 510b6a0:	e3023268 	movw	r3, #8808	; 0x2268
 510b6a4:	e3403510 	movt	r3, #1296	; 0x510
 510b6a8:	e12fff33 	blx	r3
                    if( xMutexHolderTaskInternalHandle != NULL )
 510b6ac:	e3500000 	cmp	r0, #0
 510b6b0:	0a00000e 	beq	510b6f0 <MPU_xQueueGetMutexHolderFromISR+0x8c>
 510b6b4:	e1a03004 	mov	r3, r4
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b6b8:	e3a02000 	mov	r2, #0
 510b6bc:	ea000003 	b	510b6d0 <MPU_xQueueGetMutexHolderFromISR+0x6c>
 510b6c0:	e2822001 	add	r2, r2, #1
 510b6c4:	e3520080 	cmp	r2, #128	; 0x80
 510b6c8:	e283300c 	add	r3, r3, #12
 510b6cc:	0a000007 	beq	510b6f0 <MPU_xQueueGetMutexHolderFromISR+0x8c>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 510b6d0:	e5931000 	ldr	r1, [r3]
 510b6d4:	e1500001 	cmp	r0, r1
 510b6d8:	1afffff8 	bne	510b6c0 <MPU_xQueueGetMutexHolderFromISR+0x5c>
 510b6dc:	e5931004 	ldr	r1, [r3, #4]
 510b6e0:	e3510002 	cmp	r1, #2
 510b6e4:	1afffff5 	bne	510b6c0 <MPU_xQueueGetMutexHolderFromISR+0x5c>
                            xMutexHolderTaskExternalHandle = ( TaskHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lMutexHolderTaskIndex ) );
 510b6e8:	e2820001 	add	r0, r2, #1
        }
 510b6ec:	e8bd8010 	pop	{r4, pc}
            TaskHandle_t xMutexHolderTaskExternalHandle = NULL;
 510b6f0:	e3a00000 	mov	r0, #0
            return xMutexHolderTaskExternalHandle;
 510b6f4:	e8bd8010 	pop	{r4, pc}
            TaskHandle_t xMutexHolderTaskExternalHandle = NULL;
 510b6f8:	e3a00000 	mov	r0, #0
        }
 510b6fc:	e12fff1e 	bx	lr

0510b700 <MPU_xQueueSelectFromSetFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndexQueueSet ) != pdFALSE )
 510b700:	e2400001 	sub	r0, r0, #1
 510b704:	e350007f 	cmp	r0, #127	; 0x7f
 510b708:	8a000021 	bhi	510b794 <MPU_xQueueSelectFromSetFromISR+0x94>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b70c:	e0800080 	add	r0, r0, r0, lsl #1
        {
 510b710:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b714:	e3064fa8 	movw	r4, #28584	; 0x6fa8
 510b718:	e3404512 	movt	r4, #1298	; 0x512
 510b71c:	e0843100 	add	r3, r4, r0, lsl #2
 510b720:	e1a00100 	lsl	r0, r0, #2
 510b724:	e5933004 	ldr	r3, [r3, #4]
 510b728:	e3530001 	cmp	r3, #1
 510b72c:	1a000016 	bne	510b78c <MPU_xQueueSelectFromSetFromISR+0x8c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510b730:	e7940000 	ldr	r0, [r4, r0]
                if( xInternalQueueSetHandle != NULL )
 510b734:	e3500000 	cmp	r0, #0
 510b738:	0a000013 	beq	510b78c <MPU_xQueueSelectFromSetFromISR+0x8c>
                    xSelectedMemberInternal = xQueueSelectFromSetFromISR( xInternalQueueSetHandle );
 510b73c:	e30236e0 	movw	r3, #9952	; 0x26e0
 510b740:	e3403510 	movt	r3, #1296	; 0x510
 510b744:	e12fff33 	blx	r3
                    if( xSelectedMemberInternal != NULL )
 510b748:	e3500000 	cmp	r0, #0
 510b74c:	0a00000e 	beq	510b78c <MPU_xQueueSelectFromSetFromISR+0x8c>
 510b750:	e1a03004 	mov	r3, r4
        for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b754:	e3a02000 	mov	r2, #0
 510b758:	ea000003 	b	510b76c <MPU_xQueueSelectFromSetFromISR+0x6c>
 510b75c:	e2822001 	add	r2, r2, #1
 510b760:	e3520080 	cmp	r2, #128	; 0x80
 510b764:	e283300c 	add	r3, r3, #12
 510b768:	0a000007 	beq	510b78c <MPU_xQueueSelectFromSetFromISR+0x8c>
            if( ( xKernelObjectPool[ i ].xInternalObjectHandle == xHandle ) &&
 510b76c:	e5931000 	ldr	r1, [r3]
 510b770:	e1500001 	cmp	r0, r1
 510b774:	1afffff8 	bne	510b75c <MPU_xQueueSelectFromSetFromISR+0x5c>
 510b778:	e5931004 	ldr	r1, [r3, #4]
 510b77c:	e3510001 	cmp	r1, #1
 510b780:	1afffff5 	bne	510b75c <MPU_xQueueSelectFromSetFromISR+0x5c>
                            xSelectedMemberExternal = ( QueueSetMemberHandle_t ) ( CONVERT_TO_EXTERNAL_INDEX( lIndexSelectedMember ) );
 510b784:	e2820001 	add	r0, r2, #1
        }
 510b788:	e8bd8010 	pop	{r4, pc}
            QueueSetMemberHandle_t xSelectedMemberExternal = NULL;
 510b78c:	e3a00000 	mov	r0, #0
            return xSelectedMemberExternal;
 510b790:	e8bd8010 	pop	{r4, pc}
            QueueSetMemberHandle_t xSelectedMemberExternal = NULL;
 510b794:	e3a00000 	mov	r0, #0
        }
 510b798:	e12fff1e 	bx	lr

0510b79c <MPU_xTimerCreate>:
        {
 510b79c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510b7a0:	e30542a0 	movw	r4, #21152	; 0x52a0
        {
 510b7a4:	e24dd00c 	sub	sp, sp, #12
 510b7a8:	e1a06000 	mov	r6, r0
        vTaskSuspendAll();
 510b7ac:	e3404510 	movt	r4, #1296	; 0x510
        {
 510b7b0:	e1a07001 	mov	r7, r1
 510b7b4:	e1a08002 	mov	r8, r2
 510b7b8:	e1a09003 	mov	r9, r3
 510b7bc:	e3065fa8 	movw	r5, #28584	; 0x6fa8
        vTaskSuspendAll();
 510b7c0:	e12fff34 	blx	r4
 510b7c4:	e3a0c000 	mov	ip, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b7c8:	e1a0400c 	mov	r4, ip
 510b7cc:	e3405512 	movt	r5, #1298	; 0x512
 510b7d0:	ea000002 	b	510b7e0 <MPU_xTimerCreate+0x44>
 510b7d4:	e2844001 	add	r4, r4, #1
 510b7d8:	e3540080 	cmp	r4, #128	; 0x80
 510b7dc:	0a000020 	beq	510b864 <MPU_xTimerCreate+0xc8>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b7e0:	e795e10c 	ldr	lr, [r5, ip, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b7e4:	e28cc003 	add	ip, ip, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b7e8:	e35e0000 	cmp	lr, #0
 510b7ec:	1afffff8 	bne	510b7d4 <MPU_xTimerCreate+0x38>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b7f0:	e084a084 	add	sl, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510b7f4:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b7f8:	e3e02000 	mvn	r2, #0
 510b7fc:	e1a0b10a 	lsl	fp, sl, #2
        ( void ) xTaskResumeAll();
 510b800:	e3403510 	movt	r3, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b804:	e785200b 	str	r2, [r5, fp]
 510b808:	e085a10a 	add	sl, r5, sl, lsl #2
        ( void ) xTaskResumeAll();
 510b80c:	e12fff33 	blx	r3
                xInternalTimerHandle = xTimerCreate( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, MPU_TimerCallback );
 510b810:	e308c864 	movw	ip, #34916	; 0x8864
 510b814:	e1a00006 	mov	r0, r6
 510b818:	e340c510 	movt	ip, #1296	; 0x510
 510b81c:	e30767b0 	movw	r6, #30640	; 0x77b0
 510b820:	e1a03009 	mov	r3, r9
 510b824:	e1a02008 	mov	r2, r8
 510b828:	e3406510 	movt	r6, #1296	; 0x510
 510b82c:	e58dc000 	str	ip, [sp]
 510b830:	e1a01007 	mov	r1, r7
 510b834:	e12fff36 	blx	r6
                if( xInternalTimerHandle != NULL )
 510b838:	e2506000 	subs	r6, r0, #0
 510b83c:	0a00000f 	beq	510b880 <MPU_xTimerCreate+0xe4>
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510b840:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b844:	e3a03005 	mov	r3, #5
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510b848:	e785600b 	str	r6, [r5, fp]
                    xExternalTimerHandle = ( TimerHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510b84c:	e2846001 	add	r6, r4, #1
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510b850:	e58a2008 	str	r2, [sl, #8]
        }
 510b854:	e1a00006 	mov	r0, r6
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b858:	e58a3004 	str	r3, [sl, #4]
        }
 510b85c:	e28dd00c 	add	sp, sp, #12
 510b860:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510b864:	e3053efc 	movw	r3, #24316	; 0x5efc
            TimerHandle_t xExternalTimerHandle = NULL;
 510b868:	e3a06000 	mov	r6, #0
        ( void ) xTaskResumeAll();
 510b86c:	e3403510 	movt	r3, #1296	; 0x510
 510b870:	e12fff33 	blx	r3
        }
 510b874:	e1a00006 	mov	r0, r6
 510b878:	e28dd00c 	add	sp, sp, #12
 510b87c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510b880:	e30c3930 	movw	r3, #51504	; 0xc930
 510b884:	e3403510 	movt	r3, #1296	; 0x510
 510b888:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510b88c:	e785600b 	str	r6, [r5, fp]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b890:	e58a6004 	str	r6, [sl, #4]
        taskEXIT_CRITICAL();
 510b894:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510b898:	e58a6008 	str	r6, [sl, #8]
        taskEXIT_CRITICAL();
 510b89c:	e3403510 	movt	r3, #1296	; 0x510
 510b8a0:	e12fff33 	blx	r3
        }
 510b8a4:	e1a00006 	mov	r0, r6
 510b8a8:	e28dd00c 	add	sp, sp, #12
 510b8ac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510b8b0 <MPU_xTimerCreateStatic>:
        {
 510b8b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        vTaskSuspendAll();
 510b8b4:	e30542a0 	movw	r4, #21152	; 0x52a0
        {
 510b8b8:	e24dd00c 	sub	sp, sp, #12
 510b8bc:	e1a06000 	mov	r6, r0
        vTaskSuspendAll();
 510b8c0:	e3404510 	movt	r4, #1296	; 0x510
        {
 510b8c4:	e1a07001 	mov	r7, r1
 510b8c8:	e1a08002 	mov	r8, r2
 510b8cc:	e1a09003 	mov	r9, r3
 510b8d0:	e3065fa8 	movw	r5, #28584	; 0x6fa8
        vTaskSuspendAll();
 510b8d4:	e12fff34 	blx	r4
 510b8d8:	e3a0c000 	mov	ip, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b8dc:	e1a0400c 	mov	r4, ip
 510b8e0:	e3405512 	movt	r5, #1298	; 0x512
 510b8e4:	ea000002 	b	510b8f4 <MPU_xTimerCreateStatic+0x44>
 510b8e8:	e2844001 	add	r4, r4, #1
 510b8ec:	e3540080 	cmp	r4, #128	; 0x80
 510b8f0:	0a000022 	beq	510b980 <MPU_xTimerCreateStatic+0xd0>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b8f4:	e795e10c 	ldr	lr, [r5, ip, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510b8f8:	e28cc003 	add	ip, ip, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510b8fc:	e35e0000 	cmp	lr, #0
 510b900:	1afffff8 	bne	510b8e8 <MPU_xTimerCreateStatic+0x38>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b904:	e084a084 	add	sl, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510b908:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b90c:	e3e02000 	mvn	r2, #0
 510b910:	e1a0b10a 	lsl	fp, sl, #2
        ( void ) xTaskResumeAll();
 510b914:	e3403510 	movt	r3, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510b918:	e785200b 	str	r2, [r5, fp]
 510b91c:	e085a10a 	add	sl, r5, sl, lsl #2
        ( void ) xTaskResumeAll();
 510b920:	e12fff33 	blx	r3
                xInternalTimerHandle = xTimerCreateStatic( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, MPU_TimerCallback, pxTimerBuffer );
 510b924:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
 510b928:	e58dc004 	str	ip, [sp, #4]
 510b92c:	e308c864 	movw	ip, #34916	; 0x8864
 510b930:	e1a00006 	mov	r0, r6
 510b934:	e340c510 	movt	ip, #1296	; 0x510
 510b938:	e3076848 	movw	r6, #30792	; 0x7848
 510b93c:	e1a03009 	mov	r3, r9
 510b940:	e1a02008 	mov	r2, r8
 510b944:	e3406510 	movt	r6, #1296	; 0x510
 510b948:	e58dc000 	str	ip, [sp]
 510b94c:	e1a01007 	mov	r1, r7
 510b950:	e12fff36 	blx	r6
                if( xInternalTimerHandle != NULL )
 510b954:	e2506000 	subs	r6, r0, #0
 510b958:	0a00000f 	beq	510b99c <MPU_xTimerCreateStatic+0xec>
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510b95c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b960:	e3a03005 	mov	r3, #5
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510b964:	e785600b 	str	r6, [r5, fp]
                    xExternalTimerHandle = ( TimerHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510b968:	e2846001 	add	r6, r4, #1
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510b96c:	e58a2008 	str	r2, [sl, #8]
        }
 510b970:	e1a00006 	mov	r0, r6
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510b974:	e58a3004 	str	r3, [sl, #4]
        }
 510b978:	e28dd00c 	add	sp, sp, #12
 510b97c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510b980:	e3053efc 	movw	r3, #24316	; 0x5efc
            TimerHandle_t xExternalTimerHandle = NULL;
 510b984:	e3a06000 	mov	r6, #0
        ( void ) xTaskResumeAll();
 510b988:	e3403510 	movt	r3, #1296	; 0x510
 510b98c:	e12fff33 	blx	r3
        }
 510b990:	e1a00006 	mov	r0, r6
 510b994:	e28dd00c 	add	sp, sp, #12
 510b998:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        taskENTER_CRITICAL();
 510b99c:	e30c3930 	movw	r3, #51504	; 0xc930
 510b9a0:	e3403510 	movt	r3, #1296	; 0x510
 510b9a4:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510b9a8:	e785600b 	str	r6, [r5, fp]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510b9ac:	e58a6004 	str	r6, [sl, #4]
        taskEXIT_CRITICAL();
 510b9b0:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510b9b4:	e58a6008 	str	r6, [sl, #8]
        taskEXIT_CRITICAL();
 510b9b8:	e3403510 	movt	r3, #1296	; 0x510
 510b9bc:	e12fff33 	blx	r3
        }
 510b9c0:	e1a00006 	mov	r0, r6
 510b9c4:	e28dd00c 	add	sp, sp, #12
 510b9c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

0510b9cc <MPU_xTimerGetStaticBuffer>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510b9cc:	e2400001 	sub	r0, r0, #1
 510b9d0:	e350007f 	cmp	r0, #127	; 0x7f
 510b9d4:	9a000001 	bls	510b9e0 <MPU_xTimerGetStaticBuffer+0x14>
            BaseType_t xReturn = pdFALSE;
 510b9d8:	e3a00000 	mov	r0, #0
        }
 510b9dc:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510b9e0:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510b9e4:	e0800080 	add	r0, r0, r0, lsl #1
 510b9e8:	e3403512 	movt	r3, #1298	; 0x512
 510b9ec:	e0832100 	add	r2, r3, r0, lsl #2
 510b9f0:	e1a00100 	lsl	r0, r0, #2
 510b9f4:	e5922004 	ldr	r2, [r2, #4]
 510b9f8:	e3520005 	cmp	r2, #5
 510b9fc:	1afffff5 	bne	510b9d8 <MPU_xTimerGetStaticBuffer+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510ba00:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalTimerHandle != NULL )
 510ba04:	e3500000 	cmp	r0, #0
 510ba08:	0afffff2 	beq	510b9d8 <MPU_xTimerGetStaticBuffer+0xc>
                    xReturn = xTimerGetStaticBuffer( xInternalTimerHandle, ppxTimerBuffer );
 510ba0c:	e3073ce8 	movw	r3, #31976	; 0x7ce8
 510ba10:	e3403510 	movt	r3, #1296	; 0x510
        {
 510ba14:	e92d4010 	push	{r4, lr}
                    xReturn = xTimerGetStaticBuffer( xInternalTimerHandle, ppxTimerBuffer );
 510ba18:	e12fff33 	blx	r3
        }
 510ba1c:	e8bd8010 	pop	{r4, pc}

0510ba20 <MPU_xTimerGenericCommandFromISR>:
        {
 510ba20:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 510ba24:	e1a04000 	mov	r4, r0
            if( pxHigherPriorityTaskWoken != NULL )
 510ba28:	e2536000 	subs	r6, r3, #0
        {
 510ba2c:	e1a05001 	mov	r5, r1
 510ba30:	e24dd00c 	sub	sp, sp, #12
 510ba34:	e1a07002 	mov	r7, r2
            if( pxHigherPriorityTaskWoken != NULL )
 510ba38:	0a00000a 	beq	510ba68 <MPU_xTimerGenericCommandFromISR+0x48>
                xIsHigherPriorityTaskWokenWriteable = xPortIsAuthorizedToAccessBuffer( pxHigherPriorityTaskWoken,
 510ba3c:	e30c3824 	movw	r3, #51236	; 0xc824
 510ba40:	e3a02002 	mov	r2, #2
 510ba44:	e3a01004 	mov	r1, #4
 510ba48:	e3403510 	movt	r3, #1296	; 0x510
 510ba4c:	e1a00006 	mov	r0, r6
 510ba50:	e12fff33 	blx	r3
            if( ( pxHigherPriorityTaskWoken == NULL ) || ( xIsHigherPriorityTaskWokenWriteable == pdTRUE ) )
 510ba54:	e3500001 	cmp	r0, #1
 510ba58:	0a000002 	beq	510ba68 <MPU_xTimerGenericCommandFromISR+0x48>
            BaseType_t xReturn = pdFALSE;
 510ba5c:	e3a00000 	mov	r0, #0
        }
 510ba60:	e28dd00c 	add	sp, sp, #12
 510ba64:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
                if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510ba68:	e2440001 	sub	r0, r4, #1
 510ba6c:	e350007f 	cmp	r0, #127	; 0x7f
 510ba70:	8afffff9 	bhi	510ba5c <MPU_xTimerGenericCommandFromISR+0x3c>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510ba74:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510ba78:	e0800080 	add	r0, r0, r0, lsl #1
 510ba7c:	e3403512 	movt	r3, #1298	; 0x512
 510ba80:	e0832100 	add	r2, r3, r0, lsl #2
 510ba84:	e1a00100 	lsl	r0, r0, #2
 510ba88:	e5922004 	ldr	r2, [r2, #4]
 510ba8c:	e3520005 	cmp	r2, #5
 510ba90:	1afffff1 	bne	510ba5c <MPU_xTimerGenericCommandFromISR+0x3c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510ba94:	e7930000 	ldr	r0, [r3, r0]
                    if( xInternalTimerHandle != NULL )
 510ba98:	e3500000 	cmp	r0, #0
 510ba9c:	0affffee 	beq	510ba5c <MPU_xTimerGenericCommandFromISR+0x3c>
                        xReturn = xTimerGenericCommandFromISR( xInternalTimerHandle, xCommandID, xOptionalValue, pxHigherPriorityTaskWoken, xTicksToWait );
 510baa0:	e59dc020 	ldr	ip, [sp, #32]
 510baa4:	e3074ebc 	movw	r4, #32444	; 0x7ebc
 510baa8:	e1a03006 	mov	r3, r6
 510baac:	e1a02007 	mov	r2, r7
 510bab0:	e1a01005 	mov	r1, r5
 510bab4:	e3404510 	movt	r4, #1296	; 0x510
 510bab8:	e58dc000 	str	ip, [sp]
 510babc:	e12fff34 	blx	r4
            return xReturn;
 510bac0:	eaffffe6 	b	510ba60 <MPU_xTimerGenericCommandFromISR+0x40>

0510bac4 <MPU_xEventGroupCreate>:
        vTaskSuspendAll();
 510bac4:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510bac8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510bacc:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510bad0:	e3403510 	movt	r3, #1296	; 0x510
 510bad4:	e12fff33 	blx	r3
 510bad8:	e3a03000 	mov	r3, #0
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510badc:	e1a04003 	mov	r4, r3
 510bae0:	e3406512 	movt	r6, #1298	; 0x512
 510bae4:	ea000002 	b	510baf4 <MPU_xEventGroupCreate+0x30>
 510bae8:	e2844001 	add	r4, r4, #1
 510baec:	e3540080 	cmp	r4, #128	; 0x80
 510baf0:	0a000016 	beq	510bb50 <MPU_xEventGroupCreate+0x8c>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510baf4:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510baf8:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bafc:	e3550000 	cmp	r5, #0
 510bb00:	1afffff8 	bne	510bae8 <MPU_xEventGroupCreate+0x24>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bb04:	e0843084 	add	r3, r4, r4, lsl #1
 510bb08:	e1a09103 	lsl	r9, r3, #2
 510bb0c:	e0868103 	add	r8, r6, r3, lsl #2
 510bb10:	e3e03000 	mvn	r3, #0
 510bb14:	e7863009 	str	r3, [r6, r9]
        ( void ) xTaskResumeAll();
 510bb18:	e3053efc 	movw	r3, #24316	; 0x5efc
 510bb1c:	e3403510 	movt	r3, #1296	; 0x510
 510bb20:	e12fff33 	blx	r3
                xInternalEventGroupHandle = xEventGroupCreate();
 510bb24:	e3003428 	movw	r3, #1064	; 0x428
 510bb28:	e3403510 	movt	r3, #1296	; 0x510
 510bb2c:	e12fff33 	blx	r3
                if( xInternalEventGroupHandle != NULL )
 510bb30:	e2507000 	subs	r7, r0, #0
 510bb34:	0a00000b 	beq	510bb68 <MPU_xEventGroupCreate+0xa4>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510bb38:	e7867009 	str	r7, [r6, r9]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bb3c:	e3a03004 	mov	r3, #4
                    xExternalEventGroupHandle = ( EventGroupHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510bb40:	e2847001 	add	r7, r4, #1
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bb44:	e9880028 	stmib	r8, {r3, r5}
        }
 510bb48:	e1a00007 	mov	r0, r7
 510bb4c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510bb50:	e3053efc 	movw	r3, #24316	; 0x5efc
            EventGroupHandle_t xExternalEventGroupHandle = NULL;
 510bb54:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510bb58:	e3403510 	movt	r3, #1296	; 0x510
 510bb5c:	e12fff33 	blx	r3
        }
 510bb60:	e1a00007 	mov	r0, r7
 510bb64:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510bb68:	e30c3930 	movw	r3, #51504	; 0xc930
 510bb6c:	e3403510 	movt	r3, #1296	; 0x510
 510bb70:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bb74:	e7867009 	str	r7, [r6, r9]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bb78:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510bb7c:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510bb80:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510bb84:	e3403510 	movt	r3, #1296	; 0x510
 510bb88:	e12fff33 	blx	r3
        }
 510bb8c:	e1a00007 	mov	r0, r7
 510bb90:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510bb94 <MPU_xEventGroupCreateStatic>:
        vTaskSuspendAll();
 510bb94:	e30532a0 	movw	r3, #21152	; 0x52a0
        {
 510bb98:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510bb9c:	e1a07000 	mov	r7, r0
        vTaskSuspendAll();
 510bba0:	e3403510 	movt	r3, #1296	; 0x510
 510bba4:	e12fff33 	blx	r3
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bba8:	e3066fa8 	movw	r6, #28584	; 0x6fa8
        vTaskSuspendAll();
 510bbac:	e3a03000 	mov	r3, #0
 510bbb0:	e3406512 	movt	r6, #1298	; 0x512
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bbb4:	e1a04003 	mov	r4, r3
 510bbb8:	ea000002 	b	510bbc8 <MPU_xEventGroupCreateStatic+0x34>
 510bbbc:	e2844001 	add	r4, r4, #1
 510bbc0:	e3540080 	cmp	r4, #128	; 0x80
 510bbc4:	0a000017 	beq	510bc28 <MPU_xEventGroupCreateStatic+0x94>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bbc8:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bbcc:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bbd0:	e3550000 	cmp	r5, #0
 510bbd4:	1afffff8 	bne	510bbbc <MPU_xEventGroupCreateStatic+0x28>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bbd8:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510bbdc:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bbe0:	e3e01000 	mvn	r1, #0
 510bbe4:	e1a09103 	lsl	r9, r3, #2
        ( void ) xTaskResumeAll();
 510bbe8:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bbec:	e7861009 	str	r1, [r6, r9]
 510bbf0:	e0868103 	add	r8, r6, r3, lsl #2
        ( void ) xTaskResumeAll();
 510bbf4:	e12fff32 	blx	r2
                xInternalEventGroupHandle = xEventGroupCreateStatic( pxEventGroupBuffer );
 510bbf8:	e3003468 	movw	r3, #1128	; 0x468
 510bbfc:	e1a00007 	mov	r0, r7
 510bc00:	e3403510 	movt	r3, #1296	; 0x510
 510bc04:	e12fff33 	blx	r3
                if( xInternalEventGroupHandle != NULL )
 510bc08:	e2507000 	subs	r7, r0, #0
 510bc0c:	0a00000b 	beq	510bc40 <MPU_xEventGroupCreateStatic+0xac>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510bc10:	e7867009 	str	r7, [r6, r9]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bc14:	e3a03004 	mov	r3, #4
                    xExternalEventGroupHandle = ( EventGroupHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510bc18:	e2847001 	add	r7, r4, #1
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bc1c:	e9880028 	stmib	r8, {r3, r5}
        }
 510bc20:	e1a00007 	mov	r0, r7
 510bc24:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        ( void ) xTaskResumeAll();
 510bc28:	e3053efc 	movw	r3, #24316	; 0x5efc
            EventGroupHandle_t xExternalEventGroupHandle = NULL;
 510bc2c:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510bc30:	e3403510 	movt	r3, #1296	; 0x510
 510bc34:	e12fff33 	blx	r3
        }
 510bc38:	e1a00007 	mov	r0, r7
 510bc3c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        taskENTER_CRITICAL();
 510bc40:	e30c3930 	movw	r3, #51504	; 0xc930
 510bc44:	e3403510 	movt	r3, #1296	; 0x510
 510bc48:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bc4c:	e7867009 	str	r7, [r6, r9]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bc50:	e5887004 	str	r7, [r8, #4]
        taskEXIT_CRITICAL();
 510bc54:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510bc58:	e5887008 	str	r7, [r8, #8]
        taskEXIT_CRITICAL();
 510bc5c:	e3403510 	movt	r3, #1296	; 0x510
 510bc60:	e12fff33 	blx	r3
        }
 510bc64:	e1a00007 	mov	r0, r7
 510bc68:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

0510bc6c <MPU_vEventGroupDelete>:
        {
 510bc6c:	e92d4070 	push	{r4, r5, r6, lr}
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510bc70:	e2404001 	sub	r4, r0, #1
 510bc74:	e354007f 	cmp	r4, #127	; 0x7f
 510bc78:	88bd8070 	pophi	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510bc7c:	e3065fa8 	movw	r5, #28584	; 0x6fa8
 510bc80:	e0843084 	add	r3, r4, r4, lsl #1
 510bc84:	e3405512 	movt	r5, #1298	; 0x512
 510bc88:	e1a02103 	lsl	r2, r3, #2
 510bc8c:	e0853103 	add	r3, r5, r3, lsl #2
 510bc90:	e1a06084 	lsl	r6, r4, #1
 510bc94:	e5933004 	ldr	r3, [r3, #4]
 510bc98:	e3530004 	cmp	r3, #4
 510bc9c:	18bd8070 	popne	{r4, r5, r6, pc}
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510bca0:	e7950002 	ldr	r0, [r5, r2]
                if( xInternalEventGroupHandle != NULL )
 510bca4:	e3500000 	cmp	r0, #0
 510bca8:	08bd8070 	popeq	{r4, r5, r6, pc}
                    vEventGroupDelete( xInternalEventGroupHandle );
 510bcac:	e3003a7c 	movw	r3, #2684	; 0xa7c
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bcb0:	e0844006 	add	r4, r4, r6
                    vEventGroupDelete( xInternalEventGroupHandle );
 510bcb4:	e3403510 	movt	r3, #1296	; 0x510
 510bcb8:	e12fff33 	blx	r3
        taskENTER_CRITICAL();
 510bcbc:	e30c3930 	movw	r3, #51504	; 0xc930
 510bcc0:	e3403510 	movt	r3, #1296	; 0x510
 510bcc4:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bcc8:	e3a02000 	mov	r2, #0
        taskEXIT_CRITICAL();
 510bccc:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bcd0:	e0851104 	add	r1, r5, r4, lsl #2
 510bcd4:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bcd8:	e5812004 	str	r2, [r1, #4]
        taskEXIT_CRITICAL();
 510bcdc:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bce0:	e7852004 	str	r2, [r5, r4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510bce4:	e5812008 	str	r2, [r1, #8]
        taskEXIT_CRITICAL();
 510bce8:	e12fff33 	blx	r3
        }
 510bcec:	e8bd8070 	pop	{r4, r5, r6, pc}

0510bcf0 <MPU_xEventGroupGetStaticBuffer>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510bcf0:	e2400001 	sub	r0, r0, #1
 510bcf4:	e350007f 	cmp	r0, #127	; 0x7f
 510bcf8:	9a000001 	bls	510bd04 <MPU_xEventGroupGetStaticBuffer+0x14>
            BaseType_t xReturn = pdFALSE;
 510bcfc:	e3a00000 	mov	r0, #0
        }
 510bd00:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510bd04:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510bd08:	e0800080 	add	r0, r0, r0, lsl #1
 510bd0c:	e3403512 	movt	r3, #1298	; 0x512
 510bd10:	e0832100 	add	r2, r3, r0, lsl #2
 510bd14:	e1a00100 	lsl	r0, r0, #2
 510bd18:	e5922004 	ldr	r2, [r2, #4]
 510bd1c:	e3520004 	cmp	r2, #4
 510bd20:	1afffff5 	bne	510bcfc <MPU_xEventGroupGetStaticBuffer+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510bd24:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalEventGroupHandle != NULL )
 510bd28:	e3500000 	cmp	r0, #0
 510bd2c:	0afffff2 	beq	510bcfc <MPU_xEventGroupGetStaticBuffer+0xc>
                    xReturn = xEventGroupGetStaticBuffer( xInternalEventGroupHandle, ppxEventGroupBuffer );
 510bd30:	e3003b3c 	movw	r3, #2876	; 0xb3c
 510bd34:	e3403510 	movt	r3, #1296	; 0x510
        {
 510bd38:	e92d4010 	push	{r4, lr}
                    xReturn = xEventGroupGetStaticBuffer( xInternalEventGroupHandle, ppxEventGroupBuffer );
 510bd3c:	e12fff33 	blx	r3
        }
 510bd40:	e8bd8010 	pop	{r4, pc}

0510bd44 <MPU_xEventGroupGetBitsFromISR>:
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510bd44:	e2400001 	sub	r0, r0, #1
 510bd48:	e350007f 	cmp	r0, #127	; 0x7f
 510bd4c:	9a000001 	bls	510bd58 <MPU_xEventGroupGetBitsFromISR+0x14>
            EventBits_t xReturn = 0;
 510bd50:	e3a00000 	mov	r0, #0
        }
 510bd54:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510bd58:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510bd5c:	e0800080 	add	r0, r0, r0, lsl #1
 510bd60:	e3403512 	movt	r3, #1298	; 0x512
 510bd64:	e0832100 	add	r2, r3, r0, lsl #2
 510bd68:	e1a00100 	lsl	r0, r0, #2
 510bd6c:	e5922004 	ldr	r2, [r2, #4]
 510bd70:	e3520004 	cmp	r2, #4
 510bd74:	1afffff5 	bne	510bd50 <MPU_xEventGroupGetBitsFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510bd78:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalEventGroupHandle != NULL )
 510bd7c:	e3500000 	cmp	r0, #0
 510bd80:	0afffff2 	beq	510bd50 <MPU_xEventGroupGetBitsFromISR+0xc>
                    xReturn = xEventGroupGetBitsFromISR( xInternalEventGroupHandle );
 510bd84:	e3003a74 	movw	r3, #2676	; 0xa74
 510bd88:	e3403510 	movt	r3, #1296	; 0x510
        {
 510bd8c:	e92d4010 	push	{r4, lr}
                    xReturn = xEventGroupGetBitsFromISR( xInternalEventGroupHandle );
 510bd90:	e12fff33 	blx	r3
        }
 510bd94:	e8bd8010 	pop	{r4, pc}

0510bd98 <MPU_xStreamBufferGenericCreate>:
        StreamBufferHandle_t MPU_xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                             size_t xTriggerLevelBytes,
                                                             BaseType_t xStreamBufferType,
                                                             StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                             StreamBufferCallbackFunction_t pxReceiveCompletedCallback ) /* PRIVILEGED_FUNCTION */
        {
 510bd98:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 510bd9c:	e24dd00c 	sub	sp, sp, #12
 510bda0:	e59de030 	ldr	lr, [sp, #48]	; 0x30

            /**
             * Stream buffer application level callback functionality is disabled for MPU
             * enabled ports.
             */
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510bda4:	e19e4003 	orrs	r4, lr, r3
 510bda8:	1a000029 	bne	510be54 <MPU_xStreamBufferGenericCreate+0xbc>
        vTaskSuspendAll();
 510bdac:	e30532a0 	movw	r3, #21152	; 0x52a0
 510bdb0:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510bdb4:	e1a07000 	mov	r7, r0
 510bdb8:	e3403510 	movt	r3, #1296	; 0x510
 510bdbc:	e1a08001 	mov	r8, r1
 510bdc0:	e1a09002 	mov	r9, r2
 510bdc4:	e3406512 	movt	r6, #1298	; 0x512
 510bdc8:	e12fff33 	blx	r3
 510bdcc:	e1a0c004 	mov	ip, r4
 510bdd0:	ea000002 	b	510bde0 <MPU_xStreamBufferGenericCreate+0x48>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bdd4:	e2844001 	add	r4, r4, #1
 510bdd8:	e3540080 	cmp	r4, #128	; 0x80
 510bddc:	0a000026 	beq	510be7c <MPU_xStreamBufferGenericCreate+0xe4>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bde0:	e796510c 	ldr	r5, [r6, ip, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bde4:	e28cc003 	add	ip, ip, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bde8:	e3550000 	cmp	r5, #0
 510bdec:	1afffff8 	bne	510bdd4 <MPU_xStreamBufferGenericCreate+0x3c>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bdf0:	e084a084 	add	sl, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510bdf4:	e3053efc 	movw	r3, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bdf8:	e3e02000 	mvn	r2, #0
 510bdfc:	e1a0b10a 	lsl	fp, sl, #2
        ( void ) xTaskResumeAll();
 510be00:	e3403510 	movt	r3, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510be04:	e786200b 	str	r2, [r6, fp]
 510be08:	e086a10a 	add	sl, r6, sl, lsl #2
        ( void ) xTaskResumeAll();
 510be0c:	e12fff33 	blx	r3
            {
                lIndex = MPU_GetFreeIndexInKernelObjectPool();

                if( lIndex != -1 )
                {
                    xInternalStreamBufferHandle = xStreamBufferGenericCreate( xBufferSizeBytes,
 510be10:	e1a00007 	mov	r0, r7
 510be14:	e3037d14 	movw	r7, #15636	; 0x3d14
 510be18:	e1a02009 	mov	r2, r9
 510be1c:	e1a01008 	mov	r1, r8
 510be20:	e3407510 	movt	r7, #1296	; 0x510
 510be24:	e58d5000 	str	r5, [sp]
 510be28:	e1a03005 	mov	r3, r5
 510be2c:	e12fff37 	blx	r7
                                                                              xTriggerLevelBytes,
                                                                              xStreamBufferType,
                                                                              NULL,
                                                                              NULL );

                    if( xInternalStreamBufferHandle != NULL )
 510be30:	e2507000 	subs	r7, r0, #0
 510be34:	0a000015 	beq	510be90 <MPU_xStreamBufferGenericCreate+0xf8>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510be38:	e786700b 	str	r7, [r6, fp]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510be3c:	e3a03003 	mov	r3, #3
                    {
                        MPU_StoreStreamBufferHandleAtIndex( lIndex, xInternalStreamBufferHandle );
                        xExternalStreamBufferHandle = ( StreamBufferHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510be40:	e2847001 	add	r7, r4, #1
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510be44:	e98a0028 	stmib	sl, {r3, r5}
                traceSTREAM_BUFFER_CREATE_FAILED( xStreamBufferType );
                xExternalStreamBufferHandle = NULL;
            }

            return xExternalStreamBufferHandle;
        }
 510be48:	e1a00007 	mov	r0, r7
 510be4c:	e28dd00c 	add	sp, sp, #12
 510be50:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510be54:	e30d0b50 	movw	r0, #56144	; 0xdb50
 510be58:	e3003900 	movw	r3, #2304	; 0x900
 510be5c:	e3011244 	movw	r1, #4676	; 0x1244
 510be60:	e3403511 	movt	r3, #1297	; 0x511
                xExternalStreamBufferHandle = NULL;
 510be64:	e3a07000 	mov	r7, #0
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510be68:	e3400512 	movt	r0, #1298	; 0x512
 510be6c:	e12fff33 	blx	r3
        }
 510be70:	e1a00007 	mov	r0, r7
 510be74:	e28dd00c 	add	sp, sp, #12
 510be78:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510be7c:	e3053efc 	movw	r3, #24316	; 0x5efc
            StreamBufferHandle_t xExternalStreamBufferHandle = NULL;
 510be80:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510be84:	e3403510 	movt	r3, #1296	; 0x510
 510be88:	e12fff33 	blx	r3
                if( lIndex != -1 )
 510be8c:	eaffffed 	b	510be48 <MPU_xStreamBufferGenericCreate+0xb0>
        taskENTER_CRITICAL();
 510be90:	e30c3930 	movw	r3, #51504	; 0xc930
 510be94:	e3403510 	movt	r3, #1296	; 0x510
 510be98:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510be9c:	e786700b 	str	r7, [r6, fp]
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bea0:	e58a7004 	str	r7, [sl, #4]
        taskEXIT_CRITICAL();
 510bea4:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510bea8:	e58a7008 	str	r7, [sl, #8]
        taskEXIT_CRITICAL();
 510beac:	e3403510 	movt	r3, #1296	; 0x510
 510beb0:	e12fff33 	blx	r3
            return xExternalStreamBufferHandle;
 510beb4:	eaffffe3 	b	510be48 <MPU_xStreamBufferGenericCreate+0xb0>

0510beb8 <MPU_xStreamBufferGenericCreateStatic>:
                                                                   BaseType_t xStreamBufferType,
                                                                   uint8_t * const pucStreamBufferStorageArea,
                                                                   StaticStreamBuffer_t * const pxStaticStreamBuffer,
                                                                   StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                                   StreamBufferCallbackFunction_t pxReceiveCompletedCallback ) /* PRIVILEGED_FUNCTION */
        {
 510beb8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 510bebc:	e1a0a003 	mov	sl, r3
 510bec0:	e24dd01c 	sub	sp, sp, #28
 510bec4:	e58d2014 	str	r2, [sp, #20]
 510bec8:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
 510becc:	e59d3048 	ldr	r3, [sp, #72]	; 0x48

            /**
             * Stream buffer application level callback functionality is disabled for MPU
             * enabled ports.
             */
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510bed0:	e19c4003 	orrs	r4, ip, r3
 510bed4:	1a00002e 	bne	510bf94 <MPU_xStreamBufferGenericCreateStatic+0xdc>
        vTaskSuspendAll();
 510bed8:	e30532a0 	movw	r3, #21152	; 0x52a0
 510bedc:	e3066fa8 	movw	r6, #28584	; 0x6fa8
 510bee0:	e1a07000 	mov	r7, r0
 510bee4:	e3403510 	movt	r3, #1296	; 0x510
 510bee8:	e1a08001 	mov	r8, r1
 510beec:	e1a09002 	mov	r9, r2
 510bef0:	e3406512 	movt	r6, #1298	; 0x512
 510bef4:	e12fff33 	blx	r3
 510bef8:	e1a03004 	mov	r3, r4
 510befc:	ea000002 	b	510bf0c <MPU_xStreamBufferGenericCreateStatic+0x54>
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bf00:	e2844001 	add	r4, r4, #1
 510bf04:	e3540080 	cmp	r4, #128	; 0x80
 510bf08:	0a00002b 	beq	510bfbc <MPU_xStreamBufferGenericCreateStatic+0x104>
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bf0c:	e7965103 	ldr	r5, [r6, r3, lsl #2]
            for( i = 0; i < configPROTECTED_KERNEL_OBJECT_POOL_SIZE; i++ )
 510bf10:	e2833003 	add	r3, r3, #3
                if( xKernelObjectPool[ i ].xInternalObjectHandle == NULL )
 510bf14:	e3550000 	cmp	r5, #0
 510bf18:	1afffff8 	bne	510bf00 <MPU_xStreamBufferGenericCreateStatic+0x48>
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bf1c:	e0843084 	add	r3, r4, r4, lsl #1
        ( void ) xTaskResumeAll();
 510bf20:	e3052efc 	movw	r2, #24316	; 0x5efc
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bf24:	e3e01000 	mvn	r1, #0
 510bf28:	e1a0b103 	lsl	fp, r3, #2
 510bf2c:	e0863103 	add	r3, r6, r3, lsl #2
 510bf30:	e786100b 	str	r1, [r6, fp]
        ( void ) xTaskResumeAll();
 510bf34:	e3402510 	movt	r2, #1296	; 0x510
                    xKernelObjectPool[ i ].xInternalObjectHandle = ( OpaqueObjectHandle_t ) ( ~0U );
 510bf38:	e58d3014 	str	r3, [sp, #20]
        ( void ) xTaskResumeAll();
 510bf3c:	e12fff32 	blx	r2
            {
                lIndex = MPU_GetFreeIndexInKernelObjectPool();

                if( lIndex != -1 )
                {
                    xInternalStreamBufferHandle = xStreamBufferGenericCreateStatic( xBufferSizeBytes,
 510bf40:	e59dc040 	ldr	ip, [sp, #64]	; 0x40
 510bf44:	e1a00007 	mov	r0, r7
 510bf48:	e3037e70 	movw	r7, #15984	; 0x3e70
 510bf4c:	e1a0300a 	mov	r3, sl
 510bf50:	e1a02009 	mov	r2, r9
 510bf54:	e3407510 	movt	r7, #1296	; 0x510
 510bf58:	e58d5008 	str	r5, [sp, #8]
 510bf5c:	e1a01008 	mov	r1, r8
 510bf60:	e58d5004 	str	r5, [sp, #4]
 510bf64:	e58dc000 	str	ip, [sp]
 510bf68:	e12fff37 	blx	r7
                                                                                    pucStreamBufferStorageArea,
                                                                                    pxStaticStreamBuffer,
                                                                                    NULL,
                                                                                    NULL );

                    if( xInternalStreamBufferHandle != NULL )
 510bf6c:	e2507000 	subs	r7, r0, #0
 510bf70:	0a000016 	beq	510bfd0 <MPU_xStreamBufferGenericCreateStatic+0x118>
        xKernelObjectPool[ lIndex ].xInternalObjectHandle = xHandle;
 510bf74:	e786700b 	str	r7, [r6, fp]
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bf78:	e3a03003 	mov	r3, #3
        xKernelObjectPool[ lIndex ].pvKernelObjectData = pvKernelObjectData;
 510bf7c:	e59d2014 	ldr	r2, [sp, #20]
                    {
                        MPU_StoreStreamBufferHandleAtIndex( lIndex, xInternalStreamBufferHandle );
                        xExternalStreamBufferHandle = ( StreamBufferHandle_t ) CONVERT_TO_EXTERNAL_INDEX( lIndex );
 510bf80:	e2847001 	add	r7, r4, #1
        xKernelObjectPool[ lIndex ].ulKernelObjectType = ulKernelObjectType;
 510bf84:	e9820028 	stmib	r2, {r3, r5}
                traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xStreamBufferType );
                xExternalStreamBufferHandle = NULL;
            }

            return xExternalStreamBufferHandle;
        }
 510bf88:	e1a00007 	mov	r0, r7
 510bf8c:	e28dd01c 	add	sp, sp, #28
 510bf90:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510bf94:	e30d0b50 	movw	r0, #56144	; 0xdb50
 510bf98:	e3003900 	movw	r3, #2304	; 0x900
 510bf9c:	e301127d 	movw	r1, #4733	; 0x127d
 510bfa0:	e3403511 	movt	r3, #1297	; 0x511
                xExternalStreamBufferHandle = NULL;
 510bfa4:	e3a07000 	mov	r7, #0
            configASSERT( ( pxSendCompletedCallback == NULL ) &&
 510bfa8:	e3400512 	movt	r0, #1298	; 0x512
 510bfac:	e12fff33 	blx	r3
        }
 510bfb0:	e1a00007 	mov	r0, r7
 510bfb4:	e28dd01c 	add	sp, sp, #28
 510bfb8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        ( void ) xTaskResumeAll();
 510bfbc:	e3053efc 	movw	r3, #24316	; 0x5efc
            StreamBufferHandle_t xExternalStreamBufferHandle = NULL;
 510bfc0:	e3a07000 	mov	r7, #0
        ( void ) xTaskResumeAll();
 510bfc4:	e3403510 	movt	r3, #1296	; 0x510
 510bfc8:	e12fff33 	blx	r3
                if( lIndex != -1 )
 510bfcc:	eaffffed 	b	510bf88 <MPU_xStreamBufferGenericCreateStatic+0xd0>
        taskENTER_CRITICAL();
 510bfd0:	e30c3930 	movw	r3, #51504	; 0xc930
 510bfd4:	e3403510 	movt	r3, #1296	; 0x510
 510bfd8:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bfdc:	e59d2014 	ldr	r2, [sp, #20]
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510bfe0:	e786700b 	str	r7, [r6, fp]
        taskEXIT_CRITICAL();
 510bfe4:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510bfe8:	e5827004 	str	r7, [r2, #4]
        taskEXIT_CRITICAL();
 510bfec:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510bff0:	e5827008 	str	r7, [r2, #8]
        taskEXIT_CRITICAL();
 510bff4:	e12fff33 	blx	r3
            return xExternalStreamBufferHandle;
 510bff8:	eaffffe2 	b	510bf88 <MPU_xStreamBufferGenericCreateStatic+0xd0>

0510bffc <MPU_vStreamBufferDelete>:
/*-----------------------------------------------------------*/

    #if ( configUSE_STREAM_BUFFERS == 1 )

        void MPU_vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer ) /* PRIVILEGED_FUNCTION */
        {
 510bffc:	e92d4070 	push	{r4, r5, r6, lr}
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c000:	e2404001 	sub	r4, r0, #1
 510c004:	e354007f 	cmp	r4, #127	; 0x7f
 510c008:	88bd8070 	pophi	{r4, r5, r6, pc}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c00c:	e3065fa8 	movw	r5, #28584	; 0x6fa8
 510c010:	e0843084 	add	r3, r4, r4, lsl #1
 510c014:	e3405512 	movt	r5, #1298	; 0x512
 510c018:	e1a02103 	lsl	r2, r3, #2
 510c01c:	e0853103 	add	r3, r5, r3, lsl #2
 510c020:	e1a06084 	lsl	r6, r4, #1
 510c024:	e5933004 	ldr	r3, [r3, #4]
 510c028:	e3530003 	cmp	r3, #3
 510c02c:	1a000005 	bne	510c048 <MPU_vStreamBufferDelete+0x4c>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c030:	e7950002 	ldr	r0, [r5, r2]
            {
                xInternalStreamBufferHandle = MPU_GetStreamBufferHandleAtIndex( CONVERT_TO_INTERNAL_INDEX( lIndex ) );

                if( xInternalStreamBufferHandle != NULL )
 510c034:	e3500000 	cmp	r0, #0
 510c038:	0a000002 	beq	510c048 <MPU_vStreamBufferDelete+0x4c>
                {
                    vStreamBufferDelete( xInternalStreamBufferHandle );
 510c03c:	e30337b0 	movw	r3, #14256	; 0x37b0
 510c040:	e3403510 	movt	r3, #1296	; 0x510
 510c044:	e12fff33 	blx	r3
        taskENTER_CRITICAL();
 510c048:	e30c3930 	movw	r3, #51504	; 0xc930
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510c04c:	e0844006 	add	r4, r4, r6
        taskENTER_CRITICAL();
 510c050:	e3403510 	movt	r3, #1296	; 0x510
 510c054:	e12fff33 	blx	r3
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510c058:	e3a02000 	mov	r2, #0
        taskEXIT_CRITICAL();
 510c05c:	e30c3988 	movw	r3, #51592	; 0xc988
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510c060:	e0851104 	add	r1, r5, r4, lsl #2
 510c064:	e1a04104 	lsl	r4, r4, #2
            xKernelObjectPool[ lIndex ].ulKernelObjectType = KERNEL_OBJECT_TYPE_INVALID;
 510c068:	e5812004 	str	r2, [r1, #4]
        taskEXIT_CRITICAL();
 510c06c:	e3403510 	movt	r3, #1296	; 0x510
            xKernelObjectPool[ lIndex ].xInternalObjectHandle = NULL;
 510c070:	e7852004 	str	r2, [r5, r4]
            xKernelObjectPool[ lIndex ].pvKernelObjectData = NULL;
 510c074:	e5812008 	str	r2, [r1, #8]
        taskEXIT_CRITICAL();
 510c078:	e12fff33 	blx	r3
                }

                MPU_SetIndexFreeInKernelObjectPool( CONVERT_TO_INTERNAL_INDEX( lIndex ) );
            }
        }
 510c07c:	e8bd8070 	pop	{r4, r5, r6, pc}

0510c080 <MPU_xStreamBufferReset>:
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c080:	e2400001 	sub	r0, r0, #1
 510c084:	e350007f 	cmp	r0, #127	; 0x7f
 510c088:	9a000001 	bls	510c094 <MPU_xStreamBufferReset+0x14>
            BaseType_t xReturn = pdFALSE;
 510c08c:	e3a00000 	mov	r0, #0
                    xReturn = xStreamBufferReset( xInternalStreamBufferHandle );
                }
            }

            return xReturn;
        }
 510c090:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c094:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510c098:	e0800080 	add	r0, r0, r0, lsl #1
 510c09c:	e3403512 	movt	r3, #1298	; 0x512
 510c0a0:	e0832100 	add	r2, r3, r0, lsl #2
 510c0a4:	e1a00100 	lsl	r0, r0, #2
 510c0a8:	e5922004 	ldr	r2, [r2, #4]
 510c0ac:	e3520003 	cmp	r2, #3
 510c0b0:	1afffff5 	bne	510c08c <MPU_xStreamBufferReset+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c0b4:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalStreamBufferHandle != NULL )
 510c0b8:	e3500000 	cmp	r0, #0
 510c0bc:	0afffff2 	beq	510c08c <MPU_xStreamBufferReset+0xc>
                    xReturn = xStreamBufferReset( xInternalStreamBufferHandle );
 510c0c0:	e30338cc 	movw	r3, #14540	; 0x38cc
 510c0c4:	e3403510 	movt	r3, #1296	; 0x510
        {
 510c0c8:	e92d4010 	push	{r4, lr}
                    xReturn = xStreamBufferReset( xInternalStreamBufferHandle );
 510c0cc:	e12fff33 	blx	r3
        }
 510c0d0:	e8bd8010 	pop	{r4, pc}

0510c0d4 <MPU_xStreamBufferGetStaticBuffers>:
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffers;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c0d4:	e2400001 	sub	r0, r0, #1
 510c0d8:	e350007f 	cmp	r0, #127	; 0x7f
 510c0dc:	9a000001 	bls	510c0e8 <MPU_xStreamBufferGetStaticBuffers+0x14>
            BaseType_t xReturn = pdFALSE;
 510c0e0:	e3a00000 	mov	r0, #0
                    xReturn = MPU_xStreamBufferGetStaticBuffers( xInternalStreamBufferHandle, ppucStreamBufferStorageArea, ppxStaticStreamBuffer );
                }
            }

            return xReturn;
        }
 510c0e4:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c0e8:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510c0ec:	e0800080 	add	r0, r0, r0, lsl #1
 510c0f0:	e3403512 	movt	r3, #1298	; 0x512
 510c0f4:	e1a0c100 	lsl	ip, r0, #2
 510c0f8:	e0830100 	add	r0, r3, r0, lsl #2
 510c0fc:	e5900004 	ldr	r0, [r0, #4]
 510c100:	e3500003 	cmp	r0, #3
 510c104:	1afffff5 	bne	510c0e0 <MPU_xStreamBufferGetStaticBuffers+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c108:	e793000c 	ldr	r0, [r3, ip]
                if( xInternalStreamBufferHandle != NULL )
 510c10c:	e3500000 	cmp	r0, #0
 510c110:	0afffff2 	beq	510c0e0 <MPU_xStreamBufferGetStaticBuffers+0xc>
            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c114:	e2400001 	sub	r0, r0, #1
 510c118:	e350007f 	cmp	r0, #127	; 0x7f
 510c11c:	8affffef 	bhi	510c0e0 <MPU_xStreamBufferGetStaticBuffers+0xc>
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c120:	e0800080 	add	r0, r0, r0, lsl #1
 510c124:	e1a0c100 	lsl	ip, r0, #2
 510c128:	e0830100 	add	r0, r3, r0, lsl #2
 510c12c:	e5900004 	ldr	r0, [r0, #4]
 510c130:	e3500003 	cmp	r0, #3
 510c134:	1affffe9 	bne	510c0e0 <MPU_xStreamBufferGetStaticBuffers+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c138:	e793000c 	ldr	r0, [r3, ip]
                if( xInternalStreamBufferHandle != NULL )
 510c13c:	e3500000 	cmp	r0, #0
 510c140:	0affffe6 	beq	510c0e0 <MPU_xStreamBufferGetStaticBuffers+0xc>
        {
 510c144:	e92d4010 	push	{r4, lr}
                    xReturn = MPU_xStreamBufferGetStaticBuffers( xInternalStreamBufferHandle, ppucStreamBufferStorageArea, ppxStaticStreamBuffer );
 510c148:	ebffffe1 	bl	510c0d4 <MPU_xStreamBufferGetStaticBuffers>
        }
 510c14c:	e8bd8010 	pop	{r4, pc}

0510c150 <MPU_xStreamBufferSendFromISR>:
        StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
        int32_t lIndex;

        lIndex = ( int32_t ) xStreamBuffer;

        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c150:	e2400001 	sub	r0, r0, #1
 510c154:	e350007f 	cmp	r0, #127	; 0x7f
 510c158:	9a000001 	bls	510c164 <MPU_xStreamBufferSendFromISR+0x14>
        size_t xReturn = 0;
 510c15c:	e3a00000 	mov	r0, #0
                xReturn = xStreamBufferSendFromISR( xInternalStreamBufferHandle, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken );
            }
        }

        return xReturn;
    }
 510c160:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c164:	e306cfa8 	movw	ip, #28584	; 0x6fa8
 510c168:	e0800080 	add	r0, r0, r0, lsl #1
 510c16c:	e340c512 	movt	ip, #1298	; 0x512
    {
 510c170:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c174:	e08ce100 	add	lr, ip, r0, lsl #2
 510c178:	e1a00100 	lsl	r0, r0, #2
 510c17c:	e59ee004 	ldr	lr, [lr, #4]
 510c180:	e35e0003 	cmp	lr, #3
 510c184:	1a000006 	bne	510c1a4 <MPU_xStreamBufferSendFromISR+0x54>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c188:	e79c0000 	ldr	r0, [ip, r0]
            if( xInternalStreamBufferHandle != NULL )
 510c18c:	e3500000 	cmp	r0, #0
 510c190:	0a000003 	beq	510c1a4 <MPU_xStreamBufferSendFromISR+0x54>
                xReturn = xStreamBufferSendFromISR( xInternalStreamBufferHandle, pvTxData, xDataLengthBytes, pxHigherPriorityTaskWoken );
 510c194:	e30343a8 	movw	r4, #13224	; 0x33a8
 510c198:	e3404510 	movt	r4, #1296	; 0x510
 510c19c:	e12fff34 	blx	r4
    }
 510c1a0:	e8bd8010 	pop	{r4, pc}
        size_t xReturn = 0;
 510c1a4:	e3a00000 	mov	r0, #0
 510c1a8:	e8bd8010 	pop	{r4, pc}

0510c1ac <MPU_xStreamBufferReceiveFromISR>:
        StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
        int32_t lIndex;

        lIndex = ( int32_t ) xStreamBuffer;

        if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c1ac:	e2400001 	sub	r0, r0, #1
 510c1b0:	e350007f 	cmp	r0, #127	; 0x7f
 510c1b4:	9a000001 	bls	510c1c0 <MPU_xStreamBufferReceiveFromISR+0x14>
        size_t xReturn = 0;
 510c1b8:	e3a00000 	mov	r0, #0
                xReturn = xStreamBufferReceiveFromISR( xInternalStreamBufferHandle, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken );
            }
        }

        return xReturn;
    }
 510c1bc:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c1c0:	e306cfa8 	movw	ip, #28584	; 0x6fa8
 510c1c4:	e0800080 	add	r0, r0, r0, lsl #1
 510c1c8:	e340c512 	movt	ip, #1298	; 0x512
    {
 510c1cc:	e92d4010 	push	{r4, lr}
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c1d0:	e08ce100 	add	lr, ip, r0, lsl #2
 510c1d4:	e1a00100 	lsl	r0, r0, #2
 510c1d8:	e59ee004 	ldr	lr, [lr, #4]
 510c1dc:	e35e0003 	cmp	lr, #3
 510c1e0:	1a000006 	bne	510c200 <MPU_xStreamBufferReceiveFromISR+0x54>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c1e4:	e79c0000 	ldr	r0, [ip, r0]
            if( xInternalStreamBufferHandle != NULL )
 510c1e8:	e3500000 	cmp	r0, #0
 510c1ec:	0a000003 	beq	510c200 <MPU_xStreamBufferReceiveFromISR+0x54>
                xReturn = xStreamBufferReceiveFromISR( xInternalStreamBufferHandle, pvRxData, xBufferLengthBytes, pxHigherPriorityTaskWoken );
 510c1f0:	e30346b4 	movw	r4, #14004	; 0x36b4
 510c1f4:	e3404510 	movt	r4, #1296	; 0x510
 510c1f8:	e12fff34 	blx	r4
    }
 510c1fc:	e8bd8010 	pop	{r4, pc}
        size_t xReturn = 0;
 510c200:	e3a00000 	mov	r0, #0
 510c204:	e8bd8010 	pop	{r4, pc}

0510c208 <MPU_xStreamBufferSendCompletedFromISR>:
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c208:	e2400001 	sub	r0, r0, #1
 510c20c:	e350007f 	cmp	r0, #127	; 0x7f
 510c210:	9a000001 	bls	510c21c <MPU_xStreamBufferSendCompletedFromISR+0x14>
            BaseType_t xReturn = pdFALSE;
 510c214:	e3a00000 	mov	r0, #0
                    xReturn = xStreamBufferSendCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
                }
            }

            return xReturn;
        }
 510c218:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c21c:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510c220:	e0800080 	add	r0, r0, r0, lsl #1
 510c224:	e3403512 	movt	r3, #1298	; 0x512
 510c228:	e0832100 	add	r2, r3, r0, lsl #2
 510c22c:	e1a00100 	lsl	r0, r0, #2
 510c230:	e5922004 	ldr	r2, [r2, #4]
 510c234:	e3520003 	cmp	r2, #3
 510c238:	1afffff5 	bne	510c214 <MPU_xStreamBufferSendCompletedFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c23c:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalStreamBufferHandle != NULL )
 510c240:	e3500000 	cmp	r0, #0
 510c244:	0afffff2 	beq	510c214 <MPU_xStreamBufferSendCompletedFromISR+0xc>
                    xReturn = xStreamBufferSendCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
 510c248:	e3033b54 	movw	r3, #15188	; 0x3b54
 510c24c:	e3403510 	movt	r3, #1296	; 0x510
        {
 510c250:	e92d4010 	push	{r4, lr}
                    xReturn = xStreamBufferSendCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
 510c254:	e12fff33 	blx	r3
        }
 510c258:	e8bd8010 	pop	{r4, pc}

0510c25c <MPU_xStreamBufferReceiveCompletedFromISR>:
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c25c:	e2400001 	sub	r0, r0, #1
 510c260:	e350007f 	cmp	r0, #127	; 0x7f
 510c264:	9a000001 	bls	510c270 <MPU_xStreamBufferReceiveCompletedFromISR+0x14>
            BaseType_t xReturn = pdFALSE;
 510c268:	e3a00000 	mov	r0, #0
                    xReturn = xStreamBufferReceiveCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
                }
            }

            return xReturn;
        }
 510c26c:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c270:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510c274:	e0800080 	add	r0, r0, r0, lsl #1
 510c278:	e3403512 	movt	r3, #1298	; 0x512
 510c27c:	e0832100 	add	r2, r3, r0, lsl #2
 510c280:	e1a00100 	lsl	r0, r0, #2
 510c284:	e5922004 	ldr	r2, [r2, #4]
 510c288:	e3520003 	cmp	r2, #3
 510c28c:	1afffff5 	bne	510c268 <MPU_xStreamBufferReceiveCompletedFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c290:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalStreamBufferHandle != NULL )
 510c294:	e3500000 	cmp	r0, #0
 510c298:	0afffff2 	beq	510c268 <MPU_xStreamBufferReceiveCompletedFromISR+0xc>
                    xReturn = xStreamBufferReceiveCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
 510c29c:	e3033bc8 	movw	r3, #15304	; 0x3bc8
 510c2a0:	e3403510 	movt	r3, #1296	; 0x510
        {
 510c2a4:	e92d4010 	push	{r4, lr}
                    xReturn = xStreamBufferReceiveCompletedFromISR( xInternalStreamBufferHandle, pxHigherPriorityTaskWoken );
 510c2a8:	e12fff33 	blx	r3
        }
 510c2ac:	e8bd8010 	pop	{r4, pc}

0510c2b0 <MPU_xStreamBufferResetFromISR>:
            StreamBufferHandle_t xInternalStreamBufferHandle = NULL;
            int32_t lIndex;

            lIndex = ( int32_t ) xStreamBuffer;

            if( IS_EXTERNAL_INDEX_VALID( lIndex ) != pdFALSE )
 510c2b0:	e2400001 	sub	r0, r0, #1
 510c2b4:	e350007f 	cmp	r0, #127	; 0x7f
 510c2b8:	9a000001 	bls	510c2c4 <MPU_xStreamBufferResetFromISR+0x14>
            BaseType_t xReturn = pdFAIL;
 510c2bc:	e3a00000 	mov	r0, #0
                    xReturn = xStreamBufferResetFromISR( xInternalStreamBufferHandle );
                }
            }

            return xReturn;
        }
 510c2c0:	e12fff1e 	bx	lr
        if( xKernelObjectPool[ lIndex ].ulKernelObjectType == ulKernelObjectType )
 510c2c4:	e3063fa8 	movw	r3, #28584	; 0x6fa8
 510c2c8:	e0800080 	add	r0, r0, r0, lsl #1
 510c2cc:	e3403512 	movt	r3, #1298	; 0x512
 510c2d0:	e0832100 	add	r2, r3, r0, lsl #2
 510c2d4:	e1a00100 	lsl	r0, r0, #2
 510c2d8:	e5922004 	ldr	r2, [r2, #4]
 510c2dc:	e3520003 	cmp	r2, #3
 510c2e0:	1afffff5 	bne	510c2bc <MPU_xStreamBufferResetFromISR+0xc>
            xObjectHandle = xKernelObjectPool[ lIndex ].xInternalObjectHandle;
 510c2e4:	e7930000 	ldr	r0, [r3, r0]
                if( xInternalStreamBufferHandle != NULL )
 510c2e8:	e3500000 	cmp	r0, #0
 510c2ec:	0afffff2 	beq	510c2bc <MPU_xStreamBufferResetFromISR+0xc>
                    xReturn = xStreamBufferResetFromISR( xInternalStreamBufferHandle );
 510c2f0:	e30339ac 	movw	r3, #14764	; 0x39ac
 510c2f4:	e3403510 	movt	r3, #1296	; 0x510
        {
 510c2f8:	e92d4010 	push	{r4, lr}
                    xReturn = xStreamBufferResetFromISR( xInternalStreamBufferHandle );
 510c2fc:	e12fff33 	blx	r3
        }
 510c300:	e8bd8010 	pop	{r4, pc}

0510c304 <FreeRTOS_Tick_Handler>:


PRIVILEGED_FUNCTION void FreeRTOS_Tick_Handler( void ) 
{
int* p = 0xB7000024;
*p = 0x1111;
 510c304:	e3a024b7 	mov	r2, #-1224736768	; 0xb7000000
 510c308:	e3013111 	movw	r3, #4369	; 0x1111
{
 510c30c:	e92d4010 	push	{r4, lr}
*p = 0x1111;
 510c310:	e5823024 	str	r3, [r2, #36]	; 0x24
     * handler runs at the lowest priority, so interrupts cannot already be masked,
     * so there is no need to save and restore the current mask value.  It is
     * necessary to turn off interrupts in the CPU itself while the ICCPMR is being
     * updated.
     */
    portCPU_IRQ_DISABLE();
 510c314:	f10c0080 	cpsid	i
 510c318:	f57ff04f 	dsb	sy
 510c31c:	f57ff06f 	isb	sy
    portICCPMR_PRIORITY_MASK_REGISTER = ( uint32_t ) ( configMAX_API_CALL_INTERRUPT_PRIORITY << portPRIORITY_SHIFT );
 510c320:	e3a03a0a 	mov	r3, #40960	; 0xa000
 510c324:	e3a01088 	mov	r1, #136	; 0x88
 510c328:	e3433120 	movt	r3, #12576	; 0x3120
 510c32c:	e5831004 	str	r1, [r3, #4]
    __asm volatile ( "dsb       \n"
 510c330:	f57ff04f 	dsb	sy
 510c334:	f57ff06f 	isb	sy
                     "isb       \n" ::: "memory" );
    portCPU_IRQ_ENABLE();
 510c338:	f1080080 	cpsie	i
 510c33c:	f57ff04f 	dsb	sy
 510c340:	f57ff06f 	isb	sy
*p = 0x1112;
 510c344:	e3011112 	movw	r1, #4370	; 0x1112
    /* Increment the RTOS tick. */
    if( xTaskIncrementTick() != pdFALSE )
 510c348:	e3053ce0 	movw	r3, #23776	; 0x5ce0
    {
        ulPortYieldRequired = pdTRUE;
    }
*p = 0x1113;
 510c34c:	e3a044b7 	mov	r4, #-1224736768	; 0xb7000000
    if( xTaskIncrementTick() != pdFALSE )
 510c350:	e3403510 	movt	r3, #1296	; 0x510
*p = 0x1112;
 510c354:	e5821024 	str	r1, [r2, #36]	; 0x24
    if( xTaskIncrementTick() != pdFALSE )
 510c358:	e12fff33 	blx	r3
 510c35c:	e3500000 	cmp	r0, #0
        ulPortYieldRequired = pdTRUE;
 510c360:	130736c0 	movwne	r3, #30400	; 0x76c0
 510c364:	13a02001 	movne	r2, #1
 510c368:	13403512 	movtne	r3, #1298	; 0x512
 510c36c:	15832000 	strne	r2, [r3]
*p = 0x1113;
 510c370:	e3013113 	movw	r3, #4371	; 0x1113
 510c374:	e5843024 	str	r3, [r4, #36]	; 0x24
    /* Ensure all interrupt priorities are active again. */
    portCLEAR_INTERRUPT_MASK();
 510c378:	f10c0080 	cpsid	i
 510c37c:	f57ff04f 	dsb	sy
 510c380:	f57ff06f 	isb	sy
 510c384:	e3a03a0a 	mov	r3, #40960	; 0xa000
 510c388:	e3a020ff 	mov	r2, #255	; 0xff
 510c38c:	e3433120 	movt	r3, #12576	; 0x3120
 510c390:	e5832004 	str	r2, [r3, #4]
 510c394:	f57ff04f 	dsb	sy
 510c398:	f57ff06f 	isb	sy
 510c39c:	f1080080 	cpsie	i
 510c3a0:	f57ff04f 	dsb	sy
 510c3a4:	f57ff06f 	isb	sy
    configCLEAR_TICK_INTERRUPT();
 510c3a8:	e3013d60 	movw	r3, #7520	; 0x1d60
 510c3ac:	e3403511 	movt	r3, #1297	; 0x511
 510c3b0:	e12fff33 	blx	r3
*p = 0x1115;
 510c3b4:	e3013115 	movw	r3, #4373	; 0x1115
 510c3b8:	e5843024 	str	r3, [r4, #36]	; 0x24
}
 510c3bc:	e8bd8010 	pop	{r4, pc}

0510c3c0 <pxPortInitialiseStack>:
{
 510c3c0:	e92d4010 	push	{r4, lr}
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x12121212; /* R12. */
 510c3c4:	e301e212 	movw	lr, #4626	; 0x1212
    if( xRunPrivileged == pdTRUE )
 510c3c8:	e3530001 	cmp	r3, #1
{
 510c3cc:	e59d3008 	ldr	r3, [sp, #8]
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x12121212; /* R12. */
 510c3d0:	e341e212 	movt	lr, #4626	; 0x1212
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) pvParameters; /* R0. */
 510c3d4:	e5832308 	str	r2, [r3, #776]	; 0x308
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000015; /* S31. */
 510c3d8:	e3a02015 	mov	r2, #21
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) pxCode; /* PC. */
 510c3dc:	e5831344 	str	r1, [r3, #836]	; 0x344
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000015; /* S31. */
 510c3e0:	e34d2000 	movt	r2, #53248	; 0xd000
        xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
 510c3e4:	e593c06c 	ldr	ip, [r3, #108]	; 0x6c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000009; /* S19. */
 510c3e8:	e3a0429d 	mov	r4, #-805306359	; 0xd0000009
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000015; /* S31. */
 510c3ec:	e5832304 	str	r2, [r3, #772]	; 0x304
        xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
 510c3f0:	038cc002 	orreq	ip, ip, #2
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) pxTopOfStack; /* SP. */
 510c3f4:	e583033c 	str	r0, [r3, #828]	; 0x33c
        xMPUSettings->ulTaskFlags &= ( ~portTASK_IS_PRIVILEGED_FLAG );
 510c3f8:	13ccc002 	bicne	ip, ip, #2
        xMPUSettings->ulTaskFlags |= portTASK_IS_PRIVILEGED_FLAG;
 510c3fc:	0583c06c 	streq	ip, [r3, #108]	; 0x6c
        xMPUSettings->ulContext[ ulIndex ] = SYS_MODE;
 510c400:	03a0c01f 	moveq	ip, #31
        xMPUSettings->ulTaskFlags &= ( ~portTASK_IS_PRIVILEGED_FLAG );
 510c404:	1583c06c 	strne	ip, [r3, #108]	; 0x6c
        xMPUSettings->ulContext[ ulIndex ] = USER_MODE;
 510c408:	13a0c010 	movne	ip, #16
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x11111111; /* R11. */
 510c40c:	e3010111 	movw	r0, #4369	; 0x1111
    if( ( ( uint32_t ) pxCode & portTHUMB_MODE_ADDRESS ) != 0x0UL )
 510c410:	e3110001 	tst	r1, #1
        xMPUSettings->ulContext[ ulIndex ] = USER_MODE;
 510c414:	e583c348 	str	ip, [r3, #840]	; 0x348
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x10101010; /* R10. */
 510c418:	e3011010 	movw	r1, #4112	; 0x1010
 510c41c:	e3411010 	movt	r1, #4112	; 0x1010
        xMPUSettings->ulContext[ ulIndex ] |= portTHUMB_MODE_BIT;
 510c420:	1593c348 	ldrne	ip, [r3, #840]	; 0x348
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x11111111; /* R11. */
 510c424:	e3410111 	movt	r0, #4369	; 0x1111
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x10101010; /* R10. */
 510c428:	e5831330 	str	r1, [r3, #816]	; 0x330
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x08080808; /* R8. */
 510c42c:	e3001808 	movw	r1, #2056	; 0x808
        xMPUSettings->ulContext[ ulIndex ] |= portTHUMB_MODE_BIT;
 510c430:	138cc020 	orrne	ip, ip, #32
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x11111111; /* R11. */
 510c434:	e5830334 	str	r0, [r3, #820]	; 0x334
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x08080808; /* R8. */
 510c438:	e3401808 	movt	r1, #2056	; 0x808
        xMPUSettings->ulContext[ ulIndex ] |= portTHUMB_MODE_BIT;
 510c43c:	1583c348 	strne	ip, [r3, #840]	; 0x348
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
 510c440:	e3a0c000 	mov	ip, #0
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1500000; /* S30. */
 510c444:	e1a0200c 	mov	r2, ip
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x09090909; /* R9. */
 510c448:	e3000909 	movw	r0, #2313	; 0x909
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x08080808; /* R8. */
 510c44c:	e5831328 	str	r1, [r3, #808]	; 0x328
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1500000; /* S30. */
 510c450:	e34d2150 	movt	r2, #53584	; 0xd150
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x06060606; /* R6. */
 510c454:	e3001606 	movw	r1, #1542	; 0x606
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x09090909; /* R9. */
 510c458:	e3400909 	movt	r0, #2313	; 0x909
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1500000; /* S30. */
 510c45c:	e5832300 	str	r2, [r3, #768]	; 0x300
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000014; /* S29. */
 510c460:	e3a02014 	mov	r2, #20
 510c464:	e34d2000 	movt	r2, #53248	; 0xd000
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x09090909; /* R9. */
 510c468:	e583032c 	str	r0, [r3, #812]	; 0x32c
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x06060606; /* R6. */
 510c46c:	e3401606 	movt	r1, #1542	; 0x606
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000014; /* S29. */
 510c470:	e58322fc 	str	r2, [r3, #764]	; 0x2fc
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1400000; /* S28. */
 510c474:	e1a0200c 	mov	r2, ip
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x06060606; /* R6. */
 510c478:	e5831320 	str	r1, [r3, #800]	; 0x320
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1400000; /* S28. */
 510c47c:	e34d2140 	movt	r2, #53568	; 0xd140
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x07070707; /* R7. */
 510c480:	e3000707 	movw	r0, #1799	; 0x707
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x04040404; /* R4. */
 510c484:	e3001404 	movw	r1, #1028	; 0x404
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1400000; /* S28. */
 510c488:	e58322f8 	str	r2, [r3, #760]	; 0x2f8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000013; /* S27. */
 510c48c:	e3a02013 	mov	r2, #19
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x07070707; /* R7. */
 510c490:	e3400707 	movt	r0, #1799	; 0x707
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x04040404; /* R4. */
 510c494:	e3401404 	movt	r1, #1028	; 0x404
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x07070707; /* R7. */
 510c498:	e5830324 	str	r0, [r3, #804]	; 0x324
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000013; /* S27. */
 510c49c:	e34d2000 	movt	r2, #53248	; 0xd000
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x04040404; /* R4. */
 510c4a0:	e5831318 	str	r1, [r3, #792]	; 0x318
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x05050505; /* R5. */
 510c4a4:	e3000505 	movw	r0, #1285	; 0x505
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000013; /* S27. */
 510c4a8:	e58322f4 	str	r2, [r3, #756]	; 0x2f4
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x02020202; /* R2. */
 510c4ac:	e3001202 	movw	r1, #514	; 0x202
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1300000; /* S26. */
 510c4b0:	e1a0200c 	mov	r2, ip
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x05050505; /* R5. */
 510c4b4:	e3400505 	movt	r0, #1285	; 0x505
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x02020202; /* R2. */
 510c4b8:	e3401202 	movt	r1, #514	; 0x202
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x05050505; /* R5. */
 510c4bc:	e583031c 	str	r0, [r3, #796]	; 0x31c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1300000; /* S26. */
 510c4c0:	e34d2130 	movt	r2, #53552	; 0xd130
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x02020202; /* R2. */
 510c4c4:	e5831310 	str	r1, [r3, #784]	; 0x310
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x03030303; /* R3. */
 510c4c8:	e3000303 	movw	r0, #771	; 0x303
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1300000; /* S26. */
 510c4cc:	e58322f0 	str	r2, [r3, #752]	; 0x2f0
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x01010101; /* R1. */
 510c4d0:	e3001101 	movw	r1, #257	; 0x101
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1200000; /* S24. */
 510c4d4:	e1a0200c 	mov	r2, ip
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x03030303; /* R3. */
 510c4d8:	e3400303 	movt	r0, #771	; 0x303
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x01010101; /* R1. */
 510c4dc:	e3401101 	movt	r1, #257	; 0x101
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x03030303; /* R3. */
 510c4e0:	e5830314 	str	r0, [r3, #788]	; 0x314
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1200000; /* S24. */
 510c4e4:	e34d2120 	movt	r2, #53536	; 0xd120
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x01010101; /* R1. */
 510c4e8:	e583130c 	str	r1, [r3, #780]	; 0x30c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000012; /* S25. */
 510c4ec:	e3a00012 	mov	r0, #18
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1200000; /* S24. */
 510c4f0:	e58322e8 	str	r2, [r3, #744]	; 0x2e8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000011; /* S23. */
 510c4f4:	e3a01011 	mov	r1, #17
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1100000; /* S22. */
 510c4f8:	e1a0200c 	mov	r2, ip
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000012; /* S25. */
 510c4fc:	e34d0000 	movt	r0, #53248	; 0xd000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000011; /* S23. */
 510c500:	e34d1000 	movt	r1, #53248	; 0xd000
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) portTASK_RETURN_ADDRESS; /* LR. */
 510c504:	e583c340 	str	ip, [r3, #832]	; 0x340
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1100000; /* S22. */
 510c508:	e34d2110 	movt	r2, #53520	; 0xd110
    xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x12121212; /* R12. */
 510c50c:	e583e338 	str	lr, [r3, #824]	; 0x338
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1000000; /* S20. */
 510c510:	e3a0e4d1 	mov	lr, #-788529152	; 0xd1000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000012; /* S25. */
 510c514:	e58302ec 	str	r0, [r3, #748]	; 0x2ec
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000010; /* S21. */
 510c518:	e3a00010 	mov	r0, #16
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000011; /* S23. */
 510c51c:	e58312e4 	str	r1, [r3, #740]	; 0x2e4
    xSysCallInfo->pulSystemCallStackPointer = &( xSysCallInfo->ulSystemCallStackBuffer[ configSYSTEM_CALL_STACK_SIZE - 1U ] );
 510c520:	e2831f9f 	add	r1, r3, #636	; 0x27c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1100000; /* S22. */
 510c524:	e58322e0 	str	r2, [r3, #736]	; 0x2e0
    xSysCallInfo->pulSystemCallExitAddress = ( uint32_t * ) ( &vPortSystemCallExit );
 510c528:	e3002010 	movw	r2, #16
 510c52c:	e3402511 	movt	r2, #1297	; 0x511
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000009; /* S19. */
 510c530:	e58342d4 	str	r4, [r3, #724]	; 0x2d4
    xSysCallInfo->pulSystemCallStackPointer = ( uint32_t * ) ( ( ( uint32_t ) ( xSysCallInfo->pulSystemCallStackPointer ) ) &
 510c534:	e3c11007 	bic	r1, r1, #7
    xSysCallInfo->pulSystemCallExitAddress = ( uint32_t * ) ( &vPortSystemCallExit );
 510c538:	e583207c 	str	r2, [r3, #124]	; 0x7c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000006; /* S13. */
 510c53c:	e3a0226d 	mov	r2, #-805306362	; 0xd0000006
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD9000000; /* S18. */
 510c540:	e3a044d9 	mov	r4, #-654311424	; 0xd9000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000010; /* S21. */
 510c544:	e34d0000 	movt	r0, #53248	; 0xd000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000006; /* S13. */
 510c548:	e58322bc 	str	r2, [r3, #700]	; 0x2bc
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000005; /* S11. */
 510c54c:	e3a0225d 	mov	r2, #-805306363	; 0xd0000005
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD9000000; /* S18. */
 510c550:	e58342d0 	str	r4, [r3, #720]	; 0x2d0
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000008; /* S17. */
 510c554:	e3a0428d 	mov	r4, #-805306360	; 0xd0000008
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000005; /* S11. */
 510c558:	e58322b4 	str	r2, [r3, #692]	; 0x2b4
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000004; /* S9. */
 510c55c:	e3a0224d 	mov	r2, #-805306364	; 0xd0000004
    xSysCallInfo->pulSystemCallStackPointer = ( uint32_t * ) ( ( ( uint32_t ) ( xSysCallInfo->pulSystemCallStackPointer ) ) &
 510c560:	e5831078 	str	r1, [r3, #120]	; 0x78
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD6000000; /* S12. */
 510c564:	e3a014d6 	mov	r1, #-704643072	; 0xd6000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0x00000000; /* FPSR. */
 510c568:	e583c284 	str	ip, [r3, #644]	; 0x284
    xMPUSettings->ulContext[ ulIndex ] = portNO_CRITICAL_NESTING;
 510c56c:	e583c280 	str	ip, [r3, #640]	; 0x280
    xSysCallInfo->pulTaskStackPointer = NULL;
 510c570:	e583c070 	str	ip, [r3, #112]	; 0x70
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD7000000; /* S14. */
 510c574:	e3a0c4d7 	mov	ip, #-687865856	; 0xd7000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000004; /* S9. */
 510c578:	e58322ac 	str	r2, [r3, #684]	; 0x2ac
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000003; /* S7. */
 510c57c:	e3a0223d 	mov	r2, #-805306365	; 0xd0000003
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000008; /* S17. */
 510c580:	e58342cc 	str	r4, [r3, #716]	; 0x2cc
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD8000000; /* S16. */
 510c584:	e3a04336 	mov	r4, #-671088640	; 0xd8000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD7000000; /* S14. */
 510c588:	e583c2c0 	str	ip, [r3, #704]	; 0x2c0
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD5000000; /* S10. */
 510c58c:	e3a0c4d5 	mov	ip, #-721420288	; 0xd5000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD6000000; /* S12. */
 510c590:	e58312b8 	str	r1, [r3, #696]	; 0x2b8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD4000000; /* S8. */
 510c594:	e3a01335 	mov	r1, #-738197504	; 0xd4000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000003; /* S7. */
 510c598:	e58322a4 	str	r2, [r3, #676]	; 0x2a4
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000002; /* S5. */
 510c59c:	e3a0222d 	mov	r2, #-805306366	; 0xd0000002
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000010; /* S21. */
 510c5a0:	e58302dc 	str	r0, [r3, #732]	; 0x2dc
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000000; /* S1. */
 510c5a4:	e3a0020d 	mov	r0, #-805306368	; 0xd0000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD8000000; /* S16. */
 510c5a8:	e58342c8 	str	r4, [r3, #712]	; 0x2c8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000007; /* S15. */
 510c5ac:	e3a0427d 	mov	r4, #-805306361	; 0xd0000007
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD5000000; /* S10. */
 510c5b0:	e583c2b0 	str	ip, [r3, #688]	; 0x2b0
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD3000000; /* S6. */
 510c5b4:	e3a0c4d3 	mov	ip, #-754974720	; 0xd3000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD4000000; /* S8. */
 510c5b8:	e58312a8 	str	r1, [r3, #680]	; 0x2a8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD2000000; /* S4. */
 510c5bc:	e3a014d2 	mov	r1, #-771751936	; 0xd2000000
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000002; /* S5. */
 510c5c0:	e583229c 	str	r2, [r3, #668]	; 0x29c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000001; /* S3. */
 510c5c4:	e3a0221d 	mov	r2, #-805306367	; 0xd0000001
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000000; /* S1. */
 510c5c8:	e583028c 	str	r0, [r3, #652]	; 0x28c
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000000; /* S0. */
 510c5cc:	e5830288 	str	r0, [r3, #648]	; 0x288
}
 510c5d0:	e2830d0a 	add	r0, r3, #640	; 0x280
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1000000; /* S20. */
 510c5d4:	e583e2d8 	str	lr, [r3, #728]	; 0x2d8
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000007; /* S15. */
 510c5d8:	e58342c4 	str	r4, [r3, #708]	; 0x2c4
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD1000000; /* S2. */
 510c5dc:	e583e290 	str	lr, [r3, #656]	; 0x290
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD3000000; /* S6. */
 510c5e0:	e583c2a0 	str	ip, [r3, #672]	; 0x2a0
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD2000000; /* S4. */
 510c5e4:	e5831298 	str	r1, [r3, #664]	; 0x298
        xMPUSettings->ulContext[ ulIndex ] = ( StackType_t ) 0xD0000001; /* S3. */
 510c5e8:	e5832294 	str	r2, [r3, #660]	; 0x294
}
 510c5ec:	e8bd8010 	pop	{r4, pc}

0510c5f0 <vPortEndScheduler>:
    prvPortSchedulerRunning = pdFALSE;
 510c5f0:	e30726c0 	movw	r2, #30400	; 0x76c0
 510c5f4:	e3a0c000 	mov	ip, #0
    configASSERT( prvPortSchedulerRunning == pdTRUE );
 510c5f8:	e30d0b84 	movw	r0, #56196	; 0xdb84
    prvPortSchedulerRunning = pdFALSE;
 510c5fc:	e3402512 	movt	r2, #1298	; 0x512
    configASSERT( prvPortSchedulerRunning == pdTRUE );
 510c600:	e3003900 	movw	r3, #2304	; 0x900
 510c604:	e3a01e32 	mov	r1, #800	; 0x320
{
 510c608:	e92d4010 	push	{r4, lr}
    configASSERT( prvPortSchedulerRunning == pdTRUE );
 510c60c:	e3403511 	movt	r3, #1297	; 0x511
    prvPortSchedulerRunning = pdFALSE;
 510c610:	e582c004 	str	ip, [r2, #4]
    configASSERT( prvPortSchedulerRunning == pdTRUE );
 510c614:	e3400512 	movt	r0, #1298	; 0x512
 510c618:	e12fff33 	blx	r3
}
 510c61c:	e8bd8010 	pop	{r4, pc}

0510c620 <vPortStoreTaskMPUSettings>:
{
 510c620:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( xRegions == NULL )
 510c624:	e2518000 	subs	r8, r1, #0
{
 510c628:	e1a0a000 	mov	sl, r0
 510c62c:	e24dd014 	sub	sp, sp, #20
 510c630:	e58d2004 	str	r2, [sp, #4]
    if( xRegions == NULL )
 510c634:	0a000056 	beq	510c794 <vPortStoreTaskMPUSettings+0x174>
                configASSERT( ( ( ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress ) % ( ulRegionLengthDecoded ) ) == 0UL );
 510c638:	e300b900 	movw	fp, #2304	; 0x900
 510c63c:	e1a07003 	mov	r7, r3
 510c640:	e340b511 	movt	fp, #1297	; 0x511
 510c644:	e30d3b84 	movw	r3, #56196	; 0xdb84
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = xRegions[ ulIndex ].ulParameters;
 510c648:	e2882008 	add	r2, r8, #8
 510c64c:	e1a04002 	mov	r4, r2
                configASSERT( ( ( ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress ) % ( ulRegionLengthDecoded ) ) == 0UL );
 510c650:	e3403512 	movt	r3, #1298	; 0x512
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = xRegions[ ulIndex ].ulParameters;
 510c654:	e1a0200b 	mov	r2, fp
 510c658:	e1a05000 	mov	r5, r0
 510c65c:	e1a0b003 	mov	fp, r3
    if( xRegions == NULL )
 510c660:	e3a06000 	mov	r6, #0
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = xRegions[ ulIndex ].ulParameters;
 510c664:	e1a03007 	mov	r3, r7
 510c668:	e2889004 	add	r9, r8, #4
 510c66c:	e1a07002 	mov	r7, r2
 510c670:	ea000003 	b	510c684 <vPortStoreTaskMPUSettings+0x64>
        for( ulIndex = 0UL; ulIndex < portNUM_CONFIGURABLE_REGIONS; ulIndex++ )
 510c674:	e2866003 	add	r6, r6, #3
 510c678:	e3560018 	cmp	r6, #24
 510c67c:	e285500c 	add	r5, r5, #12
 510c680:	0a00001d 	beq	510c6fc <vPortStoreTaskMPUSettings+0xdc>
            if( ( xRegions[ ulIndex ] ).ulLengthInBytes > 0UL )
 510c684:	e7990106 	ldr	r0, [r9, r6, lsl #2]
 510c688:	e3500000 	cmp	r0, #0
                xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = 0x0UL;
 510c68c:	05850008 	streq	r0, [r5, #8]
                xMPUSettings->xRegion[ ulIndex ].ulRegionSize = 0x0UL;
 510c690:	05850000 	streq	r0, [r5]
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = 0x0UL;
 510c694:	05850004 	streq	r0, [r5, #4]
            if( ( xRegions[ ulIndex ] ).ulLengthInBytes > 0UL )
 510c698:	0afffff5 	beq	510c674 <vPortStoreTaskMPUSettings+0x54>
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510c69c:	e3a01004 	mov	r1, #4
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c6a0:	e3a02020 	mov	r2, #32
 510c6a4:	ea000002 	b	510c6b4 <vPortStoreTaskMPUSettings+0x94>
            ulReturnValue++;
 510c6a8:	e2811001 	add	r1, r1, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c6ac:	e351001f 	cmp	r1, #31
 510c6b0:	0a00002b 	beq	510c764 <vPortStoreTaskMPUSettings+0x144>
        if( ulActualMPURegionSize <= ulRegionSize )
 510c6b4:	e1500002 	cmp	r0, r2
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c6b8:	e1a02082 	lsl	r2, r2, #1
        if( ulActualMPURegionSize <= ulRegionSize )
 510c6bc:	8afffff9 	bhi	510c6a8 <vPortStoreTaskMPUSettings+0x88>
                ulRegionLengthDecoded = 2UL << ( ulRegionLengthEncoded >> 1UL );
 510c6c0:	e3e00001 	mvn	r0, #1
 510c6c4:	e1e00110 	mvn	r0, r0, lsl r1
    return ulReturnValue << 1UL;
 510c6c8:	e1a01081 	lsl	r1, r1, #1
                xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c6cc:	e3812001 	orr	r2, r1, #1
                configASSERT( ( ( ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress ) % ( ulRegionLengthDecoded ) ) == 0UL );
 510c6d0:	e7981106 	ldr	r1, [r8, r6, lsl #2]
 510c6d4:	e1110000 	tst	r1, r0
 510c6d8:	1a000026 	bne	510c778 <vPortStoreTaskMPUSettings+0x158>
                xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress;
 510c6dc:	e5851008 	str	r1, [r5, #8]
        for( ulIndex = 0UL; ulIndex < portNUM_CONFIGURABLE_REGIONS; ulIndex++ )
 510c6e0:	e285500c 	add	r5, r5, #12
                xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c6e4:	e505200c 	str	r2, [r5, #-12]
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = xRegions[ ulIndex ].ulParameters;
 510c6e8:	e7942106 	ldr	r2, [r4, r6, lsl #2]
        for( ulIndex = 0UL; ulIndex < portNUM_CONFIGURABLE_REGIONS; ulIndex++ )
 510c6ec:	e2866003 	add	r6, r6, #3
                xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = xRegions[ ulIndex ].ulParameters;
 510c6f0:	e5052008 	str	r2, [r5, #-8]
        for( ulIndex = 0UL; ulIndex < portNUM_CONFIGURABLE_REGIONS; ulIndex++ )
 510c6f4:	e3560018 	cmp	r6, #24
 510c6f8:	1affffe1 	bne	510c684 <vPortStoreTaskMPUSettings+0x64>
        if( ulStackDepth != 0x0UL )
 510c6fc:	e3530000 	cmp	r3, #0
 510c700:	0a000015 	beq	510c75c <vPortStoreTaskMPUSettings+0x13c>
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510c704:	e3a01004 	mov	r1, #4
            ulRegionLengthEncoded = prvGetMPURegionSizeEncoding( ulStackDepth * ( uint32_t ) sizeof( StackType_t ) );
 510c708:	e1a07103 	lsl	r7, r3, #2
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c70c:	e3a02020 	mov	r2, #32
 510c710:	ea000002 	b	510c720 <vPortStoreTaskMPUSettings+0x100>
            ulReturnValue++;
 510c714:	e2811001 	add	r1, r1, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c718:	e351001f 	cmp	r1, #31
 510c71c:	0a000032 	beq	510c7ec <vPortStoreTaskMPUSettings+0x1cc>
        if( ulActualMPURegionSize <= ulRegionSize )
 510c720:	e1570002 	cmp	r7, r2
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c724:	e1a02082 	lsl	r2, r2, #1
        if( ulActualMPURegionSize <= ulRegionSize )
 510c728:	8afffff9 	bhi	510c714 <vPortStoreTaskMPUSettings+0xf4>
            ulRegionLengthDecoded = 2UL << ( ulRegionLengthEncoded >> 1UL );
 510c72c:	e3e03001 	mvn	r3, #1
    return ulReturnValue << 1UL;
 510c730:	e1a04081 	lsl	r4, r1, #1
 510c734:	e1e01113 	mvn	r1, r3, lsl r1
            configASSERT( ( ( uint32_t ) pxBottomOfStack % ( ulRegionLengthDecoded ) ) == 0U );
 510c738:	e59d3004 	ldr	r3, [sp, #4]
            xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c73c:	e3844001 	orr	r4, r4, #1
            configASSERT( ( ( uint32_t ) pxBottomOfStack % ( ulRegionLengthDecoded ) ) == 0U );
 510c740:	e1130001 	tst	r3, r1
 510c744:	1a00002d 	bne	510c800 <vPortStoreTaskMPUSettings+0x1e0>
            xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = ( uint32_t ) pxBottomOfStack;
 510c748:	e59d2004 	ldr	r2, [sp, #4]
            xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = ( portMPU_REGION_PRIV_RW_USER_RW_NOEXEC |
 510c74c:	e3013306 	movw	r3, #4870	; 0x1306
            xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = ( uint32_t ) pxBottomOfStack;
 510c750:	e58a2068 	str	r2, [sl, #104]	; 0x68
            xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c754:	e58a4060 	str	r4, [sl, #96]	; 0x60
            xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = ( portMPU_REGION_PRIV_RW_USER_RW_NOEXEC |
 510c758:	e58a3064 	str	r3, [sl, #100]	; 0x64
}
 510c75c:	e28dd014 	add	sp, sp, #20
 510c760:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                configASSERT( ( ( ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress ) % ( ulRegionLengthDecoded ) ) == 0UL );
 510c764:	e7981106 	ldr	r1, [r8, r6, lsl #2]
 510c768:	e3e00000 	mvn	r0, #0
 510c76c:	e3a0203f 	mov	r2, #63	; 0x3f
 510c770:	e1110000 	tst	r1, r0
 510c774:	0affffd8 	beq	510c6dc <vPortStoreTaskMPUSettings+0xbc>
 510c778:	e3001185 	movw	r1, #389	; 0x185
 510c77c:	e1a0000b 	mov	r0, fp
 510c780:	e1cd20f8 	strd	r2, [sp, #8]
 510c784:	e12fff37 	blx	r7
                xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = ( uint32_t ) xRegions[ ulIndex ].pvBaseAddress;
 510c788:	e7981106 	ldr	r1, [r8, r6, lsl #2]
 510c78c:	e1cd20d8 	ldrd	r2, [sp, #8]
 510c790:	eaffffd1 	b	510c6dc <vPortStoreTaskMPUSettings+0xbc>
        ulRegionLength = ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__;
 510c794:	e3000000 	movw	r0, #0
 510c798:	e3001000 	movw	r1, #0
 510c79c:	e3400514 	movt	r0, #1300	; 0x514
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510c7a0:	e3a03004 	mov	r3, #4
        ulRegionLength = ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__;
 510c7a4:	e3401517 	movt	r1, #1303	; 0x517
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c7a8:	e3a02020 	mov	r2, #32
        ulRegionLength = ( uint32_t ) __SRAM_segment_end__ - ( uint32_t ) __SRAM_segment_start__;
 510c7ac:	e0411000 	sub	r1, r1, r0
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c7b0:	ea000002 	b	510c7c0 <vPortStoreTaskMPUSettings+0x1a0>
            ulReturnValue++;
 510c7b4:	e2833001 	add	r3, r3, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c7b8:	e353001f 	cmp	r3, #31
 510c7bc:	0a000016 	beq	510c81c <vPortStoreTaskMPUSettings+0x1fc>
        if( ulActualMPURegionSize <= ulRegionSize )
 510c7c0:	e1510002 	cmp	r1, r2
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510c7c4:	e1a02082 	lsl	r2, r2, #1
        if( ulActualMPURegionSize <= ulRegionSize )
 510c7c8:	8afffff9 	bhi	510c7b4 <vPortStoreTaskMPUSettings+0x194>
    return ulReturnValue << 1UL;
 510c7cc:	e1a03083 	lsl	r3, r3, #1
        xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c7d0:	e3833001 	orr	r3, r3, #1
        xMPUSettings->xRegion[ ulIndex ].ulRegionBaseAddress = ( uint32_t ) __SRAM_segment_start__;
 510c7d4:	e58a0068 	str	r0, [sl, #104]	; 0x68
        xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = ( portMPU_REGION_PRIV_RW_USER_RW_NOEXEC |
 510c7d8:	e3012306 	movw	r2, #4870	; 0x1306
        xMPUSettings->xRegion[ ulIndex ].ulRegionSize = ( ulRegionLengthEncoded |
 510c7dc:	e58a3060 	str	r3, [sl, #96]	; 0x60
        xMPUSettings->xRegion[ ulIndex ].ulRegionAttribute = ( portMPU_REGION_PRIV_RW_USER_RW_NOEXEC |
 510c7e0:	e58a2064 	str	r2, [sl, #100]	; 0x64
}
 510c7e4:	e28dd014 	add	sp, sp, #20
 510c7e8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            configASSERT( ( ( uint32_t ) pxBottomOfStack % ( ulRegionLengthDecoded ) ) == 0U );
 510c7ec:	e59d3004 	ldr	r3, [sp, #4]
 510c7f0:	e3e01000 	mvn	r1, #0
 510c7f4:	e3a0403f 	mov	r4, #63	; 0x3f
 510c7f8:	e1130001 	tst	r3, r1
 510c7fc:	0affffd1 	beq	510c748 <vPortStoreTaskMPUSettings+0x128>
 510c800:	e30d0b84 	movw	r0, #56196	; 0xdb84
 510c804:	e3003900 	movw	r3, #2304	; 0x900
 510c808:	e300119f 	movw	r1, #415	; 0x19f
 510c80c:	e3403511 	movt	r3, #1297	; 0x511
 510c810:	e3400512 	movt	r0, #1298	; 0x512
 510c814:	e12fff33 	blx	r3
 510c818:	eaffffca 	b	510c748 <vPortStoreTaskMPUSettings+0x128>
 510c81c:	e3a0303f 	mov	r3, #63	; 0x3f
 510c820:	eaffffeb 	b	510c7d4 <vPortStoreTaskMPUSettings+0x1b4>

0510c824 <xPortIsAuthorizedToAccessBuffer>:
    if( prvPortSchedulerRunning == pdFALSE )
 510c824:	e30736c0 	movw	r3, #30400	; 0x76c0
 510c828:	e3403512 	movt	r3, #1298	; 0x512
 510c82c:	e5933004 	ldr	r3, [r3, #4]
 510c830:	e3530000 	cmp	r3, #0
 510c834:	1a000001 	bne	510c840 <xPortIsAuthorizedToAccessBuffer+0x1c>
        xAccessGranted = pdTRUE;
 510c838:	e3a00001 	mov	r0, #1
}
 510c83c:	e12fff1e 	bx	lr
        xTaskMPUSettings = xTaskGetMPUSettings( NULL );
 510c840:	e3073204 	movw	r3, #29188	; 0x7204
{
 510c844:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 510c848:	e1a04000 	mov	r4, r0
        xTaskMPUSettings = xTaskGetMPUSettings( NULL );
 510c84c:	e3403510 	movt	r3, #1296	; 0x510
 510c850:	e3a00000 	mov	r0, #0
 510c854:	e1a06001 	mov	r6, r1
 510c858:	e1a05002 	mov	r5, r2
 510c85c:	e12fff33 	blx	r3
        if( ( xTaskMPUSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )
 510c860:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
 510c864:	e3130002 	tst	r3, #2
 510c868:	1a000025 	bne	510c904 <xPortIsAuthorizedToAccessBuffer+0xe0>
 510c86c:	e1a03000 	mov	r3, r0
    if( portADD_UINT32_WILL_OVERFLOW( ulBufferStart, ( ulBufferLength - 1UL ) ) == pdFALSE )
 510c870:	e2662000 	rsb	r2, r6, #0
 510c874:	e2461001 	sub	r1, r6, #1
        ulMPURegionLength = 2UL << ( xTaskMPURegion->ulRegionSize >> 1UL );
 510c878:	e3a07002 	mov	r7, #2
 510c87c:	e280e06c 	add	lr, r0, #108	; 0x6c
            else if( ( ulAccessRequested & tskMPU_WRITE_PERMISSION ) != 0UL ) /* W or RW. */
 510c880:	e7e080d5 	ubfx	r8, r5, #1, #1
 510c884:	ea000002 	b	510c894 <xPortIsAuthorizedToAccessBuffer+0x70>
            for( ulRegionIndex = 0x0UL; ulRegionIndex < portTOTAL_NUM_REGIONS_IN_TCB; ulRegionIndex++ )
 510c888:	e283300c 	add	r3, r3, #12
 510c88c:	e15e0003 	cmp	lr, r3
 510c890:	0a00001d 	beq	510c90c <xPortIsAuthorizedToAccessBuffer+0xe8>
    if( portADD_UINT32_WILL_OVERFLOW( ulBufferStart, ( ulBufferLength - 1UL ) ) == pdFALSE )
 510c894:	e1540002 	cmp	r4, r2
 510c898:	8afffffa 	bhi	510c888 <xPortIsAuthorizedToAccessBuffer+0x64>
        ulMPURegionLength = 2UL << ( xTaskMPURegion->ulRegionSize >> 1UL );
 510c89c:	e593c000 	ldr	ip, [r3]
 510c8a0:	e0946001 	adds	r6, r4, r1
 510c8a4:	23a00001 	movcs	r0, #1
 510c8a8:	33a00000 	movcc	r0, #0
            ( ulBufferEnd <= ulMPURegionEnd ) &&
 510c8ac:	e2200001 	eor	r0, r0, #1
        ulMPURegionLength = 2UL << ( xTaskMPURegion->ulRegionSize >> 1UL );
 510c8b0:	e1a090ac 	lsr	r9, ip, #1
        ulMPURegionStart = xTaskMPURegion->ulRegionBaseAddress;
 510c8b4:	e593c008 	ldr	ip, [r3, #8]
            ( ulBufferEnd <= ulMPURegionEnd ) &&
 510c8b8:	e154000c 	cmp	r4, ip
 510c8bc:	33a00000 	movcc	r0, #0
 510c8c0:	22000001 	andcs	r0, r0, #1
        ulMPURegionEnd = xTaskMPURegion->ulRegionBaseAddress + ulMPURegionLength - 1UL;
 510c8c4:	e24cc001 	sub	ip, ip, #1
 510c8c8:	e08cc917 	add	ip, ip, r7, lsl r9
            ( ulBufferEnd <= ulMPURegionEnd ) &&
 510c8cc:	e156000c 	cmp	r6, ip
 510c8d0:	83a00000 	movhi	r0, #0
 510c8d4:	92000001 	andls	r0, r0, #1
 510c8d8:	e3500000 	cmp	r0, #0
 510c8dc:	0affffe9 	beq	510c888 <xPortIsAuthorizedToAccessBuffer+0x64>
            ulMPURegionAccessPermissions = xTaskMPURegion->ulRegionAttribute & portMPU_REGION_AP_BITMASK;
 510c8e0:	e5930004 	ldr	r0, [r3, #4]
            if( ulAccessRequested == tskMPU_READ_PERMISSION ) /* RO. */
 510c8e4:	e3550001 	cmp	r5, #1
            ulMPURegionAccessPermissions = xTaskMPURegion->ulRegionAttribute & portMPU_REGION_AP_BITMASK;
 510c8e8:	e200cc07 	and	ip, r0, #1792	; 0x700
            if( ulAccessRequested == tskMPU_READ_PERMISSION ) /* RO. */
 510c8ec:	0a000008 	beq	510c914 <xPortIsAuthorizedToAccessBuffer+0xf0>
                if( ulMPURegionAccessPermissions == portMPU_REGION_PRIV_RW_USER_RW )
 510c8f0:	e35c0c03 	cmp	ip, #768	; 0x300
 510c8f4:	13a00000 	movne	r0, #0
 510c8f8:	02080001 	andeq	r0, r8, #1
 510c8fc:	e3500000 	cmp	r0, #0
 510c900:	0affffe0 	beq	510c888 <xPortIsAuthorizedToAccessBuffer+0x64>
        xAccessGranted = pdTRUE;
 510c904:	e3a00001 	mov	r0, #1
 510c908:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 510c90c:	e3a00000 	mov	r0, #0
}
 510c910:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                if( ( ulMPURegionAccessPermissions == portMPU_REGION_PRIV_RW_USER_RO ) ||
 510c914:	e2000c06 	and	r0, r0, #1536	; 0x600
                    ( ulMPURegionAccessPermissions == portMPU_REGION_PRIV_RO_USER_RO ) ||
 510c918:	e35c0c06 	cmp	ip, #1536	; 0x600
 510c91c:	13500c02 	cmpne	r0, #512	; 0x200
 510c920:	0afffff7 	beq	510c904 <xPortIsAuthorizedToAccessBuffer+0xe0>
 510c924:	eaffffd7 	b	510c888 <xPortIsAuthorizedToAccessBuffer+0x64>

0510c928 <xPortIsAuthorizedToAccessKernelObject>:
}
 510c928:	e3a00001 	mov	r0, #1
 510c92c:	e12fff1e 	bx	lr

0510c930 <vPortEnterCritical>:
    portDISABLE_INTERRUPTS();
 510c930:	e3003210 	movw	r3, #528	; 0x210
 510c934:	e3403510 	movt	r3, #1296	; 0x510
{
 510c938:	e92d4010 	push	{r4, lr}
    portDISABLE_INTERRUPTS();
 510c93c:	e12fff33 	blx	r3
    ulCriticalNesting++;
 510c940:	e30736c0 	movw	r3, #30400	; 0x76c0
 510c944:	e3403512 	movt	r3, #1298	; 0x512
 510c948:	e5932008 	ldr	r2, [r3, #8]
 510c94c:	e2822001 	add	r2, r2, #1
 510c950:	e5832008 	str	r2, [r3, #8]
    if( ulCriticalNesting == 1 )
 510c954:	e5932008 	ldr	r2, [r3, #8]
 510c958:	e3520001 	cmp	r2, #1
 510c95c:	18bd8010 	popne	{r4, pc}
        configASSERT( ulPortInterruptNesting == 0 );
 510c960:	e593300c 	ldr	r3, [r3, #12]
 510c964:	e3530000 	cmp	r3, #0
 510c968:	08bd8010 	popeq	{r4, pc}
 510c96c:	e30d0b84 	movw	r0, #56196	; 0xdb84
 510c970:	e3003900 	movw	r3, #2304	; 0x900
 510c974:	e3001336 	movw	r1, #822	; 0x336
 510c978:	e3403511 	movt	r3, #1297	; 0x511
 510c97c:	e3400512 	movt	r0, #1298	; 0x512
 510c980:	e12fff33 	blx	r3
}
 510c984:	e8bd8010 	pop	{r4, pc}

0510c988 <vPortExitCritical>:
    if( ulCriticalNesting > portNO_CRITICAL_NESTING )
 510c988:	e30736c0 	movw	r3, #30400	; 0x76c0
 510c98c:	e3403512 	movt	r3, #1298	; 0x512
 510c990:	e5932008 	ldr	r2, [r3, #8]
 510c994:	e3520000 	cmp	r2, #0
 510c998:	012fff1e 	bxeq	lr
        ulCriticalNesting--;
 510c99c:	e5932008 	ldr	r2, [r3, #8]
 510c9a0:	e2422001 	sub	r2, r2, #1
 510c9a4:	e5832008 	str	r2, [r3, #8]
        if( ulCriticalNesting == portNO_CRITICAL_NESTING )
 510c9a8:	e5933008 	ldr	r3, [r3, #8]
 510c9ac:	e3530000 	cmp	r3, #0
 510c9b0:	112fff1e 	bxne	lr
            portENABLE_INTERRUPTS();
 510c9b4:	e3003220 	movw	r3, #544	; 0x220
 510c9b8:	e3403510 	movt	r3, #1296	; 0x510
{
 510c9bc:	e92d4010 	push	{r4, lr}
            portENABLE_INTERRUPTS();
 510c9c0:	e12fff33 	blx	r3
}
 510c9c4:	e8bd8010 	pop	{r4, pc}

0510c9c8 <xPortStartScheduler>:
{
 510c9c8:	e92d4010 	push	{r4, lr}
*p = 0x7714;
 510c9cc:	e3072714 	movw	r2, #30484	; 0x7714
 510c9d0:	e3a044b7 	mov	r4, #-1224736768	; 0xb7000000
    configSETUP_TICK_INTERRUPT();
 510c9d4:	e3013d04 	movw	r3, #7428	; 0x1d04
*p = 0x7714;
 510c9d8:	e5842020 	str	r2, [r4, #32]
    configSETUP_TICK_INTERRUPT();
 510c9dc:	e3403511 	movt	r3, #1297	; 0x511
 510c9e0:	e12fff33 	blx	r3
*p = 0x7715;
 510c9e4:	e3072715 	movw	r2, #30485	; 0x7715
    vMPUDisable();
 510c9e8:	e3003270 	movw	r3, #624	; 0x270
*p = 0x7715;
 510c9ec:	e5842020 	str	r2, [r4, #32]
    vMPUDisable();
 510c9f0:	e3403510 	movt	r3, #1296	; 0x510
 510c9f4:	e12fff33 	blx	r3
    ulRegionLength = ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__;
 510c9f8:	e3003000 	movw	r3, #0
 510c9fc:	e3001000 	movw	r1, #0
 510ca00:	e3403510 	movt	r3, #1296	; 0x510
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510ca04:	e3a02004 	mov	r2, #4
    ulRegionLength = ( uint32_t ) __FLASH_segment_end__ - ( uint32_t ) __FLASH_segment_start__;
 510ca08:	e3401514 	movt	r1, #1300	; 0x514
 510ca0c:	e0411003 	sub	r1, r1, r3
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510ca10:	e3a03020 	mov	r3, #32
 510ca14:	ea000003 	b	510ca28 <xPortStartScheduler+0x60>
            ulReturnValue++;
 510ca18:	e2822001 	add	r2, r2, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510ca1c:	e352001f 	cmp	r2, #31
 510ca20:	e1a03083 	lsl	r3, r3, #1
 510ca24:	0a000001 	beq	510ca30 <xPortStartScheduler+0x68>
        if( ulActualMPURegionSize <= ulRegionSize )
 510ca28:	e1510003 	cmp	r1, r3
 510ca2c:	8afffff9 	bhi	510ca18 <xPortStartScheduler+0x50>
    vMPUSetRegion( portUNPRIVILEGED_FLASH_REGION,
 510ca30:	e3001000 	movw	r1, #0
    return ulReturnValue << 1UL;
 510ca34:	e1a02082 	lsl	r2, r2, #1
    vMPUSetRegion( portUNPRIVILEGED_FLASH_REGION,
 510ca38:	e3004230 	movw	r4, #560	; 0x230
 510ca3c:	e3003606 	movw	r3, #1542	; 0x606
 510ca40:	e3822001 	orr	r2, r2, #1
 510ca44:	e3a00009 	mov	r0, #9
 510ca48:	e3401510 	movt	r1, #1296	; 0x510
 510ca4c:	e3404510 	movt	r4, #1296	; 0x510
 510ca50:	e12fff34 	blx	r4
    ulRegionLength = ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__;
 510ca54:	e3003000 	movw	r3, #0
 510ca58:	e3001000 	movw	r1, #0
 510ca5c:	e3403510 	movt	r3, #1296	; 0x510
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510ca60:	e3a02004 	mov	r2, #4
    ulRegionLength = ( uint32_t ) __privileged_functions_end__ - ( uint32_t ) __privileged_functions_start__;
 510ca64:	e3401511 	movt	r1, #1297	; 0x511
 510ca68:	e0411003 	sub	r1, r1, r3
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510ca6c:	e3a03020 	mov	r3, #32
 510ca70:	ea000003 	b	510ca84 <xPortStartScheduler+0xbc>
            ulReturnValue++;
 510ca74:	e2822001 	add	r2, r2, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510ca78:	e352001f 	cmp	r2, #31
 510ca7c:	e1a03083 	lsl	r3, r3, #1
 510ca80:	0a000001 	beq	510ca8c <xPortStartScheduler+0xc4>
        if( ulActualMPURegionSize <= ulRegionSize )
 510ca84:	e1510003 	cmp	r1, r3
 510ca88:	8afffff9 	bhi	510ca74 <xPortStartScheduler+0xac>
    vMPUSetRegion( portPRIVILEGED_FLASH_REGION,
 510ca8c:	e3001000 	movw	r1, #0
    return ulReturnValue << 1UL;
 510ca90:	e1a02082 	lsl	r2, r2, #1
    vMPUSetRegion( portPRIVILEGED_FLASH_REGION,
 510ca94:	e3003506 	movw	r3, #1286	; 0x506
 510ca98:	e3822001 	orr	r2, r2, #1
 510ca9c:	e3a0000a 	mov	r0, #10
 510caa0:	e3401510 	movt	r1, #1296	; 0x510
 510caa4:	e12fff34 	blx	r4
    ulRegionLength = ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__;
 510caa8:	e3003000 	movw	r3, #0
 510caac:	e3001000 	movw	r1, #0
 510cab0:	e3403514 	movt	r3, #1300	; 0x514
    uint32_t ulRegionSize, ulReturnValue = 4U;
 510cab4:	e3a02004 	mov	r2, #4
    ulRegionLength = ( uint32_t ) __privileged_data_end__ - ( uint32_t ) __privileged_data_start__;
 510cab8:	e3401515 	movt	r1, #1301	; 0x515
 510cabc:	e0411003 	sub	r1, r1, r3
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510cac0:	e3a03020 	mov	r3, #32
 510cac4:	ea000003 	b	510cad8 <xPortStartScheduler+0x110>
            ulReturnValue++;
 510cac8:	e2822001 	add	r2, r2, #1
    for( ulRegionSize = 0x20UL; ulReturnValue < 0x1FUL; ( ulRegionSize <<= 1UL ) )
 510cacc:	e352001f 	cmp	r2, #31
 510cad0:	e1a03083 	lsl	r3, r3, #1
 510cad4:	0a000001 	beq	510cae0 <xPortStartScheduler+0x118>
        if( ulActualMPURegionSize <= ulRegionSize )
 510cad8:	e1510003 	cmp	r1, r3
 510cadc:	8afffff9 	bhi	510cac8 <xPortStartScheduler+0x100>
    vMPUSetRegion( portPRIVILEGED_RAM_REGION,
 510cae0:	e3001000 	movw	r1, #0
    return ulReturnValue << 1UL;
 510cae4:	e1a02082 	lsl	r2, r2, #1
    vMPUSetRegion( portPRIVILEGED_RAM_REGION,
 510cae8:	e3822001 	orr	r2, r2, #1
 510caec:	e3a0000b 	mov	r0, #11
 510caf0:	e3401514 	movt	r1, #1300	; 0x514
 510caf4:	e3a03c11 	mov	r3, #4352	; 0x1100
 510caf8:	e12fff34 	blx	r4
    vMPUEnableBackgroundRegion();
 510cafc:	e3003290 	movw	r3, #656	; 0x290
*p = 0x7756;
 510cb00:	e3a044b7 	mov	r4, #-1224736768	; 0xb7000000
    vMPUEnableBackgroundRegion();
 510cb04:	e3403510 	movt	r3, #1296	; 0x510
 510cb08:	e12fff33 	blx	r3
    vMPUEnable();
 510cb0c:	e3003250 	movw	r3, #592	; 0x250
 510cb10:	e3403510 	movt	r3, #1296	; 0x510
 510cb14:	e12fff33 	blx	r3
*p = 0x7756;
 510cb18:	e3070756 	movw	r0, #30550	; 0x7756
    prvPortSchedulerRunning = pdTRUE;
 510cb1c:	e30726c0 	movw	r2, #30400	; 0x76c0
 510cb20:	e3a01001 	mov	r1, #1
    vPortStartFirstTask();
 510cb24:	e3003040 	movw	r3, #64	; 0x40
    prvPortSchedulerRunning = pdTRUE;
 510cb28:	e3402512 	movt	r2, #1298	; 0x512
*p = 0x7756;
 510cb2c:	e5840020 	str	r0, [r4, #32]
    vPortStartFirstTask();
 510cb30:	e3403510 	movt	r3, #1296	; 0x510
    prvPortSchedulerRunning = pdTRUE;
 510cb34:	e5821004 	str	r1, [r2, #4]
    vPortStartFirstTask();
 510cb38:	e12fff33 	blx	r3
*p = 0x7717;
 510cb3c:	e3072717 	movw	r2, #30487	; 0x7717
    ( void ) prvTaskExitError();
 510cb40:	e3083c54 	movw	r3, #35924	; 0x8c54
 510cb44:	e3403511 	movt	r3, #1297	; 0x511
*p = 0x7717;
 510cb48:	e5842020 	str	r2, [r4, #32]
    ( void ) prvTaskExitError();
 510cb4c:	e12fff33 	blx	r3
 510cb50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cb9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cba0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cba4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cba8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cbfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cc9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cca0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cca4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cca8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cccc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cce0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cce4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cce8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ccfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cd9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cda0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cda4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cda8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cddc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cde0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cde4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cde8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cdfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ce9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cea0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cea4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cea8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ceac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ceb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ceb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ceb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cebc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cec0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cec4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cec8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cecc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ced0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ced4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ced8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cedc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cee0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cee4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cee8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ceec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cef0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cef4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cef8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cefc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cf9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cfec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cff0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cff4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cff8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510cffc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d000:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d004:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d008:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d00c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d010:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d014:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d018:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d01c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d020:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d024:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d028:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d02c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d030:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d034:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d038:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d03c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d040:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d044:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d048:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d04c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d050:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d054:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d058:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d05c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d060:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d064:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d068:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d06c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d070:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d074:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d078:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d07c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d080:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d084:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d088:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d08c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d090:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d094:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d098:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d09c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d0fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d100:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d104:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d108:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d10c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d110:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d114:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d118:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d11c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d120:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d124:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d128:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d12c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d130:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d134:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d138:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d13c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d140:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d144:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d148:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d14c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d150:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d154:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d158:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d15c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d160:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d164:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d168:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d16c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d170:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d174:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d178:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d17c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d180:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d184:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d188:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d18c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d190:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d194:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d198:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d19c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d1fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d200:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d204:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d208:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d20c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d210:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d214:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d218:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d21c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d220:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d224:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d228:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d22c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d230:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d234:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d238:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d23c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d240:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d244:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d248:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d24c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d250:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d254:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d258:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d25c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d260:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d264:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d268:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d26c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d270:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d274:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d278:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d27c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d280:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d284:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d288:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d28c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d290:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d294:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d298:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d29c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d2fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d300:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d304:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d308:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d30c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d310:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d314:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d318:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d31c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d320:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d324:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d328:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d32c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d330:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d334:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d338:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d33c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d340:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d344:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d348:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d34c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d350:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d354:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d358:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d35c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d360:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d364:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d368:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d36c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d370:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d374:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d378:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d37c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d380:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d384:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d388:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d38c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d390:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d394:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d398:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d39c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d3fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d400:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d404:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d408:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d40c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d410:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d414:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d418:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d41c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d420:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d424:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d428:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d42c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d430:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d434:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d438:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d43c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d440:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d444:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d448:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d44c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d450:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d454:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d458:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d45c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d460:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d464:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d468:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d46c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d470:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d474:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d478:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d47c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d480:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d484:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d488:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d48c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d490:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d494:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d498:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d49c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d4fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d500:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d504:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d508:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d50c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d510:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d514:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d518:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d51c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d520:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d524:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d528:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d52c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d530:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d534:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d538:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d53c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d540:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d544:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d548:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d54c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d550:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d554:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d558:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d55c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d560:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d564:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d568:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d56c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d570:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d574:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d578:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d57c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d580:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d584:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d588:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d58c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d590:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d594:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d598:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d59c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d5fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d600:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d604:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d608:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d60c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d610:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d614:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d618:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d61c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d620:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d624:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d628:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d62c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d630:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d634:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d638:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d63c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d640:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d644:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d648:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d64c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d650:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d654:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d658:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d65c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d660:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d664:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d668:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d66c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d670:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d674:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d678:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d67c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d680:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d684:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d688:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d68c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d690:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d694:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d698:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d69c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d6fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d700:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d704:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d708:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d70c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d710:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d714:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d718:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d71c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d720:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d724:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d728:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d72c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d730:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d734:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d738:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d73c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d740:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d744:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d748:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d74c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d750:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d754:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d758:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d75c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d760:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d764:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d768:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d76c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d770:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d774:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d778:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d77c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d780:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d784:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d788:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d78c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d790:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d794:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d798:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d79c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d7fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d800:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d804:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d808:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d80c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d810:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d814:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d818:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d81c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d820:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d824:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d828:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d82c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d830:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d834:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d838:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d83c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d840:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d844:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d848:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d84c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d850:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d854:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d858:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d85c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d860:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d864:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d868:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d86c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d870:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d874:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d878:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d87c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d880:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d884:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d888:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d88c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d890:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d894:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d898:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d89c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d8fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d900:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d904:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d908:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d90c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d910:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d914:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d918:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d91c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d920:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d924:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d928:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d92c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d930:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d934:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d938:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d93c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d940:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d944:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d948:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d94c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d950:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d954:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d958:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d95c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d960:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d964:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d968:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d96c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d970:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d974:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d978:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d97c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d980:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d984:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d988:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d98c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d990:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d994:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d998:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d99c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510d9fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510da9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dab0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dab4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dab8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dabc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dac0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dac4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dac8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dacc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dad0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dad4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dad8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dadc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dae0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dae4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dae8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510daf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dafc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510db9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dba0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dba4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dba8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dbfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dc9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dca0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dca4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dca8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dccc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dce0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dce4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dce8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dcfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dd9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dda0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dda4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dda8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dddc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dde0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dde4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dde8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ddfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510de9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dea0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dea4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dea8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510deac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510deb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510deb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510deb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510debc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dec0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dec4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dec8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510decc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ded0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ded4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ded8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dedc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dee0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dee4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dee8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510deec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510def0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510def4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510def8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510defc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510df9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dfec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dff0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dff4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dff8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510dffc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e000:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e004:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e008:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e00c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e010:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e014:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e018:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e01c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e020:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e024:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e028:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e02c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e030:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e034:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e038:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e03c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e040:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e044:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e048:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e04c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e050:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e054:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e058:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e05c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e060:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e064:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e068:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e06c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e070:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e074:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e078:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e07c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e080:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e084:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e088:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e08c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e090:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e094:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e098:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e09c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e0fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e100:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e104:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e108:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e10c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e110:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e114:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e118:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e11c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e120:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e124:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e128:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e12c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e130:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e134:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e138:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e13c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e140:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e144:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e148:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e14c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e150:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e154:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e158:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e15c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e160:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e164:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e168:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e16c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e170:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e174:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e178:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e17c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e180:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e184:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e188:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e18c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e190:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e194:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e198:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e19c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e1fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e200:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e204:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e208:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e20c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e210:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e214:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e218:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e21c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e220:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e224:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e228:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e22c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e230:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e234:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e238:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e23c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e240:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e244:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e248:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e24c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e250:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e254:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e258:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e25c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e260:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e264:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e268:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e26c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e270:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e274:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e278:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e27c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e280:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e284:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e288:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e28c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e290:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e294:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e298:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e29c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e2fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e300:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e304:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e308:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e30c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e310:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e314:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e318:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e31c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e320:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e324:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e328:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e32c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e330:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e334:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e338:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e33c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e340:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e344:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e348:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e34c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e350:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e354:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e358:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e35c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e360:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e364:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e368:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e36c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e370:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e374:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e378:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e37c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e380:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e384:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e388:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e38c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e390:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e394:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e398:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e39c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e3fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e400:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e404:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e408:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e40c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e410:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e414:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e418:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e41c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e420:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e424:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e428:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e42c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e430:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e434:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e438:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e43c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e440:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e444:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e448:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e44c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e450:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e454:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e458:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e45c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e460:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e464:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e468:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e46c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e470:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e474:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e478:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e47c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e480:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e484:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e488:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e48c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e490:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e494:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e498:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e49c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e4fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e500:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e504:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e508:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e50c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e510:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e514:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e518:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e51c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e520:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e524:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e528:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e52c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e530:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e534:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e538:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e53c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e540:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e544:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e548:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e54c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e550:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e554:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e558:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e55c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e560:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e564:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e568:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e56c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e570:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e574:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e578:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e57c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e580:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e584:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e588:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e58c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e590:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e594:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e598:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e59c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e5fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e600:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e604:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e608:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e60c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e610:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e614:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e618:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e61c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e620:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e624:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e628:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e62c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e630:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e634:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e638:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e63c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e640:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e644:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e648:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e64c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e650:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e654:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e658:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e65c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e660:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e664:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e668:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e66c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e670:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e674:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e678:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e67c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e680:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e684:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e688:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e68c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e690:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e694:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e698:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e69c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e6fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e700:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e704:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e708:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e70c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e710:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e714:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e718:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e71c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e720:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e724:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e728:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e72c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e730:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e734:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e738:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e73c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e740:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e744:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e748:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e74c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e750:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e754:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e758:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e75c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e760:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e764:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e768:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e76c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e770:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e774:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e778:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e77c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e780:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e784:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e788:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e78c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e790:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e794:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e798:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e79c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e7fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e800:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e804:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e808:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e80c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e810:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e814:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e818:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e81c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e820:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e824:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e828:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e82c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e830:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e834:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e838:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e83c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e840:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e844:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e848:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e84c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e850:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e854:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e858:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e85c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e860:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e864:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e868:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e86c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e870:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e874:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e878:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e87c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e880:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e884:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e888:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e88c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e890:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e894:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e898:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e89c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e8fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e900:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e904:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e908:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e90c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e910:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e914:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e918:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e91c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e920:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e924:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e928:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e92c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e930:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e934:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e938:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e93c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e940:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e944:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e948:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e94c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e950:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e954:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e958:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e95c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e960:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e964:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e968:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e96c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e970:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e974:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e978:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e97c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e980:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e984:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e988:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e98c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e990:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e994:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e998:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e99c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510e9fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ea9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eab0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eab4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eab8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eabc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eac0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eac4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eac8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eacc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ead0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ead4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ead8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eadc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eae0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eae4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eae8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eaf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eafc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eb9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eba0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eba4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eba8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ebfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ec9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eca0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eca4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eca8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eccc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ece0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ece4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ece8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ecfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ed9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eda0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eda4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eda8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eddc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ede0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ede4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ede8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510edfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ee9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eea0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eea4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eea8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eeac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eeb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eeb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eeb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eebc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eec0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eec4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eec8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eecc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eed0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eed4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eed8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eedc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eee0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eee4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eee8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eeec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eef0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eef4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eef8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eefc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ef9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510efec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eff0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eff4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510eff8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510effc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f000:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f004:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f008:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f00c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f010:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f014:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f018:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f01c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f020:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f024:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f028:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f02c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f030:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f034:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f038:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f03c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f040:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f044:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f048:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f04c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f050:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f054:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f058:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f05c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f060:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f064:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f068:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f06c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f070:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f074:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f078:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f07c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f080:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f084:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f088:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f08c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f090:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f094:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f098:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f09c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f0fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f100:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f104:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f108:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f10c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f110:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f114:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f118:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f11c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f120:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f124:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f128:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f12c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f130:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f134:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f138:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f13c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f140:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f144:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f148:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f14c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f150:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f154:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f158:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f15c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f160:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f164:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f168:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f16c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f170:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f174:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f178:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f17c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f180:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f184:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f188:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f18c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f190:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f194:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f198:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f19c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f1fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f200:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f204:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f208:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f20c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f210:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f214:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f218:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f21c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f220:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f224:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f228:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f22c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f230:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f234:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f238:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f23c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f240:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f244:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f248:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f24c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f250:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f254:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f258:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f25c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f260:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f264:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f268:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f26c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f270:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f274:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f278:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f27c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f280:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f284:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f288:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f28c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f290:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f294:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f298:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f29c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f2fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f300:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f304:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f308:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f30c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f310:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f314:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f318:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f31c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f320:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f324:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f328:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f32c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f330:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f334:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f338:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f33c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f340:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f344:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f348:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f34c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f350:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f354:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f358:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f35c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f360:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f364:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f368:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f36c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f370:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f374:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f378:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f37c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f380:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f384:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f388:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f38c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f390:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f394:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f398:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f39c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f3fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f400:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f404:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f408:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f40c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f410:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f414:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f418:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f41c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f420:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f424:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f428:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f42c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f430:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f434:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f438:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f43c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f440:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f444:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f448:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f44c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f450:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f454:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f458:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f45c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f460:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f464:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f468:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f46c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f470:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f474:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f478:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f47c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f480:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f484:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f488:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f48c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f490:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f494:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f498:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f49c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f4fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f500:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f504:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f508:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f50c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f510:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f514:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f518:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f51c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f520:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f524:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f528:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f52c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f530:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f534:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f538:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f53c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f540:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f544:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f548:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f54c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f550:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f554:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f558:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f55c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f560:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f564:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f568:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f56c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f570:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f574:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f578:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f57c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f580:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f584:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f588:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f58c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f590:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f594:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f598:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f59c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f5fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f600:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f604:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f608:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f60c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f610:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f614:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f618:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f61c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f620:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f624:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f628:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f62c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f630:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f634:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f638:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f63c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f640:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f644:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f648:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f64c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f650:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f654:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f658:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f65c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f660:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f664:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f668:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f66c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f670:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f674:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f678:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f67c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f680:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f684:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f688:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f68c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f690:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f694:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f698:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f69c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f6fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f700:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f704:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f708:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f70c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f710:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f714:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f718:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f71c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f720:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f724:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f728:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f72c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f730:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f734:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f738:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f73c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f740:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f744:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f748:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f74c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f750:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f754:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f758:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f75c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f760:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f764:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f768:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f76c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f770:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f774:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f778:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f77c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f780:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f784:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f788:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f78c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f790:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f794:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f798:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f79c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f7fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f800:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f804:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f808:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f80c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f810:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f814:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f818:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f81c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f820:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f824:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f828:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f82c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f830:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f834:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f838:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f83c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f840:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f844:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f848:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f84c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f850:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f854:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f858:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f85c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f860:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f864:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f868:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f86c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f870:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f874:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f878:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f87c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f880:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f884:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f888:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f88c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f890:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f894:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f898:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f89c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f8fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f900:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f904:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f908:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f90c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f910:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f914:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f918:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f91c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f920:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f924:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f928:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f92c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f930:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f934:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f938:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f93c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f940:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f944:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f948:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f94c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f950:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f954:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f958:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f95c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f960:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f964:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f968:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f96c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f970:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f974:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f978:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f97c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f980:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f984:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f988:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f98c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f990:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f994:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f998:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f99c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9a0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9a4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9a8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9ac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9b0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9b4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9b8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9bc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9c0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9c4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9c8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9cc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9d0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9d4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9d8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9dc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9e0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9e4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9e8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9ec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9f0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9f4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9f8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510f9fc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fa9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fab0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fab4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fab8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fabc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fac0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fac4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fac8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510facc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fad0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fad4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fad8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fadc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fae0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fae4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fae8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510faf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fafc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fb9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fba0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fba4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fba8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fbfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fc9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fca0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fca4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fca8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fccc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fce0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fce4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fce8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fcfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fd9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fda0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fda4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fda8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fddc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fde0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fde4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fde8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdf0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdf4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdf8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fdfc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fe9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fea0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fea4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fea8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510feac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510feb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510feb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510feb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510febc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fec0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fec4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fec8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fecc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fed0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fed4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fed8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fedc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fee0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fee4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fee8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510feec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fef0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fef4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fef8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fefc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff00:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff04:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff08:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff0c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff10:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff14:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff18:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff1c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff20:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff24:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff28:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff2c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff30:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff34:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff38:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff3c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff40:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff44:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff48:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff4c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff50:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff54:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff58:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff5c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff60:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff64:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff68:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff6c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff70:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff74:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff78:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff7c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff80:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff84:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff88:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff8c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff90:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff94:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff98:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ff9c:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffa0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffa4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffa8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffac:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffb0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffb4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffb8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffbc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffc0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffc4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffc8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffcc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffd0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffd4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffd8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffdc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffe0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffe4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffe8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510ffec:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fff0:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fff4:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fff8:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}
 510fffc:	deaddead 	cdple	14, 10, cr13, cr13, cr13, {5}

Disassembly of section .text:

05110000 <ResetHandler>:
.EQU CPSR_MODE_UND,        0x1B
.EQU CPSR_MODE_SYS,        0x1F

.section .boot,"axS"
ResetHandler:
        LDR R10, =0xb7000070
 5110000:	e59fa21c 	ldr	sl, [pc, #540]	; 5110224 <MPU_xTaskDelayUntil+0x14>
        LDR R11, [R10]
 5110004:	e59ab000 	ldr	fp, [sl]
        ADD R11, R11, #1
 5110008:	e28bb001 	add	fp, fp, #1
        STR R11, [R10]
 511000c:	e58ab000 	str	fp, [sl]

        LDR R10, =0xb7000078
 5110010:	e59fa210 	ldr	sl, [pc, #528]	; 5110228 <MPU_xTaskDelayUntil+0x18>
        STR R14, [R10]
 5110014:	e58ae000 	str	lr, [sl]

//----------------------------------------------------------------
// Initialize processor registers to 0
//----------------------------------------------------------------
	MOV	r0,#0
 5110018:	e3a00000 	mov	r0, #0
	MOV	r1,#0
 511001c:	e3a01000 	mov	r1, #0
	MOV	r2,#0
 5110020:	e3a02000 	mov	r2, #0
	MOV	r3,#0
 5110024:	e3a03000 	mov	r3, #0
	MOV	r4,#0
 5110028:	e3a04000 	mov	r4, #0
	MOV	r5,#0
 511002c:	e3a05000 	mov	r5, #0
	MOV	r6,#0
 5110030:	e3a06000 	mov	r6, #0
	MOV	r7,#0
 5110034:	e3a07000 	mov	r7, #0
	MOV	r8,#0
 5110038:	e3a08000 	mov	r8, #0
	MOV	r9,#0
 511003c:	e3a09000 	mov	r9, #0
	MOV	r10,#0
 5110040:	e3a0a000 	mov	sl, #0
	MOV	r11,#0
 5110044:	e3a0b000 	mov	fp, #0
	MOV	r12,#0
 5110048:	e3a0c000 	mov	ip, #0
//----------------------------------------------------------------

// Disable MPU and cache in case it was left enabled from an earlier run
// This does not need to be done from a cold reset

        MRC     p15, 0, r0, c1, c0, 0       // Read System Control Register
 511004c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
        BIC     r0, r0, #0x05               // Disable MPU (M bit) and data cache (C bit)
 5110050:	e3c00005 	bic	r0, r0, #5
        BIC     r0, r0, #0x1000             // Disable instruction cache (I bit)
 5110054:	e3c00a01 	bic	r0, r0, #4096	; 0x1000
        DSB                                 // Ensure all previous loads/stores have completed
 5110058:	f57ff04f 	dsb	sy
        MCR     p15, 0, r0, c1, c0, 0       // Write System Control Register
 511005c:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
        ISB                                 // Ensure subsequent insts execute wrt new MPU settings
 5110060:	f57ff06f 	isb	sy

// In the Cortex-R5, the Z-bit of the SCTLR does not control the program flow prediction.
// Some control bits in the ACTLR control the program flow and prefetch features instead.
// These are enabled by default, but are shown here for completeness.

        MRC     p15, 0, r0, c1, c0, 1       // Read ACTLR
 5110064:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
        ORR     r0, r0, #(0x1 << 17)        // Enable RSDIS bit 17 to disable the return stack
 5110068:	e3800802 	orr	r0, r0, #131072	; 0x20000
        ORR     r0, r0, #(0x1 << 16)        // Clear BP bit 15 and set BP bit 16:
 511006c:	e3800801 	orr	r0, r0, #65536	; 0x10000
        BIC     r0, r0, #(0x1 << 15)        // Branch always not taken and history table updates disabled
 5110070:	e3c00902 	bic	r0, r0, #32768	; 0x8000
        MCR     p15, 0, r0, c1, c0, 1       // Write ACTLR
 5110074:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
        ISB
 5110078:	f57ff06f 	isb	sy

//----------------------------------------------------------------
// Setup Stacks
//----------------------------------------------------------------
        CPS #CPSR_MODE_FIQ
 511007c:	f1020011 	cps	#17
        LDR sp, = __fiq_stack_start__
 5110080:	e59fd1a4 	ldr	sp, [pc, #420]	; 511022c <MPU_xTaskDelayUntil+0x1c>

        CPS #CPSR_MODE_IRQ
 5110084:	f1020012 	cps	#18
        LDR sp, = __irq_stack_start__
 5110088:	e59fd1a0 	ldr	sp, [pc, #416]	; 5110230 <MPU_xTaskAbortDelay>

        CPS #CPSR_MODE_SVC
 511008c:	f1020013 	cps	#19
        LDR sp, = __supervisor_stack_start__
 5110090:	e59fd19c 	ldr	sp, [pc, #412]	; 5110234 <MPU_xTaskAbortDelay+0x4>

        CPS #CPSR_MODE_ABT
 5110094:	f1020017 	cps	#23
        LDR sp, = __abort_stack_start__
 5110098:	e59fd198 	ldr	sp, [pc, #408]	; 5110238 <MPU_xTaskAbortDelay+0x8>

        CPS #CPSR_MODE_UND
 511009c:	f102001b 	cps	#27
        LDR sp, = __undef_stack_start__
 51100a0:	e59fd194 	ldr	sp, [pc, #404]	; 511023c <MPU_xTaskAbortDelay+0xc>

        CPS #CPSR_MODE_SYS
 51100a4:	f102001f 	cps	#31
        LDR sp, = __sys_stack_start__
 51100a8:	e59fd190 	ldr	sp, [pc, #400]	; 5110240 <MPU_xTaskAbortDelay+0x10>

//----------------------------------------------------------------
// Cache invalidation
//----------------------------------------------------------------

        DSB                 // Complete all outstanding explicit memory operations
 51100ac:	f57ff04f 	dsb	sy
        MOV     r0, #0
 51100b0:	e3a00000 	mov	r0, #0
        MCR     p15, 0, r0, c7, c5, 0       // Invalidate entire instruction cache
 51100b4:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
        MCR     p15, 0, r0, c15, c5, 0      // Invalidate entire data cache
 51100b8:	ee0f0f15 	mcr	15, 0, r0, cr15, cr5, {0}
// * Any address range not covered by an enabled region will abort
// * The region at 0x0 over the Vector table is needed to support semihosting

#if 1
//init mpu region 0,Device 256M          0~0x10000000 （R0）
        MOV    r0, #13                    //region 13
 51100bc:	e3a0000d 	mov	r0, #13
        MOV    r3, #0                     //base addr from 0
 51100c0:	e3a03000 	mov	r3, #0
//      MOV    r1,#0x310                  //tex[5:3],ap[10:8],c=0,b=0,ap=3    ap=3,read+write,tex=2,non-share device
        MOV    r1,#0x30F                  //tex[5:3],ap[10:8],c=0,b=0,ap=3    ap=3,read+write,tex=1,normal(no cache)
 51100c4:	e300130f 	movw	r1, #783	; 0x30f
//      MOV    r1,#0x608                  //tex[5:3],ap[10:8],c=0,b=0,ap=6    ap=6,read only, tex=1,normal(no cache)
        MOV    r2,#0x37                   //size 256M,enable
 51100c8:	e3a02037 	mov	r2, #55	; 0x37
        MCR    p15,0,r0,c6,c2,0           // Set region number
 51100cc:	ee060f12 	mcr	15, 0, r0, cr6, cr2, {0}
        MCR    p15,0,r3,c6,c1,0           // Region base address         
 51100d0:	ee063f11 	mcr	15, 0, r3, cr6, cr1, {0}
        MCR    p15,0,r1,c6,c1,4           // Region access control        
 51100d4:	ee061f91 	mcr	15, 0, r1, cr6, cr1, {4}
        MCR    p15,0,r2,c6,c1,2           // Region size and enable 
 51100d8:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}

//init mpu region 1,Device 1G          0x10000000~0x50000000 （R0）
        MOV    r0, #12                    //region 12 
 51100dc:	e3a0000c 	mov	r0, #12
        MOV    r3, #0x10000000            //base addr from 0
 51100e0:	e3a03201 	mov	r3, #268435456	; 0x10000000
        MOV    r1,#0x301                  //normal,tex[5：3] 001 ,c=0,b=0,ap=3
 51100e4:	e3001301 	movw	r1, #769	; 0x301
        MOV    r2,#0x3B                   //size 1G,enable
 51100e8:	e3a0203b 	mov	r2, #59	; 0x3b
        MCR    p15,0,r0,c6,c2,0           // Set region number
 51100ec:	ee060f12 	mcr	15, 0, r0, cr6, cr2, {0}
        MCR    p15,0,r3,c6,c1,0           // Region base address         
 51100f0:	ee063f11 	mcr	15, 0, r3, cr6, cr1, {0}
        MCR    p15,0,r1,c6,c1,4           // Region access control        
 51100f4:	ee061f91 	mcr	15, 0, r1, cr6, cr1, {4}
        MCR    p15,0,r2,c6,c1,2           // Region size and enable 
 51100f8:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
//        MCR    p15,0,r3,c6,c1,0           // Region base address         
//        MCR    p15,0,r1,c6,c1,4           // Region access control        
//        MCR    p15,0,r2,c6,c1,2           // Region size and enable 
        
//init mpu region 4,Device 1G         0x40000000~0x80000000 （R0）
        MOV    r0, #14                    // region 14
 51100fc:	e3a0000e 	mov	r0, #14
        MOV    r3, #0x40000000            // base addr from 0x20000000 
 5110100:	e3a03101 	mov	r3, #1073741824	; 0x40000000
        MOV    r1,#0x301                  // share device,tex[3] 000 ,c=0,b=1,ap=3
 5110104:	e3001301 	movw	r1, #769	; 0x301
        MOV    r2,#0x3B                   // size 1G,enable    
 5110108:	e3a0203b 	mov	r2, #59	; 0x3b
        MCR    p15,0,r0,c6,c2,0           // Set region number
 511010c:	ee060f12 	mcr	15, 0, r0, cr6, cr2, {0}
        MCR    p15,0,r3,c6,c1,0           // Region base address         
 5110110:	ee063f11 	mcr	15, 0, r3, cr6, cr1, {0}
        MCR    p15,0,r1,c6,c1,4           // Region access control        
 5110114:	ee061f91 	mcr	15, 0, r1, cr6, cr1, {4}
        MCR    p15,0,r2,c6,c1,2           // Region size and enable 
 5110118:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}

//init mpu region 5,DDR  2G           0x80000000~0x1 00000000 （R0）
        MOV    r0, #15                    // region 15
 511011c:	e3a0000f 	mov	r0, #15
        MOV    r3, #0x80000000            // base addr from 0x80000000 
 5110120:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
        MOV    r1,#0x308                  // share device,tex[3] 000 ,c=0,b=1,ap=3
 5110124:	e3a01fc2 	mov	r1, #776	; 0x308
        MOV    r2,#0x3d                   // size 2G,enable    
 5110128:	e3a0203d 	mov	r2, #61	; 0x3d
        MCR    p15,0,r0,c6,c2,0           // Set region number
 511012c:	ee060f12 	mcr	15, 0, r0, cr6, cr2, {0}
        MCR    p15,0,r3,c6,c1,0           // Region base address         
 5110130:	ee063f11 	mcr	15, 0, r3, cr6, cr1, {0}
        MCR    p15,0,r1,c6,c1,4           // Region access control        
 5110134:	ee061f91 	mcr	15, 0, r1, cr6, cr1, {4}
        MCR    p15,0,r2,c6,c1,2           // Region size and enable 
 5110138:	ee062f51 	mcr	15, 0, r2, cr6, cr1, {2}
//----------------------------------------------------------------
// Enable access to VFP by enabling access to Coprocessors 10 and 11.
// Enables Full Access i.e. in both privileged and non privileged modes
//----------------------------------------------------------------

        MRC     p15, 0, r0, c1, c0, 2      // Read Coprocessor Access Control Register (CPACR)
 511013c:	ee110f50 	mrc	15, 0, r0, cr1, cr0, {2}
        ORR     r0, r0, #(0xF << 20)       // Enable access to CP 10 & 11
 5110140:	e380060f 	orr	r0, r0, #15728640	; 0xf00000
        MCR     p15, 0, r0, c1, c0, 2      // Write Coprocessor Access Control Register (CPACR)
 5110144:	ee010f50 	mcr	15, 0, r0, cr1, cr0, {2}
        ISB
 5110148:	f57ff06f 	isb	sy

//----------------------------------------------------------------
// Switch on the VFP hardware
//----------------------------------------------------------------
        MOV     r0, #0x40000000
 511014c:	e3a00101 	mov	r0, #1073741824	; 0x40000000
        VMSR    FPEXC, r0                   // Write FPEXC register, EN bit set
 5110150:	eee80a10 	vmsr	fpexc, r0

// In the Cortex-R5, the Z-bit of the SCTLR does not control the program flow prediction. 
// Some control bits in the ACTLR control the program flow and prefetch features instead.
// These are enabled by default, but are shown here for completeness.

        MRC     p15, 0, r0, c1, c0, 1       // Read ACTLR
 5110154:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
        BIC     r0, r0, #(0x1 << 17)        // Clear RSDIS bit 17 to enable return stack
 5110158:	e3c00802 	bic	r0, r0, #131072	; 0x20000
        BIC     r0, r0, #(0x1 << 16)        // Clear BP bit 15 and BP bit 16:
 511015c:	e3c00801 	bic	r0, r0, #65536	; 0x10000
        BIC     r0, r0, #(0x1 << 15)        // Normal operation, BP is taken from the global history table.
 5110160:	e3c00902 	bic	r0, r0, #32768	; 0x8000
        MCR     p15, 0, r0, c1, c0, 1       // Write ACTLR
 5110164:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
        ISB
 5110168:	f57ff06f 	isb	sy
//----------------------------------------------------------------
// Enable MPU and branch to C library init
// Leaving the caches disabled until after scatter loading.
//----------------------------------------------------------------

        MRC     p15, 0, r0, c1, c0, 0       // Read System Control Register
 511016c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
        ORR     r0, r0, #0x01               // Set M bit to enable MPU
 5110170:	e3800001 	orr	r0, r0, #1
        DSB                                 // Ensure all previous loads/stores have completed
 5110174:	f57ff04f 	dsb	sy
        MCR     p15, 0, r0, c1, c0, 0       // Write System Control Register
 5110178:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
        ISB                                 // Ensure subsequent insts execute wrt new MPU settings
 511017c:	f57ff06f 	isb	sy

//----------------------------------------------------------------
//Warm Start-Up Check & .(s)bss initialization
//----------------------------------------------------------------
        MRC     p15, 0, r0, c0, c0, 5     @ Read CPU ID register
 5110180:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
        ANDS    r0, r0, #0x03             @ Mask off, leaving the CPU ID field
 5110184:	e2100003 	ands	r0, r0, #3
        BEQ     clear_sbss_bss_data
 5110188:	0a000000 	beq	5110190 <clear_sbss_bss_data>
        BNE     .Lend_bss
 511018c:	1a00000c 	bne	51101c4 <MPU_xEventGroupClearBits+0x14>

05110190 <clear_sbss_bss_data>:
clear_sbss_bss_data:
        MOV r0, #0
 5110190:	e3a00000 	mov	r0, #0
/* Clear .sbss */
        LDR r1, =__sbss_start__
 5110194:	e59f10a8 	ldr	r1, [pc, #168]	; 5110244 <MPU_xTaskAbortDelay+0x14>
        LDR r2, =__sbss_end__
 5110198:	e59f20a8 	ldr	r2, [pc, #168]	; 5110248 <MPU_xTaskAbortDelay+0x18>
.Lloop_sbss:
        CMP r1, r2
 511019c:	e1510002 	cmp	r1, r2
/* If no .sbss, no clearing required */
        BGE .Lend_sbss
 51101a0:	aa000001 	bge	51101ac <clear_sbss_bss_data+0x1c>
        STR r0, [r1], #4
 51101a4:	e4810004 	str	r0, [r1], #4
        B .Lloop_sbss
 51101a8:	eafffffb 	b	511019c <clear_sbss_bss_data+0xc>
.Lend_sbss:

/* Clear .bss */
        LDR r1, =__bss_start__
 51101ac:	e59f1098 	ldr	r1, [pc, #152]	; 511024c <MPU_xTaskAbortDelay+0x1c>
        LDR r2, =__bss_end__
 51101b0:	e59f2098 	ldr	r2, [pc, #152]	; 5110250 <MPU_vTaskDelay>
.Lloop_bss:
        CMP r1, r2
 51101b4:	e1510002 	cmp	r1, r2
/* If no .bss, no clearing required */
        BGE .Lend_bss
 51101b8:	aa000001 	bge	51101c4 <MPU_xEventGroupClearBits+0x14>
        STR r0, [r1], #4
 51101bc:	e4810004 	str	r0, [r1], #4
        B .Lloop_bss
 51101c0:	eafffffb 	b	51101b4 <MPU_xEventGroupClearBits+0x4>
.Lend_bss:

/* Clear tcm */
        LDR r1, =_tcm_start
 51101c4:	e59f1088 	ldr	r1, [pc, #136]	; 5110254 <MPU_vTaskDelay+0x4>
        LDR r2, =_tcm_end
 51101c8:	e59f2088 	ldr	r2, [pc, #136]	; 5110258 <MPU_vTaskDelay+0x8>
.Lloop_tcm:
        CMP r1, r2
 51101cc:	e1510002 	cmp	r1, r2
/* If no .tcm, no clearing required */
        BGE .LEnd_tcm
 51101d0:	aa000001 	bge	51101dc <MPU_xEventGroupSetBits+0xc>
        STR r0, [r1], #4
 51101d4:	e4810004 	str	r0, [r1], #4
        B .Lloop_tcm
 51101d8:	eafffffb 	b	51101cc <MPU_xEventGroupClearBits+0x1c>
.LEnd_tcm:

//----------------------------------------------------------------
// enable tcm and cache ecc
//----------------------------------------------------------------
        MRC     p15, 0, r0, c1, c0, 1       // Read ACTLR
 51101dc:	ee110f30 	mrc	15, 0, r0, cr1, cr0, {1}
        ORR     r0, r0, #0x2000000          //enable tcm ECC
 51101e0:	e3800402 	orr	r0, r0, #33554432	; 0x2000000
        DSB
 51101e4:	f57ff04f 	dsb	sy
        MCR     p15, 0, r0, c1, c0, 1       // Write ACTLR
 51101e8:	ee010f30 	mcr	15, 0, r0, cr1, cr0, {1}
        ISB
 51101ec:	f57ff06f 	isb	sy

//----------------------------------------------------------------
// enable asynchronous abort exception 
//----------------------------------------------------------------
	MRS	r0, cpsr
 51101f0:	e10f0000 	mrs	r0, CPSR
	BIC	r0, r0, #0x100
 51101f4:	e3c00c01 	bic	r0, r0, #256	; 0x100
	MSR	cpsr_xsf, r0
 51101f8:	e12ef000 	msr	CPSR_fsx, r0

//----------------------------------------------------------------
// enter start up code 
//----------------------------------------------------------------
    .GLOBAL     _startup
        MRC     p15, 0, r0, c0, c0, 5     @ Read CPU ID register
 51101fc:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
        ANDS    r0, r0, #0x03             @ Mask off, leaving the CPU ID field
 5110200:	e2100003 	ands	r0, r0, #3
        BEQ     _startup
 5110204:	0a0001c7 	beq	5110928 <_startup>
.Ldone:	
        B	.Ldone			/* Paranoia: we should never get here */
 5110208:	eafffffe 	b	5110208 <MPU_xEventGroupSync+0x18>

0511020c <enable_caches>:

    .type enable_caches, "function"
    .cfi_startproc
enable_caches:

        MRC     p15, 0, r0, c1, c0, 0       // Read System Control Register
 511020c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
        ORR     r0, r0, #(0x1 << 12)        // enable I Cache
 5110210:	e3800a01 	orr	r0, r0, #4096	; 0x1000
        ORR     r0, r0, #(0x1 << 2)         // enable D Cache
 5110214:	e3800004 	orr	r0, r0, #4
        MCR     p15, 0, r0, c1, c0, 0       // Write System Control Register
 5110218:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
        ISB
 511021c:	f57ff06f 	isb	sy

        BX    lr
 5110220:	e12fff1e 	bx	lr
        LDR R10, =0xb7000070
 5110224:	b7000070 	.word	0xb7000070
        LDR R10, =0xb7000078
 5110228:	b7000078 	.word	0xb7000078
        LDR sp, = __fiq_stack_start__
 511022c:	05159110 	.word	0x05159110
        LDR sp, = __irq_stack_start__
 5110230:	05150b10 	.word	0x05150b10
        LDR sp, = __supervisor_stack_start__
 5110234:	05158b10 	.word	0x05158b10
        LDR sp, = __abort_stack_start__
 5110238:	05158d10 	.word	0x05158d10
        LDR sp, = __undef_stack_start__
 511023c:	05159310 	.word	0x05159310
        LDR sp, = __sys_stack_start__
 5110240:	05150710 	.word	0x05150710
        LDR r1, =__sbss_start__
 5110244:	0512fd98 	.word	0x0512fd98
        LDR r2, =__sbss_end__
 5110248:	0512fd98 	.word	0x0512fd98
        LDR r1, =__bss_start__
 511024c:	05130000 	.word	0x05130000
        LDR r2, =__bss_end__
 5110250:	05138710 	.word	0x05138710
        LDR r1, =_tcm_start
 5110254:	00000040 	.word	0x00000040
        LDR r2, =_tcm_end
 5110258:	00007050 	.word	0x00007050

0511025c <FreeRTOS_FIQHandler>:

.text

FreeRTOS_FIQHandler:			/* FIQ vector handler */
	STMDB	sp!,{r0-r3,r12,lr}	/* state save from compiled code */
 511025c:	e92d500f 	push	{r0, r1, r2, r3, ip, lr}
#if __ARM_FP
	/* Save the floating point context, if any. */
	FMRX  R1,  FPSCR
 5110260:	eef11a10 	vmrs	r1, fpscr
	VPUSH {D0-D15}
 5110264:	ed2d0b20 	vpush	{d0-d15}
	/*VPUSH	{D16-D31}*/
	PUSH	{R1}
 5110268:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)

0511026c <FreeRTOS_FIQLoop>:
#endif
FreeRTOS_FIQLoop:
	BL	FIQInterrupt			/* FIQ vector */
 511026c:	eb0004d4 	bl	51115c4 <FIQInterrupt>
#if __ARM_FP
	/* Restore the floating point context, if any. */
	POP 	{R0}
 5110270:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
	/*VPOP	{D16-D31}*/
	VPOP	{D0-D15}
 5110274:	ecbd0b20 	vpop	{d0-d15}
	VMSR  FPSCR, R0
 5110278:	eee10a10 	vmsr	fpscr, r0
#endif
	LDMIA	sp!,{r0-r3,r12,lr}	/* state restore from compiled code */
 511027c:	e8bd500f 	pop	{r0, r1, r2, r3, ip, lr}
	SUBS	pc, lr, #4			/* adjust return */
 5110280:	e25ef004 	subs	pc, lr, #4

.weak AbortHandler
.type AbortHandler, %function
AbortHandler:
    b  AbortHandler
 5110284:	ea0006c3 	b	5111d98 <AbortHandler>

05110288 <FreeRTOS_Undefined>:
.size AbortHandler, . - AbortHandler


FreeRTOS_Undefined:				/* Undefined handler */
	PUSH {r0}
 5110288:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	LDR r0, =AbortRarry
 511028c:	e59f0084 	ldr	r0, [pc, #132]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STMIA r0!,{r0-r14}
 5110290:	e8a07fff 	stmia	r0!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
	POP {r1}
 5110294:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
	LDR r0, =AbortRarry
 5110298:	e59f0078 	ldr	r0, [pc, #120]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STR r1,[r0]
 511029c:	e5801000 	str	r1, [r0]
	MRS r1, CPSR
 51102a0:	e10f1000 	mrs	r1, CPSR
	MSR CPSR, #0x10
 51102a4:	e329f010 	msr	CPSR_fc, #16
	MOV r0, sp
 51102a8:	e1a0000d 	mov	r0, sp
	MSR CPSR, r1
 51102ac:	e129f001 	msr	CPSR_fc, r1
	MOV r1, #0x00
 51102b0:	e3a01000 	mov	r1, #0
	b 	AbortHandler
 51102b4:	ea0006b7 	b	5111d98 <AbortHandler>

051102b8 <FreeRTOS_DataAbortHandler>:

FreeRTOS_DataAbortHandler:		 /* Data Abort handler */
	PUSH {r0}
 51102b8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	LDR r0, =AbortRarry
 51102bc:	e59f0054 	ldr	r0, [pc, #84]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STMIA r0!,{r0-r14}
 51102c0:	e8a07fff 	stmia	r0!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
	POP {r1}
 51102c4:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
	LDR r0, =AbortRarry
 51102c8:	e59f0048 	ldr	r0, [pc, #72]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STR r1,[r0]
 51102cc:	e5801000 	str	r1, [r0]
	MRS r1, CPSR
 51102d0:	e10f1000 	mrs	r1, CPSR
	MSR CPSR, #0x10
 51102d4:	e329f010 	msr	CPSR_fc, #16
	MOV r0, sp
 51102d8:	e1a0000d 	mov	r0, sp
	MSR CPSR, r1
 51102dc:	e129f001 	msr	CPSR_fc, r1
	MOV r1, #0x01
 51102e0:	e3a01001 	mov	r1, #1
	b	AbortHandler
 51102e4:	ea0006ab 	b	5111d98 <AbortHandler>

051102e8 <FreeRTOS_PrefetchAbortHandler>:

FreeRTOS_PrefetchAbortHandler:	/* Prefetch Abort handler */
	PUSH {r0}
 51102e8:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
	LDR r0, =AbortRarry
 51102ec:	e59f0024 	ldr	r0, [pc, #36]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STMIA r0!,{r0-r14}
 51102f0:	e8a07fff 	stmia	r0!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}
	POP {r1}
 51102f4:	e49d1004 	pop	{r1}		; (ldr r1, [sp], #4)
	LDR r0, =AbortRarry
 51102f8:	e59f0018 	ldr	r0, [pc, #24]	; 5110318 <MPU_xTaskGetCurrentTaskHandle+0x8>
	STR r1,[r0]
 51102fc:	e5801000 	str	r1, [r0]
	MRS r1, CPSR
 5110300:	e10f1000 	mrs	r1, CPSR
	MSR CPSR, #0x10
 5110304:	e329f010 	msr	CPSR_fc, #16
	MOV r0, sp
 5110308:	e1a0000d 	mov	r0, sp
	MSR CPSR, r1
 511030c:	e129f001 	msr	CPSR_fc, r1
	MOV r1, #0x02
 5110310:	e3a01002 	mov	r1, #2
	b	AbortHandler
 5110314:	ea00069f 	b	5111d98 <AbortHandler>
	LDR r0, =AbortRarry
 5110318:	05137390 	.word	0x05137390

0511031c <strcmp>:
 511031c:	f810 2b01 	ldrb.w	r2, [r0], #1
 5110320:	f811 3b01 	ldrb.w	r3, [r1], #1
 5110324:	2a01      	cmp	r2, #1
 5110326:	bf28      	it	cs
 5110328:	429a      	cmpcs	r2, r3
 511032a:	d0f7      	beq.n	511031c <strcmp>
 511032c:	1ad0      	subs	r0, r2, r3
 511032e:	4770      	bx	lr

05110330 <strlen>:
 5110330:	4603      	mov	r3, r0
 5110332:	f813 2b01 	ldrb.w	r2, [r3], #1
 5110336:	2a00      	cmp	r2, #0
 5110338:	d1fb      	bne.n	5110332 <strlen+0x2>
 511033a:	1a18      	subs	r0, r3, r0
 511033c:	3801      	subs	r0, #1
 511033e:	4770      	bx	lr

05110340 <__udivsi3>:
 5110340:	1e4a      	subs	r2, r1, #1
 5110342:	bf08      	it	eq
 5110344:	4770      	bxeq	lr
 5110346:	f0c0 8124 	bcc.w	5110592 <MPU_xTimerGetExpiryTime+0x2>
 511034a:	4288      	cmp	r0, r1
 511034c:	f240 8116 	bls.w	511057c <MPU_xTimerGetPeriod+0xc>
 5110350:	4211      	tst	r1, r2
 5110352:	f000 8117 	beq.w	5110584 <MPU_xTimerGetPeriod+0x14>
 5110356:	fab0 f380 	clz	r3, r0
 511035a:	fab1 f281 	clz	r2, r1
 511035e:	eba2 0303 	sub.w	r3, r2, r3
 5110362:	f1c3 031f 	rsb	r3, r3, #31
 5110366:	a204      	add	r2, pc, #16	; (adr r2, 5110378 <MPU_xQueueTakeMutexRecursive+0x8>)
 5110368:	eb02 1303 	add.w	r3, r2, r3, lsl #4
 511036c:	f04f 0200 	mov.w	r2, #0
 5110370:	469f      	mov	pc, r3
 5110372:	bf00      	nop
 5110374:	f3af 8000 	nop.w
 5110378:	ebb0 7fc1 	cmp.w	r0, r1, lsl #31
 511037c:	bf00      	nop
 511037e:	eb42 0202 	adc.w	r2, r2, r2
 5110382:	bf28      	it	cs
 5110384:	eba0 70c1 	subcs.w	r0, r0, r1, lsl #31
 5110388:	ebb0 7f81 	cmp.w	r0, r1, lsl #30
 511038c:	bf00      	nop
 511038e:	eb42 0202 	adc.w	r2, r2, r2
 5110392:	bf28      	it	cs
 5110394:	eba0 7081 	subcs.w	r0, r0, r1, lsl #30
 5110398:	ebb0 7f41 	cmp.w	r0, r1, lsl #29
 511039c:	bf00      	nop
 511039e:	eb42 0202 	adc.w	r2, r2, r2
 51103a2:	bf28      	it	cs
 51103a4:	eba0 7041 	subcs.w	r0, r0, r1, lsl #29
 51103a8:	ebb0 7f01 	cmp.w	r0, r1, lsl #28
 51103ac:	bf00      	nop
 51103ae:	eb42 0202 	adc.w	r2, r2, r2
 51103b2:	bf28      	it	cs
 51103b4:	eba0 7001 	subcs.w	r0, r0, r1, lsl #28
 51103b8:	ebb0 6fc1 	cmp.w	r0, r1, lsl #27
 51103bc:	bf00      	nop
 51103be:	eb42 0202 	adc.w	r2, r2, r2
 51103c2:	bf28      	it	cs
 51103c4:	eba0 60c1 	subcs.w	r0, r0, r1, lsl #27
 51103c8:	ebb0 6f81 	cmp.w	r0, r1, lsl #26
 51103cc:	bf00      	nop
 51103ce:	eb42 0202 	adc.w	r2, r2, r2
 51103d2:	bf28      	it	cs
 51103d4:	eba0 6081 	subcs.w	r0, r0, r1, lsl #26
 51103d8:	ebb0 6f41 	cmp.w	r0, r1, lsl #25
 51103dc:	bf00      	nop
 51103de:	eb42 0202 	adc.w	r2, r2, r2
 51103e2:	bf28      	it	cs
 51103e4:	eba0 6041 	subcs.w	r0, r0, r1, lsl #25
 51103e8:	ebb0 6f01 	cmp.w	r0, r1, lsl #24
 51103ec:	bf00      	nop
 51103ee:	eb42 0202 	adc.w	r2, r2, r2
 51103f2:	bf28      	it	cs
 51103f4:	eba0 6001 	subcs.w	r0, r0, r1, lsl #24
 51103f8:	ebb0 5fc1 	cmp.w	r0, r1, lsl #23
 51103fc:	bf00      	nop
 51103fe:	eb42 0202 	adc.w	r2, r2, r2
 5110402:	bf28      	it	cs
 5110404:	eba0 50c1 	subcs.w	r0, r0, r1, lsl #23
 5110408:	ebb0 5f81 	cmp.w	r0, r1, lsl #22
 511040c:	bf00      	nop
 511040e:	eb42 0202 	adc.w	r2, r2, r2
 5110412:	bf28      	it	cs
 5110414:	eba0 5081 	subcs.w	r0, r0, r1, lsl #22
 5110418:	ebb0 5f41 	cmp.w	r0, r1, lsl #21
 511041c:	bf00      	nop
 511041e:	eb42 0202 	adc.w	r2, r2, r2
 5110422:	bf28      	it	cs
 5110424:	eba0 5041 	subcs.w	r0, r0, r1, lsl #21
 5110428:	ebb0 5f01 	cmp.w	r0, r1, lsl #20
 511042c:	bf00      	nop
 511042e:	eb42 0202 	adc.w	r2, r2, r2
 5110432:	bf28      	it	cs
 5110434:	eba0 5001 	subcs.w	r0, r0, r1, lsl #20
 5110438:	ebb0 4fc1 	cmp.w	r0, r1, lsl #19
 511043c:	bf00      	nop
 511043e:	eb42 0202 	adc.w	r2, r2, r2
 5110442:	bf28      	it	cs
 5110444:	eba0 40c1 	subcs.w	r0, r0, r1, lsl #19
 5110448:	ebb0 4f81 	cmp.w	r0, r1, lsl #18
 511044c:	bf00      	nop
 511044e:	eb42 0202 	adc.w	r2, r2, r2
 5110452:	bf28      	it	cs
 5110454:	eba0 4081 	subcs.w	r0, r0, r1, lsl #18
 5110458:	ebb0 4f41 	cmp.w	r0, r1, lsl #17
 511045c:	bf00      	nop
 511045e:	eb42 0202 	adc.w	r2, r2, r2
 5110462:	bf28      	it	cs
 5110464:	eba0 4041 	subcs.w	r0, r0, r1, lsl #17
 5110468:	ebb0 4f01 	cmp.w	r0, r1, lsl #16
 511046c:	bf00      	nop
 511046e:	eb42 0202 	adc.w	r2, r2, r2
 5110472:	bf28      	it	cs
 5110474:	eba0 4001 	subcs.w	r0, r0, r1, lsl #16
 5110478:	ebb0 3fc1 	cmp.w	r0, r1, lsl #15
 511047c:	bf00      	nop
 511047e:	eb42 0202 	adc.w	r2, r2, r2
 5110482:	bf28      	it	cs
 5110484:	eba0 30c1 	subcs.w	r0, r0, r1, lsl #15
 5110488:	ebb0 3f81 	cmp.w	r0, r1, lsl #14
 511048c:	bf00      	nop
 511048e:	eb42 0202 	adc.w	r2, r2, r2
 5110492:	bf28      	it	cs
 5110494:	eba0 3081 	subcs.w	r0, r0, r1, lsl #14
 5110498:	ebb0 3f41 	cmp.w	r0, r1, lsl #13
 511049c:	bf00      	nop
 511049e:	eb42 0202 	adc.w	r2, r2, r2
 51104a2:	bf28      	it	cs
 51104a4:	eba0 3041 	subcs.w	r0, r0, r1, lsl #13
 51104a8:	ebb0 3f01 	cmp.w	r0, r1, lsl #12
 51104ac:	bf00      	nop
 51104ae:	eb42 0202 	adc.w	r2, r2, r2
 51104b2:	bf28      	it	cs
 51104b4:	eba0 3001 	subcs.w	r0, r0, r1, lsl #12
 51104b8:	ebb0 2fc1 	cmp.w	r0, r1, lsl #11
 51104bc:	bf00      	nop
 51104be:	eb42 0202 	adc.w	r2, r2, r2
 51104c2:	bf28      	it	cs
 51104c4:	eba0 20c1 	subcs.w	r0, r0, r1, lsl #11
 51104c8:	ebb0 2f81 	cmp.w	r0, r1, lsl #10
 51104cc:	bf00      	nop
 51104ce:	eb42 0202 	adc.w	r2, r2, r2
 51104d2:	bf28      	it	cs
 51104d4:	eba0 2081 	subcs.w	r0, r0, r1, lsl #10
 51104d8:	ebb0 2f41 	cmp.w	r0, r1, lsl #9
 51104dc:	bf00      	nop
 51104de:	eb42 0202 	adc.w	r2, r2, r2
 51104e2:	bf28      	it	cs
 51104e4:	eba0 2041 	subcs.w	r0, r0, r1, lsl #9
 51104e8:	ebb0 2f01 	cmp.w	r0, r1, lsl #8
 51104ec:	bf00      	nop
 51104ee:	eb42 0202 	adc.w	r2, r2, r2
 51104f2:	bf28      	it	cs
 51104f4:	eba0 2001 	subcs.w	r0, r0, r1, lsl #8
 51104f8:	ebb0 1fc1 	cmp.w	r0, r1, lsl #7
 51104fc:	bf00      	nop
 51104fe:	eb42 0202 	adc.w	r2, r2, r2
 5110502:	bf28      	it	cs
 5110504:	eba0 10c1 	subcs.w	r0, r0, r1, lsl #7
 5110508:	ebb0 1f81 	cmp.w	r0, r1, lsl #6
 511050c:	bf00      	nop
 511050e:	eb42 0202 	adc.w	r2, r2, r2
 5110512:	bf28      	it	cs
 5110514:	eba0 1081 	subcs.w	r0, r0, r1, lsl #6
 5110518:	ebb0 1f41 	cmp.w	r0, r1, lsl #5
 511051c:	bf00      	nop
 511051e:	eb42 0202 	adc.w	r2, r2, r2
 5110522:	bf28      	it	cs
 5110524:	eba0 1041 	subcs.w	r0, r0, r1, lsl #5
 5110528:	ebb0 1f01 	cmp.w	r0, r1, lsl #4
 511052c:	bf00      	nop
 511052e:	eb42 0202 	adc.w	r2, r2, r2
 5110532:	bf28      	it	cs
 5110534:	eba0 1001 	subcs.w	r0, r0, r1, lsl #4
 5110538:	ebb0 0fc1 	cmp.w	r0, r1, lsl #3
 511053c:	bf00      	nop
 511053e:	eb42 0202 	adc.w	r2, r2, r2
 5110542:	bf28      	it	cs
 5110544:	eba0 00c1 	subcs.w	r0, r0, r1, lsl #3
 5110548:	ebb0 0f81 	cmp.w	r0, r1, lsl #2
 511054c:	bf00      	nop
 511054e:	eb42 0202 	adc.w	r2, r2, r2
 5110552:	bf28      	it	cs
 5110554:	eba0 0081 	subcs.w	r0, r0, r1, lsl #2
 5110558:	ebb0 0f41 	cmp.w	r0, r1, lsl #1
 511055c:	bf00      	nop
 511055e:	eb42 0202 	adc.w	r2, r2, r2
 5110562:	bf28      	it	cs
 5110564:	eba0 0041 	subcs.w	r0, r0, r1, lsl #1
 5110568:	ebb0 0f01 	cmp.w	r0, r1
 511056c:	bf00      	nop
 511056e:	eb42 0202 	adc.w	r2, r2, r2
 5110572:	bf28      	it	cs
 5110574:	eba0 0001 	subcs.w	r0, r0, r1
 5110578:	4610      	mov	r0, r2
 511057a:	4770      	bx	lr
 511057c:	bf0c      	ite	eq
 511057e:	2001      	moveq	r0, #1
 5110580:	2000      	movne	r0, #0
 5110582:	4770      	bx	lr
 5110584:	fab1 f281 	clz	r2, r1
 5110588:	f1c2 021f 	rsb	r2, r2, #31
 511058c:	fa20 f002 	lsr.w	r0, r0, r2
 5110590:	4770      	bx	lr
 5110592:	b108      	cbz	r0, 5110598 <MPU_xTimerGetExpiryTime+0x8>
 5110594:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 5110598:	f000 b966 	b.w	5110868 <__aeabi_idiv0>

0511059c <__aeabi_uidivmod>:
 511059c:	2900      	cmp	r1, #0
 511059e:	d0f8      	beq.n	5110592 <MPU_xTimerGetExpiryTime+0x2>
 51105a0:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 51105a4:	f7ff fecc 	bl	5110340 <__udivsi3>
 51105a8:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 51105ac:	fb02 f300 	mul.w	r3, r2, r0
 51105b0:	eba1 0103 	sub.w	r1, r1, r3
 51105b4:	4770      	bx	lr
 51105b6:	bf00      	nop

051105b8 <__divsi3>:
 51105b8:	2900      	cmp	r1, #0
 51105ba:	f000 813e 	beq.w	511083a <__syscalls_flash_end__+0x1ee>

051105be <.divsi3_skip_div0_test>:
 51105be:	ea80 0c01 	eor.w	ip, r0, r1
 51105c2:	bf48      	it	mi
 51105c4:	4249      	negmi	r1, r1
 51105c6:	1e4a      	subs	r2, r1, #1
 51105c8:	f000 811f 	beq.w	511080a <__syscalls_flash_end__+0x1be>
 51105cc:	0003      	movs	r3, r0
 51105ce:	bf48      	it	mi
 51105d0:	4243      	negmi	r3, r0
 51105d2:	428b      	cmp	r3, r1
 51105d4:	f240 811e 	bls.w	5110814 <__syscalls_flash_end__+0x1c8>
 51105d8:	4211      	tst	r1, r2
 51105da:	f000 8123 	beq.w	5110824 <__syscalls_flash_end__+0x1d8>
 51105de:	fab3 f283 	clz	r2, r3
 51105e2:	fab1 f081 	clz	r0, r1
 51105e6:	eba0 0202 	sub.w	r2, r0, r2
 51105ea:	f1c2 021f 	rsb	r2, r2, #31
 51105ee:	a004      	add	r0, pc, #16	; (adr r0, 5110600 <MPU_ulTaskGenericNotifyTake+0x10>)
 51105f0:	eb00 1202 	add.w	r2, r0, r2, lsl #4
 51105f4:	f04f 0000 	mov.w	r0, #0
 51105f8:	4697      	mov	pc, r2
 51105fa:	bf00      	nop
 51105fc:	f3af 8000 	nop.w
 5110600:	ebb3 7fc1 	cmp.w	r3, r1, lsl #31
 5110604:	bf00      	nop
 5110606:	eb40 0000 	adc.w	r0, r0, r0
 511060a:	bf28      	it	cs
 511060c:	eba3 73c1 	subcs.w	r3, r3, r1, lsl #31
 5110610:	ebb3 7f81 	cmp.w	r3, r1, lsl #30
 5110614:	bf00      	nop
 5110616:	eb40 0000 	adc.w	r0, r0, r0
 511061a:	bf28      	it	cs
 511061c:	eba3 7381 	subcs.w	r3, r3, r1, lsl #30
 5110620:	ebb3 7f41 	cmp.w	r3, r1, lsl #29
 5110624:	bf00      	nop
 5110626:	eb40 0000 	adc.w	r0, r0, r0
 511062a:	bf28      	it	cs
 511062c:	eba3 7341 	subcs.w	r3, r3, r1, lsl #29
 5110630:	ebb3 7f01 	cmp.w	r3, r1, lsl #28
 5110634:	bf00      	nop
 5110636:	eb40 0000 	adc.w	r0, r0, r0
 511063a:	bf28      	it	cs
 511063c:	eba3 7301 	subcs.w	r3, r3, r1, lsl #28
 5110640:	ebb3 6fc1 	cmp.w	r3, r1, lsl #27
 5110644:	bf00      	nop
 5110646:	eb40 0000 	adc.w	r0, r0, r0
 511064a:	bf28      	it	cs
 511064c:	eba3 63c1 	subcs.w	r3, r3, r1, lsl #27
 5110650:	ebb3 6f81 	cmp.w	r3, r1, lsl #26
 5110654:	bf00      	nop
 5110656:	eb40 0000 	adc.w	r0, r0, r0
 511065a:	bf28      	it	cs
 511065c:	eba3 6381 	subcs.w	r3, r3, r1, lsl #26
 5110660:	ebb3 6f41 	cmp.w	r3, r1, lsl #25
 5110664:	bf00      	nop
 5110666:	eb40 0000 	adc.w	r0, r0, r0
 511066a:	bf28      	it	cs
 511066c:	eba3 6341 	subcs.w	r3, r3, r1, lsl #25
 5110670:	ebb3 6f01 	cmp.w	r3, r1, lsl #24
 5110674:	bf00      	nop
 5110676:	eb40 0000 	adc.w	r0, r0, r0
 511067a:	bf28      	it	cs
 511067c:	eba3 6301 	subcs.w	r3, r3, r1, lsl #24
 5110680:	ebb3 5fc1 	cmp.w	r3, r1, lsl #23
 5110684:	bf00      	nop
 5110686:	eb40 0000 	adc.w	r0, r0, r0
 511068a:	bf28      	it	cs
 511068c:	eba3 53c1 	subcs.w	r3, r3, r1, lsl #23
 5110690:	ebb3 5f81 	cmp.w	r3, r1, lsl #22
 5110694:	bf00      	nop
 5110696:	eb40 0000 	adc.w	r0, r0, r0
 511069a:	bf28      	it	cs
 511069c:	eba3 5381 	subcs.w	r3, r3, r1, lsl #22
 51106a0:	ebb3 5f41 	cmp.w	r3, r1, lsl #21
 51106a4:	bf00      	nop
 51106a6:	eb40 0000 	adc.w	r0, r0, r0
 51106aa:	bf28      	it	cs
 51106ac:	eba3 5341 	subcs.w	r3, r3, r1, lsl #21
 51106b0:	ebb3 5f01 	cmp.w	r3, r1, lsl #20
 51106b4:	bf00      	nop
 51106b6:	eb40 0000 	adc.w	r0, r0, r0
 51106ba:	bf28      	it	cs
 51106bc:	eba3 5301 	subcs.w	r3, r3, r1, lsl #20
 51106c0:	ebb3 4fc1 	cmp.w	r3, r1, lsl #19
 51106c4:	bf00      	nop
 51106c6:	eb40 0000 	adc.w	r0, r0, r0
 51106ca:	bf28      	it	cs
 51106cc:	eba3 43c1 	subcs.w	r3, r3, r1, lsl #19
 51106d0:	ebb3 4f81 	cmp.w	r3, r1, lsl #18
 51106d4:	bf00      	nop
 51106d6:	eb40 0000 	adc.w	r0, r0, r0
 51106da:	bf28      	it	cs
 51106dc:	eba3 4381 	subcs.w	r3, r3, r1, lsl #18
 51106e0:	ebb3 4f41 	cmp.w	r3, r1, lsl #17
 51106e4:	bf00      	nop
 51106e6:	eb40 0000 	adc.w	r0, r0, r0
 51106ea:	bf28      	it	cs
 51106ec:	eba3 4341 	subcs.w	r3, r3, r1, lsl #17
 51106f0:	ebb3 4f01 	cmp.w	r3, r1, lsl #16
 51106f4:	bf00      	nop
 51106f6:	eb40 0000 	adc.w	r0, r0, r0
 51106fa:	bf28      	it	cs
 51106fc:	eba3 4301 	subcs.w	r3, r3, r1, lsl #16
 5110700:	ebb3 3fc1 	cmp.w	r3, r1, lsl #15
 5110704:	bf00      	nop
 5110706:	eb40 0000 	adc.w	r0, r0, r0
 511070a:	bf28      	it	cs
 511070c:	eba3 33c1 	subcs.w	r3, r3, r1, lsl #15
 5110710:	ebb3 3f81 	cmp.w	r3, r1, lsl #14
 5110714:	bf00      	nop
 5110716:	eb40 0000 	adc.w	r0, r0, r0
 511071a:	bf28      	it	cs
 511071c:	eba3 3381 	subcs.w	r3, r3, r1, lsl #14
 5110720:	ebb3 3f41 	cmp.w	r3, r1, lsl #13
 5110724:	bf00      	nop
 5110726:	eb40 0000 	adc.w	r0, r0, r0
 511072a:	bf28      	it	cs
 511072c:	eba3 3341 	subcs.w	r3, r3, r1, lsl #13
 5110730:	ebb3 3f01 	cmp.w	r3, r1, lsl #12
 5110734:	bf00      	nop
 5110736:	eb40 0000 	adc.w	r0, r0, r0
 511073a:	bf28      	it	cs
 511073c:	eba3 3301 	subcs.w	r3, r3, r1, lsl #12
 5110740:	ebb3 2fc1 	cmp.w	r3, r1, lsl #11
 5110744:	bf00      	nop
 5110746:	eb40 0000 	adc.w	r0, r0, r0
 511074a:	bf28      	it	cs
 511074c:	eba3 23c1 	subcs.w	r3, r3, r1, lsl #11
 5110750:	ebb3 2f81 	cmp.w	r3, r1, lsl #10
 5110754:	bf00      	nop
 5110756:	eb40 0000 	adc.w	r0, r0, r0
 511075a:	bf28      	it	cs
 511075c:	eba3 2381 	subcs.w	r3, r3, r1, lsl #10
 5110760:	ebb3 2f41 	cmp.w	r3, r1, lsl #9
 5110764:	bf00      	nop
 5110766:	eb40 0000 	adc.w	r0, r0, r0
 511076a:	bf28      	it	cs
 511076c:	eba3 2341 	subcs.w	r3, r3, r1, lsl #9
 5110770:	ebb3 2f01 	cmp.w	r3, r1, lsl #8
 5110774:	bf00      	nop
 5110776:	eb40 0000 	adc.w	r0, r0, r0
 511077a:	bf28      	it	cs
 511077c:	eba3 2301 	subcs.w	r3, r3, r1, lsl #8
 5110780:	ebb3 1fc1 	cmp.w	r3, r1, lsl #7
 5110784:	bf00      	nop
 5110786:	eb40 0000 	adc.w	r0, r0, r0
 511078a:	bf28      	it	cs
 511078c:	eba3 13c1 	subcs.w	r3, r3, r1, lsl #7
 5110790:	ebb3 1f81 	cmp.w	r3, r1, lsl #6
 5110794:	bf00      	nop
 5110796:	eb40 0000 	adc.w	r0, r0, r0
 511079a:	bf28      	it	cs
 511079c:	eba3 1381 	subcs.w	r3, r3, r1, lsl #6
 51107a0:	ebb3 1f41 	cmp.w	r3, r1, lsl #5
 51107a4:	bf00      	nop
 51107a6:	eb40 0000 	adc.w	r0, r0, r0
 51107aa:	bf28      	it	cs
 51107ac:	eba3 1341 	subcs.w	r3, r3, r1, lsl #5
 51107b0:	ebb3 1f01 	cmp.w	r3, r1, lsl #4
 51107b4:	bf00      	nop
 51107b6:	eb40 0000 	adc.w	r0, r0, r0
 51107ba:	bf28      	it	cs
 51107bc:	eba3 1301 	subcs.w	r3, r3, r1, lsl #4
 51107c0:	ebb3 0fc1 	cmp.w	r3, r1, lsl #3
 51107c4:	bf00      	nop
 51107c6:	eb40 0000 	adc.w	r0, r0, r0
 51107ca:	bf28      	it	cs
 51107cc:	eba3 03c1 	subcs.w	r3, r3, r1, lsl #3
 51107d0:	ebb3 0f81 	cmp.w	r3, r1, lsl #2
 51107d4:	bf00      	nop
 51107d6:	eb40 0000 	adc.w	r0, r0, r0
 51107da:	bf28      	it	cs
 51107dc:	eba3 0381 	subcs.w	r3, r3, r1, lsl #2
 51107e0:	ebb3 0f41 	cmp.w	r3, r1, lsl #1
 51107e4:	bf00      	nop
 51107e6:	eb40 0000 	adc.w	r0, r0, r0
 51107ea:	bf28      	it	cs
 51107ec:	eba3 0341 	subcs.w	r3, r3, r1, lsl #1
 51107f0:	ebb3 0f01 	cmp.w	r3, r1
 51107f4:	bf00      	nop
 51107f6:	eb40 0000 	adc.w	r0, r0, r0
 51107fa:	bf28      	it	cs
 51107fc:	eba3 0301 	subcs.w	r3, r3, r1
 5110800:	f1bc 0f00 	cmp.w	ip, #0
 5110804:	bf48      	it	mi
 5110806:	4240      	negmi	r0, r0
 5110808:	4770      	bx	lr
 511080a:	ea9c 0f00 	teq	ip, r0
 511080e:	bf48      	it	mi
 5110810:	4240      	negmi	r0, r0
 5110812:	4770      	bx	lr
 5110814:	bf38      	it	cc
 5110816:	2000      	movcc	r0, #0
 5110818:	bf04      	itt	eq
 511081a:	ea4f 70ec 	moveq.w	r0, ip, asr #31
 511081e:	f040 0001 	orreq.w	r0, r0, #1
 5110822:	4770      	bx	lr
 5110824:	fab1 f281 	clz	r2, r1
 5110828:	f1c2 021f 	rsb	r2, r2, #31
 511082c:	f1bc 0f00 	cmp.w	ip, #0
 5110830:	fa23 f002 	lsr.w	r0, r3, r2
 5110834:	bf48      	it	mi
 5110836:	4240      	negmi	r0, r0
 5110838:	4770      	bx	lr
 511083a:	2800      	cmp	r0, #0
 511083c:	bfc8      	it	gt
 511083e:	f06f 4000 	mvngt.w	r0, #2147483648	; 0x80000000
 5110842:	bfb8      	it	lt
 5110844:	f04f 4000 	movlt.w	r0, #2147483648	; 0x80000000
 5110848:	f000 b80e 	b.w	5110868 <__aeabi_idiv0>

0511084c <__aeabi_idivmod>:
 511084c:	2900      	cmp	r1, #0
 511084e:	d0f4      	beq.n	511083a <__syscalls_flash_end__+0x1ee>
 5110850:	e92d 4003 	stmdb	sp!, {r0, r1, lr}
 5110854:	f7ff feb3 	bl	51105be <.divsi3_skip_div0_test>
 5110858:	e8bd 4006 	ldmia.w	sp!, {r1, r2, lr}
 511085c:	fb02 f300 	mul.w	r3, r2, r0
 5110860:	eba1 0103 	sub.w	r1, r1, r3
 5110864:	4770      	bx	lr
 5110866:	bf00      	nop

05110868 <__aeabi_idiv0>:
 5110868:	4770      	bx	lr
 511086a:	bf00      	nop

0511086c <vApplicationMallocFailedHook>:

void vApplicationMallocFailedHook( void )
{
	uint32* pp = 0xb7000048;
    uint32 a = *pp;
    *pp = a+1;
 511086c:	e3a014b7 	mov	r1, #-1224736768	; 0xb7000000
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	taskDISABLE_INTERRUPTS();
 5110870:	e3003210 	movw	r3, #528	; 0x210
{
 5110874:	e92d4010 	push	{r4, lr}
    *pp = a+1;
 5110878:	e5912048 	ldr	r2, [r1, #72]	; 0x48
	taskDISABLE_INTERRUPTS();
 511087c:	e3403510 	movt	r3, #1296	; 0x510
    *pp = a+1;
 5110880:	e2822001 	add	r2, r2, #1
 5110884:	e5812048 	str	r2, [r1, #72]	; 0x48
	taskDISABLE_INTERRUPTS();
 5110888:	e12fff33 	blx	r3
	for( ;; );
 511088c:	eafffffe 	b	511088c <vApplicationMallocFailedHook+0x20>

05110890 <vApplicationIdleHook>:
	idle task just queries the amount of FreeRTOS heap that remains.  See the
	memory management section on the http://www.FreeRTOS.org web site for memory
	management options.  If there is a lot of heap memory free then the
	configTOTAL_HEAP_SIZE value in FreeRTOSConfig.h can be reduced to free up
	RAM. */
	Dlt_MainFunction();
 5110890:	e302314c 	movw	r3, #8524	; 0x214c
 5110894:	e3403511 	movt	r3, #1297	; 0x511
{
 5110898:	e92d4010 	push	{r4, lr}
	Dlt_MainFunction();
 511089c:	e12fff33 	blx	r3
	//xFreeHeapSpace = xPortGetFreeHeapSize();

	/* Remove compiler warning about xFreeHeapSpace being set but never used. */
	//( void ) xFreeHeapSpace;
}
 51108a0:	e8bd8010 	pop	{r4, pc}

051108a4 <vApplicationStackOverflowHook>:
	( void ) pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
 51108a4:	e3003210 	movw	r3, #528	; 0x210
 51108a8:	e3403510 	movt	r3, #1296	; 0x510
{
 51108ac:	e92d4010 	push	{r4, lr}
	taskDISABLE_INTERRUPTS();
 51108b0:	e12fff33 	blx	r3
	for( ;; );
 51108b4:	eafffffe 	b	51108b4 <vApplicationStackOverflowHook+0x10>

051108b8 <vApplicationGetIdleTaskMemory>:
static StaticTask_t xIdleTaskTCB;
static StackType_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];

	/* Pass out a pointer to the StaticTask_t structure in which the Idle task's
	state will be stored. */
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
 51108b8:	e306c000 	movw	ip, #24576	; 0x6000

	/* Pass out the array that will be used as the Idle task's stack. */
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
 51108bc:	e3003000 	movw	r3, #0
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
 51108c0:	e340c513 	movt	ip, #1299	; 0x513
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
 51108c4:	e3403513 	movt	r3, #1299	; 0x513
	*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
 51108c8:	e580c000 	str	ip, [r0]

	/* Pass out the size of the array pointed to by *ppxIdleTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 51108cc:	e3a00b02 	mov	r0, #2048	; 0x800
	*ppxIdleTaskStackBuffer = uxIdleTaskStack;
 51108d0:	e5813000 	str	r3, [r1]
	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 51108d4:	e5820000 	str	r0, [r2]
}
 51108d8:	e12fff1e 	bx	lr

051108dc <vApplicationGetTimerTaskMemory>:
static StaticTask_t xTimerTaskTCB;
static StackType_t uxTimerTaskStack[ configTIMER_TASK_STACK_DEPTH ];

	/* Pass out a pointer to the StaticTask_t structure in which the Timer
	task's state will be stored. */
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 51108dc:	e306c39c 	movw	ip, #25500	; 0x639c

	/* Pass out the array that will be used as the Timer task's stack. */
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;
 51108e0:	e3023000 	movw	r3, #8192	; 0x2000
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 51108e4:	e340c513 	movt	ip, #1299	; 0x513
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;
 51108e8:	e3403513 	movt	r3, #1299	; 0x513
	*ppxTimerTaskTCBBuffer = &xTimerTaskTCB;
 51108ec:	e580c000 	str	ip, [r0]

	/* Pass out the size of the array pointed to by *ppxTimerTaskStackBuffer.
	Note that, as the array is necessarily of type StackType_t,
	configMINIMAL_STACK_SIZE is specified in words, not bytes. */
	*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 51108f0:	e3a00a01 	mov	r0, #4096	; 0x1000
	*ppxTimerTaskStackBuffer = uxTimerTaskStack;
 51108f4:	e5813000 	str	r3, [r1]
	*pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
 51108f8:	e5820000 	str	r0, [r2]
}
 51108fc:	e12fff1e 	bx	lr

05110900 <vMainAssertCalled>:

void vMainAssertCalled( const char *pcFileName, uint32_t ulLineNumber )
{
 5110900:	e92d4070 	push	{r4, r5, r6, lr}
	int* pp = 0xb7000008;
    *pp = 0x1234;
 5110904:	e3012234 	movw	r2, #4660	; 0x1234
 5110908:	e3a054b7 	mov	r5, #-1224736768	; 0xb7000000
{
 511090c:	e1a04001 	mov	r4, r1

	taskENTER_CRITICAL();
 5110910:	e30c3930 	movw	r3, #51504	; 0xc930
    *pp = 0x1234;
 5110914:	e5852008 	str	r2, [r5, #8]
	taskENTER_CRITICAL();
 5110918:	e3403510 	movt	r3, #1296	; 0x510
 511091c:	e12fff33 	blx	r3
	// myprintf("%s %d", __FUNCTION__, __LINE__);

	pp = 0xb7000040;
	*pp = ulLineNumber;
 5110920:	e5854040 	str	r4, [r5, #64]	; 0x40


	for( ;; );
 5110924:	eafffffe 	b	5110924 <vMainAssertCalled+0x24>

05110928 <_startup>:
extern void enable_caches(void);

void _startup(void)
{
	/*isr*/
	REG_WRITE32(0x30000000+0x300, 0xABCD1234);
 5110928:	e3a00203 	mov	r0, #805306368	; 0x30000000
 511092c:	e3011234 	movw	r1, #4660	; 0x1234
 5110930:	e34a1bcd 	movt	r1, #43981	; 0xabcd
{
 5110934:	e92d4010 	push	{r4, lr}
	REG_WRITE32(0x30000000+0x300, 0xABCD1234);
 5110938:	e5801300 	str	r1, [r0, #768]	; 0x300
	//REG_WRITE32(0x30000000+0x1EC, 219); /*soc timer1 to isr 0*/
	REG_RMW32(0x30000000+0x1EC, ((1<<10U)-1U), 219);   /*soc timer1 to isr 0*/
#ifdef UART_DEBUG
	REG_WRITE32(0x69036000, 0xABCD1234);
 511093c:	e3a02a06 	mov	r2, #24576	; 0x6000
	REG_RMW32(0x30000000+0x1EC, ((1<<10U)-1U), 219);   /*soc timer1 to isr 0*/
 5110940:	e59031ec 	ldr	r3, [r0, #492]	; 0x1ec
	REG_WRITE32(0x69036000, 0xABCD1234);
 5110944:	e3462903 	movt	r2, #26883	; 0x6903
	REG_WRITE32(0x69036000+0x234, 105); /*rt uart2 to isr 0*/
 5110948:	e3a0c069 	mov	ip, #105	; 0x69
	REG_RMW32(0x30000000+0x1EC, ((1<<10U)-1U), 219);   /*soc timer1 to isr 0*/
 511094c:	e3c33fff 	bic	r3, r3, #1020	; 0x3fc
 5110950:	e3c33003 	bic	r3, r3, #3
 5110954:	e38330db 	orr	r3, r3, #219	; 0xdb
 5110958:	e58031ec 	str	r3, [r0, #492]	; 0x1ec
    Uart_Init(&Uart_Config);
 511095c:	e30d0274 	movw	r0, #53876	; 0xd274
 5110960:	e30837d0 	movw	r3, #34768	; 0x87d0
 5110964:	e3400512 	movt	r0, #1298	; 0x512
	REG_WRITE32(0x69036000, 0xABCD1234);
 5110968:	e5821000 	str	r1, [r2]
    Uart_Init(&Uart_Config);
 511096c:	e3403511 	movt	r3, #1297	; 0x511
	REG_WRITE32(0x69036000+0x234, 105); /*rt uart2 to isr 0*/
 5110970:	e582c234 	str	ip, [r2, #564]	; 0x234
    Uart_Init(&Uart_Config);
 5110974:	e12fff33 	blx	r3
#endif
    DebugAndShell_Init();
 5110978:	e3023040 	movw	r3, #8256	; 0x2040
 511097c:	e3403511 	movt	r3, #1297	; 0x511
 5110980:	e12fff33 	blx	r3
	Isr_Init();
 5110984:	e3013518 	movw	r3, #5400	; 0x1518
 5110988:	e3403511 	movt	r3, #1297	; 0x511
 511098c:	e12fff33 	blx	r3
#ifdef TOUCH_SCREEN_ENABLE
	I2c_Init(NULL);
#endif
	main();
 5110990:	e3003aa8 	movw	r3, #2728	; 0xaa8
 5110994:	e3403511 	movt	r3, #1297	; 0x511
 5110998:	e12fff33 	blx	r3
}
 511099c:	e8bd8010 	pop	{r4, pc}

051109a0 <vTaskFunction>:
char cReadOnlyArray[ 32 ] __attribute__((aligned(32)));


StaticTask_t pxTaskBuffer;

void vTaskFunction(void* p) {
 51109a0:	e92d4070 	push	{r4, r5, r6, lr}
 51109a4:	e3005250 	movw	r5, #592	; 0x250
    int* pp = 0xb700001c;
    int a = 0x1111;
 51109a8:	e3013111 	movw	r3, #4369	; 0x1111
    *pp = a;
    for (;;)
    {
        *pp = a++;
 51109ac:	e3a064b7 	mov	r6, #-1224736768	; 0xb7000000
 51109b0:	e3405511 	movt	r5, #1297	; 0x511
 51109b4:	e586301c 	str	r3, [r6, #28]
 51109b8:	e2834001 	add	r4, r3, #1
        vTaskDelay(pdMS_TO_TICKS(1000));
 51109bc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
 51109c0:	e12fff35 	blx	r5
        *pp = a++;
 51109c4:	e1a03004 	mov	r3, r4
 51109c8:	eafffff9 	b	51109b4 <vTaskFunction+0x14>

051109cc <TaskStackOverflowCheck>:
{
 51109cc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 51109d0:	e59f506c 	ldr	r5, [pc, #108]	; 5110a44 <TaskStackOverflowCheck+0x78>
            myprintf("[%d] %s: FreeStackDepth:%d\n", i,
 51109d4:	e30aa614 	movw	sl, #42516	; 0xa614
 51109d8:	e30092f0 	movw	r9, #752	; 0x2f0
 51109dc:	e30c8d04 	movw	r8, #52484	; 0xcd04
{
 51109e0:	e24dd008 	sub	sp, sp, #8
 51109e4:	e2857038 	add	r7, r5, #56	; 0x38
            myprintf("[%d] %s: FreeStackDepth:%d\n", i,
 51109e8:	e340a510 	movt	sl, #1296	; 0x510
 51109ec:	e3409511 	movt	r9, #1297	; 0x511
    for (i = 0; i < TASK_TID_MAX_NUM; i++) {
 51109f0:	e3a06000 	mov	r6, #0
            myprintf("[%d] %s: FreeStackDepth:%d\n", i,
 51109f4:	e3408512 	movt	r8, #1298	; 0x512
        task_handler = TaskHandleTable[i];
 51109f8:	e5b54004 	ldr	r4, [r5, #4]!
        if (task_handler) {
 51109fc:	e2540000 	subs	r0, r4, #0
 5110a00:	0a00000a 	beq	5110a30 <TaskStackOverflowCheck+0x64>
            myprintf("[%d] %s: FreeStackDepth:%d\n", i,
 5110a04:	e12fff3a 	blx	sl
 5110a08:	e58d0004 	str	r0, [sp, #4]
 5110a0c:	e1a00004 	mov	r0, r4
 5110a10:	e12fff39 	blx	r9
 5110a14:	e30842f4 	movw	r4, #33524	; 0x82f4
 5110a18:	e59d2004 	ldr	r2, [sp, #4]
 5110a1c:	e1a01006 	mov	r1, r6
 5110a20:	e3404511 	movt	r4, #1297	; 0x511
 5110a24:	e1a03000 	mov	r3, r0
 5110a28:	e1a00008 	mov	r0, r8
 5110a2c:	e12fff34 	blx	r4
    for (i = 0; i < TASK_TID_MAX_NUM; i++) {
 5110a30:	e1550007 	cmp	r5, r7
 5110a34:	e2866001 	add	r6, r6, #1
 5110a38:	1affffee 	bne	51109f8 <TaskStackOverflowCheck+0x2c>
}
 5110a3c:	e28dd008 	add	sp, sp, #8
 5110a40:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
 5110a44:	0511ccf0 	.word	0x0511ccf0

05110a48 <StartupTask>:
//    taskENTER_CRITICAL();

    //TaskTimeHandleTable[Alarm_Temperature_Monitor] = xTimerCreate("TemperTimer", pdMS_TO_TICKS(2000), pdTRUE, 0, Alarm_Report_Temperature_Handle);
    //TaskTimeHandleTable[Alarm_HeartBeat_Monitor] = xTimerCreate("HeartBeatTImer", pdMS_TO_TICKS(500), pdTRUE, 0, HeartBeatTimeOutHandle);
   
    BaseType_t ret = xTaskCreateRestrictedStatic( &xTaskDefinition, IpcSerTaskHandle);
 5110a48:	e30c2cf4 	movw	r2, #52468	; 0xccf4
	*p = 0x6688;
 5110a4c:	e306c688 	movw	ip, #26248	; 0x6688
    BaseType_t ret = xTaskCreateRestrictedStatic( &xTaskDefinition, IpcSerTaskHandle);
 5110a50:	e3402511 	movt	r2, #1297	; 0x511
{
 5110a54:	e92d4010 	push	{r4, lr}
	*p = 0x6688;
 5110a58:	e3a044b7 	mov	r4, #-1224736768	; 0xb7000000
    BaseType_t ret = xTaskCreateRestrictedStatic( &xTaskDefinition, IpcSerTaskHandle);
 5110a5c:	e30c0d28 	movw	r0, #52520	; 0xcd28
 5110a60:	e30a378c 	movw	r3, #42892	; 0xa78c
 5110a64:	e3400512 	movt	r0, #1298	; 0x512
 5110a68:	e5921080 	ldr	r1, [r2, #128]	; 0x80
 5110a6c:	e3403510 	movt	r3, #1296	; 0x510
	*p = 0x6688;
 5110a70:	e584c000 	str	ip, [r4]
    BaseType_t ret = xTaskCreateRestrictedStatic( &xTaskDefinition, IpcSerTaskHandle);
 5110a74:	e12fff33 	blx	r3
    if (ret != pdPASS) {
        int* pp = 0xb7000004;
        *pp = 0x7798;
    } else {
        int* pp = 0xb7000004;
        *pp = 0x7797;
 5110a78:	e3073797 	movw	r3, #30615	; 0x7797
 5110a7c:	e3072798 	movw	r2, #30616	; 0x7798
 //   portTASK_USES_FLOATING_POINT();
    	
	*p = 0x8888;
//    taskEXIT_CRITICAL();
    	
	*p = 0x9999;
 5110a80:	e3091999 	movw	r1, #39321	; 0x9999
        *pp = 0x7797;
 5110a84:	e3500001 	cmp	r0, #1
 5110a88:	01a02003 	moveq	r2, r3
    vTaskStartScheduler();
 5110a8c:	e305314c 	movw	r3, #20812	; 0x514c
 5110a90:	e3403510 	movt	r3, #1296	; 0x510
 5110a94:	e8840006 	stm	r4, {r1, r2}
 5110a98:	e12fff33 	blx	r3
    *p = 0x1111;
 5110a9c:	e3013111 	movw	r3, #4369	; 0x1111
 5110aa0:	e5843000 	str	r3, [r4]

}
 5110aa4:	e8bd8010 	pop	{r4, pc}

05110aa8 <main>:
void main(void)
{
    // str
//    init_str_framework("soc_r5");

    StartupTask();
 5110aa8:	e3003a48 	movw	r3, #2632	; 0xa48
 5110aac:	e3403511 	movt	r3, #1297	; 0x511
{
 5110ab0:	e92d4010 	push	{r4, lr}
    StartupTask();
 5110ab4:	e12fff33 	blx	r3
    while (1); /* 正常不会执行到这里 */
 5110ab8:	eafffffe 	b	5110ab8 <main+0x10>

05110abc <shell_i2c_Test>:
        output_scan();

}

void shell_i2c_Test(int argc, char *argv[])
{
 5110abc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32 u32value = 0U;
 5110ac0:	e3a03000 	mov	r3, #0
{
 5110ac4:	e24dd04c 	sub	sp, sp, #76	; 0x4c
    uint8 val[8];
    int i;
    uint8 r_data[8] = {0};
    uint8 index;

    if (argc > 1)
 5110ac8:	e3500001 	cmp	r0, #1
    uint32 u32value = 0U;
 5110acc:	e58d3034 	str	r3, [sp, #52]	; 0x34
    uint8 r_data[8] = {0};
 5110ad0:	e58d3040 	str	r3, [sp, #64]	; 0x40
 5110ad4:	e58d3044 	str	r3, [sp, #68]	; 0x44
    if (argc > 1)
 5110ad8:	ca000001 	bgt	5110ae4 <shell_i2c_Test+0x28>
        else
        {
            LOG(DBG_INFO,"I2cApp", "wrong cmd\r\n");
        }
    }
}
 5110adc:	e28dd04c 	add	sp, sp, #76	; 0x4c
 5110ae0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(_atoi(argv[1], &u32value)) {
 5110ae4:	e3086390 	movw	r6, #33680	; 0x8390
 5110ae8:	e1a05000 	mov	r5, r0
 5110aec:	e1a04001 	mov	r4, r1
 5110af0:	e3406511 	movt	r6, #1297	; 0x511
 5110af4:	e5910004 	ldr	r0, [r1, #4]
 5110af8:	e28d1034 	add	r1, sp, #52	; 0x34
 5110afc:	e12fff36 	blx	r6
 5110b00:	e3500000 	cmp	r0, #0
 5110b04:	1a0000e5 	bne	5110ea0 <shell_i2c_Test+0x3e4>
        if(0 == strcmp(argv[2], "r"))
 5110b08:	e5940008 	ldr	r0, [r4, #8]
 5110b0c:	e5d03000 	ldrb	r3, [r0]
 5110b10:	e3530072 	cmp	r3, #114	; 0x72
        channel = (uint8)u32value;
 5110b14:	e5dd7034 	ldrb	r7, [sp, #52]	; 0x34
        if(0 == strcmp(argv[2], "r"))
 5110b18:	1a000044 	bne	5110c30 <shell_i2c_Test+0x174>
 5110b1c:	e5d02001 	ldrb	r2, [r0, #1]
 5110b20:	e3520000 	cmp	r2, #0
 5110b24:	1a000041 	bne	5110c30 <shell_i2c_Test+0x174>
            if(_atoi(argv[3], &u32value)) {
 5110b28:	e594000c 	ldr	r0, [r4, #12]
 5110b2c:	e28d1034 	add	r1, sp, #52	; 0x34
 5110b30:	e12fff36 	blx	r6
 5110b34:	e3500000 	cmp	r0, #0
 5110b38:	1a0000eb 	bne	5110eec <shell_i2c_Test+0x430>
            if(_atoi(argv[4], &u32value)) {
 5110b3c:	e5940010 	ldr	r0, [r4, #16]
 5110b40:	e28d1034 	add	r1, sp, #52	; 0x34
            slave_addr = (uint8)u32value;
 5110b44:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
            if(_atoi(argv[4], &u32value)) {
 5110b48:	e12fff36 	blx	r6
 5110b4c:	e3500000 	cmp	r0, #0
 5110b50:	1a000156 	bne	51110b0 <shell_i2c_Test+0x5f4>
            if(strlen(argv[4])>=6) {
 5110b54:	e5940010 	ldr	r0, [r4, #16]
 5110b58:	e3003331 	movw	r3, #817	; 0x331
 5110b5c:	e3403511 	movt	r3, #1297	; 0x511
 5110b60:	e12fff33 	blx	r3
 5110b64:	e3500005 	cmp	r0, #5
 5110b68:	8a0000f4 	bhi	5110f40 <shell_i2c_Test+0x484>
                val[0] = (uint8)u32value;
 5110b6c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
                val[index] = 1;
 5110b70:	e3a08001 	mov	r8, #1
                val[0] = (uint8)u32value;
 5110b74:	e5cd3038 	strb	r3, [sp, #56]	; 0x38
                val[index] = 1;
 5110b78:	e5cd8039 	strb	r8, [sp, #57]	; 0x39
            if(argc==6) {
 5110b7c:	e3550006 	cmp	r5, #6
 5110b80:	0a000140 	beq	5111088 <shell_i2c_Test+0x5cc>
            if(i2c_n_send_receive_data(channel, slave_addr, val, index, r_data, val[index])) {
 5110b84:	e28d3048 	add	r3, sp, #72	; 0x48
 5110b88:	e0836008 	add	r6, r3, r8
 5110b8c:	e5562010 	ldrb	r2, [r6, #-16]
 5110b90:	e3084cf8 	movw	r4, #36088	; 0x8cf8
 5110b94:	e28d5040 	add	r5, sp, #64	; 0x40
 5110b98:	e58d2004 	str	r2, [sp, #4]
 5110b9c:	e1a03008 	mov	r3, r8
 5110ba0:	e1a00007 	mov	r0, r7
 5110ba4:	e6ef1079 	uxtb	r1, r9
 5110ba8:	e3404511 	movt	r4, #1297	; 0x511
 5110bac:	e58d5000 	str	r5, [sp]
 5110bb0:	e28d2038 	add	r2, sp, #56	; 0x38
 5110bb4:	e12fff34 	blx	r4
 5110bb8:	e3500000 	cmp	r0, #0
                LOG(DBG_INFO,"I2cApp", "line:%d, receive data err\r\n", __LINE__);
 5110bbc:	130c0e20 	movwne	r0, #52768	; 0xce20
 5110bc0:	13a0c09e 	movne	ip, #158	; 0x9e
 5110bc4:	13400512 	movtne	r0, #1298	; 0x512
            if(i2c_n_send_receive_data(channel, slave_addr, val, index, r_data, val[index])) {
 5110bc8:	1a000121 	bne	5111054 <shell_i2c_Test+0x598>
            LOG_ARRAY(DBG_INFO, "I2cApp", "line:%d, receive data(hex):", r_data, 1, val[index], 1, "");
 5110bcc:	e30c3e78 	movw	r3, #52856	; 0xce78
 5110bd0:	e3a02001 	mov	r2, #1
 5110bd4:	e5560010 	ldrb	r0, [r6, #-16]
 5110bd8:	e30c1e3c 	movw	r1, #52796	; 0xce3c
 5110bdc:	e58d2014 	str	r2, [sp, #20]
 5110be0:	e3403512 	movt	r3, #1298	; 0x512
 5110be4:	e58d200c 	str	r2, [sp, #12]
 5110be8:	e30c2da4 	movw	r2, #52644	; 0xcda4
 5110bec:	e58d3018 	str	r3, [sp, #24]
 5110bf0:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5110bf4:	e3a0c0a3 	mov	ip, #163	; 0xa3
 5110bf8:	e3401512 	movt	r1, #1298	; 0x512
 5110bfc:	e3403512 	movt	r3, #1298	; 0x512
 5110c00:	e58d0010 	str	r0, [sp, #16]
 5110c04:	e3402512 	movt	r2, #1298	; 0x512
 5110c08:	e58d5008 	str	r5, [sp, #8]
            LOG_ARRAY(DBG_INFO, "I2cApp", "write data(hex):", val, 1, argc-4, 1, "");
 5110c0c:	e58d1004 	str	r1, [sp, #4]
 5110c10:	e3034620 	movw	r4, #13856	; 0x3620
 5110c14:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 5110c18:	e3a00003 	mov	r0, #3
 5110c1c:	e3401512 	movt	r1, #1298	; 0x512
 5110c20:	e58dc000 	str	ip, [sp]
 5110c24:	e3404511 	movt	r4, #1297	; 0x511
 5110c28:	e12fff34 	blx	r4
 5110c2c:	eaffffaa 	b	5110adc <shell_i2c_Test+0x20>
        else if(0 == strcmp(argv[2], "w"))
 5110c30:	e3530077 	cmp	r3, #119	; 0x77
 5110c34:	1a000022 	bne	5110cc4 <shell_i2c_Test+0x208>
 5110c38:	e5d02001 	ldrb	r2, [r0, #1]
 5110c3c:	e3520000 	cmp	r2, #0
 5110c40:	1a00001f 	bne	5110cc4 <shell_i2c_Test+0x208>
            if(_atoi(argv[3], &u32value)) {
 5110c44:	e594000c 	ldr	r0, [r4, #12]
 5110c48:	e28d1034 	add	r1, sp, #52	; 0x34
 5110c4c:	e12fff36 	blx	r6
 5110c50:	e3500000 	cmp	r0, #0
                LOG(DBG_INFO,"I2cApp", "line:%d, invalid param\r\n", __LINE__, argv[3]);
 5110c54:	130c1dc4 	movwne	r1, #52676	; 0xcdc4
 5110c58:	13a0c0a8 	movne	ip, #168	; 0xa8
 5110c5c:	13401512 	movtne	r1, #1298	; 0x512
            if(_atoi(argv[3], &u32value)) {
 5110c60:	1a0000a4 	bne	5110ef8 <shell_i2c_Test+0x43c>
            slave_addr = (uint8)u32value;
 5110c64:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
            for(i=4; i<argc; i++) {
 5110c68:	e3550004 	cmp	r5, #4
 5110c6c:	c28d3033 	addgt	r3, sp, #51	; 0x33
 5110c70:	c2844010 	addgt	r4, r4, #16
 5110c74:	c083b005 	addgt	fp, r3, r5
 5110c78:	c28d8037 	addgt	r8, sp, #55	; 0x37
 5110c7c:	ca000004 	bgt	5110c94 <shell_i2c_Test+0x1d8>
 5110c80:	ea0000d2 	b	5110fd0 <shell_i2c_Test+0x514>
                val[i-4] = (uint8)u32value;
 5110c84:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5110c88:	e5e83001 	strb	r3, [r8, #1]!
            for(i=4; i<argc; i++) {
 5110c8c:	e158000b 	cmp	r8, fp
 5110c90:	0a0000ce 	beq	5110fd0 <shell_i2c_Test+0x514>
                if(_atoi(argv[i], &u32value)) {
 5110c94:	e1a0a004 	mov	sl, r4
 5110c98:	e28d1034 	add	r1, sp, #52	; 0x34
 5110c9c:	e2844004 	add	r4, r4, #4
 5110ca0:	e59a0000 	ldr	r0, [sl]
 5110ca4:	e12fff36 	blx	r6
 5110ca8:	e3500000 	cmp	r0, #0
 5110cac:	0afffff4 	beq	5110c84 <shell_i2c_Test+0x1c8>
                    LOG(DBG_INFO,"I2cApp", "line:%d, invalid param %s\r\n", __LINE__, argv[i]);
 5110cb0:	e30c1de0 	movw	r1, #52704	; 0xcde0
 5110cb4:	e3a0c0af 	mov	ip, #175	; 0xaf
 5110cb8:	e59a0000 	ldr	r0, [sl]
 5110cbc:	e3401512 	movt	r1, #1298	; 0x512
 5110cc0:	ea00007a 	b	5110eb0 <shell_i2c_Test+0x3f4>
        else if(0 == strcmp(argv[2], "s"))
 5110cc4:	e3530073 	cmp	r3, #115	; 0x73
 5110cc8:	1a000065 	bne	5110e64 <shell_i2c_Test+0x3a8>
 5110ccc:	e5d03001 	ldrb	r3, [r0, #1]
 5110cd0:	e3530000 	cmp	r3, #0
 5110cd4:	1a000062 	bne	5110e64 <shell_i2c_Test+0x3a8>
    bool elog_flag = elog_get_output_enabled();
 5110cd8:	e30232ec 	movw	r3, #8940	; 0x22ec
 5110cdc:	e308acf8 	movw	sl, #36088	; 0x8cf8
 5110ce0:	e59f8434 	ldr	r8, [pc, #1076]	; 511111c <shell_i2c_Test+0x660>
 5110ce4:	e3403511 	movt	r3, #1297	; 0x511
 5110ce8:	e12fff33 	blx	r3
 5110cec:	e30532a0 	movw	r3, #21152	; 0x52a0
 5110cf0:	e30262dc 	movw	r6, #8924	; 0x22dc
 5110cf4:	e3403510 	movt	r3, #1296	; 0x510
 5110cf8:	e1a04008 	mov	r4, r8
 5110cfc:	e340a511 	movt	sl, #1297	; 0x511
 5110d00:	e58d3028 	str	r3, [sp, #40]	; 0x28
 5110d04:	e3053efc 	movw	r3, #24316	; 0x5efc
 5110d08:	e3403510 	movt	r3, #1296	; 0x510
 5110d0c:	e3406511 	movt	r6, #1297	; 0x511
 5110d10:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5110d14:	e2485007 	sub	r5, r8, #7
 5110d18:	e1a0b000 	mov	fp, r0
            data[chip] = 2; //??
 5110d1c:	e3a03002 	mov	r3, #2
 5110d20:	e2844001 	add	r4, r4, #1
 5110d24:	e1a09004 	mov	r9, r4
            elog_set_output_enabled(false);
 5110d28:	e3a00000 	mov	r0, #0
            data[chip] = 2; //??
 5110d2c:	e4c93007 	strb	r3, [r9], #7
            elog_set_output_enabled(false);
 5110d30:	e12fff36 	blx	r6
            vTaskSuspendAll();
 5110d34:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
 5110d38:	e12fff33 	blx	r3
            if(i2c_n_send_receive_data(bus, chip, data, 1, data, 1)) {
 5110d3c:	e3a03001 	mov	r3, #1
 5110d40:	e1a02005 	mov	r2, r5
 5110d44:	e0491008 	sub	r1, r9, r8
 5110d48:	e58d3004 	str	r3, [sp, #4]
 5110d4c:	e1a00007 	mov	r0, r7
 5110d50:	e58d5000 	str	r5, [sp]
 5110d54:	e6ef1071 	uxtb	r1, r1
 5110d58:	e12fff3a 	blx	sl
            xTaskResumeAll();
 5110d5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
            if(i2c_n_send_receive_data(bus, chip, data, 1, data, 1)) {
 5110d60:	e16f0f10 	clz	r0, r0
 5110d64:	e1a002a0 	lsr	r0, r0, #5
 5110d68:	e5c40000 	strb	r0, [r4]
            xTaskResumeAll();
 5110d6c:	e12fff33 	blx	r3
            elog_set_output_enabled(elog_flag);
 5110d70:	e1a0000b 	mov	r0, fp
 5110d74:	e12fff36 	blx	r6
    for (chip = CHIP_START; chip < CHIP_END; ++chip) {
 5110d78:	e59f33a0 	ldr	r3, [pc, #928]	; 5111120 <shell_i2c_Test+0x664>
 5110d7c:	e1540003 	cmp	r4, r3
 5110d80:	1affffe5 	bne	5110d1c <shell_i2c_Test+0x260>
    printf("     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\r\n");
 5110d84:	e30c0eac 	movw	r0, #52908	; 0xceac
 5110d88:	e30aa67d 	movw	sl, #42621	; 0xa67d
 5110d8c:	e3400512 	movt	r0, #1298	; 0x512
 5110d90:	e30a7571 	movw	r7, #42353	; 0xa571
 5110d94:	e340a511 	movt	sl, #1297	; 0x511
 5110d98:	e12fff3a 	blx	sl
        printf("%02x:", offset = i << 4);
 5110d9c:	e30c3ee4 	movw	r3, #52964	; 0xcee4
    printf("     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\r\n");
 5110da0:	e3a0400f 	mov	r4, #15
        printf("%02x:", offset = i << 4);
 5110da4:	e3403512 	movt	r3, #1298	; 0x512
    printf("     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f\r\n");
 5110da8:	e3a06010 	mov	r6, #16
 5110dac:	e3a09000 	mov	r9, #0
        printf("%02x:", offset = i << 4);
 5110db0:	e58d3024 	str	r3, [sp, #36]	; 0x24
                    printf(" ??");
 5110db4:	e30c3f00 	movw	r3, #52992	; 0xcf00
 5110db8:	e3403512 	movt	r3, #1298	; 0x512
 5110dbc:	e3407511 	movt	r7, #1297	; 0x511
 5110dc0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
                    printf(" %02x", idx);
 5110dc4:	e30c3ef8 	movw	r3, #52984	; 0xcef8
 5110dc8:	e3403512 	movt	r3, #1298	; 0x512
 5110dcc:	e58d3028 	str	r3, [sp, #40]	; 0x28
        printf("%02x:", offset = i << 4);
 5110dd0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
 5110dd4:	e1a01009 	mov	r1, r9
                    printf(" --");
 5110dd8:	e30c8ef4 	movw	r8, #52980	; 0xcef4
        printf("%02x:", offset = i << 4);
 5110ddc:	e12fff37 	blx	r7
 5110de0:	e1a0b009 	mov	fp, r9
                    printf(" --");
 5110de4:	e3408512 	movt	r8, #1298	; 0x512
 5110de8:	ea00000d 	b	5110e24 <shell_i2c_Test+0x368>
            else if (idx == CHIP_END) {
 5110dec:	e35b0078 	cmp	fp, #120	; 0x78
 5110df0:	0a000072 	beq	5110fc0 <shell_i2c_Test+0x504>
                if (data[idx] == 0)
 5110df4:	e7d5300b 	ldrb	r3, [r5, fp]
 5110df8:	e3530000 	cmp	r3, #0
 5110dfc:	0a000065 	beq	5110f98 <shell_i2c_Test+0x4dc>
                else if (data[idx] == 1)
 5110e00:	e3530001 	cmp	r3, #1
 5110e04:	0a000066 	beq	5110fa4 <shell_i2c_Test+0x4e8>
                else if (data[idx] == 2)
 5110e08:	e3530002 	cmp	r3, #2
 5110e0c:	0a000068 	beq	5110fb4 <shell_i2c_Test+0x4f8>
            if (j == 0xf)
 5110e10:	e15b0004 	cmp	fp, r4
 5110e14:	0a000009 	beq	5110e40 <shell_i2c_Test+0x384>
        for (j = 0; j <= 0xf; ++j) {
 5110e18:	e28bb001 	add	fp, fp, #1
 5110e1c:	e156000b 	cmp	r6, fp
 5110e20:	0a000009 	beq	5110e4c <shell_i2c_Test+0x390>
            if (idx < CHIP_START) {
 5110e24:	e35b0007 	cmp	fp, #7
 5110e28:	caffffef 	bgt	5110dec <shell_i2c_Test+0x330>
                printf("   ");
 5110e2c:	e30c0eec 	movw	r0, #52972	; 0xceec
 5110e30:	e3400512 	movt	r0, #1298	; 0x512
 5110e34:	e12fff37 	blx	r7
            if (j == 0xf)
 5110e38:	e15b0004 	cmp	fp, r4
 5110e3c:	1afffff5 	bne	5110e18 <shell_i2c_Test+0x35c>
                printf("\r\n");
 5110e40:	e30c0ef0 	movw	r0, #52976	; 0xcef0
 5110e44:	e3400512 	movt	r0, #1298	; 0x512
 5110e48:	e12fff3a 	blx	sl
    for (i = 0; i < 8; ++i) {
 5110e4c:	e2866010 	add	r6, r6, #16
 5110e50:	e3560090 	cmp	r6, #144	; 0x90
 5110e54:	e2899010 	add	r9, r9, #16
 5110e58:	e2844010 	add	r4, r4, #16
 5110e5c:	1affffdb 	bne	5110dd0 <shell_i2c_Test+0x314>
 5110e60:	eaffff1d 	b	5110adc <shell_i2c_Test+0x20>
        else if(0 == strcmp(argv[2], "init"))
 5110e64:	e30c1f04 	movw	r1, #52996	; 0xcf04
 5110e68:	e300331d 	movw	r3, #797	; 0x31d
 5110e6c:	e3401512 	movt	r1, #1298	; 0x512
 5110e70:	e3403511 	movt	r3, #1297	; 0x511
 5110e74:	e12fff33 	blx	r3
 5110e78:	e2504000 	subs	r4, r0, #0
 5110e7c:	1a00001f 	bne	5110f00 <shell_i2c_Test+0x444>
            I2c_DeInit();
 5110e80:	e30936c4 	movw	r3, #38596	; 0x96c4
 5110e84:	e3403511 	movt	r3, #1297	; 0x511
 5110e88:	e12fff33 	blx	r3
            I2c_Init(NULL);
 5110e8c:	e3093614 	movw	r3, #38420	; 0x9614
 5110e90:	e1a00004 	mov	r0, r4
 5110e94:	e3403511 	movt	r3, #1297	; 0x511
 5110e98:	e12fff33 	blx	r3
 5110e9c:	eaffff0e 	b	5110adc <shell_i2c_Test+0x20>
            LOG(DBG_INFO,"I2cApp", "line:%d, invalid param\r\n", __LINE__, argv[1]);
 5110ea0:	e30c1dc4 	movw	r1, #52676	; 0xcdc4
 5110ea4:	e3a0c075 	mov	ip, #117	; 0x75
 5110ea8:	e5940004 	ldr	r0, [r4, #4]
 5110eac:	e3401512 	movt	r1, #1298	; 0x512
                LOG(DBG_INFO,"I2cApp", "line:%d, invalid param %s\r\n", __LINE__, argv[3]);
 5110eb0:	e98d1002 	stmib	sp, {r1, ip}
 5110eb4:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5110eb8:	e30c2da4 	movw	r2, #52644	; 0xcda4
 5110ebc:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 5110ec0:	e30244b0 	movw	r4, #9392	; 0x24b0
 5110ec4:	e3403512 	movt	r3, #1298	; 0x512
 5110ec8:	e58d000c 	str	r0, [sp, #12]
 5110ecc:	e3402512 	movt	r2, #1298	; 0x512
 5110ed0:	e3a00003 	mov	r0, #3
 5110ed4:	e3401512 	movt	r1, #1298	; 0x512
 5110ed8:	e58dc000 	str	ip, [sp]
 5110edc:	e3404511 	movt	r4, #1297	; 0x511
 5110ee0:	e12fff34 	blx	r4
}
 5110ee4:	e28dd04c 	add	sp, sp, #76	; 0x4c
 5110ee8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                LOG(DBG_INFO,"I2cApp", "line:%d, invalid param %s\r\n", __LINE__, argv[3]);
 5110eec:	e30c1de0 	movw	r1, #52704	; 0xcde0
 5110ef0:	e3a0c07d 	mov	ip, #125	; 0x7d
 5110ef4:	e3401512 	movt	r1, #1298	; 0x512
 5110ef8:	e594000c 	ldr	r0, [r4, #12]
 5110efc:	eaffffeb 	b	5110eb0 <shell_i2c_Test+0x3f4>
            LOG(DBG_INFO,"I2cApp", "wrong cmd\r\n");
 5110f00:	e30c0f0c 	movw	r0, #53004	; 0xcf0c
 5110f04:	e3a0c0d7 	mov	ip, #215	; 0xd7
 5110f08:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5110f0c:	e3400512 	movt	r0, #1298	; 0x512
 5110f10:	e30c2da4 	movw	r2, #52644	; 0xcda4
 5110f14:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 5110f18:	e30244b0 	movw	r4, #9392	; 0x24b0
 5110f1c:	e3403512 	movt	r3, #1298	; 0x512
 5110f20:	e58d0004 	str	r0, [sp, #4]
 5110f24:	e3402512 	movt	r2, #1298	; 0x512
 5110f28:	e3a00003 	mov	r0, #3
 5110f2c:	e3401512 	movt	r1, #1298	; 0x512
 5110f30:	e58dc000 	str	ip, [sp]
 5110f34:	e3404511 	movt	r4, #1297	; 0x511
 5110f38:	e12fff34 	blx	r4
 5110f3c:	eafffee6 	b	5110adc <shell_i2c_Test+0x20>
                LOG(DBG_INFO,"I2cApp", "line:%d, device address is 16bit\r\n", __LINE__);
 5110f40:	e30c3dfc 	movw	r3, #52732	; 0xcdfc
 5110f44:	e30c2da4 	movw	r2, #52644	; 0xcda4
 5110f48:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 5110f4c:	e3403512 	movt	r3, #1298	; 0x512
 5110f50:	e30284b0 	movw	r8, #9392	; 0x24b0
 5110f54:	e3402512 	movt	r2, #1298	; 0x512
 5110f58:	e58d3004 	str	r3, [sp, #4]
 5110f5c:	e3a03089 	mov	r3, #137	; 0x89
 5110f60:	e3408511 	movt	r8, #1297	; 0x511
 5110f64:	e58d3008 	str	r3, [sp, #8]
 5110f68:	e3401512 	movt	r1, #1298	; 0x512
 5110f6c:	e58d3000 	str	r3, [sp]
 5110f70:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5110f74:	e3a00003 	mov	r0, #3
 5110f78:	e3403512 	movt	r3, #1298	; 0x512
 5110f7c:	e12fff38 	blx	r8
                val[index] = (uint8)u32value;
 5110f80:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5110f84:	e5cd3038 	strb	r3, [sp, #56]	; 0x38
                index ++;
 5110f88:	e3a08002 	mov	r8, #2
                val[index] = (uint8)(u32value>>8);
 5110f8c:	e1a03423 	lsr	r3, r3, #8
 5110f90:	e5cd3039 	strb	r3, [sp, #57]	; 0x39
                index ++;
 5110f94:	eafffef8 	b	5110b7c <shell_i2c_Test+0xc0>
                    printf(" --");
 5110f98:	e1a00008 	mov	r0, r8
 5110f9c:	e12fff37 	blx	r7
 5110fa0:	eaffff9a 	b	5110e10 <shell_i2c_Test+0x354>
                    printf(" %02x", idx);
 5110fa4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
 5110fa8:	e1a0100b 	mov	r1, fp
 5110fac:	e12fff37 	blx	r7
 5110fb0:	eaffff96 	b	5110e10 <shell_i2c_Test+0x354>
                    printf(" ??");
 5110fb4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
 5110fb8:	e12fff37 	blx	r7
 5110fbc:	eaffff93 	b	5110e10 <shell_i2c_Test+0x354>
                printf("\r\n");
 5110fc0:	e30c0ef0 	movw	r0, #52976	; 0xcef0
 5110fc4:	e3400512 	movt	r0, #1298	; 0x512
 5110fc8:	e12fff3a 	blx	sl
                return;
 5110fcc:	eafffec2 	b	5110adc <shell_i2c_Test+0x20>
            if(argc<=5) {
 5110fd0:	e3550005 	cmp	r5, #5
 5110fd4:	da00003a 	ble	51110c4 <shell_i2c_Test+0x608>
            if(i2c_n_send_data(channel, slave_addr, val, argc-4)) {
 5110fd8:	e2454004 	sub	r4, r5, #4
 5110fdc:	e3085cbc 	movw	r5, #36028	; 0x8cbc
 5110fe0:	e6ef1079 	uxtb	r1, r9
 5110fe4:	e1a00007 	mov	r0, r7
 5110fe8:	e6ef3074 	uxtb	r3, r4
 5110fec:	e3405511 	movt	r5, #1297	; 0x511
 5110ff0:	e28d2038 	add	r2, sp, #56	; 0x38
 5110ff4:	e12fff35 	blx	r5
 5110ff8:	e3500000 	cmp	r0, #0
 5110ffc:	1a000011 	bne	5111048 <shell_i2c_Test+0x58c>
            LOG_ARRAY(DBG_INFO, "I2cApp", "write data(hex):", val, 1, argc-4, 1, "");
 5111000:	e30c3e78 	movw	r3, #52856	; 0xce78
 5111004:	e3a02001 	mov	r2, #1
 5111008:	e3403512 	movt	r3, #1298	; 0x512
 511100c:	e6ff4074 	uxth	r4, r4
 5111010:	e30c1e98 	movw	r1, #52888	; 0xce98
 5111014:	e28d0038 	add	r0, sp, #56	; 0x38
 5111018:	e58d3018 	str	r3, [sp, #24]
 511101c:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5111020:	e58d2014 	str	r2, [sp, #20]
 5111024:	e3401512 	movt	r1, #1298	; 0x512
 5111028:	e58d200c 	str	r2, [sp, #12]
 511102c:	e30c2da4 	movw	r2, #52644	; 0xcda4
 5111030:	e3a0c0bf 	mov	ip, #191	; 0xbf
 5111034:	e3403512 	movt	r3, #1298	; 0x512
 5111038:	e58d4010 	str	r4, [sp, #16]
 511103c:	e3402512 	movt	r2, #1298	; 0x512
 5111040:	e58d0008 	str	r0, [sp, #8]
 5111044:	eafffef0 	b	5110c0c <shell_i2c_Test+0x150>
                LOG(DBG_INFO,"I2cApp", "line:%d, send data err\r\n", __LINE__);
 5111048:	e30c0e7c 	movw	r0, #52860	; 0xce7c
 511104c:	e3a0c0bb 	mov	ip, #187	; 0xbb
 5111050:	e3400512 	movt	r0, #1298	; 0x512
 5111054:	e30c3f18 	movw	r3, #53016	; 0xcf18
 5111058:	e30c2da4 	movw	r2, #52644	; 0xcda4
 511105c:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 5111060:	e30244b0 	movw	r4, #9392	; 0x24b0
 5111064:	e98d1001 	stmib	sp, {r0, ip}
 5111068:	e3403512 	movt	r3, #1298	; 0x512
 511106c:	e3402512 	movt	r2, #1298	; 0x512
 5111070:	e3a00003 	mov	r0, #3
 5111074:	e3401512 	movt	r1, #1298	; 0x512
 5111078:	e58dc000 	str	ip, [sp]
 511107c:	e3404511 	movt	r4, #1297	; 0x511
 5111080:	e12fff34 	blx	r4
                return;
 5111084:	eafffe94 	b	5110adc <shell_i2c_Test+0x20>
                if(_atoi(argv[5], &u32value)) {
 5111088:	e5940014 	ldr	r0, [r4, #20]
 511108c:	e28d1034 	add	r1, sp, #52	; 0x34
 5111090:	e12fff36 	blx	r6
 5111094:	e3500000 	cmp	r0, #0
 5111098:	1a00001a 	bne	5111108 <shell_i2c_Test+0x64c>
                val[index] = (uint8)u32value;
 511109c:	e28d3048 	add	r3, sp, #72	; 0x48
 51110a0:	e5dd2034 	ldrb	r2, [sp, #52]	; 0x34
 51110a4:	e0836008 	add	r6, r3, r8
 51110a8:	e5462010 	strb	r2, [r6, #-16]
 51110ac:	eafffeb7 	b	5110b90 <shell_i2c_Test+0xd4>
                LOG(DBG_INFO,"I2cApp", "line:%d, invalid param %s\r\n", __LINE__, argv[4]);
 51110b0:	e30c1de0 	movw	r1, #52704	; 0xcde0
 51110b4:	e3a0c083 	mov	ip, #131	; 0x83
 51110b8:	e5940010 	ldr	r0, [r4, #16]
 51110bc:	e3401512 	movt	r1, #1298	; 0x512
 51110c0:	eaffff7a 	b	5110eb0 <shell_i2c_Test+0x3f4>
                LOG(DBG_INFO,"I2cApp", "line:%d, invalid param argc %d\r\n", __LINE__, argc);
 51110c4:	e30c1e58 	movw	r1, #52824	; 0xce58
 51110c8:	e3a0c0b6 	mov	ip, #182	; 0xb6
 51110cc:	e30c3f18 	movw	r3, #53016	; 0xcf18
 51110d0:	e3401512 	movt	r1, #1298	; 0x512
 51110d4:	e30c2da4 	movw	r2, #52644	; 0xcda4
 51110d8:	e30244b0 	movw	r4, #9392	; 0x24b0
 51110dc:	e98d1002 	stmib	sp, {r1, ip}
 51110e0:	e30c1dbc 	movw	r1, #52668	; 0xcdbc
 51110e4:	e3403512 	movt	r3, #1298	; 0x512
 51110e8:	e3a00003 	mov	r0, #3
 51110ec:	e3402512 	movt	r2, #1298	; 0x512
 51110f0:	e3401512 	movt	r1, #1298	; 0x512
 51110f4:	e58d500c 	str	r5, [sp, #12]
 51110f8:	e3404511 	movt	r4, #1297	; 0x511
 51110fc:	e58dc000 	str	ip, [sp]
 5111100:	e12fff34 	blx	r4
                return;
 5111104:	eafffe74 	b	5110adc <shell_i2c_Test+0x20>
                    LOG(DBG_INFO,"I2cApp", "line:%d, invalid param %s\r\n", __LINE__, argv[4]);
 5111108:	e30c1de0 	movw	r1, #52704	; 0xcde0
 511110c:	e3a0c097 	mov	ip, #151	; 0x97
 5111110:	e5940010 	ldr	r0, [r4, #16]
 5111114:	e3401512 	movt	r1, #1298	; 0x512
 5111118:	eaffff64 	b	5110eb0 <shell_i2c_Test+0x3f4>
 511111c:	05137007 	.word	0x05137007
 5111120:	05137077 	.word	0x05137077

05111124 <shellDisplayCtrlHandle>:
/************************************************************************************************************************/


void shellDisplayCtrlHandle(int argc, char *argv[])
{
    if (argc > 1)
 5111124:	e3500001 	cmp	r0, #1
{
 5111128:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    if (argc > 1)
 511112c:	da000033 	ble	5111200 <shellDisplayCtrlHandle+0xdc>
    {
        if(!strcmp(argv[1], "on") || !strcmp(argv[1], "On") || !strcmp(argv[1], "ON"))
 5111130:	e5916004 	ldr	r6, [r1, #4]
 5111134:	e5d63000 	ldrb	r3, [r6]
 5111138:	e1a04000 	mov	r4, r0
 511113c:	e353006f 	cmp	r3, #111	; 0x6f
 5111140:	e1a05001 	mov	r5, r1
 5111144:	0a000022 	beq	51111d4 <shellDisplayCtrlHandle+0xb0>
 5111148:	e353004f 	cmp	r3, #79	; 0x4f
 511114c:	0a000034 	beq	5111224 <shellDisplayCtrlHandle+0x100>
        {
            elog_set_filter_lvl(ELOG_LVL_VERBOSE);
        }
        else if(!strcmp(argv[1], "off") || !strcmp(argv[1], "Off") || !strcmp(argv[1], "OFF"))
 5111150:	e30c1f28 	movw	r1, #53032	; 0xcf28
 5111154:	e300731d 	movw	r7, #797	; 0x31d
 5111158:	e1a00006 	mov	r0, r6
 511115c:	e3401512 	movt	r1, #1298	; 0x512
 5111160:	e3407511 	movt	r7, #1297	; 0x511
 5111164:	e12fff37 	blx	r7
 5111168:	e3500000 	cmp	r0, #0
 511116c:	0a00003c 	beq	5111264 <shellDisplayCtrlHandle+0x140>
 5111170:	e30c1f2c 	movw	r1, #53036	; 0xcf2c
 5111174:	e1a00006 	mov	r0, r6
 5111178:	e3401512 	movt	r1, #1298	; 0x512
 511117c:	e12fff37 	blx	r7
 5111180:	e3500000 	cmp	r0, #0
 5111184:	0a000036 	beq	5111264 <shellDisplayCtrlHandle+0x140>
 5111188:	e30c1f30 	movw	r1, #53040	; 0xcf30
 511118c:	e1a00006 	mov	r0, r6
 5111190:	e3401512 	movt	r1, #1298	; 0x512
 5111194:	e12fff37 	blx	r7
 5111198:	e3500000 	cmp	r0, #0
 511119c:	0a000030 	beq	5111264 <shellDisplayCtrlHandle+0x140>
        {
           elog_set_filter_lvl(ELOG_LVL_ASSERT);
        }
        else if(!strcmp(argv[1], "tag") || !strcmp(argv[1], "tag"))
 51111a0:	e30c1f34 	movw	r1, #53044	; 0xcf34
 51111a4:	e1a00006 	mov	r0, r6
 51111a8:	e3401512 	movt	r1, #1298	; 0x512
 51111ac:	e12fff37 	blx	r7
 51111b0:	e3500000 	cmp	r0, #0
 51111b4:	1a00002f 	bne	5111278 <shellDisplayCtrlHandle+0x154>
        {
            if(argc > 2)
 51111b8:	e3540002 	cmp	r4, #2
 51111bc:	0a000046 	beq	51112dc <shellDisplayCtrlHandle+0x1b8>
            {
                elog_set_filter_tag(argv[2]);
 51111c0:	e5950008 	ldr	r0, [r5, #8]
 51111c4:	e3023310 	movw	r3, #8976	; 0x2310
 51111c8:	e3403511 	movt	r3, #1297	; 0x511
 51111cc:	e12fff33 	blx	r3
 51111d0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        if(!strcmp(argv[1], "on") || !strcmp(argv[1], "On") || !strcmp(argv[1], "ON"))
 51111d4:	e5d62001 	ldrb	r2, [r6, #1]
 51111d8:	e352006e 	cmp	r2, #110	; 0x6e
 51111dc:	1affffd9 	bne	5111148 <shellDisplayCtrlHandle+0x24>
 51111e0:	e5d62002 	ldrb	r2, [r6, #2]
 51111e4:	e3520000 	cmp	r2, #0
 51111e8:	1affffd6 	bne	5111148 <shellDisplayCtrlHandle+0x24>
            elog_set_filter_lvl(ELOG_LVL_VERBOSE);
 51111ec:	e303341c 	movw	r3, #13340	; 0x341c
 51111f0:	e3a00005 	mov	r0, #5
 51111f4:	e3403511 	movt	r3, #1297	; 0x511
 51111f8:	e12fff33 	blx	r3
 51111fc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            }
        }
    }
    else
    {
        SHELL_OUT("Please input Log On/Off.");
 5111200:	e30c0f60 	movw	r0, #53088	; 0xcf60
 5111204:	e30243d8 	movw	r4, #9176	; 0x23d8
 5111208:	e3400512 	movt	r0, #1298	; 0x512
 511120c:	e3404511 	movt	r4, #1297	; 0x511
 5111210:	e12fff34 	blx	r4
 5111214:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5111218:	e3400512 	movt	r0, #1298	; 0x512
 511121c:	e12fff34 	blx	r4
    }
}
 5111220:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        if(!strcmp(argv[1], "on") || !strcmp(argv[1], "On") || !strcmp(argv[1], "ON"))
 5111224:	e5d62001 	ldrb	r2, [r6, #1]
 5111228:	e352006e 	cmp	r2, #110	; 0x6e
 511122c:	0a000008 	beq	5111254 <shellDisplayCtrlHandle+0x130>
 5111230:	e353004f 	cmp	r3, #79	; 0x4f
 5111234:	1affffc5 	bne	5111150 <shellDisplayCtrlHandle+0x2c>
 5111238:	e5d63001 	ldrb	r3, [r6, #1]
 511123c:	e353004e 	cmp	r3, #78	; 0x4e
 5111240:	1affffc2 	bne	5111150 <shellDisplayCtrlHandle+0x2c>
 5111244:	e5d63002 	ldrb	r3, [r6, #2]
 5111248:	e3530000 	cmp	r3, #0
 511124c:	0affffe6 	beq	51111ec <shellDisplayCtrlHandle+0xc8>
 5111250:	eaffffbe 	b	5111150 <shellDisplayCtrlHandle+0x2c>
 5111254:	e5d62002 	ldrb	r2, [r6, #2]
 5111258:	e3520000 	cmp	r2, #0
 511125c:	0affffe2 	beq	51111ec <shellDisplayCtrlHandle+0xc8>
 5111260:	eafffff2 	b	5111230 <shellDisplayCtrlHandle+0x10c>
           elog_set_filter_lvl(ELOG_LVL_ASSERT);
 5111264:	e303341c 	movw	r3, #13340	; 0x341c
 5111268:	e3a00000 	mov	r0, #0
 511126c:	e3403511 	movt	r3, #1297	; 0x511
 5111270:	e12fff33 	blx	r3
 5111274:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        else if(!strcmp(argv[1], "level") || !strcmp(argv[1], "Level"))
 5111278:	e30c1f38 	movw	r1, #53048	; 0xcf38
 511127c:	e1a00006 	mov	r0, r6
 5111280:	e3401512 	movt	r1, #1298	; 0x512
 5111284:	e12fff37 	blx	r7
 5111288:	e3500000 	cmp	r0, #0
 511128c:	0a000005 	beq	51112a8 <shellDisplayCtrlHandle+0x184>
 5111290:	e30c1f40 	movw	r1, #53056	; 0xcf40
 5111294:	e1a00006 	mov	r0, r6
 5111298:	e3401512 	movt	r1, #1298	; 0x512
 511129c:	e12fff37 	blx	r7
 51112a0:	e3500000 	cmp	r0, #0
 51112a4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
            if(argc > 2)
 51112a8:	e3540002 	cmp	r4, #2
 51112ac:	0affffce 	beq	51111ec <shellDisplayCtrlHandle+0xc8>
                uint8 i = atoi(argv[2]);
 51112b0:	e5950008 	ldr	r0, [r5, #8]
 51112b4:	e3093c7d 	movw	r3, #40061	; 0x9c7d
 51112b8:	e3403511 	movt	r3, #1297	; 0x511
 51112bc:	e12fff33 	blx	r3
 51112c0:	e6ef0070 	uxtb	r0, r0
                if(i <= ELOG_LVL_VERBOSE)
 51112c4:	e3500005 	cmp	r0, #5
 51112c8:	8a000007 	bhi	51112ec <shellDisplayCtrlHandle+0x1c8>
                    elog_set_filter_lvl(i);
 51112cc:	e303341c 	movw	r3, #13340	; 0x341c
 51112d0:	e3403511 	movt	r3, #1297	; 0x511
 51112d4:	e12fff33 	blx	r3
 51112d8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                elog_clear_filter_tag();
 51112dc:	e30232fc 	movw	r3, #8956	; 0x22fc
 51112e0:	e3403511 	movt	r3, #1297	; 0x511
 51112e4:	e12fff33 	blx	r3
 51112e8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                    SHELL_OUT("Level need smaller 5.");
 51112ec:	e30c0f48 	movw	r0, #53064	; 0xcf48
 51112f0:	e30243d8 	movw	r4, #9176	; 0x23d8
 51112f4:	e3400512 	movt	r0, #1298	; 0x512
 51112f8:	eaffffc3 	b	511120c <shellDisplayCtrlHandle+0xe8>

051112fc <MsgbxSampleServerHandle>:
extern int set_msgbx_client_arg(int argc, char *argv[]);
extern int set_msgbx_server_arg(int argc, char *argv[]);
extern TaskHandle_t IpcSerTaskHandle;
extern TaskHandle_t IpcCliTaskHandle;
void MsgbxSampleServerHandle(int argc, char *argv[])
{
 51112fc:	e1a01000 	mov	r1, r0
    myprintf("server cmd start argc:%d\r\n", argc);
 5111300:	e30832f4 	movw	r3, #33524	; 0x82f4
 5111304:	e30c0f7c 	movw	r0, #53116	; 0xcf7c
 5111308:	e3403511 	movt	r3, #1297	; 0x511
{
 511130c:	e92d4010 	push	{r4, lr}
    myprintf("server cmd start argc:%d\r\n", argc);
 5111310:	e3400512 	movt	r0, #1298	; 0x512
 5111314:	e12fff33 	blx	r3
    // if (set_msgbx_server_arg(argc, argv) == 0)
    //     vTaskResume(IpcSerTaskHandle);
}
 5111318:	e8bd8010 	pop	{r4, pc}

0511131c <MsgbxSampleClientHandle>:
void MsgbxSampleClientHandle(int argc, char *argv[])
{
 511131c:	e1a01000 	mov	r1, r0
    myprintf("client cmd start argc:%d\r\n", argc);
 5111320:	e30832f4 	movw	r3, #33524	; 0x82f4
 5111324:	e30c0f98 	movw	r0, #53144	; 0xcf98
 5111328:	e3403511 	movt	r3, #1297	; 0x511
{
 511132c:	e92d4010 	push	{r4, lr}
    myprintf("client cmd start argc:%d\r\n", argc);
 5111330:	e3400512 	movt	r0, #1298	; 0x512
 5111334:	e12fff33 	blx	r3
    // if (set_msgbx_client_arg(argc, argv) == 0)
    //     vTaskResume(IpcCliTaskHandle);
}
 5111338:	e8bd8010 	pop	{r4, pc}

0511133c <stackoverflow_check>:


static void stackoverflow_check(int argc, char *argv[])
{
    TaskStackOverflowCheck();
 511133c:	e30039cc 	movw	r3, #2508	; 0x9cc
 5111340:	e3403511 	movt	r3, #1297	; 0x511
{
 5111344:	e92d4010 	push	{r4, lr}
    TaskStackOverflowCheck();
 5111348:	e12fff33 	blx	r3
}
 511134c:	e8bd8010 	pop	{r4, pc}

05111350 <wdt_timeout_callback>:

void wdt_timeout_callback(void);

void wdt_timeout_callback(void)
{
    if(wdg_current_mode == WDGIF_FAST_MODE)
 5111350:	e3073100 	movw	r3, #28928	; 0x7100
 5111354:	e3403513 	movt	r3, #1299	; 0x513
{
 5111358:	e92d4010 	push	{r4, lr}
    if(wdg_current_mode == WDGIF_FAST_MODE)
 511135c:	e5933000 	ldr	r3, [r3]
 5111360:	e3530002 	cmp	r3, #2
    {
        Wdg_SetTriggerCondition(WDG_USER11_OR_128M);
 5111364:	e3093c08 	movw	r3, #39944	; 0x9c08
 5111368:	03a0000b 	moveq	r0, #11
    }
    else
    {
        Wdg_SetTriggerCondition(WDG_USER13_OR_512M);
 511136c:	13a0000d 	movne	r0, #13
 5111370:	e3403511 	movt	r3, #1297	; 0x511
 5111374:	e12fff33 	blx	r3
    }
    TEST_LOG("wdg time out and trigger isr");
 5111378:	e30d13e0 	movw	r1, #54240	; 0xd3e0
 511137c:	e30d0074 	movw	r0, #53364	; 0xd074
 5111380:	e30832f4 	movw	r3, #33524	; 0x82f4
 5111384:	e3401512 	movt	r1, #1298	; 0x512
 5111388:	e3403511 	movt	r3, #1297	; 0x511
 511138c:	e3400512 	movt	r0, #1298	; 0x512
 5111390:	e12fff33 	blx	r3
}
 5111394:	e8bd8010 	pop	{r4, pc}

05111398 <shell_wdg_Test>:

void shell_wdg_Test(int argc, char *argv[])
{
    if (argc > 1)
 5111398:	e3500001 	cmp	r0, #1
 511139c:	d12fff1e 	bxle	lr
{
 51113a0:	e92d4070 	push	{r4, r5, r6, lr}
    {
        if(0 == strcmp(argv[1], "start"))
 51113a4:	e5915004 	ldr	r5, [r1, #4]
 51113a8:	e300431d 	movw	r4, #797	; 0x31d
 51113ac:	e30d1094 	movw	r1, #53396	; 0xd094
 51113b0:	e1a00005 	mov	r0, r5
 51113b4:	e3401512 	movt	r1, #1298	; 0x512
 51113b8:	e3404511 	movt	r4, #1297	; 0x511
 51113bc:	e12fff34 	blx	r4
 51113c0:	e3500000 	cmp	r0, #0
 51113c4:	1a00000c 	bne	51113fc <shell_wdg_Test+0x64>
        {
            if(wdg_init_flag == 0)
 51113c8:	e3074104 	movw	r4, #28932	; 0x7104
 51113cc:	e3404513 	movt	r4, #1299	; 0x513
 51113d0:	e5943000 	ldr	r3, [r4]
 51113d4:	e3530000 	cmp	r3, #0
 51113d8:	0a000031 	beq	51114a4 <shell_wdg_Test+0x10c>
            {
                Wdg_Init(&WdgSettingsConfig_0);
                wdg_init_flag = 1;
            }
            TEST_LOG("wdg started");
 51113dc:	e30d13e0 	movw	r1, #54240	; 0xd3e0
 51113e0:	e30d009c 	movw	r0, #53404	; 0xd09c
 51113e4:	e30832f4 	movw	r3, #33524	; 0x82f4
 51113e8:	e3401512 	movt	r1, #1298	; 0x512
 51113ec:	e3403511 	movt	r3, #1297	; 0x511
 51113f0:	e3400512 	movt	r0, #1298	; 0x512
 51113f4:	e12fff33 	blx	r3
 51113f8:	e8bd8070 	pop	{r4, r5, r6, pc}
        }
        else if(0 == strcmp(argv[1], "fast"))
 51113fc:	e30d10ac 	movw	r1, #53420	; 0xd0ac
 5111400:	e1a00005 	mov	r0, r5
 5111404:	e3401512 	movt	r1, #1298	; 0x512
 5111408:	e12fff34 	blx	r4
 511140c:	e3500000 	cmp	r0, #0
 5111410:	0a000014 	beq	5111468 <shell_wdg_Test+0xd0>
        {
            wdg_current_mode = WDGIF_FAST_MODE;
            Wdg_SetMode(WDGIF_FAST_MODE);
            TEST_LOG("wdg fast");
        }
        else if(0 == strcmp(argv[1], "slow"))
 5111414:	e30d10b8 	movw	r1, #53432	; 0xd0b8
 5111418:	e1a00005 	mov	r0, r5
 511141c:	e3401512 	movt	r1, #1298	; 0x512
 5111420:	e12fff34 	blx	r4
 5111424:	e3500000 	cmp	r0, #0
 5111428:	1a000025 	bne	51114c4 <shell_wdg_Test+0x12c>
        {
            wdg_current_mode = WDGIF_SLOW_MODE;
 511142c:	e3072100 	movw	r2, #28928	; 0x7100
 5111430:	e3a00001 	mov	r0, #1
            Wdg_SetMode(WDGIF_SLOW_MODE);
 5111434:	e3093b08 	movw	r3, #39688	; 0x9b08
            wdg_current_mode = WDGIF_SLOW_MODE;
 5111438:	e3402513 	movt	r2, #1299	; 0x513
            Wdg_SetMode(WDGIF_SLOW_MODE);
 511143c:	e3403511 	movt	r3, #1297	; 0x511
            wdg_current_mode = WDGIF_SLOW_MODE;
 5111440:	e5820000 	str	r0, [r2]
            Wdg_SetMode(WDGIF_SLOW_MODE);
 5111444:	e12fff33 	blx	r3
            TEST_LOG("wdg slow");
 5111448:	e30d13e0 	movw	r1, #54240	; 0xd3e0
 511144c:	e30d00b4 	movw	r0, #53428	; 0xd0b4
 5111450:	e30832f4 	movw	r3, #33524	; 0x82f4
 5111454:	e3401512 	movt	r1, #1298	; 0x512
 5111458:	e3403511 	movt	r3, #1297	; 0x511
 511145c:	e3400512 	movt	r0, #1298	; 0x512
 5111460:	e12fff33 	blx	r3
 5111464:	e8bd8070 	pop	{r4, r5, r6, pc}
            wdg_current_mode = WDGIF_FAST_MODE;
 5111468:	e3072100 	movw	r2, #28928	; 0x7100
 511146c:	e3a00002 	mov	r0, #2
            Wdg_SetMode(WDGIF_FAST_MODE);
 5111470:	e3093b08 	movw	r3, #39688	; 0x9b08
            wdg_current_mode = WDGIF_FAST_MODE;
 5111474:	e3402513 	movt	r2, #1299	; 0x513
            Wdg_SetMode(WDGIF_FAST_MODE);
 5111478:	e3403511 	movt	r3, #1297	; 0x511
            wdg_current_mode = WDGIF_FAST_MODE;
 511147c:	e5820000 	str	r0, [r2]
            Wdg_SetMode(WDGIF_FAST_MODE);
 5111480:	e12fff33 	blx	r3
            TEST_LOG("wdg fast");
 5111484:	e30d13e0 	movw	r1, #54240	; 0xd3e0
 5111488:	e30d00a8 	movw	r0, #53416	; 0xd0a8
 511148c:	e30832f4 	movw	r3, #33524	; 0x82f4
 5111490:	e3401512 	movt	r1, #1298	; 0x512
 5111494:	e3403511 	movt	r3, #1297	; 0x511
 5111498:	e3400512 	movt	r0, #1298	; 0x512
 511149c:	e12fff33 	blx	r3
 51114a0:	e8bd8070 	pop	{r4, r5, r6, pc}
                Wdg_Init(&WdgSettingsConfig_0);
 51114a4:	e30d029c 	movw	r0, #53916	; 0xd29c
 51114a8:	e3093a58 	movw	r3, #39512	; 0x9a58
 51114ac:	e3403511 	movt	r3, #1297	; 0x511
 51114b0:	e3400512 	movt	r0, #1298	; 0x512
 51114b4:	e12fff33 	blx	r3
                wdg_init_flag = 1;
 51114b8:	e3a03001 	mov	r3, #1
 51114bc:	e5843000 	str	r3, [r4]
 51114c0:	eaffffc5 	b	51113dc <shell_wdg_Test+0x44>
        }
        else
        {
            TEST_LOG("param support start/fast/slow");
 51114c4:	e30d13e0 	movw	r1, #54240	; 0xd3e0
 51114c8:	e30d00c0 	movw	r0, #53440	; 0xd0c0
 51114cc:	e30832f4 	movw	r3, #33524	; 0x82f4
 51114d0:	e3401512 	movt	r1, #1298	; 0x512
 51114d4:	e3403511 	movt	r3, #1297	; 0x511
 51114d8:	e3400512 	movt	r0, #1298	; 0x512
 51114dc:	e12fff33 	blx	r3
        }
    }
}
 51114e0:	e8bd8070 	pop	{r4, r5, r6, pc}

051114e4 <BST_Uart_IsrHandle>:
}

void BST_Uart_IsrHandle(void *param)
{
    uint32_t* p =0xb700006c;
    *p = 0x12345;
 51114e4:	e3022345 	movw	r2, #9029	; 0x2345
    uint32 isr_id = (uint32) param;
    Uart_IsrTransmit(LSP0_UART0);
 51114e8:	e30837b4 	movw	r3, #34740	; 0x87b4
{
 51114ec:	e92d4010 	push	{r4, lr}
    *p = 0x12345;
 51114f0:	e3a044b7 	mov	r4, #-1224736768	; 0xb7000000
 51114f4:	e3402001 	movt	r2, #1
    Uart_IsrTransmit(LSP0_UART0);
 51114f8:	e3a00000 	mov	r0, #0
 51114fc:	e3403511 	movt	r3, #1297	; 0x511
    *p = 0x12345;
 5111500:	e584206c 	str	r2, [r4, #108]	; 0x6c
    Uart_IsrTransmit(LSP0_UART0);
 5111504:	e12fff33 	blx	r3
    *p = 0x12346;
 5111508:	e3023346 	movw	r3, #9030	; 0x2346
 511150c:	e3403001 	movt	r3, #1
 5111510:	e584306c 	str	r3, [r4, #108]	; 0x6c
}
 5111514:	e8bd8010 	pop	{r4, pc}

05111518 <Isr_Init>:
{
 5111518:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 511151c:	e30e4324 	movw	r4, #58148	; 0xe324
                cpu_gic_config(&isr_cfg_data[i]);
 5111520:	e3077c0c 	movw	r7, #31756	; 0x7c0c
                cpu_gicd_set_enable(isr_cfg_data[i].isrId);
 5111524:	e3076b68 	movw	r6, #31592	; 0x7b68
 5111528:	e3404512 	movt	r4, #1298	; 0x512
 511152c:	e59f5030 	ldr	r5, [pc, #48]	; 5111564 <Isr_Init+0x4c>
                cpu_gic_config(&isr_cfg_data[i]);
 5111530:	e3407511 	movt	r7, #1297	; 0x511
                cpu_gicd_set_enable(isr_cfg_data[i].isrId);
 5111534:	e3406511 	movt	r6, #1297	; 0x511
            if(isr_cfg_data[i].isrFn != NULL)
 5111538:	e5943000 	ldr	r3, [r4]
                cpu_gic_config(&isr_cfg_data[i]);
 511153c:	e1a00004 	mov	r0, r4
            if(isr_cfg_data[i].isrFn != NULL)
 5111540:	e3530000 	cmp	r3, #0
 5111544:	0a000002 	beq	5111554 <Isr_Init+0x3c>
                cpu_gic_config(&isr_cfg_data[i]);
 5111548:	e12fff37 	blx	r7
                cpu_gicd_set_enable(isr_cfg_data[i].isrId);
 511154c:	e5940004 	ldr	r0, [r4, #4]
 5111550:	e12fff36 	blx	r6
        for(i = 0; i < NUMBER_OF_ISR_NUM; i++)
 5111554:	e284401c 	add	r4, r4, #28
 5111558:	e1540005 	cmp	r4, r5
 511155c:	1afffff5 	bne	5111538 <Isr_Init+0x20>
 5111560:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5111564:	0512fa38 	.word	0x0512fa38

05111568 <vApplicationIRQHandler>:
    *pp = a+1;
 5111568:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
 511156c:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 5111570:	e2822001 	add	r2, r2, #1
 5111574:	e5832038 	str	r2, [r3, #56]	; 0x38
    __asm ("cpsie i");
 5111578:	f1080080 	cpsie	i
    __asm__ volatile (
 511157c:	e1a00006 	mov	r0, r6
	ulInterruptID = r6_value & 0x3FFUL;
 5111580:	e7e90050 	ubfx	r0, r0, #0, #10
	if( ulInterruptID < NUMBER_OF_ISR_NUM)
 5111584:	e35000d2 	cmp	r0, #210	; 0xd2
    *p = ulInterruptID;
 5111588:	e583003c 	str	r0, [r3, #60]	; 0x3c
	if( ulInterruptID < NUMBER_OF_ISR_NUM)
 511158c:	812fff1e 	bxhi	lr
        if((isr_cfg_data[ulInterruptID].isrFn != NULL) && (isr_cfg_data[ulInterruptID].isrGroup == ISR_GROUP_IRQ))
 5111590:	e30e3324 	movw	r3, #58148	; 0xe324
 5111594:	e0602180 	rsb	r2, r0, r0, lsl #3
 5111598:	e3403512 	movt	r3, #1298	; 0x512
 511159c:	e0831102 	add	r1, r3, r2, lsl #2
 51115a0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 51115a4:	e3530000 	cmp	r3, #0
 51115a8:	012fff1e 	bxeq	lr
 51115ac:	e591200c 	ldr	r2, [r1, #12]
 51115b0:	e3520001 	cmp	r2, #1
 51115b4:	112fff1e 	bxne	lr
{
 51115b8:	e92d4010 	push	{r4, lr}
            isr_cfg_data[ulInterruptID].isrFn((void *)ulInterruptID);
 51115bc:	e12fff33 	blx	r3
}
 51115c0:	e8bd8010 	pop	{r4, pc}

051115c4 <FIQInterrupt>:
    uint32 ulInterruptID = cpu_gicc_get_iar();
 51115c4:	e3073b88 	movw	r3, #31624	; 0x7b88
{
 51115c8:	e92d4010 	push	{r4, lr}
    uint32 ulInterruptID = cpu_gicc_get_iar();
 51115cc:	e3403511 	movt	r3, #1297	; 0x511
 51115d0:	e12fff33 	blx	r3
    ulInterruptID = ulInterruptID & 0x3FF;
 51115d4:	e7e94050 	ubfx	r4, r0, #0, #10
    if(ulInterruptID < NUMBER_OF_ISR_NUM)
 51115d8:	e35400d2 	cmp	r4, #210	; 0xd2
 51115dc:	88bd8010 	pophi	{r4, pc}
        if((isr_cfg_data[ulInterruptID].isrFn != NULL) && (isr_cfg_data[ulInterruptID].isrGroup == ISR_GROUP_FIQ))
 51115e0:	e30e3324 	movw	r3, #58148	; 0xe324
 51115e4:	e0642184 	rsb	r2, r4, r4, lsl #3
 51115e8:	e3403512 	movt	r3, #1298	; 0x512
 51115ec:	e0831102 	add	r1, r3, r2, lsl #2
 51115f0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 51115f4:	e3530000 	cmp	r3, #0
 51115f8:	0a000004 	beq	5111610 <FIQInterrupt+0x4c>
 51115fc:	e591200c 	ldr	r2, [r1, #12]
 5111600:	e3520000 	cmp	r2, #0
 5111604:	1a000001 	bne	5111610 <FIQInterrupt+0x4c>
            isr_cfg_data[ulInterruptID].isrFn((void *)ulInterruptID);
 5111608:	e1a00004 	mov	r0, r4
 511160c:	e12fff33 	blx	r3
        cpu_gicc_set_eoir(ulInterruptID);
 5111610:	e3073b98 	movw	r3, #31640	; 0x7b98
 5111614:	e1a00004 	mov	r0, r4
 5111618:	e3403511 	movt	r3, #1297	; 0x511
 511161c:	e12fff33 	blx	r3
}
 5111620:	e8bd8010 	pop	{r4, pc}

05111624 <elog_port_init>:
    ElogSem.count = 1;
#endif

    /* add your code here */
    return result;
}
 5111624:	e3a00000 	mov	r0, #0
 5111628:	e12fff1e 	bx	lr

0511162c <elog_port_output>:
 */
void elog_port_output(const char *log, size_t size)
{

#if 1
    Debug_Buffer_Input(log, size);
 511162c:	e3023108 	movw	r3, #8456	; 0x2108
 5111630:	e3403511 	movt	r3, #1297	; 0x511
{
 5111634:	e92d4010 	push	{r4, lr}
    Debug_Buffer_Input(log, size);
 5111638:	e12fff33 	blx	r3
    for (i = 0; i < size; i++)
    {
        putc(log[i]);
    }
#endif
}
 511163c:	e8bd8010 	pop	{r4, pc}

05111640 <elog_port_output_lock>:
{
    //Os_MtxLock(SID_DbgMutex, 10);
#if (ERIKA_OS_ENABLE == STD_ON)
    WaitSem(&ElogSem);
#endif
}
 5111640:	e12fff1e 	bx	lr

05111644 <elog_port_output_unlock>:
 5111644:	e12fff1e 	bx	lr

05111648 <elog_port_get_time>:
 */
const char *elog_port_get_time(void)
{
    /* add your code here */
    static char cur_system_time[16] = {0};
    uint32_t SysTime = systemTick;
 5111648:	e307338c 	movw	r3, #29580	; 0x738c
 511164c:	e3403513 	movt	r3, #1299	; 0x513
{
 5111650:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    uint32_t SysTime = systemTick;
 5111654:	e5932000 	ldr	r2, [r3]
    //SysTime = systemTick;
#else
    GetCounterValue(SystemTimer, &SysTime);
#endif

    DecimalPart = SysTime%1000;
 5111658:	e3044dd3 	movw	r4, #19923	; 0x4dd3
 511165c:	e3414062 	movt	r4, #4194	; 0x1062
    IntegerPart = SysTime/1000;
    BkIntegerPart = IntegerPart;
    for(Offset=0; BkIntegerPart>0; Offset++)
 5111660:	e3520ffa 	cmp	r2, #1000	; 0x3e8
    DecimalPart = SysTime%1000;
 5111664:	e0843294 	umull	r3, r4, r4, r2
 5111668:	e1a04324 	lsr	r4, r4, #6
 511166c:	e1a03004 	mov	r3, r4
 5111670:	e0644284 	rsb	r4, r4, r4, lsl #5
 5111674:	e0834104 	add	r4, r3, r4, lsl #2
 5111678:	e0424184 	sub	r4, r2, r4, lsl #3
    for(Offset=0; BkIntegerPart>0; Offset++)
 511167c:	3a000017 	bcc	51116e0 <elog_port_get_time+0x98>
    {
        BkIntegerPart /= 10;
 5111680:	e30ccccd 	movw	ip, #52429	; 0xcccd
    BkIntegerPart = IntegerPart;
 5111684:	e1a02003 	mov	r2, r3
    for(Offset=0; BkIntegerPart>0; Offset++)
 5111688:	e3a01000 	mov	r1, #0
        BkIntegerPart /= 10;
 511168c:	e34ccccc 	movt	ip, #52428	; 0xcccc
 5111690:	e080e29c 	umull	lr, r0, ip, r2
    for(Offset=0; BkIntegerPart>0; Offset++)
 5111694:	e2811001 	add	r1, r1, #1
 5111698:	e3520009 	cmp	r2, #9
 511169c:	e6ef1071 	uxtb	r1, r1
        BkIntegerPart /= 10;
 51116a0:	e1a021a0 	lsr	r2, r0, #3
    for(Offset=0; BkIntegerPart>0; Offset++)
 51116a4:	8afffff9 	bhi	5111690 <elog_port_get_time+0x48>
    }
        
    switch(Offset)
 51116a8:	e351000a 	cmp	r1, #10
 51116ac:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
 51116b0:	ea0000a2 	b	5111940 <elog_port_get_time+0x2f8>
 51116b4:	051116e0 	.word	0x051116e0
 51116b8:	051116e0 	.word	0x051116e0
 51116bc:	05111748 	.word	0x05111748
 51116c0:	05111780 	.word	0x05111780
 51116c4:	051117b8 	.word	0x051117b8
 51116c8:	051117f0 	.word	0x051117f0
 51116cc:	05111828 	.word	0x05111828
 51116d0:	05111860 	.word	0x05111860
 51116d4:	05111898 	.word	0x05111898
 51116d8:	051118d0 	.word	0x051118d0
 51116dc:	05111908 	.word	0x05111908
    {
        case 0:
        case 1:
            Offset = 1;
            snprintf(cur_system_time, 16, "%01d", (int)IntegerPart);
 51116e0:	e30d2130 	movw	r2, #53552	; 0xd130
 51116e4:	e3070108 	movw	r0, #28936	; 0x7108
 51116e8:	e30a568d 	movw	r5, #42637	; 0xa68d
 51116ec:	e3a01010 	mov	r1, #16
 51116f0:	e3402512 	movt	r2, #1298	; 0x512
 51116f4:	e3400513 	movt	r0, #1299	; 0x513
        break;
 51116f8:	e3a0600e 	mov	r6, #14
            snprintf(cur_system_time, 16, "%01d", (int)IntegerPart);
 51116fc:	e3405511 	movt	r5, #1297	; 0x511
 5111700:	e12fff35 	blx	r5
        break;
 5111704:	e59f0258 	ldr	r0, [pc, #600]	; 5111964 <elog_port_get_time+0x31c>
 5111708:	e3a08002 	mov	r8, #2
 511170c:	e3a0100f 	mov	r1, #15
 5111710:	e2407001 	sub	r7, r0, #1
        break;
        default:
             Offset = 0;   
            break;
    }
    snprintf(cur_system_time + Offset, 16 - Offset, "%c", '.');
 5111714:	e30d2180 	movw	r2, #53632	; 0xd180
 5111718:	e3a0302e 	mov	r3, #46	; 0x2e
 511171c:	e3402512 	movt	r2, #1298	; 0x512
 5111720:	e12fff35 	blx	r5
    Offset++;
    snprintf(cur_system_time + Offset, 16 - Offset, "%03d", (int)DecimalPart);    
 5111724:	e30d2140 	movw	r2, #53568	; 0xd140
 5111728:	e1a03004 	mov	r3, r4
 511172c:	e0870008 	add	r0, r7, r8
 5111730:	e1a01006 	mov	r1, r6
 5111734:	e3402512 	movt	r2, #1298	; 0x512
 5111738:	e12fff35 	blx	r5
    
    return cur_system_time;
}
 511173c:	e3070108 	movw	r0, #28936	; 0x7108
 5111740:	e3400513 	movt	r0, #1299	; 0x513
 5111744:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            snprintf(cur_system_time, 16, "%02d", (int)IntegerPart);
 5111748:	e30d2138 	movw	r2, #53560	; 0xd138
 511174c:	e3070108 	movw	r0, #28936	; 0x7108
 5111750:	e30a568d 	movw	r5, #42637	; 0xa68d
 5111754:	e3a01010 	mov	r1, #16
 5111758:	e3402512 	movt	r2, #1298	; 0x512
 511175c:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111760:	e3a0600d 	mov	r6, #13
            snprintf(cur_system_time, 16, "%02d", (int)IntegerPart);
 5111764:	e3405511 	movt	r5, #1297	; 0x511
 5111768:	e12fff35 	blx	r5
        break;
 511176c:	e59f01f4 	ldr	r0, [pc, #500]	; 5111968 <elog_port_get_time+0x320>
 5111770:	e3a08003 	mov	r8, #3
 5111774:	e3a0100e 	mov	r1, #14
 5111778:	e2407002 	sub	r7, r0, #2
 511177c:	eaffffe4 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%03d", (int)IntegerPart);
 5111780:	e30d2140 	movw	r2, #53568	; 0xd140
 5111784:	e3070108 	movw	r0, #28936	; 0x7108
 5111788:	e30a568d 	movw	r5, #42637	; 0xa68d
 511178c:	e3a01010 	mov	r1, #16
 5111790:	e3402512 	movt	r2, #1298	; 0x512
 5111794:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111798:	e3a0600c 	mov	r6, #12
            snprintf(cur_system_time, 16, "%03d", (int)IntegerPart);
 511179c:	e3405511 	movt	r5, #1297	; 0x511
 51117a0:	e12fff35 	blx	r5
        break;
 51117a4:	e59f01c0 	ldr	r0, [pc, #448]	; 511196c <elog_port_get_time+0x324>
 51117a8:	e3a08004 	mov	r8, #4
 51117ac:	e3a0100d 	mov	r1, #13
 51117b0:	e2407003 	sub	r7, r0, #3
 51117b4:	eaffffd6 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%04d", (int)IntegerPart);
 51117b8:	e30d2148 	movw	r2, #53576	; 0xd148
 51117bc:	e3070108 	movw	r0, #28936	; 0x7108
 51117c0:	e30a568d 	movw	r5, #42637	; 0xa68d
 51117c4:	e3a01010 	mov	r1, #16
 51117c8:	e3402512 	movt	r2, #1298	; 0x512
 51117cc:	e3400513 	movt	r0, #1299	; 0x513
        break;
 51117d0:	e3a0600b 	mov	r6, #11
            snprintf(cur_system_time, 16, "%04d", (int)IntegerPart);
 51117d4:	e3405511 	movt	r5, #1297	; 0x511
 51117d8:	e12fff35 	blx	r5
        break;
 51117dc:	e59f018c 	ldr	r0, [pc, #396]	; 5111970 <elog_port_get_time+0x328>
 51117e0:	e3a08005 	mov	r8, #5
 51117e4:	e3a0100c 	mov	r1, #12
 51117e8:	e2407004 	sub	r7, r0, #4
 51117ec:	eaffffc8 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%05d", (int)IntegerPart);
 51117f0:	e30d2150 	movw	r2, #53584	; 0xd150
 51117f4:	e3070108 	movw	r0, #28936	; 0x7108
 51117f8:	e30a568d 	movw	r5, #42637	; 0xa68d
 51117fc:	e3a01010 	mov	r1, #16
 5111800:	e3402512 	movt	r2, #1298	; 0x512
 5111804:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111808:	e3a0600a 	mov	r6, #10
            snprintf(cur_system_time, 16, "%05d", (int)IntegerPart);
 511180c:	e3405511 	movt	r5, #1297	; 0x511
 5111810:	e12fff35 	blx	r5
        break;
 5111814:	e59f0158 	ldr	r0, [pc, #344]	; 5111974 <elog_port_get_time+0x32c>
 5111818:	e3a08006 	mov	r8, #6
 511181c:	e3a0100b 	mov	r1, #11
 5111820:	e2407005 	sub	r7, r0, #5
 5111824:	eaffffba 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%06d", (int)IntegerPart);
 5111828:	e30d2158 	movw	r2, #53592	; 0xd158
 511182c:	e3070108 	movw	r0, #28936	; 0x7108
 5111830:	e30a568d 	movw	r5, #42637	; 0xa68d
 5111834:	e3a01010 	mov	r1, #16
 5111838:	e3402512 	movt	r2, #1298	; 0x512
 511183c:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111840:	e3a06009 	mov	r6, #9
            snprintf(cur_system_time, 16, "%06d", (int)IntegerPart);
 5111844:	e3405511 	movt	r5, #1297	; 0x511
 5111848:	e12fff35 	blx	r5
        break;
 511184c:	e59f0124 	ldr	r0, [pc, #292]	; 5111978 <elog_port_get_time+0x330>
 5111850:	e3a08007 	mov	r8, #7
 5111854:	e3a0100a 	mov	r1, #10
 5111858:	e2407006 	sub	r7, r0, #6
 511185c:	eaffffac 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%07d", (int)IntegerPart);
 5111860:	e30d2160 	movw	r2, #53600	; 0xd160
 5111864:	e3070108 	movw	r0, #28936	; 0x7108
 5111868:	e30a568d 	movw	r5, #42637	; 0xa68d
 511186c:	e3a01010 	mov	r1, #16
 5111870:	e3402512 	movt	r2, #1298	; 0x512
 5111874:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111878:	e3a06008 	mov	r6, #8
            snprintf(cur_system_time, 16, "%07d", (int)IntegerPart);
 511187c:	e3405511 	movt	r5, #1297	; 0x511
 5111880:	e12fff35 	blx	r5
        break;
 5111884:	e59f00f0 	ldr	r0, [pc, #240]	; 511197c <elog_port_get_time+0x334>
 5111888:	e1a08006 	mov	r8, r6
 511188c:	e3a01009 	mov	r1, #9
 5111890:	e2407007 	sub	r7, r0, #7
 5111894:	eaffff9e 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%08d", (int)IntegerPart);
 5111898:	e30d2168 	movw	r2, #53608	; 0xd168
 511189c:	e3070108 	movw	r0, #28936	; 0x7108
 51118a0:	e30a568d 	movw	r5, #42637	; 0xa68d
 51118a4:	e3a01010 	mov	r1, #16
 51118a8:	e3402512 	movt	r2, #1298	; 0x512
 51118ac:	e3400513 	movt	r0, #1299	; 0x513
        break;
 51118b0:	e3a06007 	mov	r6, #7
            snprintf(cur_system_time, 16, "%08d", (int)IntegerPart);
 51118b4:	e3405511 	movt	r5, #1297	; 0x511
 51118b8:	e12fff35 	blx	r5
        break;
 51118bc:	e59f00bc 	ldr	r0, [pc, #188]	; 5111980 <elog_port_get_time+0x338>
 51118c0:	e3a08009 	mov	r8, #9
 51118c4:	e3a01008 	mov	r1, #8
 51118c8:	e2407008 	sub	r7, r0, #8
 51118cc:	eaffff90 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%09d", (int)IntegerPart);
 51118d0:	e30d2170 	movw	r2, #53616	; 0xd170
 51118d4:	e3070108 	movw	r0, #28936	; 0x7108
 51118d8:	e30a568d 	movw	r5, #42637	; 0xa68d
 51118dc:	e3a01010 	mov	r1, #16
 51118e0:	e3402512 	movt	r2, #1298	; 0x512
 51118e4:	e3400513 	movt	r0, #1299	; 0x513
        break;
 51118e8:	e3a06006 	mov	r6, #6
            snprintf(cur_system_time, 16, "%09d", (int)IntegerPart);
 51118ec:	e3405511 	movt	r5, #1297	; 0x511
 51118f0:	e12fff35 	blx	r5
        break;
 51118f4:	e59f0088 	ldr	r0, [pc, #136]	; 5111984 <elog_port_get_time+0x33c>
 51118f8:	e3a0800a 	mov	r8, #10
 51118fc:	e3a01007 	mov	r1, #7
 5111900:	e2407009 	sub	r7, r0, #9
 5111904:	eaffff82 	b	5111714 <elog_port_get_time+0xcc>
            snprintf(cur_system_time, 16, "%010d", (int)IntegerPart);
 5111908:	e30d2178 	movw	r2, #53624	; 0xd178
 511190c:	e3070108 	movw	r0, #28936	; 0x7108
 5111910:	e30a568d 	movw	r5, #42637	; 0xa68d
 5111914:	e3a01010 	mov	r1, #16
 5111918:	e3402512 	movt	r2, #1298	; 0x512
 511191c:	e3400513 	movt	r0, #1299	; 0x513
        break;
 5111920:	e3a06005 	mov	r6, #5
            snprintf(cur_system_time, 16, "%010d", (int)IntegerPart);
 5111924:	e3405511 	movt	r5, #1297	; 0x511
 5111928:	e12fff35 	blx	r5
        break;
 511192c:	e59f0054 	ldr	r0, [pc, #84]	; 5111988 <elog_port_get_time+0x340>
 5111930:	e3a0800b 	mov	r8, #11
 5111934:	e3a01006 	mov	r1, #6
 5111938:	e240700a 	sub	r7, r0, #10
 511193c:	eaffff74 	b	5111714 <elog_port_get_time+0xcc>
    for(Offset=0; BkIntegerPart>0; Offset++)
 5111940:	e3077108 	movw	r7, #28936	; 0x7108
 5111944:	e30a568d 	movw	r5, #42637	; 0xa68d
 5111948:	e3a0600f 	mov	r6, #15
 511194c:	e3407513 	movt	r7, #1299	; 0x513
 5111950:	e3a08001 	mov	r8, #1
 5111954:	e3405511 	movt	r5, #1297	; 0x511
 5111958:	e3a01010 	mov	r1, #16
 511195c:	e1a00007 	mov	r0, r7
 5111960:	eaffff6b 	b	5111714 <elog_port_get_time+0xcc>
 5111964:	05137109 	.word	0x05137109
 5111968:	0513710a 	.word	0x0513710a
 511196c:	0513710b 	.word	0x0513710b
 5111970:	0513710c 	.word	0x0513710c
 5111974:	0513710d 	.word	0x0513710d
 5111978:	0513710e 	.word	0x0513710e
 511197c:	0513710f 	.word	0x0513710f
 5111980:	05137110 	.word	0x05137110
 5111984:	05137111 	.word	0x05137111
 5111988:	05137112 	.word	0x05137112

0511198c <elog_port_get_p_info>:
const char *elog_port_get_p_info(void)
{
    
    /* add your code here */
    return "";
}
 511198c:	e30c0e78 	movw	r0, #52856	; 0xce78
 5111990:	e3400512 	movt	r0, #1298	; 0x512
 5111994:	e12fff1e 	bx	lr

05111998 <elog_port_get_t_info>:
 */
const char *elog_port_get_t_info(void)
{
    /* add your code here */
    return "HLL";//Os_GetCurTaskName();
}
 5111998:	e30d0184 	movw	r0, #53636	; 0xd184
 511199c:	e3400512 	movt	r0, #1298	; 0x512
 51119a0:	e12fff1e 	bx	lr

051119a4 <_write>:
 * @param len 
 * @return int 
 */
int _write(int fd, char *ptr, int len)
{  
    Debug_Buffer_Input((const char *)ptr, len);
 51119a4:	e3023108 	movw	r3, #8456	; 0x2108
{  
 51119a8:	e1a00001 	mov	r0, r1
 51119ac:	e92d4010 	push	{r4, lr}
    Debug_Buffer_Input((const char *)ptr, len);
 51119b0:	e1a01002 	mov	r1, r2
{  
 51119b4:	e1a04002 	mov	r4, r2
    Debug_Buffer_Input((const char *)ptr, len);
 51119b8:	e3403511 	movt	r3, #1297	; 0x511
 51119bc:	e12fff33 	blx	r3
    return len;
}
 51119c0:	e1a00004 	mov	r0, r4
 51119c4:	e8bd8010 	pop	{r4, pc}

051119c8 <userShellLock>:
{
#if (ERIKA_OS_ENABLE == STD_ON)
    WaitSem(&shellMutex);
#endif
    return 0;
}
 51119c8:	e3a00000 	mov	r0, #0
 51119cc:	e12fff1e 	bx	lr

051119d0 <_atoh>:
 
	register size_t uTempSize = uHexLen;
	const char * lpszTempPtr = lpszHexStr;
 
	//判断合法性,必须以0x为前缀
	if ((uTempSize > 0x02 && uTempSize < 0x0B) && 
 51119d0:	e2411003 	sub	r1, r1, #3
 51119d4:	e3510007 	cmp	r1, #7
 51119d8:	8a000021 	bhi	5111a64 <_atoh+0x94>
 51119dc:	e1d030d0 	ldrsb	r3, [r0]
 51119e0:	e3530030 	cmp	r3, #48	; 0x30
 51119e4:	1a00001e 	bne	5111a64 <_atoh+0x94>
		(0x30 == *lpszTempPtr++ && 0x78 == *lpszTempPtr++))
 51119e8:	e1d030d1 	ldrsb	r3, [r0, #1]
 51119ec:	e3530078 	cmp	r3, #120	; 0x78
 51119f0:	1a00001b 	bne	5111a64 <_atoh+0x94>
{
 51119f4:	e92d4030 	push	{r4, r5, lr}
 51119f8:	e1a01101 	lsl	r1, r1, #2
	register unsigned int uHalue = 0U;
 51119fc:	e3a04000 	mov	r4, #0
 5111a00:	e280e001 	add	lr, r0, #1
		uTempSize -= 0x02;
    
		while (uTempSize--)
		{
			//如果是数字0-9
			if (*lpszTempPtr > 0x2F && *lpszTempPtr < 0x3A)
 5111a04:	e1fe30d1 	ldrsb	r3, [lr, #1]!
 5111a08:	e6efc073 	uxtb	ip, r3
 5111a0c:	e24c0030 	sub	r0, ip, #48	; 0x30
 5111a10:	e3500009 	cmp	r0, #9
			{
				uAalue = *lpszTempPtr - 0x30;
 5111a14:	e2430030 	sub	r0, r3, #48	; 0x30
				//如果小写字母a-f
			}
			else if (*lpszTempPtr > 0x60 && *lpszTempPtr < 0x67)
 5111a18:	e24c5061 	sub	r5, ip, #97	; 0x61
				uAalue = *lpszTempPtr - 0x30;
 5111a1c:	96af0070 	sxtbls	r0, r0
			if (*lpszTempPtr > 0x2F && *lpszTempPtr < 0x3A)
 5111a20:	9a000008 	bls	5111a48 <_atoh+0x78>
				uAalue = *lpszTempPtr - 0x57;
				//如果是大写字母A-F
			}
			else if (*lpszTempPtr > 0x40 && *lpszTempPtr < 0x47)
			{
				uAalue = *lpszTempPtr - 0x37;
 5111a24:	e2430037 	sub	r0, r3, #55	; 0x37
			else if (*lpszTempPtr > 0x60 && *lpszTempPtr < 0x67)
 5111a28:	e3550005 	cmp	r5, #5
				uAalue = *lpszTempPtr - 0x57;
 5111a2c:	e2433057 	sub	r3, r3, #87	; 0x57
				uAalue = *lpszTempPtr - 0x37;
 5111a30:	e6af0070 	sxtb	r0, r0
			else if (*lpszTempPtr > 0x40 && *lpszTempPtr < 0x47)
 5111a34:	e24cc041 	sub	ip, ip, #65	; 0x41
				uAalue = *lpszTempPtr - 0x57;
 5111a38:	96af0073 	sxtbls	r0, r3
			else if (*lpszTempPtr > 0x60 && *lpszTempPtr < 0x67)
 5111a3c:	9a000001 	bls	5111a48 <_atoh+0x78>
			else if (*lpszTempPtr > 0x40 && *lpszTempPtr < 0x47)
 5111a40:	e35c0005 	cmp	ip, #5
 5111a44:	8a000008 	bhi	5111a6c <_atoh+0x9c>
			else 
			{
				return 0U;
			}
			//移位计算各个值的和
			uHalue += uAalue << 4U * uTempSize;
 5111a48:	e0844110 	add	r4, r4, r0, lsl r1
		while (uTempSize--)
 5111a4c:	e2411004 	sub	r1, r1, #4
 5111a50:	e3710004 	cmn	r1, #4
 5111a54:	1affffea 	bne	5111a04 <_atoh+0x34>
	}
    else
    {
        return 1;
    }
    *out = uHalue;
 5111a58:	e5824000 	str	r4, [r2]
	return 0;
 5111a5c:	e3a00000 	mov	r0, #0
 5111a60:	e8bd8030 	pop	{r4, r5, pc}
        return 1;
 5111a64:	e3a00001 	mov	r0, #1
}
 5111a68:	e12fff1e 	bx	lr
				return 0U;
 5111a6c:	e3a00000 	mov	r0, #0
}
 5111a70:	e8bd8030 	pop	{r4, r5, pc}

05111a74 <userShellWrite>:
{
 5111a74:	e92d4010 	push	{r4, lr}
    Debug_Buffer_Input((uint8_t *)data, len);
 5111a78:	e3023108 	movw	r3, #8456	; 0x2108
{
 5111a7c:	e1a04001 	mov	r4, r1
    Debug_Buffer_Input((uint8_t *)data, len);
 5111a80:	e3403511 	movt	r3, #1297	; 0x511
 5111a84:	e12fff33 	blx	r3
}
 5111a88:	e6bf0074 	sxth	r0, r4
 5111a8c:	e8bd8010 	pop	{r4, pc}

05111a90 <userShellRead>:
    return Uart_Read(DEBUG_UART_CH, (uint8_t *)data, len);
 5111a90:	e3083a34 	movw	r3, #35380	; 0x8a34
{
 5111a94:	e1a02001 	mov	r2, r1
    return Uart_Read(DEBUG_UART_CH, (uint8_t *)data, len);
 5111a98:	e3403511 	movt	r3, #1297	; 0x511
 5111a9c:	e1a01000 	mov	r1, r0
 5111aa0:	e3a00000 	mov	r0, #0
{
 5111aa4:	e92d4010 	push	{r4, lr}
    return Uart_Read(DEBUG_UART_CH, (uint8_t *)data, len);
 5111aa8:	e12fff33 	blx	r3
}
 5111aac:	e6bf0070 	sxth	r0, r0
 5111ab0:	e8bd8010 	pop	{r4, pc}

05111ab4 <Version_Dispaly_Handle>:

extern const char s_bst_ver_string[80];
void Version_Dispaly_Handle(void)
{
    // test_cmd_handle();
    LOG(DBG_INFO,"Bst","%s", s_bst_ver_string);
 5111ab4:	e30d11b4 	movw	r1, #53684	; 0xd1b4
 5111ab8:	e30f0d44 	movw	r0, #64836	; 0xfd44
{
 5111abc:	e92d4010 	push	{r4, lr}
    LOG(DBG_INFO,"Bst","%s", s_bst_ver_string);
 5111ac0:	e3401512 	movt	r1, #1298	; 0x512
 5111ac4:	e3a0c0da 	mov	ip, #218	; 0xda
{
 5111ac8:	e24dd010 	sub	sp, sp, #16
    LOG(DBG_INFO,"Bst","%s", s_bst_ver_string);
 5111acc:	e30d31e8 	movw	r3, #53736	; 0xd1e8
 5111ad0:	e3400512 	movt	r0, #1298	; 0x512
 5111ad4:	e58d1004 	str	r1, [sp, #4]
 5111ad8:	e30d2188 	movw	r2, #53640	; 0xd188
 5111adc:	e30d11b0 	movw	r1, #53680	; 0xd1b0
 5111ae0:	e30244b0 	movw	r4, #9392	; 0x24b0
 5111ae4:	e58d0008 	str	r0, [sp, #8]
 5111ae8:	e3403512 	movt	r3, #1298	; 0x512
 5111aec:	e3402512 	movt	r2, #1298	; 0x512
 5111af0:	e3a00003 	mov	r0, #3
 5111af4:	e3401512 	movt	r1, #1298	; 0x512
 5111af8:	e58dc000 	str	ip, [sp]
 5111afc:	e3404511 	movt	r4, #1297	; 0x511
 5111b00:	e12fff34 	blx	r4
}
 5111b04:	e28dd010 	add	sp, sp, #16
 5111b08:	e8bd8010 	pop	{r4, pc}

05111b0c <RegSet32Handle>:
    if (argc == 3)
 5111b0c:	e3500003 	cmp	r0, #3
 5111b10:	112fff1e 	bxne	lr
{
 5111b14:	e92d4070 	push	{r4, r5, r6, lr}
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111b18:	e5915004 	ldr	r5, [r1, #4]
 5111b1c:	e3006331 	movw	r6, #817	; 0x331
 5111b20:	e1a00005 	mov	r0, r5
{
 5111b24:	e24dd008 	sub	sp, sp, #8
 5111b28:	e1a04001 	mov	r4, r1
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111b2c:	e3406511 	movt	r6, #1297	; 0x511
 5111b30:	e12fff36 	blx	r6
 5111b34:	e1a0200d 	mov	r2, sp
 5111b38:	e1a01000 	mov	r1, r0
 5111b3c:	e1a00005 	mov	r0, r5
 5111b40:	e30159d0 	movw	r5, #6608	; 0x19d0
 5111b44:	e3405511 	movt	r5, #1297	; 0x511
 5111b48:	e12fff35 	blx	r5
 5111b4c:	e3500000 	cmp	r0, #0
 5111b50:	1a00000b 	bne	5111b84 <RegSet32Handle+0x78>
           (0 == _atoh(argv[2], strlen(argv[2]), &RegValue)))
 5111b54:	e5944008 	ldr	r4, [r4, #8]
 5111b58:	e1a00004 	mov	r0, r4
 5111b5c:	e12fff36 	blx	r6
 5111b60:	e28d2004 	add	r2, sp, #4
 5111b64:	e1a01000 	mov	r1, r0
 5111b68:	e1a00004 	mov	r0, r4
 5111b6c:	e12fff35 	blx	r5
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111b70:	e3500000 	cmp	r0, #0
            REG_WRITE32(RegAddr, RegValue);
 5111b74:	059d3000 	ldreq	r3, [sp]
 5111b78:	059d2004 	ldreq	r2, [sp, #4]
 5111b7c:	05832000 	streq	r2, [r3]
 5111b80:	0a000007 	beq	5111ba4 <RegSet32Handle+0x98>
            SHELL_OUT("need input hex data: 0x...");
 5111b84:	e30d01b8 	movw	r0, #53688	; 0xd1b8
 5111b88:	e30243d8 	movw	r4, #9176	; 0x23d8
 5111b8c:	e3400512 	movt	r0, #1298	; 0x512
 5111b90:	e3404511 	movt	r4, #1297	; 0x511
 5111b94:	e12fff34 	blx	r4
 5111b98:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5111b9c:	e3400512 	movt	r0, #1298	; 0x512
 5111ba0:	e12fff34 	blx	r4
}
 5111ba4:	e28dd008 	add	sp, sp, #8
 5111ba8:	e8bd8070 	pop	{r4, r5, r6, pc}

05111bac <RegDumpHandle>:
    if(argc == 3)
 5111bac:	e3500003 	cmp	r0, #3
 5111bb0:	112fff1e 	bxne	lr
{
 5111bb4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111bb8:	e5915004 	ldr	r5, [r1, #4]
 5111bbc:	e3006331 	movw	r6, #817	; 0x331
 5111bc0:	e1a00005 	mov	r0, r5
{
 5111bc4:	e24dd00c 	sub	sp, sp, #12
 5111bc8:	e1a04001 	mov	r4, r1
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111bcc:	e3406511 	movt	r6, #1297	; 0x511
 5111bd0:	e12fff36 	blx	r6
 5111bd4:	e1a0200d 	mov	r2, sp
 5111bd8:	e1a01000 	mov	r1, r0
 5111bdc:	e1a00005 	mov	r0, r5
 5111be0:	e30159d0 	movw	r5, #6608	; 0x19d0
 5111be4:	e3405511 	movt	r5, #1297	; 0x511
 5111be8:	e12fff35 	blx	r5
 5111bec:	e3500000 	cmp	r0, #0
 5111bf0:	1a00001f 	bne	5111c74 <RegDumpHandle+0xc8>
           (0 == _atoh(argv[2], strlen(argv[2]), &DumpSize)))
 5111bf4:	e5944008 	ldr	r4, [r4, #8]
 5111bf8:	e1a00004 	mov	r0, r4
 5111bfc:	e12fff36 	blx	r6
 5111c00:	e28d2004 	add	r2, sp, #4
 5111c04:	e1a01000 	mov	r1, r0
 5111c08:	e1a00004 	mov	r0, r4
 5111c0c:	e12fff35 	blx	r5
        if((0 == _atoh(argv[1], strlen(argv[1]), &RegAddr)) &&
 5111c10:	e2504000 	subs	r4, r0, #0
 5111c14:	1a000016 	bne	5111c74 <RegDumpHandle+0xc8>
                for(i = 0; i < DumpSize; i++)
 5111c18:	e59d3004 	ldr	r3, [sp, #4]
 5111c1c:	e3530000 	cmp	r3, #0
 5111c20:	0a00001b 	beq	5111c94 <RegDumpHandle+0xe8>
 5111c24:	e30253d8 	movw	r5, #9176	; 0x23d8
                    SHELL_OUT("ADDR 0x%08x: 0x%08x", RegAddr, REG_READ32(RegAddr));
 5111c28:	e30d71d4 	movw	r7, #53716	; 0xd1d4
 5111c2c:	e30d63e0 	movw	r6, #54240	; 0xd3e0
 5111c30:	e3405511 	movt	r5, #1297	; 0x511
 5111c34:	e59d1000 	ldr	r1, [sp]
 5111c38:	e3407512 	movt	r7, #1298	; 0x512
 5111c3c:	e3406512 	movt	r6, #1298	; 0x512
 5111c40:	e5912000 	ldr	r2, [r1]
 5111c44:	e1a00007 	mov	r0, r7
 5111c48:	e12fff35 	blx	r5
 5111c4c:	e1a00006 	mov	r0, r6
 5111c50:	e12fff35 	blx	r5
                    RegAddr += 4;
 5111c54:	e59d1000 	ldr	r1, [sp]
                for(i = 0; i < DumpSize; i++)
 5111c58:	e59d3004 	ldr	r3, [sp, #4]
 5111c5c:	e2844001 	add	r4, r4, #1
                    RegAddr += 4;
 5111c60:	e2811004 	add	r1, r1, #4
                for(i = 0; i < DumpSize; i++)
 5111c64:	e1540003 	cmp	r4, r3
                    RegAddr += 4;
 5111c68:	e58d1000 	str	r1, [sp]
                for(i = 0; i < DumpSize; i++)
 5111c6c:	3afffff3 	bcc	5111c40 <RegDumpHandle+0x94>
 5111c70:	ea000007 	b	5111c94 <RegDumpHandle+0xe8>
               SHELL_OUT("need input hex data: 0x...");
 5111c74:	e30d01b8 	movw	r0, #53688	; 0xd1b8
 5111c78:	e30243d8 	movw	r4, #9176	; 0x23d8
 5111c7c:	e3400512 	movt	r0, #1298	; 0x512
 5111c80:	e3404511 	movt	r4, #1297	; 0x511
 5111c84:	e12fff34 	blx	r4
 5111c88:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5111c8c:	e3400512 	movt	r0, #1298	; 0x512
 5111c90:	e12fff34 	blx	r4
}
 5111c94:	e28dd00c 	add	sp, sp, #12
 5111c98:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

05111c9c <userShellUnlock>:
 5111c9c:	e3a00000 	mov	r0, #0
 5111ca0:	e12fff1e 	bx	lr

05111ca4 <GetSystemTick>:
}
 5111ca4:	e3a00000 	mov	r0, #0
 5111ca8:	e12fff1e 	bx	lr

05111cac <userShellInit>:
    shell_instance.write = userShellWrite;
 5111cac:	e3070318 	movw	r0, #29464	; 0x7318
 5111cb0:	e3011a74 	movw	r1, #6772	; 0x1a74
    shell_instance.lock = userShellLock;
 5111cb4:	e30139c8 	movw	r3, #6600	; 0x19c8
    shell_instance.write = userShellWrite;
 5111cb8:	e3400513 	movt	r0, #1299	; 0x513
 5111cbc:	e3401511 	movt	r1, #1297	; 0x511
    shell_instance.read = userShellRead;
 5111cc0:	e3012a90 	movw	r2, #6800	; 0x1a90
    shell_instance.lock = userShellLock;
 5111cc4:	e3403511 	movt	r3, #1297	; 0x511
    shell_instance.unlock = userShellUnlock;
 5111cc8:	e301cc9c 	movw	ip, #7324	; 0x1c9c
    shell_instance.read = userShellRead;
 5111ccc:	e3402511 	movt	r2, #1297	; 0x511
{
 5111cd0:	e92d4010 	push	{r4, lr}
    shell_instance.write = userShellWrite;
 5111cd4:	e5801068 	str	r1, [r0, #104]	; 0x68
    shell_instance.unlock = userShellUnlock;
 5111cd8:	e340c511 	movt	ip, #1297	; 0x511
    shell_instance.lock = userShellLock;
 5111cdc:	e580306c 	str	r3, [r0, #108]	; 0x6c
    shellInit(&shell_instance, shellBuffer, 512);
 5111ce0:	e3071118 	movw	r1, #28952	; 0x7118
 5111ce4:	e3063c7c 	movw	r3, #27772	; 0x6c7c
 5111ce8:	e3401513 	movt	r1, #1299	; 0x513
    shell_instance.read = userShellRead;
 5111cec:	e5802064 	str	r2, [r0, #100]	; 0x64
    shellInit(&shell_instance, shellBuffer, 512);
 5111cf0:	e3403511 	movt	r3, #1297	; 0x511
    shell_instance.unlock = userShellUnlock;
 5111cf4:	e580c070 	str	ip, [r0, #112]	; 0x70
    shellInit(&shell_instance, shellBuffer, 512);
 5111cf8:	e3a02c02 	mov	r2, #512	; 0x200
 5111cfc:	e12fff33 	blx	r3
}
 5111d00:	e8bd8010 	pop	{r4, pc}

05111d04 <vConfigureTickInterrupt>:
 * create the FreeRTOS tick interrupt, then define configSETUP_TICK_INTERRUPT()
 * in FreeRTOSConfig.h to call the function.  This file contains a function
 * that is suitable for use on the Zynq SoC.
 */
void vConfigureTickInterrupt( void )
{
 5111d04:	e92d4010 	push	{r4, lr}
    uint32 period_tick = LSP_CLOCK/OSEE_TICK_RATE_HZ;
    switch(SYS_TICK_TIEMR_CFG)
    {
        case SOC_INTR_SOC_TO_SOC_R5_INTR_0:
            cpu_gicd_set_enable(SOC_INTR_SOC_TO_SOC_R5_INTR_0);
 5111d08:	e3074b68 	movw	r4, #31592	; 0x7b68
 5111d0c:	e3a00060 	mov	r0, #96	; 0x60
 5111d10:	e3404511 	movt	r4, #1297	; 0x511
 5111d14:	e12fff34 	blx	r4
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR+8, 0);
 5111d18:	e3a03a01 	mov	r3, #4096	; 0x1000
            //start config
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR, period_tick);
 5111d1c:	e30826a0 	movw	r2, #34464	; 0x86a0
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR+8, 0);
 5111d20:	e3423001 	movt	r3, #8193	; 0x2001
            //timer bit2=0,intr unmask
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR+8, 3);
 5111d24:	e3a01003 	mov	r1, #3
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR, period_tick);
 5111d28:	e3402001 	movt	r2, #1
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR+8, 0);
 5111d2c:	e3a00000 	mov	r0, #0
 5111d30:	e583001c 	str	r0, [r3, #28]
            break;
        default:
        break;
    }
    cpu_gicd_set_enable(SOC_INTR_SOC_TO_SOC_R5_INTR_0);
 5111d34:	e3a00060 	mov	r0, #96	; 0x60
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR, period_tick);
 5111d38:	e5832014 	str	r2, [r3, #20]
            REG_WRITE32(TIMER0_PWM0_BASE_ADDR+8, 3);
 5111d3c:	e583101c 	str	r1, [r3, #28]
    cpu_gicd_set_enable(SOC_INTR_SOC_TO_SOC_R5_INTR_0);
 5111d40:	e12fff34 	blx	r4
    cpu_gic_config_nonsecure();
 5111d44:	e3073ba8 	movw	r3, #31656	; 0x7ba8
 5111d48:	e3403511 	movt	r3, #1297	; 0x511
 5111d4c:	e12fff33 	blx	r3

    int* pp = 0xb7000030;
    *pp = 0x5555;
 5111d50:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
 5111d54:	e3052555 	movw	r2, #21845	; 0x5555
 5111d58:	e5832030 	str	r2, [r3, #48]	; 0x30
}
 5111d5c:	e8bd8010 	pop	{r4, pc}

05111d60 <vClearTickInterrupt>:

void vClearTickInterrupt( void )
{
    unsigned int regVal;

    systemTick++;
 5111d60:	e307338c 	movw	r3, #29580	; 0x738c
    regVal = REG_READ32(TIMER0_PWM0_BASE_ADDR + 0xc);
 5111d64:	e3a01a01 	mov	r1, #4096	; 0x1000
    systemTick++;
 5111d68:	e3403513 	movt	r3, #1299	; 0x513
    regVal = REG_READ32(TIMER0_PWM0_BASE_ADDR + 0xc);
 5111d6c:	e3421001 	movt	r1, #8193	; 0x2001
    systemTick++;
 5111d70:	e5932000 	ldr	r2, [r3]
 5111d74:	e2822001 	add	r2, r2, #1
 5111d78:	e5832000 	str	r2, [r3]
    {
        REG_READ32(TIMER0_PWM0_BASE_ADDR + 0xc);
    }

    int* pp = 0xb7000034;
    *pp = 0x5555;
 5111d7c:	e3052555 	movw	r2, #21845	; 0x5555
    regVal = REG_READ32(TIMER0_PWM0_BASE_ADDR + 0xc);
 5111d80:	e5913020 	ldr	r3, [r1, #32]
    if(regVal != 0)
 5111d84:	e3530000 	cmp	r3, #0
        REG_READ32(TIMER0_PWM0_BASE_ADDR + 0xc);
 5111d88:	15913020 	ldrne	r3, [r1, #32]
    *pp = 0x5555;
 5111d8c:	e3a034b7 	mov	r3, #-1224736768	; 0xb7000000
 5111d90:	e5832034 	str	r2, [r3, #52]	; 0x34
}
 5111d94:	e12fff1e 	bx	lr

05111d98 <AbortHandler>:
#include "common.h"

uint32 AbortRarry[15];
void AbortHandler(uint32 *pStack, uint32 type)
{
    uint8 *AbortType[3] ={
 5111d98:	e30c3cf8 	movw	r3, #52472	; 0xccf8
{
 5111d9c:	e1a04000 	mov	r4, r0
    uint8 *AbortType[3] ={
 5111da0:	e3403512 	movt	r3, #1298	; 0x512
{
 5111da4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        "UndefinedAbort",
        "DataAbort",
        "PrefetchAbort"
    };

    myprintf("\r\n%s:\r\n\
 5111da8:	e30852f4 	movw	r5, #33524	; 0x82f4
{
 5111dac:	e24dd04c 	sub	sp, sp, #76	; 0x4c
    myprintf("\r\n%s:\r\n\
 5111db0:	e28d2048 	add	r2, sp, #72	; 0x48
 5111db4:	e082c101 	add	ip, r2, r1, lsl #2
    uint8 *AbortType[3] ={
 5111db8:	e8930007 	ldm	r3, {r0, r1, r2}
 5111dbc:	e28d3048 	add	r3, sp, #72	; 0x48
    myprintf("\r\n%s:\r\n\
 5111dc0:	e3405511 	movt	r5, #1297	; 0x511
    uint8 *AbortType[3] ={
 5111dc4:	e9030007 	stmdb	r3, {r0, r1, r2}
    myprintf("\r\n%s:\r\n\
 5111dc8:	e3072390 	movw	r2, #29584	; 0x7390
 5111dcc:	e30d02e8 	movw	r0, #53992	; 0xd2e8
 5111dd0:	e3402513 	movt	r2, #1299	; 0x513
 5111dd4:	e3400512 	movt	r0, #1298	; 0x512
 5111dd8:	e5921038 	ldr	r1, [r2, #56]	; 0x38
 5111ddc:	e5923034 	ldr	r3, [r2, #52]	; 0x34
 5111de0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
 5111de4:	e58d1030 	str	r1, [sp, #48]	; 0x30
 5111de8:	e5921030 	ldr	r1, [r2, #48]	; 0x30
 5111dec:	e592302c 	ldr	r3, [r2, #44]	; 0x2c
 5111df0:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5111df4:	e58d1028 	str	r1, [sp, #40]	; 0x28
 5111df8:	e5921028 	ldr	r1, [r2, #40]	; 0x28
 5111dfc:	e5923024 	ldr	r3, [r2, #36]	; 0x24
 5111e00:	e58d301c 	str	r3, [sp, #28]
 5111e04:	e58d1020 	str	r1, [sp, #32]
 5111e08:	e5921020 	ldr	r1, [r2, #32]
 5111e0c:	e592301c 	ldr	r3, [r2, #28]
 5111e10:	e58d3014 	str	r3, [sp, #20]
 5111e14:	e58d1018 	str	r1, [sp, #24]
 5111e18:	e5921018 	ldr	r1, [r2, #24]
 5111e1c:	e5923014 	ldr	r3, [r2, #20]
 5111e20:	e58d300c 	str	r3, [sp, #12]
 5111e24:	e58d1010 	str	r1, [sp, #16]
 5111e28:	e5921010 	ldr	r1, [r2, #16]
 5111e2c:	e592300c 	ldr	r3, [r2, #12]
 5111e30:	e58d3004 	str	r3, [sp, #4]
 5111e34:	e58d1008 	str	r1, [sp, #8]
 5111e38:	e5923008 	ldr	r3, [r2, #8]
 5111e3c:	e58d3000 	str	r3, [sp]
 5111e40:	e1c220d0 	ldrd	r2, [r2]
 5111e44:	e51c100c 	ldr	r1, [ip, #-12]
 5111e48:	e12fff35 	blx	r5
    r12=0x%08x,\r\n\
    sp=0x%08x,\r\n\
    lr=0x%08x,\r\n",AbortType[type], AbortRarry[0], AbortRarry[1], AbortRarry[2], AbortRarry[3], AbortRarry[4], AbortRarry[5], AbortRarry[6], 
    AbortRarry[7], AbortRarry[8], AbortRarry[9], AbortRarry[10], AbortRarry[11], AbortRarry[12], AbortRarry[13], AbortRarry[14]);

    myprintf("\r\nUsrSP[0x%08x] Data:\r\n\
 5111e4c:	e5940014 	ldr	r0, [r4, #20]
 5111e50:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
 5111e54:	e5943010 	ldr	r3, [r4, #16]
 5111e58:	e594100c 	ldr	r1, [r4, #12]
 5111e5c:	e58d0008 	str	r0, [sp, #8]
 5111e60:	e30d03e4 	movw	r0, #54244	; 0xd3e4
 5111e64:	e58d2030 	str	r2, [sp, #48]	; 0x30
 5111e68:	e3400512 	movt	r0, #1298	; 0x512
 5111e6c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
 5111e70:	e58d3004 	str	r3, [sp, #4]
 5111e74:	e5943008 	ldr	r3, [r4, #8]
 5111e78:	e58d1000 	str	r1, [sp]
 5111e7c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
 5111e80:	e5941034 	ldr	r1, [r4, #52]	; 0x34
 5111e84:	e5942030 	ldr	r2, [r4, #48]	; 0x30
 5111e88:	e58d2024 	str	r2, [sp, #36]	; 0x24
 5111e8c:	e58d1028 	str	r1, [sp, #40]	; 0x28
 5111e90:	e594102c 	ldr	r1, [r4, #44]	; 0x2c
 5111e94:	e5942028 	ldr	r2, [r4, #40]	; 0x28
 5111e98:	e58d201c 	str	r2, [sp, #28]
 5111e9c:	e58d1020 	str	r1, [sp, #32]
 5111ea0:	e5941024 	ldr	r1, [r4, #36]	; 0x24
 5111ea4:	e5942020 	ldr	r2, [r4, #32]
 5111ea8:	e58d2014 	str	r2, [sp, #20]
 5111eac:	e58d1018 	str	r1, [sp, #24]
 5111eb0:	e594101c 	ldr	r1, [r4, #28]
 5111eb4:	e5942018 	ldr	r2, [r4, #24]
 5111eb8:	e58d200c 	str	r2, [sp, #12]
 5111ebc:	e58d1010 	str	r1, [sp, #16]
 5111ec0:	e8940006 	ldm	r4, {r1, r2}
 5111ec4:	e12fff35 	blx	r5
    0x%08x,0x%08x,0x%08x,0x%08x,\r\n\
    0x%08x,0x%08x,0x%08x,0x%08x,\r\n\
    0x%08x,0x%08x,0x%08x,0x%08x,\r\n\
    0x%08x,0x%08x,0x%08x,0x%08x\r\n", pStack[0], pStack[1], pStack[2], pStack[3], pStack[4], pStack[5], pStack[6], pStack[7]
    , pStack[8], pStack[9], pStack[10], pStack[11], pStack[12], pStack[13], pStack[14], pStack[15]);
    while (1)
 5111ec8:	eafffffe 	b	5111ec8 <AbortHandler+0x130>

05111ecc <i2c_bus_sem_lock>:
 5111ecc:	e12fff1e 	bx	lr

05111ed0 <i2c_bus_sem_unlock>:

    locker = i2c_bus_id_to_helper(bus_id, 0);
    if (locker && locker->unlock) {
        locker->unlock(locker->priv);
    }
}
 5111ed0:	e12fff1e 	bx	lr

05111ed4 <i2c_bus_hw_lock>:
        if (pResource[i].bus_id == bus_id) {
 5111ed4:	e30f3a80 	movw	r3, #64128	; 0xfa80
 5111ed8:	e3403512 	movt	r3, #1298	; 0x512
 5111edc:	e5932000 	ldr	r2, [r3]
 5111ee0:	e1500002 	cmp	r0, r2
 5111ee4:	0a000003 	beq	5111ef8 <i2c_bus_hw_lock+0x24>
 5111ee8:	e5932008 	ldr	r2, [r3, #8]
 5111eec:	e1500002 	cmp	r0, r2
 5111ef0:	112fff1e 	bxne	lr
 5111ef4:	e2833008 	add	r3, r3, #8
            return pResource[i].helper;
 5111ef8:	e5933004 	ldr	r3, [r3, #4]
void i2c_bus_hw_lock(unsigned int bus_id)
{
    struct bus_lock_helper* locker;

    locker = i2c_bus_id_to_helper(bus_id, 1);
    if (locker && locker->lock) {
 5111efc:	e3530000 	cmp	r3, #0
 5111f00:	012fff1e 	bxeq	lr
 5111f04:	e5932000 	ldr	r2, [r3]
 5111f08:	e3520000 	cmp	r2, #0
 5111f0c:	012fff1e 	bxeq	lr
        locker->lock(locker->priv);
 5111f10:	e5930008 	ldr	r0, [r3, #8]
{
 5111f14:	e92d4010 	push	{r4, lr}
        locker->lock(locker->priv);
 5111f18:	e12fff32 	blx	r2
    }
}
 5111f1c:	e8bd8010 	pop	{r4, pc}

05111f20 <i2c_bus_hw_unlock>:
        if (pResource[i].bus_id == bus_id) {
 5111f20:	e30f3a80 	movw	r3, #64128	; 0xfa80
 5111f24:	e3403512 	movt	r3, #1298	; 0x512
 5111f28:	e5932000 	ldr	r2, [r3]
 5111f2c:	e1500002 	cmp	r0, r2
 5111f30:	0a000003 	beq	5111f44 <i2c_bus_hw_unlock+0x24>
 5111f34:	e5932008 	ldr	r2, [r3, #8]
 5111f38:	e1500002 	cmp	r0, r2
 5111f3c:	112fff1e 	bxne	lr
 5111f40:	e2833008 	add	r3, r3, #8
            return pResource[i].helper;
 5111f44:	e5933004 	ldr	r3, [r3, #4]
void i2c_bus_hw_unlock(unsigned int bus_id)
{
    struct bus_lock_helper* locker;

    locker = i2c_bus_id_to_helper(bus_id, 1);
    if (locker && locker->unlock) {
 5111f48:	e3530000 	cmp	r3, #0
 5111f4c:	012fff1e 	bxeq	lr
 5111f50:	e5932004 	ldr	r2, [r3, #4]
 5111f54:	e3520000 	cmp	r2, #0
 5111f58:	012fff1e 	bxeq	lr
        locker->unlock(locker->priv);
 5111f5c:	e5930008 	ldr	r0, [r3, #8]
{
 5111f60:	e92d4010 	push	{r4, lr}
        locker->unlock(locker->priv);
 5111f64:	e12fff32 	blx	r2
    }
 5111f68:	e8bd8010 	pop	{r4, pc}

05111f6c <Shell_MainFunction.part.0>:
        }
    }
#endif
}

void Shell_MainFunction(void)
 5111f6c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        static uint8 ShellRxBuf[128];
        uint32 RxLen;
        uint32 i = 0;


        RxLen = Uart_Read(DEBUG_UART_CH, ShellRxBuf, sizeof(ShellRxBuf));
 5111f70:	e3074c64 	movw	r4, #31844	; 0x7c64
 5111f74:	e3083a34 	movw	r3, #35380	; 0x8a34
 5111f78:	e3a02080 	mov	r2, #128	; 0x80
 5111f7c:	e3404513 	movt	r4, #1299	; 0x513
 5111f80:	e1a01004 	mov	r1, r4
 5111f84:	e3a00000 	mov	r0, #0
        if(RxLen > 0)
        {
            if(ShellRxhookFunc != NULL)
 5111f88:	e3076ce4 	movw	r6, #31972	; 0x7ce4
        RxLen = Uart_Read(DEBUG_UART_CH, ShellRxBuf, sizeof(ShellRxBuf));
 5111f8c:	e3403511 	movt	r3, #1297	; 0x511
 5111f90:	e12fff33 	blx	r3
            if(ShellRxhookFunc != NULL)
 5111f94:	e3406513 	movt	r6, #1299	; 0x513
        if(RxLen > 0)
 5111f98:	e2501000 	subs	r1, r0, #0
 5111f9c:	0a000018 	beq	5112004 <Shell_MainFunction.part.0+0x98>
            if(ShellRxhookFunc != NULL)
 5111fa0:	e5963000 	ldr	r3, [r6]
 5111fa4:	e3530000 	cmp	r3, #0
 5111fa8:	0a00000b 	beq	5111fdc <Shell_MainFunction.part.0+0x70>
            {
                ShellRxhookFunc((char *)ShellRxBuf, RxLen);
 5111fac:	e1a00004 	mov	r0, r4
 5111fb0:	e12fff33 	blx	r3
                    shellHandler(&shell_instance, ShellRxBuf[i]);
                }
            }
        }

        if(ShellRxhookFunc != NULL)
 5111fb4:	e5961000 	ldr	r1, [r6]
                RxHookCnt = 0;
 5111fb8:	e3a02000 	mov	r2, #0
 5111fbc:	e3073c60 	movw	r3, #31840	; 0x7c60
        if(ShellRxhookFunc != NULL)
 5111fc0:	e1510002 	cmp	r1, r2
                RxHookCnt = 0;
 5111fc4:	e3403513 	movt	r3, #1299	; 0x513
 5111fc8:	e1c320b0 	strh	r2, [r3]
        if(ShellRxhookFunc != NULL)
 5111fcc:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
        {
            RxHookCnt++;
 5111fd0:	e3a02001 	mov	r2, #1
 5111fd4:	e1c320b0 	strh	r2, [r3]
 5111fd8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5111fdc:	e3078b4c 	movw	r8, #31564	; 0x7b4c
                    shellHandler(&shell_instance, ShellRxBuf[i]);
 5111fe0:	e3077318 	movw	r7, #29464	; 0x7318
 5111fe4:	e0845001 	add	r5, r4, r1
 5111fe8:	e3408511 	movt	r8, #1297	; 0x511
 5111fec:	e3407513 	movt	r7, #1299	; 0x513
 5111ff0:	e0d410d1 	ldrsb	r1, [r4], #1
 5111ff4:	e1a00007 	mov	r0, r7
 5111ff8:	e12fff38 	blx	r8
                for(i = 0; i < RxLen; i++)
 5111ffc:	e1550004 	cmp	r5, r4
 5112000:	1afffffa 	bne	5111ff0 <Shell_MainFunction.part.0+0x84>
        if(ShellRxhookFunc != NULL)
 5112004:	e5964000 	ldr	r4, [r6]
 5112008:	e3540000 	cmp	r4, #0
 511200c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            RxHookCnt++;
 5112010:	e3073c60 	movw	r3, #31840	; 0x7c60
 5112014:	e3403513 	movt	r3, #1299	; 0x513
 5112018:	e1d320b0 	ldrh	r2, [r3]
 511201c:	e2822001 	add	r2, r2, #1
 5112020:	e6ff2072 	uxth	r2, r2
            if(RxHookCnt >= 100)
 5112024:	e3520063 	cmp	r2, #99	; 0x63
 5112028:	9affffe9 	bls	5111fd4 <Shell_MainFunction.part.0+0x68>
            {
                RxHookCnt = 0;
 511202c:	e3a01000 	mov	r1, #0
                ShellRxhookFunc((char *)NULL, 0);
 5112030:	e1a00001 	mov	r0, r1
                RxHookCnt = 0;
 5112034:	e1c310b0 	strh	r1, [r3]
                ShellRxhookFunc((char *)NULL, 0);
 5112038:	e12fff34 	blx	r4
        }
    }
#endif

#endif 
}
 511203c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05112040 <DebugAndShell_Init>:
    fifo_Init(&DebugFifoTx, DebugTxBuffer, DEBUG_TX_FIFO_SIZE);
 5112040:	e3071460 	movw	r1, #29792	; 0x7460
 5112044:	e307044c 	movw	r0, #29772	; 0x744c
 5112048:	e3083100 	movw	r3, #33024	; 0x8100
 511204c:	e3a02b02 	mov	r2, #2048	; 0x800
{
 5112050:	e92d4010 	push	{r4, lr}
    fifo_Init(&DebugFifoTx, DebugTxBuffer, DEBUG_TX_FIFO_SIZE);
 5112054:	e3401513 	movt	r1, #1299	; 0x513
 5112058:	e3403511 	movt	r3, #1297	; 0x511
    elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_ALL & ~ELOG_FMT_P_INFO);
 511205c:	e3034370 	movw	r4, #13168	; 0x3370
    fifo_Init(&DebugFifoTx, DebugTxBuffer, DEBUG_TX_FIFO_SIZE);
 5112060:	e3400513 	movt	r0, #1299	; 0x513
 5112064:	e12fff33 	blx	r3
    elog_init();
 5112068:	e30231fc 	movw	r3, #8700	; 0x21fc
 511206c:	e3403511 	movt	r3, #1297	; 0x511
 5112070:	e12fff33 	blx	r3
    elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_ALL & ~ELOG_FMT_P_INFO);
 5112074:	e3a010f7 	mov	r1, #247	; 0xf7
 5112078:	e3a00000 	mov	r0, #0
 511207c:	e3404511 	movt	r4, #1297	; 0x511
 5112080:	e12fff34 	blx	r4
    elog_set_fmt(ELOG_LVL_ERROR,  ELOG_FMT_TAG | ELOG_FMT_TIME);
 5112084:	e3a01006 	mov	r1, #6
 5112088:	e3a00001 	mov	r0, #1
 511208c:	e12fff34 	blx	r4
    elog_set_fmt(ELOG_LVL_WARN,  ELOG_FMT_TAG | ELOG_FMT_TIME);
 5112090:	e3a01006 	mov	r1, #6
 5112094:	e3a00002 	mov	r0, #2
 5112098:	e12fff34 	blx	r4
    elog_set_fmt(ELOG_LVL_INFO,  ELOG_FMT_TAG | ELOG_FMT_TIME);
 511209c:	e3a01006 	mov	r1, #6
 51120a0:	e3a00003 	mov	r0, #3
 51120a4:	e12fff34 	blx	r4
    elog_set_fmt(ELOG_LVL_DEBUG,  ELOG_FMT_TAG | ELOG_FMT_TIME);
 51120a8:	e3a01006 	mov	r1, #6
 51120ac:	e3a00004 	mov	r0, #4
 51120b0:	e12fff34 	blx	r4
    elog_set_fmt(ELOG_LVL_VERBOSE, ELOG_FMT_TAG | ELOG_FMT_TIME);
 51120b4:	e3a01006 	mov	r1, #6
 51120b8:	e3a00005 	mov	r0, #5
 51120bc:	e12fff34 	blx	r4
    elog_start();
 51120c0:	e303330c 	movw	r3, #13068	; 0x330c
 51120c4:	e3403511 	movt	r3, #1297	; 0x511
 51120c8:	e12fff33 	blx	r3
    Uart_SetRxBuffer(DEBUG_UART_CH, DbgUartRxBuffer, DEBUG_RX_BUFF_SIZE);
 51120cc:	e30713cc 	movw	r1, #29644	; 0x73cc
 51120d0:	e3083b94 	movw	r3, #35732	; 0x8b94
 51120d4:	e3a02080 	mov	r2, #128	; 0x80
 51120d8:	e3401513 	movt	r1, #1299	; 0x513
 51120dc:	e3a00000 	mov	r0, #0
 51120e0:	e3403511 	movt	r3, #1297	; 0x511
 51120e4:	e12fff33 	blx	r3
    userShellInit();
 51120e8:	e3013cac 	movw	r3, #7340	; 0x1cac
 51120ec:	e3403511 	movt	r3, #1297	; 0x511
 51120f0:	e12fff33 	blx	r3
    DebugInitState = 1;
 51120f4:	e307345c 	movw	r3, #29788	; 0x745c
 51120f8:	e3a02001 	mov	r2, #1
 51120fc:	e3403513 	movt	r3, #1299	; 0x513
 5112100:	e5c32000 	strb	r2, [r3]
}
 5112104:	e8bd8010 	pop	{r4, pc}

05112108 <Debug_Buffer_Input>:
    if(DebugInitState == 1)
 5112108:	e307345c 	movw	r3, #29788	; 0x745c
 511210c:	e3403513 	movt	r3, #1299	; 0x513
 5112110:	e5d33000 	ldrb	r3, [r3]
 5112114:	e3530001 	cmp	r3, #1
 5112118:	0a000001 	beq	5112124 <Debug_Buffer_Input+0x1c>
    uint32 ret = 0;
 511211c:	e3a00000 	mov	r0, #0
}
 5112120:	e12fff1e 	bx	lr
 5112124:	e1a03000 	mov	r3, r0
        ret = fifo_insert(&DebugFifoTx, (uint8 *)Data, Len);
 5112128:	e307044c 	movw	r0, #29772	; 0x744c
{
 511212c:	e92d4010 	push	{r4, lr}
        ret = fifo_insert(&DebugFifoTx, (uint8 *)Data, Len);
 5112130:	e3084180 	movw	r4, #33152	; 0x8180
 5112134:	e1a02001 	mov	r2, r1
 5112138:	e3404511 	movt	r4, #1297	; 0x511
 511213c:	e1a01003 	mov	r1, r3
 5112140:	e3400513 	movt	r0, #1299	; 0x513
 5112144:	e12fff34 	blx	r4
}
 5112148:	e8bd8010 	pop	{r4, pc}

0511214c <Dlt_MainFunction>:

void Dlt_MainFunction(void)
{
 511214c:	e92d4070 	push	{r4, r5, r6, lr}
	if(!DebugInitState)
 5112150:	e307445c 	movw	r4, #29788	; 0x745c
 5112154:	e3404513 	movt	r4, #1299	; 0x513
 5112158:	e5d43000 	ldrb	r3, [r4]
 511215c:	e3530000 	cmp	r3, #0
 5112160:	1a000006 	bne	5112180 <Dlt_MainFunction+0x34>
	if(!DebugInitState)
 5112164:	e5d43000 	ldrb	r3, [r4]
 5112168:	e3530000 	cmp	r3, #0
 511216c:	08bd8070 	popeq	{r4, r5, r6, pc}
 5112170:	e3013f6c 	movw	r3, #8044	; 0x1f6c
 5112174:	e3403511 	movt	r3, #1297	; 0x511
 5112178:	e12fff33 	blx	r3
	Debug_MainFunction();
	Shell_MainFunction();
}
 511217c:	e8bd8070 	pop	{r4, r5, r6, pc}
    if(UART_TX_IDLE == Uart_GetTxStatus(DEBUG_UART_CH))
 5112180:	e3083c1c 	movw	r3, #35868	; 0x8c1c
 5112184:	e3a00000 	mov	r0, #0
 5112188:	e3403511 	movt	r3, #1297	; 0x511
 511218c:	e12fff33 	blx	r3
 5112190:	e2505000 	subs	r5, r0, #0
 5112194:	1afffff2 	bne	5112164 <Dlt_MainFunction+0x18>
        Length = fifo_GetLen(&DebugFifoTx);
 5112198:	e307044c 	movw	r0, #29772	; 0x744c
 511219c:	e3083170 	movw	r3, #33136	; 0x8170
 51121a0:	e3400513 	movt	r0, #1299	; 0x513
 51121a4:	e3403511 	movt	r3, #1297	; 0x511
 51121a8:	e12fff33 	blx	r3
 51121ac:	e6ff2070 	uxth	r2, r0
        if(Length > 0)
 51121b0:	e3520000 	cmp	r2, #0
 51121b4:	0affffea 	beq	5112164 <Dlt_MainFunction+0x18>
            Length = fifo_retrieve(&DebugFifoTx, Txbuffer, ValidLen);
 51121b8:	e3071ce8 	movw	r1, #31976	; 0x7ce8
 51121bc:	e3520080 	cmp	r2, #128	; 0x80
 51121c0:	e307044c 	movw	r0, #29772	; 0x744c
 51121c4:	e308322c 	movw	r3, #33324	; 0x822c
 51121c8:	23a02080 	movcs	r2, #128	; 0x80
 51121cc:	e3401513 	movt	r1, #1299	; 0x513
 51121d0:	e3403511 	movt	r3, #1297	; 0x511
 51121d4:	e3400513 	movt	r0, #1299	; 0x513
 51121d8:	e12fff33 	blx	r3
            Uart_Write(DEBUG_UART_CH, Txbuffer, Length);
 51121dc:	e3071ce8 	movw	r1, #31976	; 0x7ce8
 51121e0:	e30839a0 	movw	r3, #35232	; 0x89a0
 51121e4:	e3401513 	movt	r1, #1299	; 0x513
 51121e8:	e3403511 	movt	r3, #1297	; 0x511
 51121ec:	e6ff2070 	uxth	r2, r0
 51121f0:	e1a00005 	mov	r0, r5
 51121f4:	e12fff33 	blx	r3
 51121f8:	eaffffd9 	b	5112164 <Dlt_MainFunction+0x18>

051121fc <elog_init>:
/**
 * EasyLogger initialize.
 *
 * @return result
 */
ElogErrCode elog_init(void) {
 51121fc:	e92d4010 	push	{r4, lr}
    extern ElogErrCode elog_port_init(void);
    extern ElogErrCode elog_async_init(void);

    ElogErrCode result = ELOG_NO_ERR;

    if (elog.init_ok == true) {
 5112200:	e3074d68 	movw	r4, #32104	; 0x7d68
ElogErrCode elog_init(void) {
 5112204:	e24dd008 	sub	sp, sp, #8
    if (elog.init_ok == true) {
 5112208:	e3404513 	movt	r4, #1299	; 0x513
 511220c:	e5d43058 	ldrb	r3, [r4, #88]	; 0x58
 5112210:	e3530000 	cmp	r3, #0
        return result;
 5112214:	13a00000 	movne	r0, #0
    if (elog.init_ok == true) {
 5112218:	0a000001 	beq	5112224 <elog_init+0x28>
    elog_set_filter_tag_lvl_default();

    elog.init_ok = true;

    return result;
}
 511221c:	e28dd008 	add	sp, sp, #8
 5112220:	e8bd8010 	pop	{r4, pc}
    result = elog_port_init();
 5112224:	e3013624 	movw	r3, #5668	; 0x1624
 5112228:	e3403511 	movt	r3, #1297	; 0x511
 511222c:	e12fff33 	blx	r3
    if (result != ELOG_NO_ERR) {
 5112230:	e3500000 	cmp	r0, #0
 5112234:	1afffff8 	bne	511221c <elog_init+0x20>
 * @note disable this lock is not recommended except you want output system exception log
 *
 * @param enabled true: enable  false: disable
 */
void elog_output_lock_enabled(bool enabled) {
    elog.output_lock_enabled = enabled;
 5112238:	e3a03001 	mov	r3, #1
    /* it will re-lock or re-unlock before output lock enable */
    if (elog.output_lock_enabled) {
        if (!elog.output_is_locked_before_disable && elog.output_is_locked_before_enable) {
 511223c:	e5d4205c 	ldrb	r2, [r4, #92]	; 0x5c
 5112240:	e3520000 	cmp	r2, #0
    elog.output_lock_enabled = enabled;
 5112244:	e5c4305a 	strb	r3, [r4, #90]	; 0x5a
        if (!elog.output_is_locked_before_disable && elog.output_is_locked_before_enable) {
 5112248:	e5d4305b 	ldrb	r3, [r4, #91]	; 0x5b
 511224c:	1a000013 	bne	51122a0 <elog_init+0xa4>
 5112250:	e3530000 	cmp	r3, #0
 5112254:	1a000019 	bne	51122c0 <elog_init+0xc4>
    elog.filter.level = level;
 5112258:	e3a01004 	mov	r1, #4
    elog.output_is_locked_before_enable = false;
 511225c:	e3a02000 	mov	r2, #0
 5112260:	e59f3070 	ldr	r3, [pc, #112]	; 51122d8 <elog_init+0xdc>
    elog.filter.level = level;
 5112264:	e5c41000 	strb	r1, [r4]
    elog.output_is_locked_before_enable = false;
 5112268:	e5c4205b 	strb	r2, [r4, #91]	; 0x5b
    elog.output_is_locked_before_disable = false;
 511226c:	e283102d 	add	r1, r3, #45	; 0x2d
 5112270:	e5c4205c 	strb	r2, [r4, #92]	; 0x5c
        memset(elog.filter.tag_lvl[i].tag, '\0', ELOG_FILTER_TAG_MAX_LEN + 1);
 5112274:	e5832000 	str	r2, [r3]
    for (i =0; i< ELOG_FILTER_TAG_LVL_MAX_NUM; i++){
 5112278:	e2833009 	add	r3, r3, #9
        elog.filter.tag_lvl[i].level = ELOG_FILTER_LVL_SILENT;
 511227c:	e543200a 	strb	r2, [r3, #-10]
        memset(elog.filter.tag_lvl[i].tag, '\0', ELOG_FILTER_TAG_MAX_LEN + 1);
 5112280:	e5032006 	str	r2, [r3, #-6]
        elog.filter.tag_lvl[i].tag_use_flag = false;
 5112284:	e5432002 	strb	r2, [r3, #-2]
    for (i =0; i< ELOG_FILTER_TAG_LVL_MAX_NUM; i++){
 5112288:	e1530001 	cmp	r3, r1
 511228c:	1afffff8 	bne	5112274 <elog_init+0x78>
    elog.init_ok = true;
 5112290:	e3a03001 	mov	r3, #1
 5112294:	e5c43058 	strb	r3, [r4, #88]	; 0x58
}
 5112298:	e28dd008 	add	sp, sp, #8
 511229c:	e8bd8010 	pop	{r4, pc}
            /* the output lock is unlocked before disable, and the lock will unlocking after enable */
            elog_port_output_lock();
        } else if (elog.output_is_locked_before_disable && !elog.output_is_locked_before_enable) {
 51122a0:	e3530000 	cmp	r3, #0
 51122a4:	1affffeb 	bne	5112258 <elog_init+0x5c>
 51122a8:	e58d0004 	str	r0, [sp, #4]
            /* the output lock is locked before disable, and the lock will locking after enable */
            elog_port_output_unlock();
 51122ac:	e3013644 	movw	r3, #5700	; 0x1644
 51122b0:	e3403511 	movt	r3, #1297	; 0x511
 51122b4:	e12fff33 	blx	r3
 51122b8:	e59d0004 	ldr	r0, [sp, #4]
 51122bc:	eaffffe5 	b	5112258 <elog_init+0x5c>
 51122c0:	e58d0004 	str	r0, [sp, #4]
            elog_port_output_lock();
 51122c4:	e3013640 	movw	r3, #5696	; 0x1640
 51122c8:	e3403511 	movt	r3, #1297	; 0x511
 51122cc:	e12fff33 	blx	r3
 51122d0:	e59d0004 	ldr	r0, [sp, #4]
 51122d4:	eaffffdf 	b	5112258 <elog_init+0x5c>
 51122d8:	05137d7b 	.word	0x05137d7b

051122dc <elog_set_output_enabled>:
    elog.output_enabled = enabled;
 51122dc:	e3073d68 	movw	r3, #32104	; 0x7d68
 51122e0:	e3403513 	movt	r3, #1299	; 0x513
 51122e4:	e5c30059 	strb	r0, [r3, #89]	; 0x59
}
 51122e8:	e12fff1e 	bx	lr

051122ec <elog_get_output_enabled>:
    return elog.output_enabled;
 51122ec:	e3073d68 	movw	r3, #32104	; 0x7d68
 51122f0:	e3403513 	movt	r3, #1299	; 0x513
}
 51122f4:	e5d30059 	ldrb	r0, [r3, #89]	; 0x59
 51122f8:	e12fff1e 	bx	lr

051122fc <elog_clear_filter_tag>:
    elog.filter.tag_num = 0;
 51122fc:	e3073d68 	movw	r3, #32104	; 0x7d68
 5112300:	e3a02000 	mov	r2, #0
 5112304:	e3403513 	movt	r3, #1299	; 0x513
 5112308:	e5c32001 	strb	r2, [r3, #1]
}
 511230c:	e12fff1e 	bx	lr

05112310 <elog_set_filter_tag>:
    elog.filter.tag_num = 0;
 5112310:	e3a02000 	mov	r2, #0
{
 5112314:	e92d4070 	push	{r4, r5, r6, lr}
    elog.filter.tag_num = 0;
 5112318:	e3075d68 	movw	r5, #32104	; 0x7d68
 511231c:	e1a03002 	mov	r3, r2
    int8_t tag_state = 0;
 5112320:	e1a06002 	mov	r6, r2
    elog.filter.tag_num = 0;
 5112324:	e3405513 	movt	r5, #1299	; 0x513
    int8_t start = 0;
 5112328:	e1a01002 	mov	r1, r2
    elog.filter.tag_num = 0;
 511232c:	e5c52001 	strb	r2, [r5, #1]
            if(tag_state == 0)
 5112330:	e6afe073 	sxtb	lr, r3
        if(tag[index] == '\0')
 5112334:	e19020de 	ldrsb	r2, [r0, lr]
 5112338:	e3520000 	cmp	r2, #0
                || (tag[index] >= 'a' && tag[index] <= 'z')
 511233c:	e202c0df 	and	ip, r2, #223	; 0xdf
        else if((tag[index] >= 'A' && tag[index] <= 'Z')
 5112340:	e24cc041 	sub	ip, ip, #65	; 0x41
 5112344:	e6ef4073 	uxtb	r4, r3
        if(tag[index] == '\0')
 5112348:	1a000012 	bne	5112398 <elog_set_filter_tag+0x88>
            len = end - start;
 511234c:	e0444001 	sub	r4, r4, r1
 5112350:	e6af4074 	sxtb	r4, r4
            len = MIN_VAL(len, ELOG_FILTER_TAG_MAX_LEN);
 5112354:	e3540006 	cmp	r4, #6
 5112358:	b1a06004 	movlt	r6, r4
 511235c:	a3a06006 	movge	r6, #6
            if(len > 0)
 5112360:	e3540000 	cmp	r4, #0
 5112364:	da000005 	ble	5112380 <elog_set_filter_tag+0x70>
                strncpy(&elog.filter.tag[elog.filter.tag_num][0], &tag[start], len);
 5112368:	e30a3731 	movw	r3, #42801	; 0xa731
 511236c:	e0801001 	add	r1, r0, r1
 5112370:	e1a02006 	mov	r2, r6
 5112374:	e3403511 	movt	r3, #1297	; 0x511
 5112378:	e59f0054 	ldr	r0, [pc, #84]	; 51123d4 <elog_set_filter_tag+0xc4>
 511237c:	e12fff33 	blx	r3
            elog.filter.tag[elog.filter.tag_num][len] = '\0';
 5112380:	e3a01000 	mov	r1, #0
 5112384:	e0852006 	add	r2, r5, r6
            elog.filter.tag_num++;
 5112388:	e3a03001 	mov	r3, #1
            elog.filter.tag[elog.filter.tag_num][len] = '\0';
 511238c:	e5c21002 	strb	r1, [r2, #2]
            elog.filter.tag_num++;
 5112390:	e5c53001 	strb	r3, [r5, #1]
}
 5112394:	e8bd8070 	pop	{r4, r5, r6, pc}
        else if((tag[index] >= 'A' && tag[index] <= 'Z')
 5112398:	e35c0019 	cmp	ip, #25
                || (tag[index] >= 'a' && tag[index] <= 'z')
 511239c:	e6efc072 	uxtb	ip, r2
                || (tag[index] >= '0' && tag[index] <= '9')
 51123a0:	e24cc030 	sub	ip, ip, #48	; 0x30
        else if((tag[index] >= 'A' && tag[index] <= 'Z')
 51123a4:	9a000002 	bls	51123b4 <elog_set_filter_tag+0xa4>
                || (tag[index] == '_'))
 51123a8:	e352005f 	cmp	r2, #95	; 0x5f
 51123ac:	135c0009 	cmpne	ip, #9
 51123b0:	8a000004 	bhi	51123c8 <elog_set_filter_tag+0xb8>
            if(tag_state == 0)
 51123b4:	e3560000 	cmp	r6, #0
 51123b8:	01a0100e 	moveq	r1, lr
                tag_state = 1;
 51123bc:	03a06001 	moveq	r6, #1
    while(1)
 51123c0:	e2833001 	add	r3, r3, #1
        if(tag[index] == '\0')
 51123c4:	eaffffd9 	b	5112330 <elog_set_filter_tag+0x20>
            if(tag_state == 1)
 51123c8:	e3560001 	cmp	r6, #1
 51123cc:	1afffffb 	bne	51123c0 <elog_set_filter_tag+0xb0>
 51123d0:	eaffffdd 	b	511234c <elog_set_filter_tag+0x3c>
 51123d4:	05137d6a 	.word	0x05137d6a

051123d8 <elog_raw>:
void elog_raw(const char *format, ...) {
 51123d8:	e92d000f 	push	{r0, r1, r2, r3}
 51123dc:	e92d4030 	push	{r4, r5, lr}
    if (!elog.output_enabled) {
 51123e0:	e3074d68 	movw	r4, #32104	; 0x7d68
void elog_raw(const char *format, ...) {
 51123e4:	e24dd00c 	sub	sp, sp, #12
    if (!elog.output_enabled) {
 51123e8:	e3404513 	movt	r4, #1299	; 0x513
 51123ec:	e5d43059 	ldrb	r3, [r4, #89]	; 0x59
 51123f0:	e3530000 	cmp	r3, #0
 51123f4:	1a000003 	bne	5112408 <elog_raw+0x30>
}
 51123f8:	e28dd00c 	add	sp, sp, #12
 51123fc:	e8bd4030 	pop	{r4, r5, lr}
 5112400:	e28dd010 	add	sp, sp, #16
 5112404:	e12fff1e 	bx	lr
    va_start(args, format);
 5112408:	e28d301c 	add	r3, sp, #28
    if (elog.output_lock_enabled) {
 511240c:	e5d4205a 	ldrb	r2, [r4, #90]	; 0x5a
 5112410:	e3520000 	cmp	r2, #0
    va_start(args, format);
 5112414:	e58d3004 	str	r3, [sp, #4]
        elog.output_is_locked_before_enable = true;
 5112418:	03a03001 	moveq	r3, #1
 511241c:	05c4305b 	strbeq	r3, [r4, #91]	; 0x5b
    if (elog.output_lock_enabled) {
 5112420:	1a00001c 	bne	5112498 <elog_raw+0xc0>
    fmt_result = vsnprintf(log_buf, ELOG_LINE_BUF_SIZE, format, args);
 5112424:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5112428:	e30a58fd 	movw	r5, #43261	; 0xa8fd
 511242c:	e59d3004 	ldr	r3, [sp, #4]
 5112430:	e3a01b01 	mov	r1, #1024	; 0x400
 5112434:	e59d2018 	ldr	r2, [sp, #24]
 5112438:	e3400513 	movt	r0, #1299	; 0x513
 511243c:	e3405511 	movt	r5, #1297	; 0x511
 5112440:	e12fff35 	blx	r5
    elog_port_output(log_buf, log_len);
 5112444:	e301362c 	movw	r3, #5676	; 0x162c
 5112448:	e3403511 	movt	r3, #1297	; 0x511
    fmt_result = vsnprintf(log_buf, ELOG_LINE_BUF_SIZE, format, args);
 511244c:	e1a01000 	mov	r1, r0
    elog_port_output(log_buf, log_len);
 5112450:	e3500b01 	cmp	r0, #1024	; 0x400
 5112454:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5112458:	23a01b01 	movcs	r1, #1024	; 0x400
 511245c:	e3400513 	movt	r0, #1299	; 0x513
 5112460:	e12fff33 	blx	r3
    if (elog.output_lock_enabled) {
 5112464:	e5d4305a 	ldrb	r3, [r4, #90]	; 0x5a
 5112468:	e3530000 	cmp	r3, #0
        elog.output_is_locked_before_enable = false;
 511246c:	05c4305b 	strbeq	r3, [r4, #91]	; 0x5b
    if (elog.output_lock_enabled) {
 5112470:	0affffe0 	beq	51123f8 <elog_raw+0x20>
        elog_port_output_unlock();
 5112474:	e3013644 	movw	r3, #5700	; 0x1644
 5112478:	e3403511 	movt	r3, #1297	; 0x511
 511247c:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = false;
 5112480:	e3a03000 	mov	r3, #0
 5112484:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
}
 5112488:	e28dd00c 	add	sp, sp, #12
 511248c:	e8bd4030 	pop	{r4, r5, lr}
 5112490:	e28dd010 	add	sp, sp, #16
 5112494:	e12fff1e 	bx	lr
        elog_port_output_lock();
 5112498:	e3013640 	movw	r3, #5696	; 0x1640
 511249c:	e3403511 	movt	r3, #1297	; 0x511
 51124a0:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = true;
 51124a4:	e3a03001 	mov	r3, #1
 51124a8:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
 51124ac:	eaffffdc 	b	5112424 <elog_raw+0x4c>

051124b0 <elog_output>:
        const long line, const char *format, ...) {
 51124b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 51124b4:	e1a06000 	mov	r6, r0
 51124b8:	e24dd044 	sub	sp, sp, #68	; 0x44
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 51124bc:	e1a00001 	mov	r0, r1
        const long line, const char *format, ...) {
 51124c0:	e1a04001 	mov	r4, r1
 51124c4:	e58d3018 	str	r3, [sp, #24]
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 51124c8:	e3003331 	movw	r3, #817	; 0x331
        const long line, const char *format, ...) {
 51124cc:	e1a08002 	mov	r8, r2
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 51124d0:	e3403511 	movt	r3, #1297	; 0x511
 51124d4:	e12fff33 	blx	r3
    char line_num[ELOG_LINE_NUM_MAX_LEN + 1] = { 0 };
 51124d8:	e3a03000 	mov	r3, #0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51124dc:	e3560005 	cmp	r6, #5
    char line_num[ELOG_LINE_NUM_MAX_LEN + 1] = { 0 };
 51124e0:	e58d3030 	str	r3, [sp, #48]	; 0x30
 51124e4:	e1cd33b4 	strh	r3, [sp, #52]	; 0x34
    char tag_sapce[ELOG_FILTER_TAG_MAX_LEN + 1] = { 0 };
 51124e8:	e58d3038 	str	r3, [sp, #56]	; 0x38
 51124ec:	e1cd33bc 	strh	r3, [sp, #60]	; 0x3c
 51124f0:	e5cd303e 	strb	r3, [sp, #62]	; 0x3e
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 51124f4:	e1a07000 	mov	r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51124f8:	9a00000a 	bls	5112528 <elog_output+0x78>
 51124fc:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112500:	e3409513 	movt	r9, #1299	; 0x513
 5112504:	e5995000 	ldr	r5, [r9]
 5112508:	e1550003 	cmp	r5, r3
 511250c:	0a0000cf 	beq	5112850 <elog_output+0x3a0>
 5112510:	e30d15ac 	movw	r1, #54700	; 0xd5ac
 5112514:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112518:	e3401512 	movt	r1, #1298	; 0x512
 511251c:	e3002261 	movw	r2, #609	; 0x261
 5112520:	e3400512 	movt	r0, #1298	; 0x512
 5112524:	e12fff35 	blx	r5
    if (!elog.output_enabled) {
 5112528:	e3075d68 	movw	r5, #32104	; 0x7d68
 511252c:	e3405513 	movt	r5, #1299	; 0x513
 5112530:	e5d53059 	ldrb	r3, [r5, #89]	; 0x59
 5112534:	e3530000 	cmp	r3, #0
 5112538:	0a000002 	beq	5112548 <elog_output+0x98>
    if (level > elog.filter.level || level > elog_get_filter_tag_lvl(tag)) 
 511253c:	e5d53000 	ldrb	r3, [r5]
 5112540:	e1530006 	cmp	r3, r6
 5112544:	2a000001 	bcs	5112550 <elog_output+0xa0>
}
 5112548:	e28dd044 	add	sp, sp, #68	; 0x44
 511254c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (level > elog.filter.level || level > elog_get_filter_tag_lvl(tag)) 
 5112550:	e30334c0 	movw	r3, #13504	; 0x34c0
 5112554:	e1a00004 	mov	r0, r4
 5112558:	e3403511 	movt	r3, #1297	; 0x511
 511255c:	e12fff33 	blx	r3
 5112560:	e1500006 	cmp	r0, r6
 5112564:	3afffff7 	bcc	5112548 <elog_output+0x98>
        for(index = 0; index < elog.filter.tag_num; index++)
 5112568:	e5d53001 	ldrb	r3, [r5, #1]
 511256c:	e3530000 	cmp	r3, #0
 5112570:	0a000010 	beq	51125b8 <elog_output+0x108>
 5112574:	e2433001 	sub	r3, r3, #1
 5112578:	e3a0a007 	mov	sl, #7
 511257c:	e2852009 	add	r2, r5, #9
 5112580:	e30a9757 	movw	r9, #42839	; 0xa757
 5112584:	e6ef3073 	uxtb	r3, r3
 5112588:	e3409511 	movt	r9, #1297	; 0x511
 511258c:	e10a238a 	smlabb	sl, sl, r3, r2
 5112590:	e285b002 	add	fp, r5, #2
 5112594:	ea000001 	b	51125a0 <elog_output+0xf0>
 5112598:	e15a000b 	cmp	sl, fp
 511259c:	0affffe9 	beq	5112548 <elog_output+0x98>
            if (strstr(tag, &elog.filter.tag[index][0]))
 51125a0:	e1a0100b 	mov	r1, fp
 51125a4:	e1a00004 	mov	r0, r4
 51125a8:	e12fff39 	blx	r9
        for(index = 0; index < elog.filter.tag_num; index++)
 51125ac:	e28bb007 	add	fp, fp, #7
            if (strstr(tag, &elog.filter.tag[index][0]))
 51125b0:	e3500000 	cmp	r0, #0
 51125b4:	0afffff7 	beq	5112598 <elog_output+0xe8>
    va_start(args, format);
 51125b8:	e28d3070 	add	r3, sp, #112	; 0x70
 51125bc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    if (elog.output_lock_enabled) {
 51125c0:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 51125c4:	e3530000 	cmp	r3, #0
        elog.output_is_locked_before_enable = true;
 51125c8:	03a03001 	moveq	r3, #1
 51125cc:	05c5305b 	strbeq	r3, [r5, #91]	; 0x5b
    if (elog.output_lock_enabled) {
 51125d0:	1a000222 	bne	5112e60 <elog_output+0x9b0>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51125d4:	e3560005 	cmp	r6, #5
 51125d8:	9a0000ae 	bls	5112898 <elog_output+0x3e8>
 51125dc:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 51125e0:	e3409513 	movt	r9, #1299	; 0x513
 51125e4:	e599a000 	ldr	sl, [r9]
 51125e8:	e35a0000 	cmp	sl, #0
 51125ec:	0a000242 	beq	5112efc <elog_output+0xa4c>
 51125f0:	e30d159c 	movw	r1, #54684	; 0xd59c
    if (elog.enabled_fmt_set[level] & set) {
 51125f4:	e286b010 	add	fp, r6, #16
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51125f8:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51125fc:	e3401512 	movt	r1, #1298	; 0x512
 5112600:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112604:	e3400512 	movt	r0, #1298	; 0x512
 5112608:	e12fff3a 	blx	sl
    if (elog.enabled_fmt_set[level] & set) {
 511260c:	e795a10b 	ldr	sl, [r5, fp, lsl #2]
 5112610:	e21aa001 	ands	sl, sl, #1
 5112614:	1a0000a3 	bne	51128a8 <elog_output+0x3f8>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112618:	e5993000 	ldr	r3, [r9]
 511261c:	e3530000 	cmp	r3, #0
 5112620:	0a000247 	beq	5112f44 <elog_output+0xa94>
 5112624:	e30d159c 	movw	r1, #54684	; 0xd59c
 5112628:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 511262c:	e3401512 	movt	r1, #1298	; 0x512
 5112630:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112634:	e3400512 	movt	r0, #1298	; 0x512
 5112638:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 511263c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112640:	e3130002 	tst	r3, #2
 5112644:	03074dcc 	movweq	r4, #32204	; 0x7dcc
 5112648:	03404513 	movteq	r4, #1299	; 0x513
 511264c:	1a00019b 	bne	5112cc0 <elog_output+0x810>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112650:	e5997000 	ldr	r7, [r9]
 5112654:	e30d359c 	movw	r3, #54684	; 0xd59c
 5112658:	e3570000 	cmp	r7, #0
 511265c:	0a00024c 	beq	5112f94 <elog_output+0xae4>
 5112660:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112664:	e3403512 	movt	r3, #1298	; 0x512
 5112668:	e3a02fc7 	mov	r2, #796	; 0x31c
 511266c:	e3400512 	movt	r0, #1298	; 0x512
 5112670:	e58d301c 	str	r3, [sp, #28]
 5112674:	e1a01003 	mov	r1, r3
 5112678:	e58d0020 	str	r0, [sp, #32]
 511267c:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 5112680:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112684:	e59d301c 	ldr	r3, [sp, #28]
 5112688:	e312001c 	tst	r2, #28
 511268c:	0a0000bd 	beq	5112988 <elog_output+0x4d8>
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5112690:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5112694:	e3043718 	movw	r3, #18200	; 0x4718
 5112698:	e30d24f0 	movw	r2, #54512	; 0xd4f0
 511269c:	e3403511 	movt	r3, #1297	; 0x511
 51126a0:	e3402512 	movt	r2, #1298	; 0x512
 51126a4:	e1a0000a 	mov	r0, sl
 51126a8:	e084100a 	add	r1, r4, sl
 51126ac:	e58d301c 	str	r3, [sp, #28]
 51126b0:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51126b4:	e5993000 	ldr	r3, [r9]
 51126b8:	e253e000 	subs	lr, r3, #0
 51126bc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 51126c0:	0a000254 	beq	5113018 <elog_output+0xb68>
 51126c4:	e3a02fc7 	mov	r2, #796	; 0x31c
 51126c8:	e1a01003 	mov	r1, r3
 51126cc:	e58d3024 	str	r3, [sp, #36]	; 0x24
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 51126d0:	e080700a 	add	r7, r0, sl
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51126d4:	e59d0020 	ldr	r0, [sp, #32]
 51126d8:	e1a0300e 	mov	r3, lr
 51126dc:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 51126e0:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 51126e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 51126e8:	e3120004 	tst	r2, #4
 51126ec:	0a00001d 	beq	5112768 <elog_output+0x2b8>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 51126f0:	e58d3024 	str	r3, [sp, #36]	; 0x24
 51126f4:	e3012648 	movw	r2, #5704	; 0x1648
 51126f8:	e3402511 	movt	r2, #1297	; 0x511
 51126fc:	e12fff32 	blx	r2
 5112700:	e59d301c 	ldr	r3, [sp, #28]
 5112704:	e0841007 	add	r1, r4, r7
 5112708:	e1a02000 	mov	r2, r0
 511270c:	e1a00007 	mov	r0, r7
 5112710:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112714:	e599a000 	ldr	sl, [r9]
 5112718:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 511271c:	e35a0000 	cmp	sl, #0
 5112720:	0a0002d8 	beq	5113288 <elog_output+0xdd8>
 5112724:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112728:	e1a01003 	mov	r1, r3
 511272c:	e58d3024 	str	r3, [sp, #36]	; 0x24
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5112730:	e0877000 	add	r7, r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112734:	e59d0020 	ldr	r0, [sp, #32]
 5112738:	e12fff3a 	blx	sl
    if (elog.enabled_fmt_set[level] & set) {
 511273c:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112740:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112744:	e3120018 	tst	r2, #24
 5112748:	0a00000f 	beq	511278c <elog_output+0x2dc>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 511274c:	e30d2554 	movw	r2, #54612	; 0xd554
 5112750:	e0841007 	add	r1, r4, r7
 5112754:	e1a00007 	mov	r0, r7
 5112758:	e3402512 	movt	r2, #1298	; 0x512
 511275c:	e59d301c 	ldr	r3, [sp, #28]
 5112760:	e12fff33 	blx	r3
 5112764:	e0877000 	add	r7, r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112768:	e3560005 	cmp	r6, #5
 511276c:	9a00006f 	bls	5112930 <elog_output+0x480>
 5112770:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 5112774:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112778:	e3403512 	movt	r3, #1298	; 0x512
 511277c:	e3409513 	movt	r9, #1299	; 0x513
 5112780:	e58d3020 	str	r3, [sp, #32]
 5112784:	e30d359c 	movw	r3, #54684	; 0xd59c
 5112788:	e3403512 	movt	r3, #1298	; 0x512
 511278c:	e599a000 	ldr	sl, [r9]
 5112790:	e35a0000 	cmp	sl, #0
 5112794:	0a00022f 	beq	5113058 <elog_output+0xba8>
 5112798:	e30d159c 	movw	r1, #54684	; 0xd59c
 511279c:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51127a0:	e3a02fc7 	mov	r2, #796	; 0x31c
 51127a4:	e3401512 	movt	r1, #1298	; 0x512
 51127a8:	e58d3024 	str	r3, [sp, #36]	; 0x24
 51127ac:	e3400512 	movt	r0, #1298	; 0x512
 51127b0:	e12fff3a 	blx	sl
    if (elog.enabled_fmt_set[level] & set) {
 51127b4:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 51127b8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 51127bc:	e3120008 	tst	r2, #8
 51127c0:	0a0001c8 	beq	5112ee8 <elog_output+0xa38>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 51127c4:	e58d3024 	str	r3, [sp, #36]	; 0x24
 51127c8:	e301298c 	movw	r2, #6540	; 0x198c
 51127cc:	e3402511 	movt	r2, #1297	; 0x511
 51127d0:	e12fff32 	blx	r2
 51127d4:	e59d301c 	ldr	r3, [sp, #28]
 51127d8:	e0841007 	add	r1, r4, r7
 51127dc:	e1a02000 	mov	r2, r0
 51127e0:	e1a00007 	mov	r0, r7
 51127e4:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51127e8:	e599a000 	ldr	sl, [r9]
 51127ec:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 51127f0:	e35a0000 	cmp	sl, #0
 51127f4:	0a00026f 	beq	51131b8 <elog_output+0xd08>
 51127f8:	e30d159c 	movw	r1, #54684	; 0xd59c
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 51127fc:	e0877000 	add	r7, r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112800:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112804:	e3401512 	movt	r1, #1298	; 0x512
 5112808:	e3a02fc7 	mov	r2, #796	; 0x31c
 511280c:	e3400512 	movt	r0, #1298	; 0x512
 5112810:	e12fff3a 	blx	sl
    if (elog.enabled_fmt_set[level] & set) {
 5112814:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112818:	e3130010 	tst	r3, #16
 511281c:	1a0001aa 	bne	5112ecc <elog_output+0xa1c>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112820:	e3560005 	cmp	r6, #5
 5112824:	9a000050 	bls	511296c <elog_output+0x4bc>
 5112828:	e5999000 	ldr	r9, [r9]
 511282c:	e3590000 	cmp	r9, #0
 5112830:	0a00021a 	beq	51130a0 <elog_output+0xbf0>
 5112834:	e30d159c 	movw	r1, #54684	; 0xd59c
 5112838:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 511283c:	e3401512 	movt	r1, #1298	; 0x512
 5112840:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112844:	e3400512 	movt	r0, #1298	; 0x512
 5112848:	e12fff39 	blx	r9
 511284c:	ea00003a 	b	511293c <elog_output+0x48c>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112850:	e30d35ac 	movw	r3, #54700	; 0xd5ac
 5112854:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5112858:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511285c:	e3402512 	movt	r2, #1298	; 0x512
 5112860:	e3401512 	movt	r1, #1298	; 0x512
 5112864:	e300c261 	movw	ip, #609	; 0x261
 5112868:	e3403512 	movt	r3, #1298	; 0x512
 511286c:	e58d1004 	str	r1, [sp, #4]
 5112870:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5112874:	e1cd20f8 	strd	r2, [sp, #8]
 5112878:	e30d2484 	movw	r2, #54404	; 0xd484
 511287c:	e1a00005 	mov	r0, r5
 5112880:	e3402512 	movt	r2, #1298	; 0x512
 5112884:	e58dc010 	str	ip, [sp, #16]
 5112888:	e3401512 	movt	r1, #1298	; 0x512
 511288c:	e58dc000 	str	ip, [sp]
 5112890:	ebffff06 	bl	51124b0 <elog_output>
 5112894:	eafffffe 	b	5112894 <elog_output+0x3e4>
    if (elog.enabled_fmt_set[level] & set) {
 5112898:	e286b010 	add	fp, r6, #16
 511289c:	e795a10b 	ldr	sl, [r5, fp, lsl #2]
 51128a0:	e21aa001 	ands	sl, sl, #1
 51128a4:	0a00000d 	beq	51128e0 <elog_output+0x430>
        log_len += elog_strcpy(log_len, log_buf + log_len, level_output_info[level]);
 51128a8:	e30d35f4 	movw	r3, #54772	; 0xd5f4
 51128ac:	e3071dcc 	movw	r1, #32204	; 0x7dcc
 51128b0:	e3403512 	movt	r3, #1298	; 0x512
 51128b4:	e3a00000 	mov	r0, #0
 51128b8:	e3401513 	movt	r1, #1299	; 0x513
 51128bc:	e7932106 	ldr	r2, [r3, r6, lsl #2]
 51128c0:	e3043718 	movw	r3, #18200	; 0x4718
 51128c4:	e3403511 	movt	r3, #1297	; 0x511
 51128c8:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51128cc:	e3560005 	cmp	r6, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, level_output_info[level]);
 51128d0:	e1a0a000 	mov	sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51128d4:	83079dc8 	movwhi	r9, #32200	; 0x7dc8
 51128d8:	83409513 	movthi	r9, #1299	; 0x513
 51128dc:	8affff4d 	bhi	5112618 <elog_output+0x168>
    if (elog.enabled_fmt_set[level] & set) {
 51128e0:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 51128e4:	e3130002 	tst	r3, #2
 51128e8:	03074dcc 	movweq	r4, #32204	; 0x7dcc
 51128ec:	03404513 	movteq	r4, #1299	; 0x513
 51128f0:	1a0000f2 	bne	5112cc0 <elog_output+0x810>
 51128f4:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 51128f8:	e313001c 	tst	r3, #28
 51128fc:	0a000107 	beq	5112d20 <elog_output+0x870>
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5112900:	e3043718 	movw	r3, #18200	; 0x4718
 5112904:	e30d24f0 	movw	r2, #54512	; 0xd4f0
 5112908:	e3403511 	movt	r3, #1297	; 0x511
 511290c:	e3402512 	movt	r2, #1298	; 0x512
 5112910:	e1a0000a 	mov	r0, sl
 5112914:	e084100a 	add	r1, r4, sl
 5112918:	e58d301c 	str	r3, [sp, #28]
 511291c:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112920:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112924:	e3130004 	tst	r3, #4
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5112928:	e080700a 	add	r7, r0, sl
    if (elog.enabled_fmt_set[level] & set) {
 511292c:	1a0001a9 	bne	5112fd8 <elog_output+0xb28>
 5112930:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112934:	e3130008 	tst	r3, #8
 5112938:	1a000157 	bne	5112e9c <elog_output+0x9ec>
 511293c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112940:	e3130010 	tst	r3, #16
 5112944:	0a000008 	beq	511296c <elog_output+0x4bc>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_t_info());
 5112948:	e3013998 	movw	r3, #6552	; 0x1998
 511294c:	e3403511 	movt	r3, #1297	; 0x511
 5112950:	e12fff33 	blx	r3
 5112954:	e59d301c 	ldr	r3, [sp, #28]
 5112958:	e0841007 	add	r1, r4, r7
 511295c:	e1a02000 	mov	r2, r0
 5112960:	e1a00007 	mov	r0, r7
 5112964:	e12fff33 	blx	r3
 5112968:	e0877000 	add	r7, r7, r0
        log_len += elog_strcpy(log_len, log_buf + log_len, "] ");
 511296c:	e30d24f4 	movw	r2, #54516	; 0xd4f4
 5112970:	e0841007 	add	r1, r4, r7
 5112974:	e59d301c 	ldr	r3, [sp, #28]
 5112978:	e3402512 	movt	r2, #1298	; 0x512
 511297c:	e1a00007 	mov	r0, r7
 5112980:	e12fff33 	blx	r3
 5112984:	e087a000 	add	sl, r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112988:	e3560005 	cmp	r6, #5
 511298c:	9a0000e3 	bls	5112d20 <elog_output+0x870>
 5112990:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112994:	e30d359c 	movw	r3, #54684	; 0xd59c
 5112998:	e3409513 	movt	r9, #1299	; 0x513
 511299c:	e5997000 	ldr	r7, [r9]
 51129a0:	e3570000 	cmp	r7, #0
 51129a4:	0a00011c 	beq	5112e1c <elog_output+0x96c>
 51129a8:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51129ac:	e3403512 	movt	r3, #1298	; 0x512
 51129b0:	e3a02fc7 	mov	r2, #796	; 0x31c
 51129b4:	e3400512 	movt	r0, #1298	; 0x512
 51129b8:	e58d301c 	str	r3, [sp, #28]
 51129bc:	e1a01003 	mov	r1, r3
 51129c0:	e58d0020 	str	r0, [sp, #32]
 51129c4:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 51129c8:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 51129cc:	e59d301c 	ldr	r3, [sp, #28]
 51129d0:	e31200e0 	tst	r2, #224	; 0xe0
 51129d4:	0a000089 	beq	5112c00 <elog_output+0x750>
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 51129d8:	e58d3024 	str	r3, [sp, #36]	; 0x24
 51129dc:	e3043718 	movw	r3, #18200	; 0x4718
 51129e0:	e30d2500 	movw	r2, #54528	; 0xd500
 51129e4:	e3403511 	movt	r3, #1297	; 0x511
 51129e8:	e3402512 	movt	r2, #1298	; 0x512
 51129ec:	e1a0000a 	mov	r0, sl
 51129f0:	e084100a 	add	r1, r4, sl
 51129f4:	e58d301c 	str	r3, [sp, #28]
 51129f8:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51129fc:	e5997000 	ldr	r7, [r9]
 5112a00:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112a04:	e3570000 	cmp	r7, #0
 5112a08:	0a0001b6 	beq	51130e8 <elog_output+0xc38>
 5112a0c:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112a10:	e1a01003 	mov	r1, r3
 5112a14:	e58d3024 	str	r3, [sp, #36]	; 0x24
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5112a18:	e080a00a 	add	sl, r0, sl
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112a1c:	e59d0020 	ldr	r0, [sp, #32]
 5112a20:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 5112a24:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112a28:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112a2c:	e3120020 	tst	r2, #32
 5112a30:	0a00002f 	beq	5112af4 <elog_output+0x644>
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5112a34:	e1a02008 	mov	r2, r8
 5112a38:	e084100a 	add	r1, r4, sl
 5112a3c:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5112a40:	e1a0000a 	mov	r0, sl
 5112a44:	e59d301c 	ldr	r3, [sp, #28]
 5112a48:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112a4c:	e5998000 	ldr	r8, [r9]
 5112a50:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112a54:	e3580000 	cmp	r8, #0
 5112a58:	0a0001e8 	beq	5113200 <elog_output+0xd50>
 5112a5c:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112a60:	e1a01003 	mov	r1, r3
 5112a64:	e58d3024 	str	r3, [sp, #36]	; 0x24
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5112a68:	e08aa000 	add	sl, sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112a6c:	e59d0020 	ldr	r0, [sp, #32]
 5112a70:	e12fff38 	blx	r8
    if (elog.enabled_fmt_set[level] & set) {
 5112a74:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112a78:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112a7c:	e3120040 	tst	r2, #64	; 0x40
 5112a80:	1a000161 	bne	511300c <elog_output+0xb5c>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112a84:	e5998000 	ldr	r8, [r9]
 5112a88:	e3580000 	cmp	r8, #0
 5112a8c:	0a00020d 	beq	51132c8 <elog_output+0xe18>
 5112a90:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112a94:	e1a01003 	mov	r1, r3
 5112a98:	e59d0020 	ldr	r0, [sp, #32]
 5112a9c:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5112aa0:	e12fff38 	blx	r8
    if (elog.enabled_fmt_set[level] & set) {
 5112aa4:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112aa8:	e3120080 	tst	r2, #128	; 0x80
 5112aac:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
 5112ab0:	0a00000f 	beq	5112af4 <elog_output+0x644>
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5112ab4:	e30c2ee8 	movw	r2, #52968	; 0xcee8
 5112ab8:	e3402512 	movt	r2, #1298	; 0x512
 5112abc:	e1a0000a 	mov	r0, sl
 5112ac0:	e084100a 	add	r1, r4, sl
 5112ac4:	e59d301c 	ldr	r3, [sp, #28]
 5112ac8:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112acc:	e3560005 	cmp	r6, #5
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5112ad0:	e08aa000 	add	sl, sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112ad4:	9a0000ab 	bls	5112d88 <elog_output+0x8d8>
 5112ad8:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 5112adc:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112ae0:	e3403512 	movt	r3, #1298	; 0x512
 5112ae4:	e3409513 	movt	r9, #1299	; 0x513
 5112ae8:	e58d3020 	str	r3, [sp, #32]
 5112aec:	e30d359c 	movw	r3, #54684	; 0xd59c
 5112af0:	e3403512 	movt	r3, #1298	; 0x512
 5112af4:	e5998000 	ldr	r8, [r9]
 5112af8:	e3580000 	cmp	r8, #0
 5112afc:	0a000189 	beq	5113128 <elog_output+0xc78>
 5112b00:	e30d159c 	movw	r1, #54684	; 0xd59c
 5112b04:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112b08:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112b0c:	e3401512 	movt	r1, #1298	; 0x512
 5112b10:	e58d3024 	str	r3, [sp, #36]	; 0x24
 5112b14:	e3400512 	movt	r0, #1298	; 0x512
 5112b18:	e12fff38 	blx	r8
    if (elog.enabled_fmt_set[level] & set) {
 5112b1c:	e795210b 	ldr	r2, [r5, fp, lsl #2]
 5112b20:	e3120040 	tst	r2, #64	; 0x40
 5112b24:	0a0000aa 	beq	5112dd4 <elog_output+0x924>
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5112b28:	e59d301c 	ldr	r3, [sp, #28]
 5112b2c:	e084100a 	add	r1, r4, sl
 5112b30:	e59d2018 	ldr	r2, [sp, #24]
 5112b34:	e1a0000a 	mov	r0, sl
 5112b38:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112b3c:	e5998000 	ldr	r8, [r9]
 5112b40:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
 5112b44:	e3580000 	cmp	r8, #0
 5112b48:	0a0001bc 	beq	5113240 <elog_output+0xd90>
 5112b4c:	e30d159c 	movw	r1, #54684	; 0xd59c
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5112b50:	e08aa000 	add	sl, sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112b54:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112b58:	e3401512 	movt	r1, #1298	; 0x512
 5112b5c:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112b60:	e3400512 	movt	r0, #1298	; 0x512
 5112b64:	e12fff38 	blx	r8
    if (elog.enabled_fmt_set[level] & set) {
 5112b68:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112b6c:	e3130080 	tst	r3, #128	; 0x80
 5112b70:	1a000090 	bne	5112db8 <elog_output+0x908>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112b74:	e3560005 	cmp	r6, #5
 5112b78:	9a000019 	bls	5112be4 <elog_output+0x734>
 5112b7c:	e5996000 	ldr	r6, [r9]
 5112b80:	e3560000 	cmp	r6, #0
 5112b84:	0a000179 	beq	5113170 <elog_output+0xcc0>
 5112b88:	e30d159c 	movw	r1, #54684	; 0xd59c
 5112b8c:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5112b90:	e3401512 	movt	r1, #1298	; 0x512
 5112b94:	e3a02fc7 	mov	r2, #796	; 0x31c
 5112b98:	e3400512 	movt	r0, #1298	; 0x512
 5112b9c:	e12fff36 	blx	r6
    if (elog.enabled_fmt_set[level] & set) {
 5112ba0:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112ba4:	e3130080 	tst	r3, #128	; 0x80
 5112ba8:	0a00000d 	beq	5112be4 <elog_output+0x734>
            snprintf(line_num, ELOG_LINE_NUM_MAX_LEN, "%ld", line);
 5112bac:	e30d24f8 	movw	r2, #54520	; 0xd4f8
 5112bb0:	e30a668d 	movw	r6, #42637	; 0xa68d
 5112bb4:	e59d3068 	ldr	r3, [sp, #104]	; 0x68
 5112bb8:	e3402512 	movt	r2, #1298	; 0x512
 5112bbc:	e3a01005 	mov	r1, #5
 5112bc0:	e3406511 	movt	r6, #1297	; 0x511
 5112bc4:	e28d0030 	add	r0, sp, #48	; 0x30
 5112bc8:	e12fff36 	blx	r6
            log_len += elog_strcpy(log_len, log_buf + log_len, line_num);
 5112bcc:	e1a0000a 	mov	r0, sl
 5112bd0:	e59d301c 	ldr	r3, [sp, #28]
 5112bd4:	e084100a 	add	r1, r4, sl
 5112bd8:	e28d2030 	add	r2, sp, #48	; 0x30
 5112bdc:	e12fff33 	blx	r3
 5112be0:	e08aa000 	add	sl, sl, r0
        log_len += elog_strcpy(log_len, log_buf + log_len, ")");
 5112be4:	e30d24fc 	movw	r2, #54524	; 0xd4fc
 5112be8:	e084100a 	add	r1, r4, sl
 5112bec:	e1a0000a 	mov	r0, sl
 5112bf0:	e3402512 	movt	r2, #1298	; 0x512
 5112bf4:	e59d301c 	ldr	r3, [sp, #28]
 5112bf8:	e12fff33 	blx	r3
 5112bfc:	e08aa000 	add	sl, sl, r0
    fmt_result = vsnprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, format, args);
 5112c00:	e30a68fd 	movw	r6, #43261	; 0xa8fd
 5112c04:	e26a1b01 	rsb	r1, sl, #1024	; 0x400
 5112c08:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5112c0c:	e084000a 	add	r0, r4, sl
 5112c10:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
 5112c14:	e3406511 	movt	r6, #1297	; 0x511
 5112c18:	e12fff36 	blx	r6
    if ((log_len + fmt_result <= ELOG_LINE_BUF_SIZE) && (fmt_result > -1)) {
 5112c1c:	e30033fe 	movw	r3, #1022	; 0x3fe
 5112c20:	e080a00a 	add	sl, r0, sl
 5112c24:	e1e00000 	mvn	r0, r0
 5112c28:	e15a0003 	cmp	sl, r3
 5112c2c:	e1a00fa0 	lsr	r0, r0, #31
 5112c30:	83a00000 	movhi	r0, #0
        log_len -= newline_len;
 5112c34:	e3500000 	cmp	r0, #0
 5112c38:	01a0a003 	moveq	sl, r3
    if (elog.filter.keyword[0] != '\0') {
 5112c3c:	e1d530d9 	ldrsb	r3, [r5, #9]
 5112c40:	e3530000 	cmp	r3, #0
 5112c44:	0a000009 	beq	5112c70 <elog_output+0x7c0>
        log_buf[log_len] = '\0';
 5112c48:	e3a03000 	mov	r3, #0
        if (!strstr(log_buf, elog.filter.keyword)) {
 5112c4c:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5112c50:	e59f16b0 	ldr	r1, [pc, #1712]	; 5113308 <elog_output+0xe58>
 5112c54:	e3400513 	movt	r0, #1299	; 0x513
        log_buf[log_len] = '\0';
 5112c58:	e7c4300a 	strb	r3, [r4, sl]
        if (!strstr(log_buf, elog.filter.keyword)) {
 5112c5c:	e30a3757 	movw	r3, #42839	; 0xa757
 5112c60:	e3403511 	movt	r3, #1297	; 0x511
 5112c64:	e12fff33 	blx	r3
 5112c68:	e3500000 	cmp	r0, #0
 5112c6c:	0a000081 	beq	5112e78 <elog_output+0x9c8>
    log_len += elog_strcpy(log_len, log_buf + log_len, ELOG_NEWLINE_SIGN);
 5112c70:	e30d23e0 	movw	r2, #54240	; 0xd3e0
 5112c74:	e3043718 	movw	r3, #18200	; 0x4718
 5112c78:	e084100a 	add	r1, r4, sl
 5112c7c:	e3402512 	movt	r2, #1298	; 0x512
 5112c80:	e1a0000a 	mov	r0, sl
 5112c84:	e3403511 	movt	r3, #1297	; 0x511
 5112c88:	e12fff33 	blx	r3
    elog_port_output(log_buf, log_len);
 5112c8c:	e301362c 	movw	r3, #5676	; 0x162c
 5112c90:	e3403511 	movt	r3, #1297	; 0x511
    log_len += elog_strcpy(log_len, log_buf + log_len, ELOG_NEWLINE_SIGN);
 5112c94:	e1a01000 	mov	r1, r0
    elog_port_output(log_buf, log_len);
 5112c98:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5112c9c:	e08a1001 	add	r1, sl, r1
 5112ca0:	e3400513 	movt	r0, #1299	; 0x513
 5112ca4:	e12fff33 	blx	r3
    if (elog.output_lock_enabled) {
 5112ca8:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 5112cac:	e3530000 	cmp	r3, #0
 5112cb0:	1a000073 	bne	5112e84 <elog_output+0x9d4>
        elog.output_is_locked_before_enable = false;
 5112cb4:	e3a03000 	mov	r3, #0
 5112cb8:	e5c5305b 	strb	r3, [r5, #91]	; 0x5b
 5112cbc:	eafffe21 	b	5112548 <elog_output+0x98>
        log_len += elog_strcpy(log_len, log_buf + log_len, tag);
 5112cc0:	e1a02004 	mov	r2, r4
 5112cc4:	e3043718 	movw	r3, #18200	; 0x4718
 5112cc8:	e3074dcc 	movw	r4, #32204	; 0x7dcc
 5112ccc:	e3403511 	movt	r3, #1297	; 0x511
 5112cd0:	e1a0000a 	mov	r0, sl
 5112cd4:	e3404513 	movt	r4, #1299	; 0x513
 5112cd8:	e58d301c 	str	r3, [sp, #28]
 5112cdc:	e084100a 	add	r1, r4, sl
 5112ce0:	e12fff33 	blx	r3
        if (tag_len < ELOG_FILTER_TAG_MAX_LEN) 
 5112ce4:	e3570005 	cmp	r7, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, tag);
 5112ce8:	e080a00a 	add	sl, r0, sl
        if (tag_len < ELOG_FILTER_TAG_MAX_LEN) 
 5112cec:	9a00003d 	bls	5112de8 <elog_output+0x938>
        log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5112cf0:	e30d2554 	movw	r2, #54612	; 0xd554
 5112cf4:	e084100a 	add	r1, r4, sl
 5112cf8:	e1a0000a 	mov	r0, sl
 5112cfc:	e3402512 	movt	r2, #1298	; 0x512
 5112d00:	e59d301c 	ldr	r3, [sp, #28]
 5112d04:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112d08:	e3560005 	cmp	r6, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5112d0c:	e08aa000 	add	sl, sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112d10:	9afffef7 	bls	51128f4 <elog_output+0x444>
 5112d14:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112d18:	e3409513 	movt	r9, #1299	; 0x513
 5112d1c:	eafffe4b 	b	5112650 <elog_output+0x1a0>
    if (elog.enabled_fmt_set[level] & set) {
 5112d20:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112d24:	e31300e0 	tst	r3, #224	; 0xe0
 5112d28:	0affffb4 	beq	5112c00 <elog_output+0x750>
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5112d2c:	e3043718 	movw	r3, #18200	; 0x4718
 5112d30:	e30d2500 	movw	r2, #54528	; 0xd500
 5112d34:	e3403511 	movt	r3, #1297	; 0x511
 5112d38:	e1a0000a 	mov	r0, sl
 5112d3c:	e084100a 	add	r1, r4, sl
 5112d40:	e58d301c 	str	r3, [sp, #28]
 5112d44:	e3402512 	movt	r2, #1298	; 0x512
 5112d48:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112d4c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112d50:	e3130020 	tst	r3, #32
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5112d54:	e080a00a 	add	sl, r0, sl
    if (elog.enabled_fmt_set[level] & set) {
 5112d58:	0a00000a 	beq	5112d88 <elog_output+0x8d8>
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5112d5c:	e59d301c 	ldr	r3, [sp, #28]
 5112d60:	e084100a 	add	r1, r4, sl
 5112d64:	e1a0000a 	mov	r0, sl
 5112d68:	e1a02008 	mov	r2, r8
 5112d6c:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112d70:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112d74:	e3130040 	tst	r3, #64	; 0x40
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5112d78:	e08aa000 	add	sl, sl, r0
    if (elog.enabled_fmt_set[level] & set) {
 5112d7c:	1a0000a2 	bne	511300c <elog_output+0xb5c>
 5112d80:	e3130080 	tst	r3, #128	; 0x80
 5112d84:	1affff4a 	bne	5112ab4 <elog_output+0x604>
 5112d88:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112d8c:	e3130040 	tst	r3, #64	; 0x40
 5112d90:	0affff83 	beq	5112ba4 <elog_output+0x6f4>
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5112d94:	e59d301c 	ldr	r3, [sp, #28]
 5112d98:	e084100a 	add	r1, r4, sl
 5112d9c:	e59d2018 	ldr	r2, [sp, #24]
 5112da0:	e1a0000a 	mov	r0, sl
 5112da4:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112da8:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112dac:	e3130080 	tst	r3, #128	; 0x80
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5112db0:	e08aa000 	add	sl, sl, r0
    if (elog.enabled_fmt_set[level] & set) {
 5112db4:	0affff8a 	beq	5112be4 <elog_output+0x734>
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5112db8:	e30c2ee8 	movw	r2, #52968	; 0xcee8
 5112dbc:	e084100a 	add	r1, r4, sl
 5112dc0:	e1a0000a 	mov	r0, sl
 5112dc4:	e3402512 	movt	r2, #1298	; 0x512
 5112dc8:	e59d301c 	ldr	r3, [sp, #28]
 5112dcc:	e12fff33 	blx	r3
 5112dd0:	e08aa000 	add	sl, sl, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112dd4:	e3560005 	cmp	r6, #5
 5112dd8:	9affff70 	bls	5112ba0 <elog_output+0x6f0>
 5112ddc:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112de0:	e3409513 	movt	r9, #1299	; 0x513
 5112de4:	eaffff64 	b	5112b7c <elog_output+0x6cc>
            memset(tag_sapce, ' ', ELOG_FILTER_TAG_MAX_LEN - tag_len);
 5112de8:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5112dec:	e2672006 	rsb	r2, r7, #6
 5112df0:	e3a01020 	mov	r1, #32
 5112df4:	e3403511 	movt	r3, #1297	; 0x511
 5112df8:	e28d0038 	add	r0, sp, #56	; 0x38
 5112dfc:	e12fff33 	blx	r3
            log_len += elog_strcpy(log_len, log_buf + log_len, tag_sapce);
 5112e00:	e1a0000a 	mov	r0, sl
 5112e04:	e59d301c 	ldr	r3, [sp, #28]
 5112e08:	e084100a 	add	r1, r4, sl
 5112e0c:	e28d2038 	add	r2, sp, #56	; 0x38
 5112e10:	e12fff33 	blx	r3
 5112e14:	e08aa000 	add	sl, sl, r0
 5112e18:	eaffffb4 	b	5112cf0 <elog_output+0x840>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112e1c:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5112e20:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5112e24:	e3402512 	movt	r2, #1298	; 0x512
 5112e28:	e3401512 	movt	r1, #1298	; 0x512
 5112e2c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5112e30:	e3403512 	movt	r3, #1298	; 0x512
 5112e34:	e58d1004 	str	r1, [sp, #4]
 5112e38:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5112e3c:	e1cd20f8 	strd	r2, [sp, #8]
 5112e40:	e30d2484 	movw	r2, #54404	; 0xd484
 5112e44:	e1a00007 	mov	r0, r7
 5112e48:	e3402512 	movt	r2, #1298	; 0x512
 5112e4c:	e58dc010 	str	ip, [sp, #16]
 5112e50:	e3401512 	movt	r1, #1298	; 0x512
 5112e54:	e58dc000 	str	ip, [sp]
 5112e58:	ebfffd94 	bl	51124b0 <elog_output>
 5112e5c:	eafffffe 	b	5112e5c <elog_output+0x9ac>
        elog_port_output_lock();
 5112e60:	e3013640 	movw	r3, #5696	; 0x1640
 5112e64:	e3403511 	movt	r3, #1297	; 0x511
 5112e68:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = true;
 5112e6c:	e3a03001 	mov	r3, #1
 5112e70:	e5c5305c 	strb	r3, [r5, #92]	; 0x5c
 5112e74:	eafffdd6 	b	51125d4 <elog_output+0x124>
    if (elog.output_lock_enabled) {
 5112e78:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 5112e7c:	e3530000 	cmp	r3, #0
 5112e80:	0affff8b 	beq	5112cb4 <elog_output+0x804>
        elog_port_output_unlock();
 5112e84:	e3013644 	movw	r3, #5700	; 0x1644
 5112e88:	e3403511 	movt	r3, #1297	; 0x511
 5112e8c:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = false;
 5112e90:	e3a03000 	mov	r3, #0
 5112e94:	e5c5305c 	strb	r3, [r5, #92]	; 0x5c
 5112e98:	eafffdaa 	b	5112548 <elog_output+0x98>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 5112e9c:	e301398c 	movw	r3, #6540	; 0x198c
 5112ea0:	e3403511 	movt	r3, #1297	; 0x511
 5112ea4:	e12fff33 	blx	r3
 5112ea8:	e59d301c 	ldr	r3, [sp, #28]
 5112eac:	e0841007 	add	r1, r4, r7
 5112eb0:	e1a02000 	mov	r2, r0
 5112eb4:	e1a00007 	mov	r0, r7
 5112eb8:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112ebc:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112ec0:	e3130010 	tst	r3, #16
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 5112ec4:	e0877000 	add	r7, r7, r0
    if (elog.enabled_fmt_set[level] & set) {
 5112ec8:	0afffea7 	beq	511296c <elog_output+0x4bc>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5112ecc:	e30d2554 	movw	r2, #54612	; 0xd554
 5112ed0:	e0841007 	add	r1, r4, r7
 5112ed4:	e1a00007 	mov	r0, r7
 5112ed8:	e3402512 	movt	r2, #1298	; 0x512
 5112edc:	e59d301c 	ldr	r3, [sp, #28]
 5112ee0:	e12fff33 	blx	r3
 5112ee4:	e0877000 	add	r7, r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5112ee8:	e3560005 	cmp	r6, #5
 5112eec:	9afffe92 	bls	511293c <elog_output+0x48c>
 5112ef0:	e3079dc8 	movw	r9, #32200	; 0x7dc8
 5112ef4:	e3409513 	movt	r9, #1299	; 0x513
 5112ef8:	eafffe4a 	b	5112828 <elog_output+0x378>
 5112efc:	e30d359c 	movw	r3, #54684	; 0xd59c
 5112f00:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5112f04:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5112f08:	e3402512 	movt	r2, #1298	; 0x512
 5112f0c:	e3401512 	movt	r1, #1298	; 0x512
 5112f10:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5112f14:	e3403512 	movt	r3, #1298	; 0x512
 5112f18:	e58d1004 	str	r1, [sp, #4]
 5112f1c:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5112f20:	e1cd20f8 	strd	r2, [sp, #8]
 5112f24:	e30d2484 	movw	r2, #54404	; 0xd484
 5112f28:	e1a0000a 	mov	r0, sl
 5112f2c:	e3402512 	movt	r2, #1298	; 0x512
 5112f30:	e58dc010 	str	ip, [sp, #16]
 5112f34:	e3401512 	movt	r1, #1298	; 0x512
 5112f38:	e58dc000 	str	ip, [sp]
 5112f3c:	ebfffd5b 	bl	51124b0 <elog_output>
 5112f40:	eafffffe 	b	5112f40 <elog_output+0xa90>
 5112f44:	e30d259c 	movw	r2, #54684	; 0xd59c
 5112f48:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5112f4c:	e3402512 	movt	r2, #1298	; 0x512
 5112f50:	e30dc4b0 	movw	ip, #54448	; 0xd4b0
 5112f54:	e3401512 	movt	r1, #1298	; 0x512
 5112f58:	e3a0efc7 	mov	lr, #796	; 0x31c
 5112f5c:	e340c512 	movt	ip, #1298	; 0x512
 5112f60:	e58d200c 	str	r2, [sp, #12]
 5112f64:	e1a00003 	mov	r0, r3
 5112f68:	e58d1004 	str	r1, [sp, #4]
 5112f6c:	e1a03002 	mov	r3, r2
 5112f70:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5112f74:	e30d2484 	movw	r2, #54404	; 0xd484
 5112f78:	e3402512 	movt	r2, #1298	; 0x512
 5112f7c:	e58de010 	str	lr, [sp, #16]
 5112f80:	e3401512 	movt	r1, #1298	; 0x512
 5112f84:	e58dc008 	str	ip, [sp, #8]
 5112f88:	e58de000 	str	lr, [sp]
 5112f8c:	ebfffd47 	bl	51124b0 <elog_output>
 5112f90:	eafffffe 	b	5112f90 <elog_output+0xae0>
 5112f94:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5112f98:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5112f9c:	e3402512 	movt	r2, #1298	; 0x512
 5112fa0:	e3401512 	movt	r1, #1298	; 0x512
 5112fa4:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5112fa8:	e3403512 	movt	r3, #1298	; 0x512
 5112fac:	e58d1004 	str	r1, [sp, #4]
 5112fb0:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5112fb4:	e1cd20f8 	strd	r2, [sp, #8]
 5112fb8:	e30d2484 	movw	r2, #54404	; 0xd484
 5112fbc:	e1a00007 	mov	r0, r7
 5112fc0:	e3402512 	movt	r2, #1298	; 0x512
 5112fc4:	e58dc010 	str	ip, [sp, #16]
 5112fc8:	e3401512 	movt	r1, #1298	; 0x512
 5112fcc:	e58dc000 	str	ip, [sp]
 5112fd0:	ebfffd36 	bl	51124b0 <elog_output>
 5112fd4:	eafffffe 	b	5112fd4 <elog_output+0xb24>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5112fd8:	e3013648 	movw	r3, #5704	; 0x1648
 5112fdc:	e3403511 	movt	r3, #1297	; 0x511
 5112fe0:	e12fff33 	blx	r3
 5112fe4:	e59d301c 	ldr	r3, [sp, #28]
 5112fe8:	e0841007 	add	r1, r4, r7
 5112fec:	e1a02000 	mov	r2, r0
 5112ff0:	e1a00007 	mov	r0, r7
 5112ff4:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5112ff8:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5112ffc:	e3130018 	tst	r3, #24
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5113000:	e0877000 	add	r7, r7, r0
    if (elog.enabled_fmt_set[level] & set) {
 5113004:	1afffdd0 	bne	511274c <elog_output+0x29c>
 5113008:	eafffe48 	b	5112930 <elog_output+0x480>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 511300c:	e30d2554 	movw	r2, #54612	; 0xd554
 5113010:	e3402512 	movt	r2, #1298	; 0x512
 5113014:	eafffea8 	b	5112abc <elog_output+0x60c>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113018:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511301c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113020:	e59d2020 	ldr	r2, [sp, #32]
 5113024:	e3401512 	movt	r1, #1298	; 0x512
 5113028:	e58d2008 	str	r2, [sp, #8]
 511302c:	e30d2484 	movw	r2, #54404	; 0xd484
 5113030:	e58d1004 	str	r1, [sp, #4]
 5113034:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113038:	e1a0000e 	mov	r0, lr
 511303c:	e3402512 	movt	r2, #1298	; 0x512
 5113040:	e58dc010 	str	ip, [sp, #16]
 5113044:	e3401512 	movt	r1, #1298	; 0x512
 5113048:	e58d300c 	str	r3, [sp, #12]
 511304c:	e58dc000 	str	ip, [sp]
 5113050:	ebfffd16 	bl	51124b0 <elog_output>
 5113054:	eafffffe 	b	5113054 <elog_output+0xba4>
 5113058:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 511305c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113060:	e59d1020 	ldr	r1, [sp, #32]
 5113064:	e3402512 	movt	r2, #1298	; 0x512
 5113068:	e58d300c 	str	r3, [sp, #12]
 511306c:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113070:	e58d1008 	str	r1, [sp, #8]
 5113074:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113078:	e58d2004 	str	r2, [sp, #4]
 511307c:	e30d2484 	movw	r2, #54404	; 0xd484
 5113080:	e1a0000a 	mov	r0, sl
 5113084:	e3403512 	movt	r3, #1298	; 0x512
 5113088:	e3402512 	movt	r2, #1298	; 0x512
 511308c:	e58dc010 	str	ip, [sp, #16]
 5113090:	e3401512 	movt	r1, #1298	; 0x512
 5113094:	e58dc000 	str	ip, [sp]
 5113098:	ebfffd04 	bl	51124b0 <elog_output>
 511309c:	eafffffe 	b	511309c <elog_output+0xbec>
 51130a0:	e30d359c 	movw	r3, #54684	; 0xd59c
 51130a4:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 51130a8:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51130ac:	e3402512 	movt	r2, #1298	; 0x512
 51130b0:	e3401512 	movt	r1, #1298	; 0x512
 51130b4:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51130b8:	e3403512 	movt	r3, #1298	; 0x512
 51130bc:	e58d1004 	str	r1, [sp, #4]
 51130c0:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51130c4:	e1cd20f8 	strd	r2, [sp, #8]
 51130c8:	e30d2484 	movw	r2, #54404	; 0xd484
 51130cc:	e1a00009 	mov	r0, r9
 51130d0:	e3402512 	movt	r2, #1298	; 0x512
 51130d4:	e58dc010 	str	ip, [sp, #16]
 51130d8:	e3401512 	movt	r1, #1298	; 0x512
 51130dc:	e58dc000 	str	ip, [sp]
 51130e0:	ebfffcf2 	bl	51124b0 <elog_output>
 51130e4:	eafffffe 	b	51130e4 <elog_output+0xc34>
 51130e8:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51130ec:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51130f0:	e59d2020 	ldr	r2, [sp, #32]
 51130f4:	e3401512 	movt	r1, #1298	; 0x512
 51130f8:	e58d2008 	str	r2, [sp, #8]
 51130fc:	e30d2484 	movw	r2, #54404	; 0xd484
 5113100:	e58d1004 	str	r1, [sp, #4]
 5113104:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113108:	e1a00007 	mov	r0, r7
 511310c:	e3402512 	movt	r2, #1298	; 0x512
 5113110:	e58dc010 	str	ip, [sp, #16]
 5113114:	e3401512 	movt	r1, #1298	; 0x512
 5113118:	e58d300c 	str	r3, [sp, #12]
 511311c:	e58dc000 	str	ip, [sp]
 5113120:	ebfffce2 	bl	51124b0 <elog_output>
 5113124:	eafffffe 	b	5113124 <elog_output+0xc74>
 5113128:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 511312c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113130:	e59d1020 	ldr	r1, [sp, #32]
 5113134:	e3402512 	movt	r2, #1298	; 0x512
 5113138:	e58d300c 	str	r3, [sp, #12]
 511313c:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113140:	e58d1008 	str	r1, [sp, #8]
 5113144:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113148:	e58d2004 	str	r2, [sp, #4]
 511314c:	e30d2484 	movw	r2, #54404	; 0xd484
 5113150:	e1a00008 	mov	r0, r8
 5113154:	e3403512 	movt	r3, #1298	; 0x512
 5113158:	e3402512 	movt	r2, #1298	; 0x512
 511315c:	e58dc010 	str	ip, [sp, #16]
 5113160:	e3401512 	movt	r1, #1298	; 0x512
 5113164:	e58dc000 	str	ip, [sp]
 5113168:	ebfffcd0 	bl	51124b0 <elog_output>
 511316c:	eafffffe 	b	511316c <elog_output+0xcbc>
 5113170:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113174:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5113178:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511317c:	e3402512 	movt	r2, #1298	; 0x512
 5113180:	e3401512 	movt	r1, #1298	; 0x512
 5113184:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113188:	e3403512 	movt	r3, #1298	; 0x512
 511318c:	e58d1004 	str	r1, [sp, #4]
 5113190:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113194:	e1cd20f8 	strd	r2, [sp, #8]
 5113198:	e30d2484 	movw	r2, #54404	; 0xd484
 511319c:	e1a00006 	mov	r0, r6
 51131a0:	e3402512 	movt	r2, #1298	; 0x512
 51131a4:	e58dc010 	str	ip, [sp, #16]
 51131a8:	e3401512 	movt	r1, #1298	; 0x512
 51131ac:	e58dc000 	str	ip, [sp]
 51131b0:	ebfffcbe 	bl	51124b0 <elog_output>
 51131b4:	eafffffe 	b	51131b4 <elog_output+0xd04>
 51131b8:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 51131bc:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51131c0:	e59d1020 	ldr	r1, [sp, #32]
 51131c4:	e3402512 	movt	r2, #1298	; 0x512
 51131c8:	e58d300c 	str	r3, [sp, #12]
 51131cc:	e30d359c 	movw	r3, #54684	; 0xd59c
 51131d0:	e58d1008 	str	r1, [sp, #8]
 51131d4:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51131d8:	e58d2004 	str	r2, [sp, #4]
 51131dc:	e30d2484 	movw	r2, #54404	; 0xd484
 51131e0:	e1a0000a 	mov	r0, sl
 51131e4:	e3403512 	movt	r3, #1298	; 0x512
 51131e8:	e3402512 	movt	r2, #1298	; 0x512
 51131ec:	e58dc010 	str	ip, [sp, #16]
 51131f0:	e3401512 	movt	r1, #1298	; 0x512
 51131f4:	e58dc000 	str	ip, [sp]
 51131f8:	ebfffcac 	bl	51124b0 <elog_output>
 51131fc:	eafffffe 	b	51131fc <elog_output+0xd4c>
 5113200:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5113204:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113208:	e59d2020 	ldr	r2, [sp, #32]
 511320c:	e3401512 	movt	r1, #1298	; 0x512
 5113210:	e58d2008 	str	r2, [sp, #8]
 5113214:	e30d2484 	movw	r2, #54404	; 0xd484
 5113218:	e58d1004 	str	r1, [sp, #4]
 511321c:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113220:	e1a00008 	mov	r0, r8
 5113224:	e3402512 	movt	r2, #1298	; 0x512
 5113228:	e58dc010 	str	ip, [sp, #16]
 511322c:	e3401512 	movt	r1, #1298	; 0x512
 5113230:	e58d300c 	str	r3, [sp, #12]
 5113234:	e58dc000 	str	ip, [sp]
 5113238:	ebfffc9c 	bl	51124b0 <elog_output>
 511323c:	eafffffe 	b	511323c <elog_output+0xd8c>
 5113240:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 5113244:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113248:	e59d1020 	ldr	r1, [sp, #32]
 511324c:	e3402512 	movt	r2, #1298	; 0x512
 5113250:	e58d300c 	str	r3, [sp, #12]
 5113254:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113258:	e58d1008 	str	r1, [sp, #8]
 511325c:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113260:	e58d2004 	str	r2, [sp, #4]
 5113264:	e30d2484 	movw	r2, #54404	; 0xd484
 5113268:	e1a00008 	mov	r0, r8
 511326c:	e3403512 	movt	r3, #1298	; 0x512
 5113270:	e3402512 	movt	r2, #1298	; 0x512
 5113274:	e58dc010 	str	ip, [sp, #16]
 5113278:	e3401512 	movt	r1, #1298	; 0x512
 511327c:	e58dc000 	str	ip, [sp]
 5113280:	ebfffc8a 	bl	51124b0 <elog_output>
 5113284:	eafffffe 	b	5113284 <elog_output+0xdd4>
 5113288:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511328c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5113290:	e59d2020 	ldr	r2, [sp, #32]
 5113294:	e3401512 	movt	r1, #1298	; 0x512
 5113298:	e58d2008 	str	r2, [sp, #8]
 511329c:	e30d2484 	movw	r2, #54404	; 0xd484
 51132a0:	e58d1004 	str	r1, [sp, #4]
 51132a4:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51132a8:	e1a0000a 	mov	r0, sl
 51132ac:	e3402512 	movt	r2, #1298	; 0x512
 51132b0:	e58dc010 	str	ip, [sp, #16]
 51132b4:	e3401512 	movt	r1, #1298	; 0x512
 51132b8:	e58d300c 	str	r3, [sp, #12]
 51132bc:	e58dc000 	str	ip, [sp]
 51132c0:	ebfffc7a 	bl	51124b0 <elog_output>
 51132c4:	eafffffe 	b	51132c4 <elog_output+0xe14>
 51132c8:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51132cc:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51132d0:	e59d2020 	ldr	r2, [sp, #32]
 51132d4:	e3401512 	movt	r1, #1298	; 0x512
 51132d8:	e58d2008 	str	r2, [sp, #8]
 51132dc:	e30d2484 	movw	r2, #54404	; 0xd484
 51132e0:	e58d1004 	str	r1, [sp, #4]
 51132e4:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51132e8:	e1a00008 	mov	r0, r8
 51132ec:	e3402512 	movt	r2, #1298	; 0x512
 51132f0:	e58dc010 	str	ip, [sp, #16]
 51132f4:	e3401512 	movt	r1, #1298	; 0x512
 51132f8:	e58d300c 	str	r3, [sp, #12]
 51132fc:	e58dc000 	str	ip, [sp]
 5113300:	ebfffc6a 	bl	51124b0 <elog_output>
 5113304:	eafffffe 	b	5113304 <elog_output+0xe54>
 5113308:	05137d71 	.word	0x05137d71

0511330c <elog_start>:
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 511330c:	e30d3504 	movw	r3, #54532	; 0xd504
 5113310:	e30d250c 	movw	r2, #54540	; 0xd50c
void elog_start(void) {
 5113314:	e92d4010 	push	{r4, lr}
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 5113318:	e3403512 	movt	r3, #1298	; 0x512
void elog_start(void) {
 511331c:	e24dd010 	sub	sp, sp, #16
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 5113320:	e3a010de 	mov	r1, #222	; 0xde
 5113324:	e3402512 	movt	r2, #1298	; 0x512
    elog.output_enabled = enabled;
 5113328:	e3070d68 	movw	r0, #32104	; 0x7d68
 511332c:	e3a0c001 	mov	ip, #1
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 5113330:	e88d0006 	stm	sp, {r1, r2}
    elog.output_enabled = enabled;
 5113334:	e3400513 	movt	r0, #1299	; 0x513
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 5113338:	e58d3008 	str	r3, [sp, #8]
 511333c:	e30d2484 	movw	r2, #54404	; 0xd484
 5113340:	e30d3590 	movw	r3, #54672	; 0xd590
 5113344:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113348:	e30244b0 	movw	r4, #9392	; 0x24b0
 511334c:	e3403512 	movt	r3, #1298	; 0x512
    elog.output_enabled = enabled;
 5113350:	e5c0c059 	strb	ip, [r0, #89]	; 0x59
    log_i("EasyLogger V%s is initialize success.", ELOG_SW_VERSION);
 5113354:	e3402512 	movt	r2, #1298	; 0x512
 5113358:	e3401512 	movt	r1, #1298	; 0x512
 511335c:	e3a00003 	mov	r0, #3
 5113360:	e3404511 	movt	r4, #1297	; 0x511
 5113364:	e12fff34 	blx	r4
}
 5113368:	e28dd010 	add	sp, sp, #16
 511336c:	e8bd8010 	pop	{r4, pc}

05113370 <elog_set_fmt>:
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113370:	e3500005 	cmp	r0, #5
void elog_set_fmt(uint8_t level, size_t set) {
 5113374:	e92d4070 	push	{r4, r5, r6, lr}
 5113378:	e1a04000 	mov	r4, r0
 511337c:	e24dd018 	sub	sp, sp, #24
 5113380:	e1a05001 	mov	r5, r1
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113384:	9a00000a 	bls	51133b4 <elog_set_fmt+0x44>
 5113388:	e3073dc8 	movw	r3, #32200	; 0x7dc8
 511338c:	e3403513 	movt	r3, #1299	; 0x513
 5113390:	e5936000 	ldr	r6, [r3]
 5113394:	e3560000 	cmp	r6, #0
 5113398:	0a00000b 	beq	51133cc <elog_set_fmt+0x5c>
 511339c:	e30d15e4 	movw	r1, #54756	; 0xd5e4
 51133a0:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51133a4:	e3a02e11 	mov	r2, #272	; 0x110
 51133a8:	e3401512 	movt	r1, #1298	; 0x512
 51133ac:	e3400512 	movt	r0, #1298	; 0x512
 51133b0:	e12fff36 	blx	r6
    elog.enabled_fmt_set[level] = set;
 51133b4:	e3073d68 	movw	r3, #32104	; 0x7d68
 51133b8:	e2844010 	add	r4, r4, #16
 51133bc:	e3403513 	movt	r3, #1299	; 0x513
 51133c0:	e7835104 	str	r5, [r3, r4, lsl #2]
}
 51133c4:	e28dd018 	add	sp, sp, #24
 51133c8:	e8bd8070 	pop	{r4, r5, r6, pc}
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51133cc:	e30d35e4 	movw	r3, #54756	; 0xd5e4
 51133d0:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 51133d4:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51133d8:	e3402512 	movt	r2, #1298	; 0x512
 51133dc:	e3401512 	movt	r1, #1298	; 0x512
 51133e0:	e3a0ce11 	mov	ip, #272	; 0x110
 51133e4:	e3403512 	movt	r3, #1298	; 0x512
 51133e8:	e30244b0 	movw	r4, #9392	; 0x24b0
 51133ec:	e1a00006 	mov	r0, r6
 51133f0:	e1cd20f8 	strd	r2, [sp, #8]
 51133f4:	e30d2484 	movw	r2, #54404	; 0xd484
 51133f8:	e58d1004 	str	r1, [sp, #4]
 51133fc:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113400:	e3402512 	movt	r2, #1298	; 0x512
 5113404:	e3401512 	movt	r1, #1298	; 0x512
 5113408:	e58dc010 	str	ip, [sp, #16]
 511340c:	e3404511 	movt	r4, #1297	; 0x511
 5113410:	e58dc000 	str	ip, [sp]
 5113414:	e12fff34 	blx	r4
 5113418:	eafffffe 	b	5113418 <elog_set_fmt+0xa8>

0511341c <elog_set_filter_lvl>:
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 511341c:	e3500005 	cmp	r0, #5
void elog_set_filter_lvl(uint8_t level) {
 5113420:	e92d4030 	push	{r4, r5, lr}
 5113424:	e1a04000 	mov	r4, r0
 5113428:	e24dd01c 	sub	sp, sp, #28
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 511342c:	9a00000a 	bls	511345c <elog_set_filter_lvl+0x40>
 5113430:	e3073dc8 	movw	r3, #32200	; 0x7dc8
 5113434:	e3403513 	movt	r3, #1299	; 0x513
 5113438:	e5935000 	ldr	r5, [r3]
 511343c:	e3550000 	cmp	r5, #0
 5113440:	0a00000a 	beq	5113470 <elog_set_filter_lvl+0x54>
 5113444:	e30d15d0 	movw	r1, #54736	; 0xd5d0
 5113448:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 511344c:	e300212a 	movw	r2, #298	; 0x12a
 5113450:	e3401512 	movt	r1, #1298	; 0x512
 5113454:	e3400512 	movt	r0, #1298	; 0x512
 5113458:	e12fff35 	blx	r5
    elog.filter.level = level;
 511345c:	e3073d68 	movw	r3, #32104	; 0x7d68
 5113460:	e3403513 	movt	r3, #1299	; 0x513
 5113464:	e5c34000 	strb	r4, [r3]
}
 5113468:	e28dd01c 	add	sp, sp, #28
 511346c:	e8bd8030 	pop	{r4, r5, pc}
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113470:	e30d35d0 	movw	r3, #54736	; 0xd5d0
 5113474:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5113478:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511347c:	e3402512 	movt	r2, #1298	; 0x512
 5113480:	e3401512 	movt	r1, #1298	; 0x512
 5113484:	e300c12a 	movw	ip, #298	; 0x12a
 5113488:	e3403512 	movt	r3, #1298	; 0x512
 511348c:	e30244b0 	movw	r4, #9392	; 0x24b0
 5113490:	e1a00005 	mov	r0, r5
 5113494:	e1cd20f8 	strd	r2, [sp, #8]
 5113498:	e30d2484 	movw	r2, #54404	; 0xd484
 511349c:	e58d1004 	str	r1, [sp, #4]
 51134a0:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51134a4:	e3402512 	movt	r2, #1298	; 0x512
 51134a8:	e3401512 	movt	r1, #1298	; 0x512
 51134ac:	e58dc010 	str	ip, [sp, #16]
 51134b0:	e3404511 	movt	r4, #1297	; 0x511
 51134b4:	e58dc000 	str	ip, [sp]
 51134b8:	e12fff34 	blx	r4
 51134bc:	eafffffe 	b	51134bc <elog_set_filter_lvl+0xa0>

051134c0 <elog_get_filter_tag_lvl>:
{
 51134c0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    ELOG_ASSERT(tag != ((void *)0));
 51134c4:	e2509000 	subs	r9, r0, #0
{
 51134c8:	e24dd024 	sub	sp, sp, #36	; 0x24
    ELOG_ASSERT(tag != ((void *)0));
 51134cc:	0a00002f 	beq	5113590 <elog_get_filter_tag_lvl+0xd0>
    if (!elog.init_ok) 
 51134d0:	e3076d68 	movw	r6, #32104	; 0x7d68
 51134d4:	e3406513 	movt	r6, #1299	; 0x513
 51134d8:	e5d63058 	ldrb	r3, [r6, #88]	; 0x58
 51134dc:	e3530000 	cmp	r3, #0
        return level;
 51134e0:	03a00005 	moveq	r0, #5
    if (!elog.init_ok) 
 51134e4:	0a00001e 	beq	5113564 <elog_get_filter_tag_lvl+0xa4>
    elog_port_output_lock();
 51134e8:	e3013640 	movw	r3, #5696	; 0x1640
        filter_tag_len = strlen(elog.filter.tag_lvl[i].tag);
 51134ec:	e3008331 	movw	r8, #817	; 0x331
            if(!strncmp(tag, elog.filter.tag_lvl[i].tag, filter_tag_len))
 51134f0:	e30a7709 	movw	r7, #42761	; 0xa709
    elog_port_output_lock();
 51134f4:	e3403511 	movt	r3, #1297	; 0x511
 51134f8:	e12fff33 	blx	r3
    for (i =0; i< ELOG_FILTER_TAG_LVL_MAX_NUM; i++)
 51134fc:	e2864013 	add	r4, r6, #19
        filter_tag_len = strlen(elog.filter.tag_lvl[i].tag);
 5113500:	e3408511 	movt	r8, #1297	; 0x511
    elog_port_output_lock();
 5113504:	e3a05000 	mov	r5, #0
            if(!strncmp(tag, elog.filter.tag_lvl[i].tag, filter_tag_len))
 5113508:	e3407511 	movt	r7, #1297	; 0x511
        if (elog.filter.tag_lvl[i].tag_use_flag == true)
 511350c:	e5d43007 	ldrb	r3, [r4, #7]
        filter_tag_len = strlen(elog.filter.tag_lvl[i].tag);
 5113510:	e1a00004 	mov	r0, r4
        if (elog.filter.tag_lvl[i].tag_use_flag == true)
 5113514:	e3530000 	cmp	r3, #0
 5113518:	0a000008 	beq	5113540 <elog_get_filter_tag_lvl+0x80>
        filter_tag_len = strlen(elog.filter.tag_lvl[i].tag);
 511351c:	e12fff38 	blx	r8
            if(!strncmp(tag, elog.filter.tag_lvl[i].tag, filter_tag_len))
 5113520:	e1a01004 	mov	r1, r4
        filter_tag_len = strlen(elog.filter.tag_lvl[i].tag);
 5113524:	e1a02000 	mov	r2, r0
            if(!strncmp(tag, elog.filter.tag_lvl[i].tag, filter_tag_len))
 5113528:	e3500006 	cmp	r0, #6
 511352c:	23a02006 	movcs	r2, #6
 5113530:	e1a00009 	mov	r0, r9
 5113534:	e12fff37 	blx	r7
 5113538:	e3500000 	cmp	r0, #0
 511353c:	0a00001f 	beq	51135c0 <elog_get_filter_tag_lvl+0x100>
    for (i =0; i< ELOG_FILTER_TAG_LVL_MAX_NUM; i++)
 5113540:	e2855001 	add	r5, r5, #1
 5113544:	e3550005 	cmp	r5, #5
 5113548:	e2844009 	add	r4, r4, #9
 511354c:	1affffee 	bne	511350c <elog_get_filter_tag_lvl+0x4c>
    uint8_t level = ELOG_FILTER_LVL_ALL;
 5113550:	e1a00005 	mov	r0, r5
    if (elog.output_lock_enabled) {
 5113554:	e5d6305a 	ldrb	r3, [r6, #90]	; 0x5a
 5113558:	e3530000 	cmp	r3, #0
        elog.output_is_locked_before_enable = false;
 511355c:	05c6305b 	strbeq	r3, [r6, #91]	; 0x5b
    if (elog.output_lock_enabled) {
 5113560:	1a000001 	bne	511356c <elog_get_filter_tag_lvl+0xac>
}
 5113564:	e28dd024 	add	sp, sp, #36	; 0x24
 5113568:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
 511356c:	e58d001c 	str	r0, [sp, #28]
        elog_port_output_unlock();
 5113570:	e3013644 	movw	r3, #5700	; 0x1644
 5113574:	e3403511 	movt	r3, #1297	; 0x511
 5113578:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = false;
 511357c:	e59d001c 	ldr	r0, [sp, #28]
 5113580:	e3a03000 	mov	r3, #0
 5113584:	e5c6305c 	strb	r3, [r6, #92]	; 0x5c
}
 5113588:	e28dd024 	add	sp, sp, #36	; 0x24
 511358c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    ELOG_ASSERT(tag != ((void *)0));
 5113590:	e3073dc8 	movw	r3, #32200	; 0x7dc8
 5113594:	e3403513 	movt	r3, #1299	; 0x513
 5113598:	e5933000 	ldr	r3, [r3]
 511359c:	e3530000 	cmp	r3, #0
 51135a0:	0a00000a 	beq	51135d0 <elog_get_filter_tag_lvl+0x110>
 51135a4:	e30d15b8 	movw	r1, #54712	; 0xd5b8
 51135a8:	e30d0534 	movw	r0, #54580	; 0xd534
 51135ac:	e3a02f7e 	mov	r2, #504	; 0x1f8
 51135b0:	e3401512 	movt	r1, #1298	; 0x512
 51135b4:	e3400512 	movt	r0, #1298	; 0x512
 51135b8:	e12fff33 	blx	r3
 51135bc:	eaffffc3 	b	51134d0 <elog_get_filter_tag_lvl+0x10>
                level = elog.filter.tag_lvl[i].level;
 51135c0:	e0855185 	add	r5, r5, r5, lsl #3
 51135c4:	e0863005 	add	r3, r6, r5
 51135c8:	e5d30012 	ldrb	r0, [r3, #18]
                break;
 51135cc:	eaffffe0 	b	5113554 <elog_get_filter_tag_lvl+0x94>
    ELOG_ASSERT(tag != ((void *)0));
 51135d0:	e30d2534 	movw	r2, #54580	; 0xd534
 51135d4:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51135d8:	e3402512 	movt	r2, #1298	; 0x512
 51135dc:	e30d35b8 	movw	r3, #54712	; 0xd5b8
 51135e0:	e3401512 	movt	r1, #1298	; 0x512
 51135e4:	e3a0cf7e 	mov	ip, #504	; 0x1f8
 51135e8:	e3403512 	movt	r3, #1298	; 0x512
 51135ec:	e58d2008 	str	r2, [sp, #8]
 51135f0:	e30244b0 	movw	r4, #9392	; 0x24b0
 51135f4:	e30d2484 	movw	r2, #54404	; 0xd484
 51135f8:	e3404511 	movt	r4, #1297	; 0x511
 51135fc:	e58d1004 	str	r1, [sp, #4]
 5113600:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113604:	e3402512 	movt	r2, #1298	; 0x512
 5113608:	e58d300c 	str	r3, [sp, #12]
 511360c:	e3401512 	movt	r1, #1298	; 0x512
 5113610:	e58dc010 	str	ip, [sp, #16]
 5113614:	e58dc000 	str	ip, [sp]
 5113618:	e12fff34 	blx	r4
 511361c:	eafffffe 	b	511361c <elog_get_filter_tag_lvl+0x15c>

05113620 <elog_arraydump>:
 * @param start_str user self-define end string
 *
 */
void elog_arraydump(uint8_t level, const char *tag, const char *file, const char *func,
        const long line, const char *start_str, uint8_t *ArrayData, uint8_t DataSize, uint16_t ArrayLen, uint8_t DataType, const char *end_str) 
{
 5113620:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5113624:	e1a06000 	mov	r6, r0
 5113628:	e24dd04c 	sub	sp, sp, #76	; 0x4c
    extern const char *elog_port_get_time(void);
    extern const char *elog_port_get_p_info(void);
    extern const char *elog_port_get_t_info(void);

    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 511362c:	e1a00001 	mov	r0, r1
{
 5113630:	e1a04001 	mov	r4, r1
 5113634:	e1cd22f4 	strd	r2, [sp, #36]	; 0x24
 5113638:	e5dd307c 	ldrb	r3, [sp, #124]	; 0x7c
 511363c:	e58d3020 	str	r3, [sp, #32]
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 5113640:	e3003331 	movw	r3, #817	; 0x331
 5113644:	e3403511 	movt	r3, #1297	; 0x511
 5113648:	e12fff33 	blx	r3
    char line_num[ELOG_LINE_NUM_MAX_LEN + 1] = { 0 };
 511364c:	e3a03000 	mov	r3, #0
    char tag_sapce[ELOG_FILTER_TAG_MAX_LEN + 1] = { 0 };
    int array_result;
    int ArrayIndex;


    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113650:	e3560005 	cmp	r6, #5
{
 5113654:	e1dda8b0 	ldrh	sl, [sp, #128]	; 0x80
    char line_num[ELOG_LINE_NUM_MAX_LEN + 1] = { 0 };
 5113658:	e58d3038 	str	r3, [sp, #56]	; 0x38
 511365c:	e1cd33bc 	strh	r3, [sp, #60]	; 0x3c
    char tag_sapce[ELOG_FILTER_TAG_MAX_LEN + 1] = { 0 };
 5113660:	e58d3040 	str	r3, [sp, #64]	; 0x40
 5113664:	e1cd34b4 	strh	r3, [sp, #68]	; 0x44
 5113668:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
{
 511366c:	e5dd3084 	ldrb	r3, [sp, #132]	; 0x84
 5113670:	e58d301c 	str	r3, [sp, #28]
    size_t tag_len = strlen(tag), log_len = 0, newline_len = strlen(ELOG_NEWLINE_SIGN);
 5113674:	e1a07000 	mov	r7, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113678:	9a00000a 	bls	51136a8 <elog_arraydump+0x88>
 511367c:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113680:	e3408513 	movt	r8, #1299	; 0x513
 5113684:	e5985000 	ldr	r5, [r8]
 5113688:	e3550000 	cmp	r5, #0
 511368c:	0a0001a7 	beq	5113d30 <elog_arraydump+0x710>
 5113690:	e30d1580 	movw	r1, #54656	; 0xd580
 5113694:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113698:	e3401512 	movt	r1, #1298	; 0x512
 511369c:	e300240e 	movw	r2, #1038	; 0x40e
 51136a0:	e3400512 	movt	r0, #1298	; 0x512
 51136a4:	e12fff35 	blx	r5

    /* check output enabled */
    if (!elog.output_enabled) {
 51136a8:	e3075d68 	movw	r5, #32104	; 0x7d68
 51136ac:	e3405513 	movt	r5, #1299	; 0x513
 51136b0:	e5d53059 	ldrb	r3, [r5, #89]	; 0x59
 51136b4:	e3530000 	cmp	r3, #0
 51136b8:	0a000002 	beq	51136c8 <elog_arraydump+0xa8>
        return;
    }
    /* level filter */
    if (level > elog.filter.level || level > elog_get_filter_tag_lvl(tag)) 
 51136bc:	e5d53000 	ldrb	r3, [r5]
 51136c0:	e1530006 	cmp	r3, r6
 51136c4:	2a000001 	bcs	51136d0 <elog_arraydump+0xb0>
#else
    elog_port_output(log_buf, log_len);
#endif
    /* unlock output */
    elog_output_unlock();
}
 51136c8:	e28dd04c 	add	sp, sp, #76	; 0x4c
 51136cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (level > elog.filter.level || level > elog_get_filter_tag_lvl(tag)) 
 51136d0:	e30334c0 	movw	r3, #13504	; 0x34c0
 51136d4:	e1a00004 	mov	r0, r4
 51136d8:	e3403511 	movt	r3, #1297	; 0x511
 51136dc:	e12fff33 	blx	r3
 51136e0:	e1500006 	cmp	r0, r6
 51136e4:	3afffff7 	bcc	51136c8 <elog_arraydump+0xa8>
        for(index = 0; index < elog.filter.tag_num; index++)
 51136e8:	e5d53001 	ldrb	r3, [r5, #1]
 51136ec:	e3530000 	cmp	r3, #0
 51136f0:	0a000010 	beq	5113738 <elog_arraydump+0x118>
 51136f4:	e2433001 	sub	r3, r3, #1
 51136f8:	e3a09007 	mov	r9, #7
 51136fc:	e2852009 	add	r2, r5, #9
 5113700:	e30a8757 	movw	r8, #42839	; 0xa757
 5113704:	e6ef3073 	uxtb	r3, r3
 5113708:	e3408511 	movt	r8, #1297	; 0x511
 511370c:	e1092389 	smlabb	r9, r9, r3, r2
 5113710:	e285b002 	add	fp, r5, #2
 5113714:	ea000001 	b	5113720 <elog_arraydump+0x100>
 5113718:	e159000b 	cmp	r9, fp
 511371c:	0affffe9 	beq	51136c8 <elog_arraydump+0xa8>
            if (strstr(tag, &elog.filter.tag[index][0]))
 5113720:	e1a0100b 	mov	r1, fp
 5113724:	e1a00004 	mov	r0, r4
 5113728:	e12fff38 	blx	r8
        for(index = 0; index < elog.filter.tag_num; index++)
 511372c:	e28bb007 	add	fp, fp, #7
            if (strstr(tag, &elog.filter.tag[index][0]))
 5113730:	e3500000 	cmp	r0, #0
 5113734:	0afffff7 	beq	5113718 <elog_arraydump+0xf8>
    if (elog.output_lock_enabled) {
 5113738:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 511373c:	e3530000 	cmp	r3, #0
        elog.output_is_locked_before_enable = true;
 5113740:	03a03001 	moveq	r3, #1
 5113744:	05c5305b 	strbeq	r3, [r5, #91]	; 0x5b
    if (elog.output_lock_enabled) {
 5113748:	1a00021a 	bne	5113fb8 <elog_arraydump+0x998>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 511374c:	e3560005 	cmp	r6, #5
 5113750:	9a00018a 	bls	5113d80 <elog_arraydump+0x760>
 5113754:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113758:	e3408513 	movt	r8, #1299	; 0x513
 511375c:	e5989000 	ldr	r9, [r8]
 5113760:	e3590000 	cmp	r9, #0
 5113764:	0a000257 	beq	51140c8 <elog_arraydump+0xaa8>
 5113768:	e30d159c 	movw	r1, #54684	; 0xd59c
    if (elog.enabled_fmt_set[level] & set) {
 511376c:	e286b010 	add	fp, r6, #16
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113770:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113774:	e3401512 	movt	r1, #1298	; 0x512
 5113778:	e3a02fc7 	mov	r2, #796	; 0x31c
 511377c:	e3400512 	movt	r0, #1298	; 0x512
 5113780:	e12fff39 	blx	r9
    if (elog.enabled_fmt_set[level] & set) {
 5113784:	e795910b 	ldr	r9, [r5, fp, lsl #2]
 5113788:	e2199001 	ands	r9, r9, #1
 511378c:	0a0001cb 	beq	5113ec0 <elog_arraydump+0x8a0>
        log_len += elog_strcpy(log_len, log_buf + log_len, level_output_info[level]);
 5113790:	e30d35f4 	movw	r3, #54772	; 0xd5f4
 5113794:	e3071dcc 	movw	r1, #32204	; 0x7dcc
 5113798:	e3403512 	movt	r3, #1298	; 0x512
 511379c:	e3a00000 	mov	r0, #0
 51137a0:	e3401513 	movt	r1, #1299	; 0x513
 51137a4:	e7932106 	ldr	r2, [r3, r6, lsl #2]
 51137a8:	e3043718 	movw	r3, #18200	; 0x4718
 51137ac:	e3403511 	movt	r3, #1297	; 0x511
 51137b0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
 51137b4:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51137b8:	e3560005 	cmp	r6, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, level_output_info[level]);
 51137bc:	e1a09000 	mov	r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51137c0:	9a000175 	bls	5113d9c <elog_arraydump+0x77c>
 51137c4:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 51137c8:	e3408513 	movt	r8, #1299	; 0x513
 51137cc:	e5983000 	ldr	r3, [r8]
 51137d0:	e3530000 	cmp	r3, #0
 51137d4:	0a00024f 	beq	5114118 <elog_arraydump+0xaf8>
 51137d8:	e30d159c 	movw	r1, #54684	; 0xd59c
 51137dc:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51137e0:	e3401512 	movt	r1, #1298	; 0x512
 51137e4:	e3a02fc7 	mov	r2, #796	; 0x31c
 51137e8:	e3400512 	movt	r0, #1298	; 0x512
 51137ec:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 51137f0:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 51137f4:	e3130002 	tst	r3, #2
 51137f8:	03074dcc 	movweq	r4, #32204	; 0x7dcc
 51137fc:	03404513 	movteq	r4, #1299	; 0x513
 5113800:	1a000192 	bne	5113e50 <elog_arraydump+0x830>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113804:	e5987000 	ldr	r7, [r8]
 5113808:	e3570000 	cmp	r7, #0
 511380c:	0a00025a 	beq	511417c <elog_arraydump+0xb5c>
 5113810:	e30d159c 	movw	r1, #54684	; 0xd59c
 5113814:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 5113818:	e3403512 	movt	r3, #1298	; 0x512
 511381c:	e1a00003 	mov	r0, r3
 5113820:	e3401512 	movt	r1, #1298	; 0x512
 5113824:	e58d3030 	str	r3, [sp, #48]	; 0x30
 5113828:	e3a02fc7 	mov	r2, #796	; 0x31c
 511382c:	e58d1034 	str	r1, [sp, #52]	; 0x34
 5113830:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 5113834:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113838:	e313001c 	tst	r3, #28
 511383c:	0a000071 	beq	5113a08 <elog_arraydump+0x3e8>
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5113840:	e30d24f0 	movw	r2, #54512	; 0xd4f0
 5113844:	e0841009 	add	r1, r4, r9
 5113848:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 511384c:	e3402512 	movt	r2, #1298	; 0x512
 5113850:	e1a00009 	mov	r0, r9
 5113854:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113858:	e5983000 	ldr	r3, [r8]
 511385c:	e3530000 	cmp	r3, #0
 5113860:	0a0002bb 	beq	5114354 <elog_arraydump+0xd34>
 5113864:	e3a02fc7 	mov	r2, #796	; 0x31c
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5113868:	e0809009 	add	r9, r0, r9
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 511386c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
 5113870:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113874:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113878:	e3130004 	tst	r3, #4
 511387c:	0a000018 	beq	51138e4 <elog_arraydump+0x2c4>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5113880:	e3013648 	movw	r3, #5704	; 0x1648
 5113884:	e3403511 	movt	r3, #1297	; 0x511
 5113888:	e12fff33 	blx	r3
 511388c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113890:	e0841009 	add	r1, r4, r9
 5113894:	e1a02000 	mov	r2, r0
 5113898:	e1a00009 	mov	r0, r9
 511389c:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51138a0:	e5983000 	ldr	r3, [r8]
 51138a4:	e3530000 	cmp	r3, #0
 51138a8:	0a00034b 	beq	51145dc <elog_arraydump+0xfbc>
 51138ac:	e3a02fc7 	mov	r2, #796	; 0x31c
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 51138b0:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51138b4:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
 51138b8:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 51138bc:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 51138c0:	e3130018 	tst	r3, #24
 51138c4:	0a000010 	beq	511390c <elog_arraydump+0x2ec>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 51138c8:	e30d2554 	movw	r2, #54612	; 0xd554
 51138cc:	e0841009 	add	r1, r4, r9
 51138d0:	e1a00009 	mov	r0, r9
 51138d4:	e3402512 	movt	r2, #1298	; 0x512
 51138d8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 51138dc:	e12fff33 	blx	r3
 51138e0:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51138e4:	e3560005 	cmp	r6, #5
 51138e8:	9a00013d 	bls	5113de4 <elog_arraydump+0x7c4>
 51138ec:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 51138f0:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 51138f4:	e3403512 	movt	r3, #1298	; 0x512
 51138f8:	e3408513 	movt	r8, #1299	; 0x513
 51138fc:	e58d3030 	str	r3, [sp, #48]	; 0x30
 5113900:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113904:	e3403512 	movt	r3, #1298	; 0x512
 5113908:	e58d3034 	str	r3, [sp, #52]	; 0x34
 511390c:	e5983000 	ldr	r3, [r8]
 5113910:	e3530000 	cmp	r3, #0
 5113914:	0a0002de 	beq	5114494 <elog_arraydump+0xe74>
 5113918:	e30d159c 	movw	r1, #54684	; 0xd59c
 511391c:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113920:	e3401512 	movt	r1, #1298	; 0x512
 5113924:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113928:	e3400512 	movt	r0, #1298	; 0x512
 511392c:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113930:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113934:	e3130008 	tst	r3, #8
 5113938:	0a00013f 	beq	5113e3c <elog_arraydump+0x81c>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 511393c:	e301398c 	movw	r3, #6540	; 0x198c
 5113940:	e3403511 	movt	r3, #1297	; 0x511
 5113944:	e12fff33 	blx	r3
 5113948:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 511394c:	e0841009 	add	r1, r4, r9
 5113950:	e1a02000 	mov	r2, r0
 5113954:	e1a00009 	mov	r0, r9
 5113958:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 511395c:	e5983000 	ldr	r3, [r8]
 5113960:	e3530000 	cmp	r3, #0
 5113964:	0a00032f 	beq	5114628 <elog_arraydump+0x1008>
 5113968:	e30d159c 	movw	r1, #54684	; 0xd59c
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 511396c:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113970:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113974:	e3401512 	movt	r1, #1298	; 0x512
 5113978:	e3a02fc7 	mov	r2, #796	; 0x31c
 511397c:	e3400512 	movt	r0, #1298	; 0x512
 5113980:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113984:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113988:	e3130010 	tst	r3, #16
 511398c:	1a000123 	bne	5113e20 <elog_arraydump+0x800>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113990:	e3560005 	cmp	r6, #5
 5113994:	9a000014 	bls	51139ec <elog_arraydump+0x3cc>
 5113998:	e5987000 	ldr	r7, [r8]
 511399c:	e3570000 	cmp	r7, #0
 51139a0:	0a0002d0 	beq	51144e8 <elog_arraydump+0xec8>
 51139a4:	e30d159c 	movw	r1, #54684	; 0xd59c
 51139a8:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 51139ac:	e3401512 	movt	r1, #1298	; 0x512
 51139b0:	e3a02fc7 	mov	r2, #796	; 0x31c
 51139b4:	e3400512 	movt	r0, #1298	; 0x512
 51139b8:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 51139bc:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 51139c0:	e3130010 	tst	r3, #16
 51139c4:	0a000008 	beq	51139ec <elog_arraydump+0x3cc>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_t_info());
 51139c8:	e3013998 	movw	r3, #6552	; 0x1998
 51139cc:	e3403511 	movt	r3, #1297	; 0x511
 51139d0:	e12fff33 	blx	r3
 51139d4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 51139d8:	e0841009 	add	r1, r4, r9
 51139dc:	e1a02000 	mov	r2, r0
 51139e0:	e1a00009 	mov	r0, r9
 51139e4:	e12fff33 	blx	r3
 51139e8:	e0899000 	add	r9, r9, r0
        log_len += elog_strcpy(log_len, log_buf + log_len, "] ");
 51139ec:	e30d24f4 	movw	r2, #54516	; 0xd4f4
 51139f0:	e0841009 	add	r1, r4, r9
 51139f4:	e1a00009 	mov	r0, r9
 51139f8:	e3402512 	movt	r2, #1298	; 0x512
 51139fc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113a00:	e12fff33 	blx	r3
 5113a04:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113a08:	e3560005 	cmp	r6, #5
 5113a0c:	9a000125 	bls	5113ea8 <elog_arraydump+0x888>
 5113a10:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113a14:	e3408513 	movt	r8, #1299	; 0x513
 5113a18:	e5987000 	ldr	r7, [r8]
 5113a1c:	e3570000 	cmp	r7, #0
 5113a20:	0a00020b 	beq	5114254 <elog_arraydump+0xc34>
 5113a24:	e30d159c 	movw	r1, #54684	; 0xd59c
 5113a28:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 5113a2c:	e3403512 	movt	r3, #1298	; 0x512
 5113a30:	e1a00003 	mov	r0, r3
 5113a34:	e3401512 	movt	r1, #1298	; 0x512
 5113a38:	e58d3030 	str	r3, [sp, #48]	; 0x30
 5113a3c:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113a40:	e58d1034 	str	r1, [sp, #52]	; 0x34
 5113a44:	e12fff37 	blx	r7
    if (elog.enabled_fmt_set[level] & set) {
 5113a48:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113a4c:	e31300e0 	tst	r3, #224	; 0xe0
 5113a50:	0a000117 	beq	5113eb4 <elog_arraydump+0x894>
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5113a54:	e30d2500 	movw	r2, #54528	; 0xd500
 5113a58:	e0841009 	add	r1, r4, r9
 5113a5c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113a60:	e3402512 	movt	r2, #1298	; 0x512
 5113a64:	e1a00009 	mov	r0, r9
 5113a68:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113a6c:	e5983000 	ldr	r3, [r8]
 5113a70:	e3530000 	cmp	r3, #0
 5113a74:	0a00025e 	beq	51143f4 <elog_arraydump+0xdd4>
 5113a78:	e3a02fc7 	mov	r2, #796	; 0x31c
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5113a7c:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113a80:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
 5113a84:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113a88:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113a8c:	e3130020 	tst	r3, #32
 5113a90:	0a000028 	beq	5113b38 <elog_arraydump+0x518>
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5113a94:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113a98:	e0841009 	add	r1, r4, r9
 5113a9c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
 5113aa0:	e1a00009 	mov	r0, r9
 5113aa4:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113aa8:	e5983000 	ldr	r3, [r8]
 5113aac:	e3530000 	cmp	r3, #0
 5113ab0:	0a0002f1 	beq	511467c <elog_arraydump+0x105c>
 5113ab4:	e3a02fc7 	mov	r2, #796	; 0x31c
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5113ab8:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113abc:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
 5113ac0:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113ac4:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113ac8:	e3130040 	tst	r3, #64	; 0x40
 5113acc:	1a00021d 	bne	5114348 <elog_arraydump+0xd28>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113ad0:	e5983000 	ldr	r3, [r8]
 5113ad4:	e3530000 	cmp	r3, #0
 5113ad8:	0a0002fa 	beq	51146c8 <elog_arraydump+0x10a8>
 5113adc:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
 5113ae0:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113ae4:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113ae8:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113aec:	e3130080 	tst	r3, #128	; 0x80
 5113af0:	0a000010 	beq	5113b38 <elog_arraydump+0x518>
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5113af4:	e30c2ee8 	movw	r2, #52968	; 0xcee8
 5113af8:	e3402512 	movt	r2, #1298	; 0x512
 5113afc:	e1a00009 	mov	r0, r9
 5113b00:	e0841009 	add	r1, r4, r9
 5113b04:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113b08:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113b0c:	e3560005 	cmp	r6, #5
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5113b10:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113b14:	9a000102 	bls	5113f24 <elog_arraydump+0x904>
 5113b18:	e30d34b0 	movw	r3, #54448	; 0xd4b0
 5113b1c:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113b20:	e3403512 	movt	r3, #1298	; 0x512
 5113b24:	e3408513 	movt	r8, #1299	; 0x513
 5113b28:	e58d3030 	str	r3, [sp, #48]	; 0x30
 5113b2c:	e30d359c 	movw	r3, #54684	; 0xd59c
 5113b30:	e3403512 	movt	r3, #1298	; 0x512
 5113b34:	e58d3034 	str	r3, [sp, #52]	; 0x34
 5113b38:	e5983000 	ldr	r3, [r8]
 5113b3c:	e3530000 	cmp	r3, #0
 5113b40:	0a00023e 	beq	5114440 <elog_arraydump+0xe20>
 5113b44:	e30d159c 	movw	r1, #54684	; 0xd59c
 5113b48:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113b4c:	e3401512 	movt	r1, #1298	; 0x512
 5113b50:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113b54:	e3400512 	movt	r0, #1298	; 0x512
 5113b58:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113b5c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113b60:	e3130040 	tst	r3, #64	; 0x40
 5113b64:	0a000101 	beq	5113f70 <elog_arraydump+0x950>
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5113b68:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113b6c:	e0841009 	add	r1, r4, r9
 5113b70:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
 5113b74:	e1a00009 	mov	r0, r9
 5113b78:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113b7c:	e5983000 	ldr	r3, [r8]
 5113b80:	e3530000 	cmp	r3, #0
 5113b84:	0a00027f 	beq	5114588 <elog_arraydump+0xf68>
 5113b88:	e30d159c 	movw	r1, #54684	; 0xd59c
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5113b8c:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113b90:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113b94:	e3401512 	movt	r1, #1298	; 0x512
 5113b98:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113b9c:	e3400512 	movt	r0, #1298	; 0x512
 5113ba0:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113ba4:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113ba8:	e3130080 	tst	r3, #128	; 0x80
 5113bac:	1a0000e8 	bne	5113f54 <elog_arraydump+0x934>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113bb0:	e3560005 	cmp	r6, #5
 5113bb4:	9a00016d 	bls	5114170 <elog_arraydump+0xb50>
 5113bb8:	e5986000 	ldr	r6, [r8]
 5113bbc:	e3560000 	cmp	r6, #0
 5113bc0:	0a00025c 	beq	5114538 <elog_arraydump+0xf18>
 5113bc4:	e30d159c 	movw	r1, #54684	; 0xd59c
 5113bc8:	e30d04b0 	movw	r0, #54448	; 0xd4b0
 5113bcc:	e3401512 	movt	r1, #1298	; 0x512
 5113bd0:	e3a02fc7 	mov	r2, #796	; 0x31c
 5113bd4:	e3400512 	movt	r0, #1298	; 0x512
 5113bd8:	e12fff36 	blx	r6
    if (elog.enabled_fmt_set[level] & set) {
 5113bdc:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113be0:	e3130080 	tst	r3, #128	; 0x80
 5113be4:	0a000161 	beq	5114170 <elog_arraydump+0xb50>
            snprintf(line_num, ELOG_LINE_NUM_MAX_LEN, "%ld", line);
 5113be8:	e30d24f8 	movw	r2, #54520	; 0xd4f8
 5113bec:	e30a668d 	movw	r6, #42637	; 0xa68d
 5113bf0:	e59d3070 	ldr	r3, [sp, #112]	; 0x70
 5113bf4:	e3402512 	movt	r2, #1298	; 0x512
 5113bf8:	e3a01005 	mov	r1, #5
 5113bfc:	e3406511 	movt	r6, #1297	; 0x511
 5113c00:	e28d0038 	add	r0, sp, #56	; 0x38
 5113c04:	e12fff36 	blx	r6
            log_len += elog_strcpy(log_len, log_buf + log_len, line_num);
 5113c08:	e1a00009 	mov	r0, r9
 5113c0c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113c10:	e0841009 	add	r1, r4, r9
 5113c14:	e28d2038 	add	r2, sp, #56	; 0x38
 5113c18:	e12fff33 	blx	r3
 5113c1c:	e0899000 	add	r9, r9, r0
        log_len += elog_strcpy(log_len, log_buf + log_len, ")");
 5113c20:	e30d24fc 	movw	r2, #54524	; 0xd4fc
 5113c24:	e0841009 	add	r1, r4, r9
 5113c28:	e1a00009 	mov	r0, r9
 5113c2c:	e3402512 	movt	r2, #1298	; 0x512
 5113c30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113c34:	e12fff33 	blx	r3
 5113c38:	e0899000 	add	r9, r9, r0
    log_len += elog_strcpy(log_len, log_buf + log_len, start_str);
 5113c3c:	e59d2074 	ldr	r2, [sp, #116]	; 0x74
 5113c40:	e0841009 	add	r1, r4, r9
 5113c44:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113c48:	e1a00009 	mov	r0, r9
 5113c4c:	e12fff33 	blx	r3
    log_len += snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d:", ArrayLen);
 5113c50:	e30d2548 	movw	r2, #54600	; 0xd548
 5113c54:	e1a0300a 	mov	r3, sl
 5113c58:	e3402512 	movt	r2, #1298	; 0x512
    log_len += elog_strcpy(log_len, log_buf + log_len, start_str);
 5113c5c:	e0899000 	add	r9, r9, r0
    log_len += snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d:", ArrayLen);
 5113c60:	e2691b01 	rsb	r1, r9, #1024	; 0x400
 5113c64:	e0840009 	add	r0, r4, r9
 5113c68:	e12fff36 	blx	r6
    if(DataType == 0)
 5113c6c:	e59d301c 	ldr	r3, [sp, #28]
 5113c70:	e3530000 	cmp	r3, #0
    log_len += snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d:", ArrayLen);
 5113c74:	e0807009 	add	r7, r0, r9
    if(DataType == 0)
 5113c78:	1a0000d4 	bne	5113fd0 <elog_arraydump+0x9b0>
        if(DataSize == 1)
 5113c7c:	e59d3020 	ldr	r3, [sp, #32]
 5113c80:	e3530001 	cmp	r3, #1
 5113c84:	0a0000fa 	beq	5114074 <elog_arraydump+0xa54>
        else if(DataSize == 2)
 5113c88:	e59d3020 	ldr	r3, [sp, #32]
 5113c8c:	e3530002 	cmp	r3, #2
 5113c90:	0a00014d 	beq	51141cc <elog_arraydump+0xbac>
        else if(DataSize == 4)
 5113c94:	e59d3020 	ldr	r3, [sp, #32]
 5113c98:	e3530004 	cmp	r3, #4
 5113c9c:	0a000180 	beq	51142a4 <elog_arraydump+0xc84>
        log_len -= newline_len;
 5113ca0:	e30033fe 	movw	r3, #1022	; 0x3fe
    if (log_len + newline_len > ELOG_LINE_BUF_SIZE) {
 5113ca4:	e2872002 	add	r2, r7, #2
        log_len -= newline_len;
 5113ca8:	e3520b01 	cmp	r2, #1024	; 0x400
 5113cac:	81a07003 	movhi	r7, r3
    if (elog.filter.keyword[0] != '\0') {
 5113cb0:	e1d530d9 	ldrsb	r3, [r5, #9]
 5113cb4:	e3530000 	cmp	r3, #0
 5113cb8:	0a000009 	beq	5113ce4 <elog_arraydump+0x6c4>
        log_buf[log_len] = '\0';
 5113cbc:	e3a03000 	mov	r3, #0
        if (!strstr(log_buf, elog.filter.keyword)) {
 5113cc0:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5113cc4:	e59f1a48 	ldr	r1, [pc, #2632]	; 5114714 <elog_arraydump+0x10f4>
 5113cc8:	e3400513 	movt	r0, #1299	; 0x513
        log_buf[log_len] = '\0';
 5113ccc:	e7c43007 	strb	r3, [r4, r7]
        if (!strstr(log_buf, elog.filter.keyword)) {
 5113cd0:	e30a3757 	movw	r3, #42839	; 0xa757
 5113cd4:	e3403511 	movt	r3, #1297	; 0x511
 5113cd8:	e12fff33 	blx	r3
 5113cdc:	e3500000 	cmp	r0, #0
 5113ce0:	0a0000da 	beq	5114050 <elog_arraydump+0xa30>
    log_len += elog_strcpy(log_len, log_buf + log_len, ELOG_NEWLINE_SIGN);
 5113ce4:	e30d23e0 	movw	r2, #54240	; 0xd3e0
 5113ce8:	e0841007 	add	r1, r4, r7
 5113cec:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113cf0:	e3402512 	movt	r2, #1298	; 0x512
 5113cf4:	e1a00007 	mov	r0, r7
 5113cf8:	e12fff33 	blx	r3
    elog_port_output(log_buf, log_len);
 5113cfc:	e301362c 	movw	r3, #5676	; 0x162c
 5113d00:	e3403511 	movt	r3, #1297	; 0x511
    log_len += elog_strcpy(log_len, log_buf + log_len, ELOG_NEWLINE_SIGN);
 5113d04:	e1a01000 	mov	r1, r0
    elog_port_output(log_buf, log_len);
 5113d08:	e3070dcc 	movw	r0, #32204	; 0x7dcc
 5113d0c:	e0871001 	add	r1, r7, r1
 5113d10:	e3400513 	movt	r0, #1299	; 0x513
 5113d14:	e12fff33 	blx	r3
    if (elog.output_lock_enabled) {
 5113d18:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 5113d1c:	e3530000 	cmp	r3, #0
 5113d20:	1a0000cd 	bne	511405c <elog_arraydump+0xa3c>
        elog.output_is_locked_before_enable = false;
 5113d24:	e3a03000 	mov	r3, #0
 5113d28:	e5c5305b 	strb	r3, [r5, #91]	; 0x5b
 5113d2c:	eafffe65 	b	51136c8 <elog_arraydump+0xa8>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113d30:	e30d3580 	movw	r3, #54656	; 0xd580
 5113d34:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5113d38:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5113d3c:	e3402512 	movt	r2, #1298	; 0x512
 5113d40:	e3401512 	movt	r1, #1298	; 0x512
 5113d44:	e300c40e 	movw	ip, #1038	; 0x40e
 5113d48:	e3403512 	movt	r3, #1298	; 0x512
 5113d4c:	e30244b0 	movw	r4, #9392	; 0x24b0
 5113d50:	e1a00005 	mov	r0, r5
 5113d54:	e1cd20f8 	strd	r2, [sp, #8]
 5113d58:	e30d2484 	movw	r2, #54404	; 0xd484
 5113d5c:	e58d1004 	str	r1, [sp, #4]
 5113d60:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5113d64:	e3402512 	movt	r2, #1298	; 0x512
 5113d68:	e3401512 	movt	r1, #1298	; 0x512
 5113d6c:	e58dc010 	str	ip, [sp, #16]
 5113d70:	e3404511 	movt	r4, #1297	; 0x511
 5113d74:	e58dc000 	str	ip, [sp]
 5113d78:	e12fff34 	blx	r4
 5113d7c:	eafffffe 	b	5113d7c <elog_arraydump+0x75c>
    if (elog.enabled_fmt_set[level] & set) {
 5113d80:	e286b010 	add	fp, r6, #16
 5113d84:	e795910b 	ldr	r9, [r5, fp, lsl #2]
 5113d88:	e2199001 	ands	r9, r9, #1
 5113d8c:	1afffe7f 	bne	5113790 <elog_arraydump+0x170>
 5113d90:	e3043718 	movw	r3, #18200	; 0x4718
 5113d94:	e3403511 	movt	r3, #1297	; 0x511
 5113d98:	e58d302c 	str	r3, [sp, #44]	; 0x2c
 5113d9c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113da0:	e3130002 	tst	r3, #2
 5113da4:	03074dcc 	movweq	r4, #32204	; 0x7dcc
 5113da8:	03404513 	movteq	r4, #1299	; 0x513
 5113dac:	1a000027 	bne	5113e50 <elog_arraydump+0x830>
 5113db0:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113db4:	e313001c 	tst	r3, #28
 5113db8:	0a00003a 	beq	5113ea8 <elog_arraydump+0x888>
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5113dbc:	e30d24f0 	movw	r2, #54512	; 0xd4f0
 5113dc0:	e0841009 	add	r1, r4, r9
 5113dc4:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113dc8:	e1a00009 	mov	r0, r9
 5113dcc:	e3402512 	movt	r2, #1298	; 0x512
 5113dd0:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113dd4:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113dd8:	e3130004 	tst	r3, #4
        log_len += elog_strcpy(log_len, log_buf + log_len, "[");
 5113ddc:	e0809009 	add	r9, r0, r9
    if (elog.enabled_fmt_set[level] & set) {
 5113de0:	1a00010e 	bne	5114220 <elog_arraydump+0xc00>
 5113de4:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113de8:	e3130008 	tst	r3, #8
 5113dec:	0afffef2 	beq	51139bc <elog_arraydump+0x39c>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 5113df0:	e301398c 	movw	r3, #6540	; 0x198c
 5113df4:	e3403511 	movt	r3, #1297	; 0x511
 5113df8:	e12fff33 	blx	r3
 5113dfc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113e00:	e0841009 	add	r1, r4, r9
 5113e04:	e1a02000 	mov	r2, r0
 5113e08:	e1a00009 	mov	r0, r9
 5113e0c:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113e10:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113e14:	e3130010 	tst	r3, #16
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_p_info());
 5113e18:	e0899000 	add	r9, r9, r0
    if (elog.enabled_fmt_set[level] & set) {
 5113e1c:	0afffef2 	beq	51139ec <elog_arraydump+0x3cc>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5113e20:	e30d2554 	movw	r2, #54612	; 0xd554
 5113e24:	e0841009 	add	r1, r4, r9
 5113e28:	e1a00009 	mov	r0, r9
 5113e2c:	e3402512 	movt	r2, #1298	; 0x512
 5113e30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113e34:	e12fff33 	blx	r3
 5113e38:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113e3c:	e3560005 	cmp	r6, #5
 5113e40:	9afffedd 	bls	51139bc <elog_arraydump+0x39c>
 5113e44:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113e48:	e3408513 	movt	r8, #1299	; 0x513
 5113e4c:	eafffed1 	b	5113998 <elog_arraydump+0x378>
        log_len += elog_strcpy(log_len, log_buf + log_len, tag);
 5113e50:	e1a02004 	mov	r2, r4
 5113e54:	e3074dcc 	movw	r4, #32204	; 0x7dcc
 5113e58:	e1a00009 	mov	r0, r9
 5113e5c:	e3404513 	movt	r4, #1299	; 0x513
 5113e60:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113e64:	e0841009 	add	r1, r4, r9
 5113e68:	e12fff33 	blx	r3
        if (tag_len < ELOG_FILTER_TAG_MAX_LEN) 
 5113e6c:	e3570005 	cmp	r7, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, tag);
 5113e70:	e0809009 	add	r9, r0, r9
        if (tag_len < ELOG_FILTER_TAG_MAX_LEN) 
 5113e74:	9a000042 	bls	5113f84 <elog_arraydump+0x964>
        log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5113e78:	e30d2554 	movw	r2, #54612	; 0xd554
 5113e7c:	e0841009 	add	r1, r4, r9
 5113e80:	e1a00009 	mov	r0, r9
 5113e84:	e3402512 	movt	r2, #1298	; 0x512
 5113e88:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113e8c:	e12fff33 	blx	r3
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113e90:	e3560005 	cmp	r6, #5
        log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5113e94:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113e98:	9affffc4 	bls	5113db0 <elog_arraydump+0x790>
 5113e9c:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113ea0:	e3408513 	movt	r8, #1299	; 0x513
 5113ea4:	eafffe56 	b	5113804 <elog_arraydump+0x1e4>
    if (elog.enabled_fmt_set[level] & set) {
 5113ea8:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113eac:	e31300e0 	tst	r3, #224	; 0xe0
 5113eb0:	1a000006 	bne	5113ed0 <elog_arraydump+0x8b0>
 5113eb4:	e30a668d 	movw	r6, #42637	; 0xa68d
 5113eb8:	e3406511 	movt	r6, #1297	; 0x511
 5113ebc:	eaffff5e 	b	5113c3c <elog_arraydump+0x61c>
 5113ec0:	e3043718 	movw	r3, #18200	; 0x4718
 5113ec4:	e3403511 	movt	r3, #1297	; 0x511
 5113ec8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
 5113ecc:	eafffe3e 	b	51137cc <elog_arraydump+0x1ac>
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5113ed0:	e30d2500 	movw	r2, #54528	; 0xd500
 5113ed4:	e0841009 	add	r1, r4, r9
 5113ed8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113edc:	e1a00009 	mov	r0, r9
 5113ee0:	e3402512 	movt	r2, #1298	; 0x512
 5113ee4:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113ee8:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113eec:	e3130020 	tst	r3, #32
        log_len += elog_strcpy(log_len, log_buf + log_len, "(");
 5113ef0:	e0809009 	add	r9, r0, r9
    if (elog.enabled_fmt_set[level] & set) {
 5113ef4:	0a00000a 	beq	5113f24 <elog_arraydump+0x904>
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5113ef8:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113efc:	e0841009 	add	r1, r4, r9
 5113f00:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
 5113f04:	e1a00009 	mov	r0, r9
 5113f08:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113f0c:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113f10:	e3130040 	tst	r3, #64	; 0x40
            log_len += elog_strcpy(log_len, log_buf + log_len, file);
 5113f14:	e0899000 	add	r9, r9, r0
    if (elog.enabled_fmt_set[level] & set) {
 5113f18:	1a00010a 	bne	5114348 <elog_arraydump+0xd28>
 5113f1c:	e3130080 	tst	r3, #128	; 0x80
 5113f20:	1afffef3 	bne	5113af4 <elog_arraydump+0x4d4>
 5113f24:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113f28:	e3130040 	tst	r3, #64	; 0x40
 5113f2c:	0affff2b 	beq	5113be0 <elog_arraydump+0x5c0>
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5113f30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113f34:	e0841009 	add	r1, r4, r9
 5113f38:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
 5113f3c:	e1a00009 	mov	r0, r9
 5113f40:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5113f44:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5113f48:	e3130080 	tst	r3, #128	; 0x80
            log_len += elog_strcpy(log_len, log_buf + log_len, func);
 5113f4c:	e0899000 	add	r9, r9, r0
    if (elog.enabled_fmt_set[level] & set) {
 5113f50:	0a000086 	beq	5114170 <elog_arraydump+0xb50>
                log_len += elog_strcpy(log_len, log_buf + log_len, ":");
 5113f54:	e30c2ee8 	movw	r2, #52968	; 0xcee8
 5113f58:	e0841009 	add	r1, r4, r9
 5113f5c:	e1a00009 	mov	r0, r9
 5113f60:	e3402512 	movt	r2, #1298	; 0x512
 5113f64:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113f68:	e12fff33 	blx	r3
 5113f6c:	e0899000 	add	r9, r9, r0
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5113f70:	e3560005 	cmp	r6, #5
 5113f74:	9affff18 	bls	5113bdc <elog_arraydump+0x5bc>
 5113f78:	e3078dc8 	movw	r8, #32200	; 0x7dc8
 5113f7c:	e3408513 	movt	r8, #1299	; 0x513
 5113f80:	eaffff0c 	b	5113bb8 <elog_arraydump+0x598>
            memset(tag_sapce, ' ', ELOG_FILTER_TAG_MAX_LEN - tag_len);
 5113f84:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5113f88:	e2672006 	rsb	r2, r7, #6
 5113f8c:	e3a01020 	mov	r1, #32
 5113f90:	e3403511 	movt	r3, #1297	; 0x511
 5113f94:	e28d0040 	add	r0, sp, #64	; 0x40
 5113f98:	e12fff33 	blx	r3
            log_len += elog_strcpy(log_len, log_buf + log_len, tag_sapce);
 5113f9c:	e1a00009 	mov	r0, r9
 5113fa0:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5113fa4:	e0841009 	add	r1, r4, r9
 5113fa8:	e28d2040 	add	r2, sp, #64	; 0x40
 5113fac:	e12fff33 	blx	r3
 5113fb0:	e0899000 	add	r9, r9, r0
 5113fb4:	eaffffaf 	b	5113e78 <elog_arraydump+0x858>
        elog_port_output_lock();
 5113fb8:	e3013640 	movw	r3, #5696	; 0x1640
 5113fbc:	e3403511 	movt	r3, #1297	; 0x511
 5113fc0:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = true;
 5113fc4:	e3a03001 	mov	r3, #1
 5113fc8:	e5c5305c 	strb	r3, [r5, #92]	; 0x5c
 5113fcc:	eafffdde 	b	511374c <elog_arraydump+0x12c>
    else if(DataType == 1)
 5113fd0:	e59d301c 	ldr	r3, [sp, #28]
 5113fd4:	e3530001 	cmp	r3, #1
 5113fd8:	1affff30 	bne	5113ca0 <elog_arraydump+0x680>
        if(DataSize == 1)
 5113fdc:	e59d3020 	ldr	r3, [sp, #32]
 5113fe0:	e3530001 	cmp	r3, #1
 5113fe4:	0a0000c2 	beq	51142f4 <elog_arraydump+0xcd4>
        else if(DataSize == 2)
 5113fe8:	e59d3020 	ldr	r3, [sp, #32]
 5113fec:	e3530002 	cmp	r3, #2
 5113ff0:	0a0000ea 	beq	51143a0 <elog_arraydump+0xd80>
        else if(DataSize == 4)
 5113ff4:	e59d3020 	ldr	r3, [sp, #32]
 5113ff8:	e3530004 	cmp	r3, #4
 5113ffc:	1affff27 	bne	5113ca0 <elog_arraydump+0x680>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114000:	e35a0000 	cmp	sl, #0
 5114004:	0affff25 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%08x ", (int)*Data++);
 5114008:	e30d9560 	movw	r9, #54624	; 0xd560
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 511400c:	e3a08000 	mov	r8, #0
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%08x ", (int)*Data++);
 5114010:	e3409512 	movt	r9, #1298	; 0x512
 5114014:	ea000002 	b	5114024 <elog_arraydump+0xa04>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114018:	e15a0008 	cmp	sl, r8
                    log_len += array_result;
 511401c:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114020:	0affff1e 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%08x ", (int)*Data++);
 5114024:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 5114028:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 511402c:	e0840007 	add	r0, r4, r7
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114030:	e2888001 	add	r8, r8, #1
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%08x ", (int)*Data++);
 5114034:	e4923004 	ldr	r3, [r2], #4
 5114038:	e58d2078 	str	r2, [sp, #120]	; 0x78
 511403c:	e1a02009 	mov	r2, r9
 5114040:	e12fff36 	blx	r6
                if(array_result > 0)
 5114044:	e3500000 	cmp	r0, #0
 5114048:	cafffff2 	bgt	5114018 <elog_arraydump+0x9f8>
 511404c:	eaffff13 	b	5113ca0 <elog_arraydump+0x680>
    if (elog.output_lock_enabled) {
 5114050:	e5d5305a 	ldrb	r3, [r5, #90]	; 0x5a
 5114054:	e3530000 	cmp	r3, #0
 5114058:	0affff31 	beq	5113d24 <elog_arraydump+0x704>
        elog_port_output_unlock();
 511405c:	e3013644 	movw	r3, #5700	; 0x1644
 5114060:	e3403511 	movt	r3, #1297	; 0x511
 5114064:	e12fff33 	blx	r3
        elog.output_is_locked_before_disable = false;
 5114068:	e3a03000 	mov	r3, #0
 511406c:	e5c5305c 	strb	r3, [r5, #92]	; 0x5c
 5114070:	eafffd94 	b	51136c8 <elog_arraydump+0xa8>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114074:	e35a0000 	cmp	sl, #0
 5114078:	0affff08 	beq	5113ca0 <elog_arraydump+0x680>
 511407c:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*ArrayData++);
 5114080:	e30d854c 	movw	r8, #54604	; 0xd54c
 5114084:	e3408512 	movt	r8, #1298	; 0x512
 5114088:	e083a00a 	add	sl, r3, sl
 511408c:	ea000003 	b	51140a0 <elog_arraydump+0xa80>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114090:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                    log_len += array_result;
 5114094:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114098:	e153000a 	cmp	r3, sl
 511409c:	0afffeff 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*ArrayData++);
 51140a0:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 51140a4:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 51140a8:	e4d23001 	ldrb	r3, [r2], #1
 51140ac:	e58d2078 	str	r2, [sp, #120]	; 0x78
 51140b0:	e1a02008 	mov	r2, r8
 51140b4:	e0840007 	add	r0, r4, r7
 51140b8:	e12fff36 	blx	r6
                if(array_result > 0)
 51140bc:	e3500000 	cmp	r0, #0
 51140c0:	cafffff2 	bgt	5114090 <elog_arraydump+0xa70>
 51140c4:	eafffef5 	b	5113ca0 <elog_arraydump+0x680>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51140c8:	e30d359c 	movw	r3, #54684	; 0xd59c
 51140cc:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 51140d0:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51140d4:	e3402512 	movt	r2, #1298	; 0x512
 51140d8:	e3401512 	movt	r1, #1298	; 0x512
 51140dc:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51140e0:	e3403512 	movt	r3, #1298	; 0x512
 51140e4:	e30244b0 	movw	r4, #9392	; 0x24b0
 51140e8:	e1a00009 	mov	r0, r9
 51140ec:	e1cd20f8 	strd	r2, [sp, #8]
 51140f0:	e30d2484 	movw	r2, #54404	; 0xd484
 51140f4:	e58d1004 	str	r1, [sp, #4]
 51140f8:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51140fc:	e3402512 	movt	r2, #1298	; 0x512
 5114100:	e3401512 	movt	r1, #1298	; 0x512
 5114104:	e58dc010 	str	ip, [sp, #16]
 5114108:	e3404511 	movt	r4, #1297	; 0x511
 511410c:	e58dc000 	str	ip, [sp]
 5114110:	e12fff34 	blx	r4
 5114114:	eafffffe 	b	5114114 <elog_arraydump+0xaf4>
 5114118:	e30d259c 	movw	r2, #54684	; 0xd59c
 511411c:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114120:	e3402512 	movt	r2, #1298	; 0x512
 5114124:	e30dc4b0 	movw	ip, #54448	; 0xd4b0
 5114128:	e3401512 	movt	r1, #1298	; 0x512
 511412c:	e3a0efc7 	mov	lr, #796	; 0x31c
 5114130:	e340c512 	movt	ip, #1298	; 0x512
 5114134:	e1a00003 	mov	r0, r3
 5114138:	e30244b0 	movw	r4, #9392	; 0x24b0
 511413c:	e1a03002 	mov	r3, r2
 5114140:	e3404511 	movt	r4, #1297	; 0x511
 5114144:	e58d200c 	str	r2, [sp, #12]
 5114148:	e30d2484 	movw	r2, #54404	; 0xd484
 511414c:	e58d1004 	str	r1, [sp, #4]
 5114150:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114154:	e3402512 	movt	r2, #1298	; 0x512
 5114158:	e58de010 	str	lr, [sp, #16]
 511415c:	e3401512 	movt	r1, #1298	; 0x512
 5114160:	e58dc008 	str	ip, [sp, #8]
 5114164:	e58de000 	str	lr, [sp]
 5114168:	e12fff34 	blx	r4
 511416c:	eafffffe 	b	511416c <elog_arraydump+0xb4c>
 5114170:	e30a668d 	movw	r6, #42637	; 0xa68d
 5114174:	e3406511 	movt	r6, #1297	; 0x511
 5114178:	eafffea8 	b	5113c20 <elog_arraydump+0x600>
 511417c:	e30d359c 	movw	r3, #54684	; 0xd59c
 5114180:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5114184:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114188:	e3402512 	movt	r2, #1298	; 0x512
 511418c:	e3401512 	movt	r1, #1298	; 0x512
 5114190:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114194:	e3403512 	movt	r3, #1298	; 0x512
 5114198:	e30244b0 	movw	r4, #9392	; 0x24b0
 511419c:	e1a00007 	mov	r0, r7
 51141a0:	e1cd20f8 	strd	r2, [sp, #8]
 51141a4:	e30d2484 	movw	r2, #54404	; 0xd484
 51141a8:	e58d1004 	str	r1, [sp, #4]
 51141ac:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51141b0:	e3402512 	movt	r2, #1298	; 0x512
 51141b4:	e3401512 	movt	r1, #1298	; 0x512
 51141b8:	e58dc010 	str	ip, [sp, #16]
 51141bc:	e3404511 	movt	r4, #1297	; 0x511
 51141c0:	e58dc000 	str	ip, [sp]
 51141c4:	e12fff34 	blx	r4
 51141c8:	eafffffe 	b	51141c8 <elog_arraydump+0xba8>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51141cc:	e35a0000 	cmp	sl, #0
 51141d0:	0afffeb2 	beq	5113ca0 <elog_arraydump+0x680>
 51141d4:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*Data++);
 51141d8:	e30d854c 	movw	r8, #54604	; 0xd54c
 51141dc:	e3408512 	movt	r8, #1298	; 0x512
 51141e0:	e083a08a 	add	sl, r3, sl, lsl #1
 51141e4:	ea000003 	b	51141f8 <elog_arraydump+0xbd8>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51141e8:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                    log_len += array_result;
 51141ec:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51141f0:	e153000a 	cmp	r3, sl
 51141f4:	0afffea9 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*Data++);
 51141f8:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 51141fc:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 5114200:	e0d230b2 	ldrh	r3, [r2], #2
 5114204:	e58d2078 	str	r2, [sp, #120]	; 0x78
 5114208:	e1a02008 	mov	r2, r8
 511420c:	e0840007 	add	r0, r4, r7
 5114210:	e12fff36 	blx	r6
                if(array_result > 0)
 5114214:	e3500000 	cmp	r0, #0
 5114218:	cafffff2 	bgt	51141e8 <elog_arraydump+0xbc8>
 511421c:	eafffe9f 	b	5113ca0 <elog_arraydump+0x680>
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5114220:	e3013648 	movw	r3, #5704	; 0x1648
 5114224:	e3403511 	movt	r3, #1297	; 0x511
 5114228:	e12fff33 	blx	r3
 511422c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
 5114230:	e0841009 	add	r1, r4, r9
 5114234:	e1a02000 	mov	r2, r0
 5114238:	e1a00009 	mov	r0, r9
 511423c:	e12fff33 	blx	r3
    if (elog.enabled_fmt_set[level] & set) {
 5114240:	e795310b 	ldr	r3, [r5, fp, lsl #2]
 5114244:	e3130018 	tst	r3, #24
            log_len += elog_strcpy(log_len, log_buf + log_len, elog_port_get_time());
 5114248:	e0899000 	add	r9, r9, r0
    if (elog.enabled_fmt_set[level] & set) {
 511424c:	1afffd9d 	bne	51138c8 <elog_arraydump+0x2a8>
 5114250:	eafffee3 	b	5113de4 <elog_arraydump+0x7c4>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5114254:	e30d359c 	movw	r3, #54684	; 0xd59c
 5114258:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 511425c:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114260:	e3402512 	movt	r2, #1298	; 0x512
 5114264:	e3401512 	movt	r1, #1298	; 0x512
 5114268:	e3a0cfc7 	mov	ip, #796	; 0x31c
 511426c:	e3403512 	movt	r3, #1298	; 0x512
 5114270:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114274:	e1a00007 	mov	r0, r7
 5114278:	e1cd20f8 	strd	r2, [sp, #8]
 511427c:	e30d2484 	movw	r2, #54404	; 0xd484
 5114280:	e58d1004 	str	r1, [sp, #4]
 5114284:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114288:	e3402512 	movt	r2, #1298	; 0x512
 511428c:	e3401512 	movt	r1, #1298	; 0x512
 5114290:	e58dc010 	str	ip, [sp, #16]
 5114294:	e3404511 	movt	r4, #1297	; 0x511
 5114298:	e58dc000 	str	ip, [sp]
 511429c:	e12fff34 	blx	r4
 51142a0:	eafffffe 	b	51142a0 <elog_arraydump+0xc80>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51142a4:	e35a0000 	cmp	sl, #0
 51142a8:	0afffe7c 	beq	5113ca0 <elog_arraydump+0x680>
 51142ac:	e59d801c 	ldr	r8, [sp, #28]
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*Data++);
 51142b0:	e30d954c 	movw	r9, #54604	; 0xd54c
 51142b4:	e3409512 	movt	r9, #1298	; 0x512
 51142b8:	ea000002 	b	51142c8 <elog_arraydump+0xca8>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51142bc:	e15a0008 	cmp	sl, r8
                    log_len += array_result;
 51142c0:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51142c4:	0afffe75 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*Data++);
 51142c8:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 51142cc:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 51142d0:	e0840007 	add	r0, r4, r7
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51142d4:	e2888001 	add	r8, r8, #1
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%d ", (int)*Data++);
 51142d8:	e4923004 	ldr	r3, [r2], #4
 51142dc:	e58d2078 	str	r2, [sp, #120]	; 0x78
 51142e0:	e1a02009 	mov	r2, r9
 51142e4:	e12fff36 	blx	r6
                if(array_result > 0)
 51142e8:	e3500000 	cmp	r0, #0
 51142ec:	cafffff2 	bgt	51142bc <elog_arraydump+0xc9c>
 51142f0:	eafffe6a 	b	5113ca0 <elog_arraydump+0x680>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51142f4:	e35a0000 	cmp	sl, #0
 51142f8:	0afffe68 	beq	5113ca0 <elog_arraydump+0x680>
 51142fc:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%02x ", (int)*ArrayData++);
 5114300:	e30d8550 	movw	r8, #54608	; 0xd550
 5114304:	e3408512 	movt	r8, #1298	; 0x512
 5114308:	e083a00a 	add	sl, r3, sl
 511430c:	ea000003 	b	5114320 <elog_arraydump+0xd00>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114310:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                    log_len += array_result;
 5114314:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 5114318:	e153000a 	cmp	r3, sl
 511431c:	0afffe5f 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%02x ", (int)*ArrayData++);
 5114320:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 5114324:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 5114328:	e4d23001 	ldrb	r3, [r2], #1
 511432c:	e58d2078 	str	r2, [sp, #120]	; 0x78
 5114330:	e1a02008 	mov	r2, r8
 5114334:	e0840007 	add	r0, r4, r7
 5114338:	e12fff36 	blx	r6
                if(array_result > 0)
 511433c:	e3500000 	cmp	r0, #0
 5114340:	cafffff2 	bgt	5114310 <elog_arraydump+0xcf0>
 5114344:	eafffe55 	b	5113ca0 <elog_arraydump+0x680>
                log_len += elog_strcpy(log_len, log_buf + log_len, " ");
 5114348:	e30d2554 	movw	r2, #54612	; 0xd554
 511434c:	e3402512 	movt	r2, #1298	; 0x512
 5114350:	eafffde9 	b	5113afc <elog_arraydump+0x4dc>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 5114354:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114358:	e3a0cfc7 	mov	ip, #796	; 0x31c
 511435c:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
 5114360:	e3401512 	movt	r1, #1298	; 0x512
 5114364:	e1a00003 	mov	r0, r3
 5114368:	e30244b0 	movw	r4, #9392	; 0x24b0
 511436c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5114370:	e3404511 	movt	r4, #1297	; 0x511
 5114374:	e58d2008 	str	r2, [sp, #8]
 5114378:	e30d2484 	movw	r2, #54404	; 0xd484
 511437c:	e58d1004 	str	r1, [sp, #4]
 5114380:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114384:	e3402512 	movt	r2, #1298	; 0x512
 5114388:	e58dc010 	str	ip, [sp, #16]
 511438c:	e3401512 	movt	r1, #1298	; 0x512
 5114390:	e58d300c 	str	r3, [sp, #12]
 5114394:	e58dc000 	str	ip, [sp]
 5114398:	e12fff34 	blx	r4
 511439c:	eafffffe 	b	511439c <elog_arraydump+0xd7c>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51143a0:	e35a0000 	cmp	sl, #0
 51143a4:	0afffe3d 	beq	5113ca0 <elog_arraydump+0x680>
 51143a8:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%04x ", (int)*Data++);
 51143ac:	e30d8558 	movw	r8, #54616	; 0xd558
 51143b0:	e3408512 	movt	r8, #1298	; 0x512
 51143b4:	e083a08a 	add	sl, r3, sl, lsl #1
 51143b8:	ea000003 	b	51143cc <elog_arraydump+0xdac>
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51143bc:	e59d3078 	ldr	r3, [sp, #120]	; 0x78
                    log_len += array_result;
 51143c0:	e0877000 	add	r7, r7, r0
            for(ArrayIndex = 0; ArrayIndex < ArrayLen; ArrayIndex++)
 51143c4:	e153000a 	cmp	r3, sl
 51143c8:	0afffe34 	beq	5113ca0 <elog_arraydump+0x680>
                array_result = snprintf(log_buf + log_len, ELOG_LINE_BUF_SIZE - log_len, "%04x ", (int)*Data++);
 51143cc:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
 51143d0:	e2671b01 	rsb	r1, r7, #1024	; 0x400
 51143d4:	e0d230b2 	ldrh	r3, [r2], #2
 51143d8:	e58d2078 	str	r2, [sp, #120]	; 0x78
 51143dc:	e1a02008 	mov	r2, r8
 51143e0:	e0840007 	add	r0, r4, r7
 51143e4:	e12fff36 	blx	r6
                if(array_result > 0)
 51143e8:	e3500000 	cmp	r0, #0
 51143ec:	cafffff2 	bgt	51143bc <elog_arraydump+0xd9c>
 51143f0:	eafffe2a 	b	5113ca0 <elog_arraydump+0x680>
    ELOG_ASSERT(level <= ELOG_LVL_VERBOSE);
 51143f4:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51143f8:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51143fc:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
 5114400:	e3401512 	movt	r1, #1298	; 0x512
 5114404:	e1a00003 	mov	r0, r3
 5114408:	e30244b0 	movw	r4, #9392	; 0x24b0
 511440c:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5114410:	e3404511 	movt	r4, #1297	; 0x511
 5114414:	e58d2008 	str	r2, [sp, #8]
 5114418:	e30d2484 	movw	r2, #54404	; 0xd484
 511441c:	e58d1004 	str	r1, [sp, #4]
 5114420:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114424:	e3402512 	movt	r2, #1298	; 0x512
 5114428:	e58dc010 	str	ip, [sp, #16]
 511442c:	e3401512 	movt	r1, #1298	; 0x512
 5114430:	e58d300c 	str	r3, [sp, #12]
 5114434:	e58dc000 	str	ip, [sp]
 5114438:	e12fff34 	blx	r4
 511443c:	eafffffe 	b	511443c <elog_arraydump+0xe1c>
 5114440:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 5114444:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114448:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
 511444c:	e3402512 	movt	r2, #1298	; 0x512
 5114450:	e1a00003 	mov	r0, r3
 5114454:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114458:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 511445c:	e3404511 	movt	r4, #1297	; 0x511
 5114460:	e58d300c 	str	r3, [sp, #12]
 5114464:	e30d359c 	movw	r3, #54684	; 0xd59c
 5114468:	e58d1008 	str	r1, [sp, #8]
 511446c:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114470:	e58d2004 	str	r2, [sp, #4]
 5114474:	e30d2484 	movw	r2, #54404	; 0xd484
 5114478:	e3403512 	movt	r3, #1298	; 0x512
 511447c:	e3402512 	movt	r2, #1298	; 0x512
 5114480:	e58dc010 	str	ip, [sp, #16]
 5114484:	e3401512 	movt	r1, #1298	; 0x512
 5114488:	e58dc000 	str	ip, [sp]
 511448c:	e12fff34 	blx	r4
 5114490:	eafffffe 	b	5114490 <elog_arraydump+0xe70>
 5114494:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 5114498:	e3a0cfc7 	mov	ip, #796	; 0x31c
 511449c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
 51144a0:	e3402512 	movt	r2, #1298	; 0x512
 51144a4:	e1a00003 	mov	r0, r3
 51144a8:	e30244b0 	movw	r4, #9392	; 0x24b0
 51144ac:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 51144b0:	e3404511 	movt	r4, #1297	; 0x511
 51144b4:	e58d300c 	str	r3, [sp, #12]
 51144b8:	e30d359c 	movw	r3, #54684	; 0xd59c
 51144bc:	e58d1008 	str	r1, [sp, #8]
 51144c0:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51144c4:	e58d2004 	str	r2, [sp, #4]
 51144c8:	e30d2484 	movw	r2, #54404	; 0xd484
 51144cc:	e3403512 	movt	r3, #1298	; 0x512
 51144d0:	e3402512 	movt	r2, #1298	; 0x512
 51144d4:	e58dc010 	str	ip, [sp, #16]
 51144d8:	e3401512 	movt	r1, #1298	; 0x512
 51144dc:	e58dc000 	str	ip, [sp]
 51144e0:	e12fff34 	blx	r4
 51144e4:	eafffffe 	b	51144e4 <elog_arraydump+0xec4>
 51144e8:	e30d359c 	movw	r3, #54684	; 0xd59c
 51144ec:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 51144f0:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51144f4:	e3402512 	movt	r2, #1298	; 0x512
 51144f8:	e3401512 	movt	r1, #1298	; 0x512
 51144fc:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114500:	e3403512 	movt	r3, #1298	; 0x512
 5114504:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114508:	e1a00007 	mov	r0, r7
 511450c:	e1cd20f8 	strd	r2, [sp, #8]
 5114510:	e30d2484 	movw	r2, #54404	; 0xd484
 5114514:	e58d1004 	str	r1, [sp, #4]
 5114518:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 511451c:	e3402512 	movt	r2, #1298	; 0x512
 5114520:	e3401512 	movt	r1, #1298	; 0x512
 5114524:	e58dc010 	str	ip, [sp, #16]
 5114528:	e3404511 	movt	r4, #1297	; 0x511
 511452c:	e58dc000 	str	ip, [sp]
 5114530:	e12fff34 	blx	r4
 5114534:	eafffffe 	b	5114534 <elog_arraydump+0xf14>
 5114538:	e30d359c 	movw	r3, #54684	; 0xd59c
 511453c:	e30d24b0 	movw	r2, #54448	; 0xd4b0
 5114540:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114544:	e3402512 	movt	r2, #1298	; 0x512
 5114548:	e3401512 	movt	r1, #1298	; 0x512
 511454c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114550:	e3403512 	movt	r3, #1298	; 0x512
 5114554:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114558:	e1a00006 	mov	r0, r6
 511455c:	e1cd20f8 	strd	r2, [sp, #8]
 5114560:	e30d2484 	movw	r2, #54404	; 0xd484
 5114564:	e58d1004 	str	r1, [sp, #4]
 5114568:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 511456c:	e3402512 	movt	r2, #1298	; 0x512
 5114570:	e3401512 	movt	r1, #1298	; 0x512
 5114574:	e58dc010 	str	ip, [sp, #16]
 5114578:	e3404511 	movt	r4, #1297	; 0x511
 511457c:	e58dc000 	str	ip, [sp]
 5114580:	e12fff34 	blx	r4
 5114584:	eafffffe 	b	5114584 <elog_arraydump+0xf64>
 5114588:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 511458c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114590:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
 5114594:	e3402512 	movt	r2, #1298	; 0x512
 5114598:	e1a00003 	mov	r0, r3
 511459c:	e30244b0 	movw	r4, #9392	; 0x24b0
 51145a0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 51145a4:	e3404511 	movt	r4, #1297	; 0x511
 51145a8:	e58d300c 	str	r3, [sp, #12]
 51145ac:	e30d359c 	movw	r3, #54684	; 0xd59c
 51145b0:	e58d1008 	str	r1, [sp, #8]
 51145b4:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51145b8:	e58d2004 	str	r2, [sp, #4]
 51145bc:	e30d2484 	movw	r2, #54404	; 0xd484
 51145c0:	e3403512 	movt	r3, #1298	; 0x512
 51145c4:	e3402512 	movt	r2, #1298	; 0x512
 51145c8:	e58dc010 	str	ip, [sp, #16]
 51145cc:	e3401512 	movt	r1, #1298	; 0x512
 51145d0:	e58dc000 	str	ip, [sp]
 51145d4:	e12fff34 	blx	r4
 51145d8:	eafffffe 	b	51145d8 <elog_arraydump+0xfb8>
 51145dc:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51145e0:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51145e4:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
 51145e8:	e3401512 	movt	r1, #1298	; 0x512
 51145ec:	e1a00003 	mov	r0, r3
 51145f0:	e30244b0 	movw	r4, #9392	; 0x24b0
 51145f4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 51145f8:	e3404511 	movt	r4, #1297	; 0x511
 51145fc:	e58d2008 	str	r2, [sp, #8]
 5114600:	e30d2484 	movw	r2, #54404	; 0xd484
 5114604:	e58d1004 	str	r1, [sp, #4]
 5114608:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 511460c:	e3402512 	movt	r2, #1298	; 0x512
 5114610:	e58dc010 	str	ip, [sp, #16]
 5114614:	e3401512 	movt	r1, #1298	; 0x512
 5114618:	e58d300c 	str	r3, [sp, #12]
 511461c:	e58dc000 	str	ip, [sp]
 5114620:	e12fff34 	blx	r4
 5114624:	eafffffe 	b	5114624 <elog_arraydump+0x1004>
 5114628:	e30d24cc 	movw	r2, #54476	; 0xd4cc
 511462c:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114630:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
 5114634:	e3402512 	movt	r2, #1298	; 0x512
 5114638:	e1a00003 	mov	r0, r3
 511463c:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114640:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5114644:	e3404511 	movt	r4, #1297	; 0x511
 5114648:	e58d300c 	str	r3, [sp, #12]
 511464c:	e30d359c 	movw	r3, #54684	; 0xd59c
 5114650:	e58d1008 	str	r1, [sp, #8]
 5114654:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114658:	e58d2004 	str	r2, [sp, #4]
 511465c:	e30d2484 	movw	r2, #54404	; 0xd484
 5114660:	e3403512 	movt	r3, #1298	; 0x512
 5114664:	e3402512 	movt	r2, #1298	; 0x512
 5114668:	e58dc010 	str	ip, [sp, #16]
 511466c:	e3401512 	movt	r1, #1298	; 0x512
 5114670:	e58dc000 	str	ip, [sp]
 5114674:	e12fff34 	blx	r4
 5114678:	eafffffe 	b	5114678 <elog_arraydump+0x1058>
 511467c:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 5114680:	e3a0cfc7 	mov	ip, #796	; 0x31c
 5114684:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
 5114688:	e3401512 	movt	r1, #1298	; 0x512
 511468c:	e1a00003 	mov	r0, r3
 5114690:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114694:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 5114698:	e3404511 	movt	r4, #1297	; 0x511
 511469c:	e58d2008 	str	r2, [sp, #8]
 51146a0:	e30d2484 	movw	r2, #54404	; 0xd484
 51146a4:	e58d1004 	str	r1, [sp, #4]
 51146a8:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51146ac:	e3402512 	movt	r2, #1298	; 0x512
 51146b0:	e58dc010 	str	ip, [sp, #16]
 51146b4:	e3401512 	movt	r1, #1298	; 0x512
 51146b8:	e58d300c 	str	r3, [sp, #12]
 51146bc:	e58dc000 	str	ip, [sp]
 51146c0:	e12fff34 	blx	r4
 51146c4:	eafffffe 	b	51146c4 <elog_arraydump+0x10a4>
 51146c8:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51146cc:	e3a0cfc7 	mov	ip, #796	; 0x31c
 51146d0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
 51146d4:	e3401512 	movt	r1, #1298	; 0x512
 51146d8:	e1a00003 	mov	r0, r3
 51146dc:	e30244b0 	movw	r4, #9392	; 0x24b0
 51146e0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
 51146e4:	e3404511 	movt	r4, #1297	; 0x511
 51146e8:	e58d2008 	str	r2, [sp, #8]
 51146ec:	e30d2484 	movw	r2, #54404	; 0xd484
 51146f0:	e58d1004 	str	r1, [sp, #4]
 51146f4:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 51146f8:	e3402512 	movt	r2, #1298	; 0x512
 51146fc:	e58dc010 	str	ip, [sp, #16]
 5114700:	e3401512 	movt	r1, #1298	; 0x512
 5114704:	e58d300c 	str	r3, [sp, #12]
 5114708:	e58dc000 	str	ip, [sp]
 511470c:	e12fff34 	blx	r4
 5114710:	eafffffe 	b	5114710 <elog_arraydump+0x10f0>
 5114714:	05137d71 	.word	0x05137d71

05114718 <elog_strcpy>:
 * @param dst destination
 * @param src source
 *
 * @return copied length
 */
size_t elog_strcpy(size_t cur_len, char *dst, const char *src) {
 5114718:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 511471c:	e1a05000 	mov	r5, r0
    const char *src_old = src;

    assert(dst);
 5114720:	e2514000 	subs	r4, r1, #0
size_t elog_strcpy(size_t cur_len, char *dst, const char *src) {
 5114724:	e1a06002 	mov	r6, r2
 5114728:	e24dd01c 	sub	sp, sp, #28
    assert(dst);
 511472c:	0a000015 	beq	5114788 <elog_strcpy+0x70>
    assert(src);
 5114730:	e3560000 	cmp	r6, #0
 5114734:	0a000020 	beq	51147bc <elog_strcpy+0xa4>

    while (*src != 0) 
 5114738:	e1d630d0 	ldrsb	r3, [r6]
 511473c:	e3530000 	cmp	r3, #0
 5114740:	0a00004a 	beq	5114870 <elog_strcpy+0x158>
    {
        /* make sure destination has enough space */
        if (cur_len++ < ELOG_LINE_BUF_SIZE) 
 5114744:	e3550b01 	cmp	r5, #1024	; 0x400
 5114748:	23a00000 	movcs	r0, #0
 511474c:	2a00000b 	bcs	5114780 <elog_strcpy+0x68>
 5114750:	e265cb01 	rsb	ip, r5, #1024	; 0x400
 5114754:	e2861001 	add	r1, r6, #1
 5114758:	e084c00c 	add	ip, r4, ip
 511475c:	ea000001 	b	5114768 <elog_strcpy+0x50>
 5114760:	e154000c 	cmp	r4, ip
 5114764:	0a000004 	beq	511477c <elog_strcpy+0x64>
        {
            *dst++ = *src++;
 5114768:	e4c43001 	strb	r3, [r4], #1
 511476c:	e1a00001 	mov	r0, r1
    while (*src != 0) 
 5114770:	e0d130d1 	ldrsb	r3, [r1], #1
 5114774:	e3530000 	cmp	r3, #0
 5114778:	1afffff8 	bne	5114760 <elog_strcpy+0x48>
        else 
        {
            break;
        }
    }
    return src - src_old;
 511477c:	e0400006 	sub	r0, r0, r6
}
 5114780:	e28dd01c 	add	sp, sp, #28
 5114784:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    assert(dst);
 5114788:	e3073dc8 	movw	r3, #32200	; 0x7dc8
 511478c:	e3403513 	movt	r3, #1299	; 0x513
 5114790:	e5937000 	ldr	r7, [r3]
 5114794:	e3570000 	cmp	r7, #0
 5114798:	0a000020 	beq	5114820 <elog_strcpy+0x108>
 511479c:	e30d163c 	movw	r1, #54844	; 0xd63c
 51147a0:	e30d0634 	movw	r0, #54836	; 0xd634
 51147a4:	e3a0202c 	mov	r2, #44	; 0x2c
 51147a8:	e3401512 	movt	r1, #1298	; 0x512
 51147ac:	e3400512 	movt	r0, #1298	; 0x512
 51147b0:	e12fff37 	blx	r7
    assert(src);
 51147b4:	e3560000 	cmp	r6, #0
 51147b8:	1affffde 	bne	5114738 <elog_strcpy+0x20>
 51147bc:	e3073dc8 	movw	r3, #32200	; 0x7dc8
 51147c0:	e3403513 	movt	r3, #1299	; 0x513
 51147c4:	e5933000 	ldr	r3, [r3]
 51147c8:	e3530000 	cmp	r3, #0
 51147cc:	1a000029 	bne	5114878 <elog_strcpy+0x160>
 51147d0:	e30d363c 	movw	r3, #54844	; 0xd63c
 51147d4:	e30d2638 	movw	r2, #54840	; 0xd638
 51147d8:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 51147dc:	e3402512 	movt	r2, #1298	; 0x512
 51147e0:	e3401512 	movt	r1, #1298	; 0x512
 51147e4:	e3a0c02d 	mov	ip, #45	; 0x2d
 51147e8:	e3403512 	movt	r3, #1298	; 0x512
 51147ec:	e30244b0 	movw	r4, #9392	; 0x24b0
 51147f0:	e1a00006 	mov	r0, r6
 51147f4:	e1cd20f8 	strd	r2, [sp, #8]
 51147f8:	e30d260c 	movw	r2, #54796	; 0xd60c
 51147fc:	e58d1004 	str	r1, [sp, #4]
 5114800:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114804:	e3402512 	movt	r2, #1298	; 0x512
 5114808:	e3401512 	movt	r1, #1298	; 0x512
 511480c:	e58dc010 	str	ip, [sp, #16]
 5114810:	e3404511 	movt	r4, #1297	; 0x511
 5114814:	e58dc000 	str	ip, [sp]
 5114818:	e12fff34 	blx	r4
 511481c:	eafffffe 	b	511481c <elog_strcpy+0x104>
    assert(dst);
 5114820:	e30d363c 	movw	r3, #54844	; 0xd63c
 5114824:	e30d2634 	movw	r2, #54836	; 0xd634
 5114828:	e30d14cc 	movw	r1, #54476	; 0xd4cc
 511482c:	e3402512 	movt	r2, #1298	; 0x512
 5114830:	e3401512 	movt	r1, #1298	; 0x512
 5114834:	e3a0c02c 	mov	ip, #44	; 0x2c
 5114838:	e3403512 	movt	r3, #1298	; 0x512
 511483c:	e30244b0 	movw	r4, #9392	; 0x24b0
 5114840:	e1a00007 	mov	r0, r7
 5114844:	e1cd20f8 	strd	r2, [sp, #8]
 5114848:	e30d260c 	movw	r2, #54796	; 0xd60c
 511484c:	e58d1004 	str	r1, [sp, #4]
 5114850:	e30d14a8 	movw	r1, #54440	; 0xd4a8
 5114854:	e3402512 	movt	r2, #1298	; 0x512
 5114858:	e3401512 	movt	r1, #1298	; 0x512
 511485c:	e58dc010 	str	ip, [sp, #16]
 5114860:	e3404511 	movt	r4, #1297	; 0x511
 5114864:	e58dc000 	str	ip, [sp]
 5114868:	e12fff34 	blx	r4
 511486c:	eafffffe 	b	511486c <elog_strcpy+0x154>
    while (*src != 0) 
 5114870:	e1a00003 	mov	r0, r3
    return src - src_old;
 5114874:	eaffffc1 	b	5114780 <elog_strcpy+0x68>
    assert(src);
 5114878:	e30d163c 	movw	r1, #54844	; 0xd63c
 511487c:	e30d0638 	movw	r0, #54840	; 0xd638
 5114880:	e3a0202d 	mov	r2, #45	; 0x2d
 5114884:	e3401512 	movt	r1, #1298	; 0x512
 5114888:	e3400512 	movt	r0, #1298	; 0x512
 511488c:	e12fff33 	blx	r3
    while (*src != 0) 
 5114890:	e5d63000 	ldrb	r3, [r6]
 5114894:	e7f000f0 	udf	#0

05114898 <shellExtParsePara>:
 * @param shell shell对象
 * @param string 参数
 * @return unsigned int 解析结果
 */
unsigned int shellExtParsePara(Shell *shell, char *string)
{
 5114898:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    if (*string == '\'' && *(string + 1))
 511489c:	e1d120d0 	ldrsb	r2, [r1]
 51148a0:	e3520027 	cmp	r2, #39	; 0x27
 51148a4:	0a00001c 	beq	511491c <shellExtParsePara+0x84>
    {
        return (unsigned int)shellExtParseChar(string);
    }
    else if (*string == '-' || (*string >= '0' && *string <= '9'))
 51148a8:	e1a04000 	mov	r4, r0
 51148ac:	e2423030 	sub	r3, r2, #48	; 0x30
 51148b0:	e6ef3073 	uxtb	r3, r3
 51148b4:	e352002d 	cmp	r2, #45	; 0x2d
 51148b8:	13530009 	cmpne	r3, #9
 51148bc:	93a03001 	movls	r3, #1
 51148c0:	83a03000 	movhi	r3, #0
 51148c4:	9a00004c 	bls	51149fc <shellExtParsePara+0x164>
    {
        return (unsigned int)shellExtParseNumber(string);
    }
    else if (*string == '$' && *(string + 1))
 51148c8:	e3520024 	cmp	r2, #36	; 0x24
 51148cc:	0a000003 	beq	51148e0 <shellExtParsePara+0x48>
    {
        return shellExtParseVar(shell, string);
    }
    else if (*string)
 51148d0:	e3520000 	cmp	r2, #0
 51148d4:	1a0000e5 	bne	5114c70 <shellExtParsePara+0x3d8>
        return 0;
 51148d8:	e3a00000 	mov	r0, #0
 51148dc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    else if (*string == '$' && *(string + 1))
 51148e0:	e1d1c0d1 	ldrsb	ip, [r1, #1]
 51148e4:	e35c0000 	cmp	ip, #0
 51148e8:	0a00000e 	beq	5114928 <shellExtParsePara+0x90>
    ShellCommand *command = shellSeekCommand(shell,
 51148ec:	e3065aec 	movw	r5, #27372	; 0x6aec
 51148f0:	e2811001 	add	r1, r1, #1
 51148f4:	e5902058 	ldr	r2, [r0, #88]	; 0x58
 51148f8:	e3405511 	movt	r5, #1297	; 0x511
 51148fc:	e12fff35 	blx	r5
    if (command)
 5114900:	e2501000 	subs	r1, r0, #0
 5114904:	0afffff3 	beq	51148d8 <shellExtParsePara+0x40>
        return shellGetVarValue(shell, command);
 5114908:	e3063fc4 	movw	r3, #28612	; 0x6fc4
 511490c:	e1a00004 	mov	r0, r4
 5114910:	e3403511 	movt	r3, #1297	; 0x511
 5114914:	e12fff33 	blx	r3
 5114918:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (*string == '\'' && *(string + 1))
 511491c:	e1d100d1 	ldrsb	r0, [r1, #1]
 5114920:	e3500000 	cmp	r0, #0
 5114924:	1a000099 	bne	5114b90 <shellExtParsePara+0x2f8>
        p = ++string;
 5114928:	e3a03000 	mov	r3, #0
        if (*p == '\\')
 511492c:	e352005c 	cmp	r2, #92	; 0x5c
        p = ++string;
 5114930:	e1a00001 	mov	r0, r1
            *(string + index) = 0;
 5114934:	e1a05003 	mov	r5, r3
        if (*p == '\\')
 5114938:	0a00000a 	beq	5114968 <shellExtParsePara+0xd0>
        else if (*p == '\"')
 511493c:	e3520022 	cmp	r2, #34	; 0x22
            *(string + index) = 0;
 5114940:	07c15003 	strbeq	r5, [r1, r3]
            *(string + index) = *p;
 5114944:	17c12003 	strbne	r2, [r1, r3]
    while (*p)
 5114948:	e1d020d1 	ldrsb	r2, [r0, #1]
        index ++;
 511494c:	e2833001 	add	r3, r3, #1
    while (*p)
 5114950:	e3520000 	cmp	r2, #0
        p++;
 5114954:	e2800001 	add	r0, r0, #1
        index ++;
 5114958:	e6ff3073 	uxth	r3, r3
    while (*p)
 511495c:	0a000086 	beq	5114b7c <shellExtParsePara+0x2e4>
        if (*p == '\\')
 5114960:	e352005c 	cmp	r2, #92	; 0x5c
 5114964:	1afffff4 	bne	511493c <shellExtParsePara+0xa4>
        switch (*(p + 1))
 5114968:	e1d020d1 	ldrsb	r2, [r0, #1]
 511496c:	e3520030 	cmp	r2, #48	; 0x30
            value = 0;
 5114970:	03a02000 	moveq	r2, #0
            *(string + index) = shellExtParseChar(p - 1);
 5114974:	e081e003 	add	lr, r1, r3
        switch (*(p + 1))
 5114978:	0a00001a 	beq	51149e8 <shellExtParsePara+0x150>
 511497c:	e242c062 	sub	ip, r2, #98	; 0x62
 5114980:	e6ef407c 	uxtb	r4, ip
 5114984:	e3540012 	cmp	r4, #18
 5114988:	8a000016 	bhi	51149e8 <shellExtParsePara+0x150>
 511498c:	e35c0012 	cmp	ip, #18
 5114990:	979ff10c 	ldrls	pc, [pc, ip, lsl #2]
 5114994:	ea000013 	b	51149e8 <shellExtParsePara+0x150>
 5114998:	05114c38 	.word	0x05114c38
 511499c:	051149e8 	.word	0x051149e8
 51149a0:	051149e8 	.word	0x051149e8
 51149a4:	051149e8 	.word	0x051149e8
 51149a8:	051149e8 	.word	0x051149e8
 51149ac:	051149e8 	.word	0x051149e8
 51149b0:	051149e8 	.word	0x051149e8
 51149b4:	051149e8 	.word	0x051149e8
 51149b8:	051149e8 	.word	0x051149e8
 51149bc:	051149e8 	.word	0x051149e8
 51149c0:	051149e8 	.word	0x051149e8
 51149c4:	051149e8 	.word	0x051149e8
 51149c8:	051149f4 	.word	0x051149f4
 51149cc:	051149e8 	.word	0x051149e8
 51149d0:	051149e8 	.word	0x051149e8
 51149d4:	051149e8 	.word	0x051149e8
 51149d8:	05114c40 	.word	0x05114c40
 51149dc:	051149e8 	.word	0x051149e8
 51149e0:	051149e4 	.word	0x051149e4
            value = '\t';
 51149e4:	e3a02009 	mov	r2, #9
            *(string + index) = shellExtParseChar(p - 1);
 51149e8:	e5ce2000 	strb	r2, [lr]
            p++;
 51149ec:	e2800001 	add	r0, r0, #1
 51149f0:	eaffffd4 	b	5114948 <shellExtParsePara+0xb0>
            value = '\n';
 51149f4:	e3a0200a 	mov	r2, #10
            break;
 51149f8:	eafffffa 	b	51149e8 <shellExtParsePara+0x150>
    if (*string == '-')
 51149fc:	e352002d 	cmp	r2, #45	; 0x2d
    if ((*p == '0') && ((*(p + 1) == 'x') || (*(p + 1) == 'X')))
 5114a00:	01d120d1 	ldrsbeq	r2, [r1, #1]
 5114a04:	03a05001 	moveq	r5, #1
    type = shellExtNumType(string + ((sign == -1) ? 1 : 0));
 5114a08:	02810001 	addeq	r0, r1, #1
 5114a0c:	11a00001 	movne	r0, r1
        sign = -1;
 5114a10:	03e0e000 	mvneq	lr, #0
 5114a14:	13a05000 	movne	r5, #0
    signed char sign = 1;
 5114a18:	13a0e001 	movne	lr, #1
    if ((*p == '0') && ((*(p + 1) == 'x') || (*(p + 1) == 'X')))
 5114a1c:	e3520030 	cmp	r2, #48	; 0x30
 5114a20:	0a000079 	beq	5114c0c <shellExtParsePara+0x374>
    while (*p++)
 5114a24:	e3520000 	cmp	r2, #0
    ShellNumType type = NUM_TYPE_DEC;
 5114a28:	01a04002 	moveq	r4, r2
    while (*p++)
 5114a2c:	e2803001 	add	r3, r0, #1
 5114a30:	03a0600a 	moveq	r6, #10
 5114a34:	0a000011 	beq	5114a80 <shellExtParsePara+0x1e8>
    ShellNumType type = NUM_TYPE_DEC;
 5114a38:	e3a04000 	mov	r4, #0
    if ((*p == '0') && ((*(p + 1) == 'x') || (*(p + 1) == 'X')))
 5114a3c:	e1d0c0d1 	ldrsb	ip, [r0, #1]
 5114a40:	ea000005 	b	5114a5c <shellExtParsePara+0x1c4>
    while (*p++)
 5114a44:	e0d2c0d1 	ldrsb	ip, [r2], #1
        if (*p == '.' && *(p + 1) != 0)
 5114a48:	e1a00003 	mov	r0, r3
    while (*p++)
 5114a4c:	e35c0000 	cmp	ip, #0
 5114a50:	0a00003b 	beq	5114b44 <shellExtParsePara+0x2ac>
        if (*p == '.' && *(p + 1) != 0)
 5114a54:	e1d3c0d1 	ldrsb	ip, [r3, #1]
 5114a58:	e1a03002 	mov	r3, r2
    while (*p++)
 5114a5c:	e1a02003 	mov	r2, r3
        if (*p == '.' && *(p + 1) != 0)
 5114a60:	e35c002e 	cmp	ip, #46	; 0x2e
 5114a64:	1afffff6 	bne	5114a44 <shellExtParsePara+0x1ac>
 5114a68:	e1d000d2 	ldrsb	r0, [r0, #2]
 5114a6c:	e3500000 	cmp	r0, #0
 5114a70:	0afffff3 	beq	5114a44 <shellExtParsePara+0x1ac>
 5114a74:	e3a02000 	mov	r2, #0
            type = NUM_TYPE_FLOAT;
 5114a78:	e3a04004 	mov	r4, #4
 5114a7c:	e3a0600a 	mov	r6, #10
    p = string + offset + ((sign == -1) ? 1 : 0);
 5114a80:	e0822005 	add	r2, r2, r5
    while (*p)
 5114a84:	e19100d2 	ldrsb	r0, [r1, r2]
 5114a88:	e3500000 	cmp	r0, #0
    p = string + offset + ((sign == -1) ? 1 : 0);
 5114a8c:	e0811002 	add	r1, r1, r2
    while (*p)
 5114a90:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
    unsigned int devide = 0;
 5114a94:	e3a02000 	mov	r2, #0
 5114a98:	e2815001 	add	r5, r1, #1
    unsigned int valueInt = 0;
 5114a9c:	e1a01002 	mov	r1, r2
        if (*p == '.')
 5114aa0:	e350002e 	cmp	r0, #46	; 0x2e
            devide = 1;
 5114aa4:	03a02001 	moveq	r2, #1
    if ((code >= '0') && (code <= '9'))
 5114aa8:	e6ef3070 	uxtb	r3, r0
 5114aac:	e243c030 	sub	ip, r3, #48	; 0x30
    else if ((code >= 'a') && (code <= 'f'))
 5114ab0:	e2430061 	sub	r0, r3, #97	; 0x61
        if (*p == '.')
 5114ab4:	0a00000e 	beq	5114af4 <shellExtParsePara+0x25c>
    if ((code >= '0') && (code <= '9'))
 5114ab8:	e6efc07c 	uxtb	ip, ip
        valueInt = valueInt * radix + shellExtToNum(*p);
 5114abc:	e0010196 	mul	r1, r6, r1
    if ((code >= '0') && (code <= '9'))
 5114ac0:	e35c0009 	cmp	ip, #9
    else if ((code >= 'A') && (code <= 'F'))
 5114ac4:	e2437041 	sub	r7, r3, #65	; 0x41
        valueInt = valueInt * radix + shellExtToNum(*p);
 5114ac8:	9081100c 	addls	r1, r1, ip
    if ((code >= '0') && (code <= '9'))
 5114acc:	9a000006 	bls	5114aec <shellExtParsePara+0x254>
    else if ((code >= 'a') && (code <= 'f'))
 5114ad0:	e3500005 	cmp	r0, #5
        return code - 'a' + 10;
 5114ad4:	92433057 	subls	r3, r3, #87	; 0x57
        valueInt = valueInt * radix + shellExtToNum(*p);
 5114ad8:	96e11073 	uxtabls	r1, r1, r3
    else if ((code >= 'a') && (code <= 'f'))
 5114adc:	9a000002 	bls	5114aec <shellExtParsePara+0x254>
        return code - 'A' + 10;
 5114ae0:	e2433037 	sub	r3, r3, #55	; 0x37
    else if ((code >= 'A') && (code <= 'F'))
 5114ae4:	e3570005 	cmp	r7, #5
        valueInt = valueInt * radix + shellExtToNum(*p);
 5114ae8:	96e11073 	uxtabls	r1, r1, r3
        devide *= 10;
 5114aec:	e0822102 	add	r2, r2, r2, lsl #2
 5114af0:	e1a02082 	lsl	r2, r2, #1
    while (*p)
 5114af4:	e0d500d1 	ldrsb	r0, [r5], #1
 5114af8:	e3500000 	cmp	r0, #0
 5114afc:	1affffe7 	bne	5114aa0 <shellExtParsePara+0x208>
    if (type == NUM_TYPE_FLOAT && devide != 0)
 5114b00:	e2444004 	sub	r4, r4, #4
 5114b04:	e16f4f14 	clz	r4, r4
 5114b08:	e3520000 	cmp	r2, #0
 5114b0c:	e1a042a4 	lsr	r4, r4, #5
 5114b10:	03a04000 	moveq	r4, #0
 5114b14:	e3540000 	cmp	r4, #0
        return valueInt * sign;
 5114b18:	00000e91 	muleq	r0, r1, lr
        value.valueFloat = (float)valueInt / devide * sign;
 5114b1c:	1e071a90 	vmovne	s15, r1
 5114b20:	1eb87a67 	vcvtne.f32.u32	s14, s15
 5114b24:	1e072a90 	vmovne	s15, r2
 5114b28:	1ef86a67 	vcvtne.f32.u32	s13, s15
 5114b2c:	1e07ea90 	vmovne	s15, lr
 5114b30:	1eb86ae7 	vcvtne.f32.s32	s12, s15
 5114b34:	1ec77a26 	vdivne.f32	s15, s14, s13
 5114b38:	1e677a86 	vmulne.f32	s15, s15, s12
 5114b3c:	1e170a90 	vmovne	r0, s15
        return *(unsigned int *)(&value.valueInt);
 5114b40:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5114b44:	e2443001 	sub	r3, r4, #1
 5114b48:	e6ef3073 	uxtb	r3, r3
    switch ((char)type)
 5114b4c:	e3530002 	cmp	r3, #2
    while (*p++)
 5114b50:	81a0400c 	movhi	r4, ip
 5114b54:	83a0600a 	movhi	r6, #10
 5114b58:	81a02004 	movhi	r2, r4
 5114b5c:	8affffc7 	bhi	5114a80 <shellExtParsePara+0x1e8>
 5114b60:	e30d2648 	movw	r2, #54856	; 0xd648
 5114b64:	e3402512 	movt	r2, #1298	; 0x512
 5114b68:	e19260d3 	ldrsb	r6, [r2, r3]
    p = string + offset + ((sign == -1) ? 1 : 0);
 5114b6c:	e30d264c 	movw	r2, #54860	; 0xd64c
 5114b70:	e3402512 	movt	r2, #1298	; 0x512
 5114b74:	e19220d3 	ldrsb	r2, [r2, r3]
 5114b78:	eaffffc0 	b	5114a80 <shellExtParsePara+0x1e8>
    *(string + index) = 0;
 5114b7c:	e0813003 	add	r3, r1, r3
 5114b80:	e3a02000 	mov	r2, #0
    {
        return (unsigned int)shellExtParseString(string);
 5114b84:	e1a00001 	mov	r0, r1
    *(string + index) = 0;
 5114b88:	e5c32000 	strb	r2, [r3]
    }
    return 0;
}
 5114b8c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (*p == '\\')
 5114b90:	e350005c 	cmp	r0, #92	; 0x5c
 5114b94:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
        switch (*(p + 1))
 5114b98:	e1d110d2 	ldrsb	r1, [r1, #2]
 5114b9c:	e3510030 	cmp	r1, #48	; 0x30
 5114ba0:	0affff4c 	beq	51148d8 <shellExtParsePara+0x40>
 5114ba4:	e2413062 	sub	r3, r1, #98	; 0x62
 5114ba8:	e6ef2073 	uxtb	r2, r3
 5114bac:	e3520012 	cmp	r2, #18
 5114bb0:	8a000024 	bhi	5114c48 <shellExtParsePara+0x3b0>
 5114bb4:	e3530012 	cmp	r3, #18
 5114bb8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 5114bbc:	ea000021 	b	5114c48 <shellExtParsePara+0x3b0>
 5114bc0:	05114c68 	.word	0x05114c68
 5114bc4:	05114c48 	.word	0x05114c48
 5114bc8:	05114c48 	.word	0x05114c48
 5114bcc:	05114c48 	.word	0x05114c48
 5114bd0:	05114c48 	.word	0x05114c48
 5114bd4:	05114c48 	.word	0x05114c48
 5114bd8:	05114c48 	.word	0x05114c48
 5114bdc:	05114c48 	.word	0x05114c48
 5114be0:	05114c48 	.word	0x05114c48
 5114be4:	05114c48 	.word	0x05114c48
 5114be8:	05114c48 	.word	0x05114c48
 5114bec:	05114c48 	.word	0x05114c48
 5114bf0:	05114c58 	.word	0x05114c58
 5114bf4:	05114c48 	.word	0x05114c48
 5114bf8:	05114c48 	.word	0x05114c48
 5114bfc:	05114c48 	.word	0x05114c48
 5114c00:	05114c60 	.word	0x05114c60
 5114c04:	05114c48 	.word	0x05114c48
 5114c08:	05114c50 	.word	0x05114c50
    if ((*p == '0') && ((*(p + 1) == 'x') || (*(p + 1) == 'X')))
 5114c0c:	e1d0c0d1 	ldrsb	ip, [r0, #1]
 5114c10:	e3cc3020 	bic	r3, ip, #32
 5114c14:	e3530058 	cmp	r3, #88	; 0x58
        type = NUM_TYPE_HEX;
 5114c18:	03a04003 	moveq	r4, #3
    if ((*p == '0') && ((*(p + 1) == 'x') || (*(p + 1) == 'X')))
 5114c1c:	1a000001 	bne	5114c28 <shellExtParsePara+0x390>
    while (*p++)
 5114c20:	e2803001 	add	r3, r0, #1
 5114c24:	eaffff8c 	b	5114a5c <shellExtParsePara+0x1c4>
        type = NUM_TYPE_OCT;
 5114c28:	e3530042 	cmp	r3, #66	; 0x42
 5114c2c:	03a04001 	moveq	r4, #1
 5114c30:	13a04002 	movne	r4, #2
 5114c34:	eafffff9 	b	5114c20 <shellExtParsePara+0x388>
        switch (*(p + 1))
 5114c38:	e3a02008 	mov	r2, #8
 5114c3c:	eaffff69 	b	51149e8 <shellExtParsePara+0x150>
            value = '\r';
 5114c40:	e3a0200d 	mov	r2, #13
 5114c44:	eaffff67 	b	51149e8 <shellExtParsePara+0x150>
        return (unsigned int)shellExtParseChar(string);
 5114c48:	e1a00001 	mov	r0, r1
            break;
 5114c4c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            break;
 5114c50:	e3a00009 	mov	r0, #9
 5114c54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            break;
 5114c58:	e3a0000a 	mov	r0, #10
 5114c5c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        switch (*(p + 1))
 5114c60:	e3a0000d 	mov	r0, #13
        return (unsigned int)shellExtParseChar(string);
 5114c64:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        switch (*(p + 1))
 5114c68:	e3a00008 	mov	r0, #8
 5114c6c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    if (*string == '\"')
 5114c70:	e3520022 	cmp	r2, #34	; 0x22
 5114c74:	1affff2b 	bne	5114928 <shellExtParsePara+0x90>
    while (*p)
 5114c78:	e1d120d1 	ldrsb	r2, [r1, #1]
 5114c7c:	e3520000 	cmp	r2, #0
        p = ++string;
 5114c80:	e2813001 	add	r3, r1, #1
 5114c84:	e1a01003 	mov	r1, r3
    while (*p)
 5114c88:	1affff26 	bne	5114928 <shellExtParsePara+0x90>
 5114c8c:	eaffffbb 	b	5114b80 <shellExtParsePara+0x2e8>

05114c90 <shellExtRun>:
 * @param argc 参数个数
 * @param argv 参数
 * @return int 返回值
 */
int shellExtRun(Shell *shell, ShellCommand *command, int argc, char *argv[])
{
 5114c90:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5114c94:	e1a05003 	mov	r5, r3
 5114c98:	e24dd034 	sub	sp, sp, #52	; 0x34
    unsigned int params[SHELL_PARAMETER_MAX_NUMBER] = {0};
 5114c9c:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5114ca0:	e28d8010 	add	r8, sp, #16
{
 5114ca4:	e1a06002 	mov	r6, r2
 5114ca8:	e1a0a001 	mov	sl, r1
 5114cac:	e1a07000 	mov	r7, r0
    unsigned int params[SHELL_PARAMETER_MAX_NUMBER] = {0};
 5114cb0:	e3403511 	movt	r3, #1297	; 0x511
 5114cb4:	e3a02020 	mov	r2, #32
 5114cb8:	e3a01000 	mov	r1, #0
 5114cbc:	e1a00008 	mov	r0, r8
 5114cc0:	e12fff33 	blx	r3
    int paramNum = command->attr.attrs.paramNum > (argc - 1) ? 
 5114cc4:	e5da9002 	ldrb	r9, [sl, #2]
 5114cc8:	e209900f 	and	r9, r9, #15
        command->attr.attrs.paramNum : (argc - 1);
 5114ccc:	e1590006 	cmp	r9, r6
 5114cd0:	b2469001 	sublt	r9, r6, #1
 5114cd4:	b1a06009 	movlt	r6, r9
 5114cd8:	a2466001 	subge	r6, r6, #1
    for (int i = 0; i < argc - 1; i++)
 5114cdc:	e3560000 	cmp	r6, #0
 5114ce0:	c304b898 	movwgt	fp, #18584	; 0x4898
 5114ce4:	c3a04000 	movgt	r4, #0
 5114ce8:	c340b511 	movtgt	fp, #1297	; 0x511
 5114cec:	da000006 	ble	5114d0c <shellExtRun+0x7c>
    {
        params[i] = shellExtParsePara(shell, argv[i + 1]);
 5114cf0:	e5b51004 	ldr	r1, [r5, #4]!
 5114cf4:	e1a00007 	mov	r0, r7
 5114cf8:	e12fff3b 	blx	fp
 5114cfc:	e7880104 	str	r0, [r8, r4, lsl #2]
    for (int i = 0; i < argc - 1; i++)
 5114d00:	e2844001 	add	r4, r4, #1
 5114d04:	e1540006 	cmp	r4, r6
 5114d08:	1afffff8 	bne	5114cf0 <shellExtRun+0x60>
    }
    switch (paramNum)
 5114d0c:	e3590007 	cmp	r9, #7
 5114d10:	979ff109 	ldrls	pc, [pc, r9, lsl #2]
 5114d14:	ea000042 	b	5114e24 <shellExtRun+0x194>
 5114d18:	05114d70 	.word	0x05114d70
 5114d1c:	05114d80 	.word	0x05114d80
 5114d20:	05114d94 	.word	0x05114d94
 5114d24:	05114da8 	.word	0x05114da8
 5114d28:	05114dc0 	.word	0x05114dc0
 5114d2c:	05114dd8 	.word	0x05114dd8
 5114d30:	05114dfc 	.word	0x05114dfc
 5114d34:	05114d38 	.word	0x05114d38
                                          params[4], params[5]);
        // break;
#endif /** SHELL_PARAMETER_MAX_NUMBER >= 7 */
#if SHELL_PARAMETER_MAX_NUMBER >= 8
    case 7:
        return command->data.cmd.function(params[0], params[1],
 5114d38:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
 5114d3c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
 5114d40:	e59d0020 	ldr	r0, [sp, #32]
 5114d44:	e59a4008 	ldr	r4, [sl, #8]
 5114d48:	e59d301c 	ldr	r3, [sp, #28]
 5114d4c:	e58d1008 	str	r1, [sp, #8]
 5114d50:	e58d2004 	str	r2, [sp, #4]
 5114d54:	e58d0000 	str	r0, [sp]
 5114d58:	e59d2018 	ldr	r2, [sp, #24]
 5114d5c:	e59d1014 	ldr	r1, [sp, #20]
 5114d60:	e59d0010 	ldr	r0, [sp, #16]
 5114d64:	e12fff34 	blx	r4
#endif /** SHELL_PARAMETER_MAX_NUMBER >= 16 */
    default:
        return -1;
        // break;
    }
}
 5114d68:	e28dd034 	add	sp, sp, #52	; 0x34
 5114d6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return ((int (*)(void))command->data.cmd.function)();
 5114d70:	e59a3008 	ldr	r3, [sl, #8]
 5114d74:	e12fff33 	blx	r3
}
 5114d78:	e28dd034 	add	sp, sp, #52	; 0x34
 5114d7c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0]);
 5114d80:	e59a3008 	ldr	r3, [sl, #8]
 5114d84:	e59d0010 	ldr	r0, [sp, #16]
 5114d88:	e12fff33 	blx	r3
}
 5114d8c:	e28dd034 	add	sp, sp, #52	; 0x34
 5114d90:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0], params[1]);
 5114d94:	e59a3008 	ldr	r3, [sl, #8]
 5114d98:	e1cd01d0 	ldrd	r0, [sp, #16]
 5114d9c:	e12fff33 	blx	r3
}
 5114da0:	e28dd034 	add	sp, sp, #52	; 0x34
 5114da4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0], params[1],
 5114da8:	e59a3008 	ldr	r3, [sl, #8]
 5114dac:	e28d0010 	add	r0, sp, #16
 5114db0:	e8900007 	ldm	r0, {r0, r1, r2}
 5114db4:	e12fff33 	blx	r3
}
 5114db8:	e28dd034 	add	sp, sp, #52	; 0x34
 5114dbc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0], params[1],
 5114dc0:	e59a4008 	ldr	r4, [sl, #8]
 5114dc4:	e1cd21d8 	ldrd	r2, [sp, #24]
 5114dc8:	e1cd01d0 	ldrd	r0, [sp, #16]
 5114dcc:	e12fff34 	blx	r4
}
 5114dd0:	e28dd034 	add	sp, sp, #52	; 0x34
 5114dd4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0], params[1],
 5114dd8:	e59d0020 	ldr	r0, [sp, #32]
 5114ddc:	e59a4008 	ldr	r4, [sl, #8]
 5114de0:	e1cd21d8 	ldrd	r2, [sp, #24]
 5114de4:	e58d0000 	str	r0, [sp]
 5114de8:	e59d1014 	ldr	r1, [sp, #20]
 5114dec:	e59d0010 	ldr	r0, [sp, #16]
 5114df0:	e12fff34 	blx	r4
}
 5114df4:	e28dd034 	add	sp, sp, #52	; 0x34
 5114df8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.cmd.function(params[0], params[1],
 5114dfc:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
 5114e00:	e59d1020 	ldr	r1, [sp, #32]
 5114e04:	e59a4008 	ldr	r4, [sl, #8]
 5114e08:	e1cd21d8 	ldrd	r2, [sp, #24]
 5114e0c:	e58d0004 	str	r0, [sp, #4]
 5114e10:	e58d1000 	str	r1, [sp]
 5114e14:	e1cd01d0 	ldrd	r0, [sp, #16]
 5114e18:	e12fff34 	blx	r4
}
 5114e1c:	e28dd034 	add	sp, sp, #52	; 0x34
 5114e20:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    for (int i = 0; i < argc - 1; i++)
 5114e24:	e3e00000 	mvn	r0, #0
 5114e28:	eaffffce 	b	5114d68 <shellExtRun+0xd8>

05114e2c <shellRight>:
 * 
 * @param shell shell对象
 */
void shellRight(Shell *shell)
{
    if (shell->parser.cursor < shell->parser.length)
 5114e2c:	e1d030be 	ldrh	r3, [r0, #14]
 5114e30:	e1d020bc 	ldrh	r2, [r0, #12]
 5114e34:	e1520003 	cmp	r2, r3
 5114e38:	912fff1e 	bxls	lr
{
 5114e3c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    {
        shellWriteByte(shell, shell->parser.buffer[shell->parser.cursor++]);
 5114e40:	e2831001 	add	r1, r3, #1
 5114e44:	e590c010 	ldr	ip, [r0, #16]
{
 5114e48:	e24dd00c 	sub	sp, sp, #12
        shellWriteByte(shell, shell->parser.buffer[shell->parser.cursor++]);
 5114e4c:	e1c010be 	strh	r1, [r0, #14]
    shell->write(&data, 1);
 5114e50:	e3a01001 	mov	r1, #1
 5114e54:	e5902068 	ldr	r2, [r0, #104]	; 0x68
        shellWriteByte(shell, shell->parser.buffer[shell->parser.cursor++]);
 5114e58:	e19c30d3 	ldrsb	r3, [ip, r3]
 5114e5c:	e5cd3007 	strb	r3, [sp, #7]
    shell->write(&data, 1);
 5114e60:	e28d0007 	add	r0, sp, #7
 5114e64:	e12fff32 	blx	r2
    }
}
 5114e68:	e28dd00c 	add	sp, sp, #12
 5114e6c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

05114e70 <shellLeft>:
 * 
 * @param shell shell对象
 */
void shellLeft(Shell *shell)
{
    if (shell->parser.cursor > 0)
 5114e70:	e1d030be 	ldrh	r3, [r0, #14]
 5114e74:	e3530000 	cmp	r3, #0
 5114e78:	012fff1e 	bxeq	lr
{
 5114e7c:	e92d4010 	push	{r4, lr}
 5114e80:	e3a02008 	mov	r2, #8
 5114e84:	e24dd008 	sub	sp, sp, #8
 5114e88:	e1a04000 	mov	r4, r0
    shell->write(&data, 1);
 5114e8c:	e3a01001 	mov	r1, #1
 5114e90:	e5903068 	ldr	r3, [r0, #104]	; 0x68
 5114e94:	e28d0007 	add	r0, sp, #7
 5114e98:	e5cd2007 	strb	r2, [sp, #7]
 5114e9c:	e12fff33 	blx	r3
    {
        shellWriteByte(shell, '\b');
        shell->parser.cursor--;
 5114ea0:	e1d430be 	ldrh	r3, [r4, #14]
 5114ea4:	e2433001 	sub	r3, r3, #1
 5114ea8:	e1c430be 	strh	r3, [r4, #14]
    }
}
 5114eac:	e28dd008 	add	sp, sp, #8
 5114eb0:	e8bd8010 	pop	{r4, pc}

05114eb4 <shellGetCommandName>:
        buffer[i] = '0';
 5114eb4:	e30811cc 	movw	r1, #33228	; 0x81cc
 5114eb8:	e3033030 	movw	r3, #12336	; 0x3030
 5114ebc:	e3433030 	movt	r3, #12336	; 0x3030
 5114ec0:	e3401513 	movt	r1, #1299	; 0x513
 5114ec4:	e5813000 	str	r3, [r1]
 5114ec8:	e5813004 	str	r3, [r1, #4]
 5114ecc:	e5c13008 	strb	r3, [r1, #8]
    if (command->attr.attrs.type <= SHELL_TYPE_CMD_FUNC)
 5114ed0:	e5d03001 	ldrb	r3, [r0, #1]
 5114ed4:	e203300f 	and	r3, r3, #15
 5114ed8:	e3530001 	cmp	r3, #1
 5114edc:	9a000016 	bls	5114f3c <shellGetCommandName+0x88>
    else if (command->attr.attrs.type <= SHELL_TYPE_VAR_NODE)
 5114ee0:	e3530007 	cmp	r3, #7
 5114ee4:	9a000014 	bls	5114f3c <shellGetCommandName+0x88>
        return command->data.user.name;
 5114ee8:	e5900004 	ldr	r0, [r0, #4]
    else if (command->attr.attrs.type <= SHELL_TYPE_USER)
 5114eec:	e3530008 	cmp	r3, #8
 5114ef0:	012fff1e 	bxeq	lr
    buffer[8] = 0;
 5114ef4:	e3a03000 	mov	r3, #0
    while (value)
 5114ef8:	e1500003 	cmp	r0, r3
    buffer[8] = 0;
 5114efc:	e5c13008 	strb	r3, [r1, #8]
    while (value)
 5114f00:	0a00000a 	beq	5114f30 <shellGetCommandName+0x7c>
    unsigned char i = 8;
 5114f04:	e3a02008 	mov	r2, #8
        byte = value & 0x0000000F;
 5114f08:	e200300f 	and	r3, r0, #15
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 5114f0c:	e283c057 	add	ip, r3, #87	; 0x57
 5114f10:	e2422001 	sub	r2, r2, #1
 5114f14:	e3530009 	cmp	r3, #9
 5114f18:	e6ef2072 	uxtb	r2, r2
 5114f1c:	e2833030 	add	r3, r3, #48	; 0x30
 5114f20:	c6af307c 	sxtbgt	r3, ip
    while (value)
 5114f24:	e1b00220 	lsrs	r0, r0, #4
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 5114f28:	e7c13002 	strb	r3, [r1, r2]
    while (value)
 5114f2c:	1afffff5 	bne	5114f08 <shellGetCommandName+0x54>
    unsigned char i = 8;
 5114f30:	e30801cc 	movw	r0, #33228	; 0x81cc
 5114f34:	e3400513 	movt	r0, #1299	; 0x513
}
 5114f38:	e12fff1e 	bx	lr
        return command->data.var.name;
 5114f3c:	e5900004 	ldr	r0, [r0, #4]
 5114f40:	e12fff1e 	bx	lr

05114f44 <shellClear>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5114f44:	e30831d8 	movw	r3, #33240	; 0x81d8
 5114f48:	e3403513 	movt	r3, #1299	; 0x513
 5114f4c:	e2830014 	add	r0, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 5114f50:	e4932004 	ldr	r2, [r3], #4
 5114f54:	e3520000 	cmp	r2, #0
 5114f58:	0a000002 	beq	5114f68 <shellClear+0x24>
 5114f5c:	e5d21060 	ldrb	r1, [r2, #96]	; 0x60
 5114f60:	e3110002 	tst	r1, #2
 5114f64:	1a000002 	bne	5114f74 <shellClear+0x30>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5114f68:	e1530000 	cmp	r3, r0
 5114f6c:	1afffff7 	bne	5114f50 <shellClear+0xc>
 5114f70:	e12fff1e 	bx	lr

/**
 * @brief shell 清空控制台(shell调用)
 */
void shellClear(void)
{
 5114f74:	e92d4010 	push	{r4, lr}
    SHELL_ASSERT(shell->write, return 0);
 5114f78:	e5924068 	ldr	r4, [r2, #104]	; 0x68
 5114f7c:	e3540000 	cmp	r4, #0
 5114f80:	08bd8010 	popeq	{r4, pc}
 5114f84:	e59f202c 	ldr	r2, [pc, #44]	; 5114fb8 <shellClear+0x74>
 5114f88:	e3a0305b 	mov	r3, #91	; 0x5b
    unsigned short count = 0;
 5114f8c:	e3a01000 	mov	r1, #0
 5114f90:	ea000000 	b	5114f98 <shellClear+0x54>
    while(*p++)
 5114f94:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5114f98:	e2811001 	add	r1, r1, #1
    while(*p++)
 5114f9c:	e3530000 	cmp	r3, #0
        count ++;
 5114fa0:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5114fa4:	1afffffa 	bne	5114f94 <shellClear+0x50>
    return shell->write((char *)string, count);
 5114fa8:	e30d0650 	movw	r0, #54864	; 0xd650
 5114fac:	e3400512 	movt	r0, #1298	; 0x512
 5114fb0:	e12fff34 	blx	r4
    Shell *shell = shellGetCurrent();
    if (shell)
    {
        shellWriteString(shell, shellText[SHELL_TEXT_CLEAR_CONSOLE]);
    }
}
 5114fb4:	e8bd8010 	pop	{r4, pc}
 5114fb8:	0512d651 	.word	0x0512d651

05114fbc <shellSetUser>:
{
 5114fbc:	e92d4070 	push	{r4, r5, r6, lr}
    shell->info.user = user;
 5114fc0:	e5801000 	str	r1, [r0]
{
 5114fc4:	e1a05000 	mov	r5, r0
        ((user->data.user.password && strlen(user->data.user.password) != 0)
 5114fc8:	e5910008 	ldr	r0, [r1, #8]
         ? 0 : 1;
 5114fcc:	e3500000 	cmp	r0, #0
 5114fd0:	0a000002 	beq	5114fe0 <shellSetUser+0x24>
        ((user->data.user.password && strlen(user->data.user.password) != 0)
 5114fd4:	e1d030d0 	ldrsb	r3, [r0]
 5114fd8:	e3530000 	cmp	r3, #0
 5114fdc:	1a000025 	bne	5115078 <shellSetUser+0xbc>
 5114fe0:	e3a00001 	mov	r0, #1
    SHELL_ASSERT(shell->write, return 0);
 5114fe4:	e5952068 	ldr	r2, [r5, #104]	; 0x68
    shell->status.isChecked = 
 5114fe8:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5114fec:	e7c03010 	bfi	r3, r0, #0, #1
    SHELL_ASSERT(shell->write, return 0);
 5114ff0:	e3520000 	cmp	r2, #0
    shell->status.isChecked = 
 5114ff4:	e5c53060 	strb	r3, [r5, #96]	; 0x60
    SHELL_ASSERT(shell->write, return 0);
 5114ff8:	08bd8070 	popeq	{r4, r5, r6, pc}
 5114ffc:	e59f30a0 	ldr	r3, [pc, #160]	; 51150a4 <shellSetUser+0xe8>
 5115000:	e3a0405b 	mov	r4, #91	; 0x5b
    unsigned short count = 0;
 5115004:	e3a01000 	mov	r1, #0
 5115008:	ea000000 	b	5115010 <shellSetUser+0x54>
    while(*p++)
 511500c:	e1f340d1 	ldrsb	r4, [r3, #1]!
        count ++;
 5115010:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115014:	e3540000 	cmp	r4, #0
        count ++;
 5115018:	e6ff1071 	uxth	r1, r1
    while(*p++)
 511501c:	1afffffa 	bne	511500c <shellSetUser+0x50>
    return shell->write((char *)string, count);
 5115020:	e30d0650 	movw	r0, #54864	; 0xd650
 5115024:	e3400512 	movt	r0, #1298	; 0x512
 5115028:	e12fff32 	blx	r2
    if (shell->status.isChecked)
 511502c:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5115030:	e3130001 	tst	r3, #1
 5115034:	08bd8070 	popeq	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 5115038:	e5955068 	ldr	r5, [r5, #104]	; 0x68
 511503c:	e3550000 	cmp	r5, #0
 5115040:	08bd8070 	popeq	{r4, r5, r6, pc}
 5115044:	e59f205c 	ldr	r2, [pc, #92]	; 51150a8 <shellSetUser+0xec>
 5115048:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 511504c:	e1a01004 	mov	r1, r4
 5115050:	ea000000 	b	5115058 <shellSetUser+0x9c>
    while(*p++)
 5115054:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115058:	e2811001 	add	r1, r1, #1
    while(*p++)
 511505c:	e3530000 	cmp	r3, #0
        count ++;
 5115060:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115064:	1afffffa 	bne	5115054 <shellSetUser+0x98>
    return shell->write((char *)string, count);
 5115068:	e30d065c 	movw	r0, #54876	; 0xd65c
 511506c:	e3400512 	movt	r0, #1298	; 0x512
 5115070:	e12fff35 	blx	r5
}
 5115074:	e8bd8070 	pop	{r4, r5, r6, pc}
         ? 0 : 1;
 5115078:	e1d533b6 	ldrh	r3, [r5, #54]	; 0x36
 511507c:	e3530001 	cmp	r3, #1
 5115080:	93a00000 	movls	r0, #0
 5115084:	9affffd6 	bls	5114fe4 <shellSetUser+0x28>
                || strcmp(user->data.user.password, shell->parser.param[1]) != 0))
 5115088:	e5951018 	ldr	r1, [r5, #24]
 511508c:	e300331d 	movw	r3, #797	; 0x31d
 5115090:	e3403511 	movt	r3, #1297	; 0x511
 5115094:	e12fff33 	blx	r3
 5115098:	e16f0f10 	clz	r0, r0
 511509c:	e1a002a0 	lsr	r0, r0, #5
 51150a0:	eaffffcf 	b	5114fe4 <shellSetUser+0x28>
 51150a4:	0512d651 	.word	0x0512d651
 51150a8:	0512d65d 	.word	0x0512d65d

051150ac <shellWritePrompt.part.0>:
        if (newline)
 51150ac:	e3510000 	cmp	r1, #0
static void shellWritePrompt(Shell *shell, unsigned char newline)
 51150b0:	e92d4070 	push	{r4, r5, r6, lr}
 51150b4:	e1a04000 	mov	r4, r0
        if (newline)
 51150b8:	1a000039 	bne	51151a4 <shellWritePrompt.part.0+0xf8>
    SHELL_ASSERT(shell->write, return 0);
 51150bc:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shellWriteString(shell, shell->info.user->data.user.name);
 51150c0:	e5943000 	ldr	r3, [r4]
    SHELL_ASSERT(shell->write, return 0);
 51150c4:	e3550000 	cmp	r5, #0
        shellWriteString(shell, shell->info.user->data.user.name);
 51150c8:	e5930004 	ldr	r0, [r3, #4]
    SHELL_ASSERT(shell->write, return 0);
 51150cc:	08bd8070 	popeq	{r4, r5, r6, pc}
    while(*p++)
 51150d0:	e1a03000 	mov	r3, r0
 51150d4:	e0d310d1 	ldrsb	r1, [r3], #1
 51150d8:	e3510000 	cmp	r1, #0
 51150dc:	0a000005 	beq	51150f8 <shellWritePrompt.part.0+0x4c>
 51150e0:	e263c001 	rsb	ip, r3, #1
        count ++;
 51150e4:	e083100c 	add	r1, r3, ip
    while(*p++)
 51150e8:	e0d320d1 	ldrsb	r2, [r3], #1
 51150ec:	e3520000 	cmp	r2, #0
 51150f0:	e6ff1071 	uxth	r1, r1
 51150f4:	1afffffa 	bne	51150e4 <shellWritePrompt.part.0+0x38>
    return shell->write((char *)string, count);
 51150f8:	e12fff35 	blx	r5
    SHELL_ASSERT(shell->write, return 0);
 51150fc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 5115100:	e3530000 	cmp	r3, #0
 5115104:	08bd8070 	popeq	{r4, r5, r6, pc}
    return shell->write((char *)string, count);
 5115108:	e30c0ee8 	movw	r0, #52968	; 0xcee8
 511510c:	e3a01001 	mov	r1, #1
 5115110:	e3400512 	movt	r0, #1298	; 0x512
 5115114:	e12fff33 	blx	r3
        shellWriteString(shell, shell->info.path ? shell->info.path : "/");
 5115118:	e5940008 	ldr	r0, [r4, #8]
    SHELL_ASSERT(shell->write, return 0);
 511511c:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shellWriteString(shell, shell->info.path ? shell->info.path : "/");
 5115120:	e3500000 	cmp	r0, #0
 5115124:	0a00002e 	beq	51151e4 <shellWritePrompt.part.0+0x138>
    SHELL_ASSERT(shell->write, return 0);
 5115128:	e3550000 	cmp	r5, #0
 511512c:	08bd8070 	popeq	{r4, r5, r6, pc}
    while(*p++)
 5115130:	e1a03000 	mov	r3, r0
 5115134:	e0d310d1 	ldrsb	r1, [r3], #1
 5115138:	e3510000 	cmp	r1, #0
 511513c:	0a000007 	beq	5115160 <shellWritePrompt.part.0+0xb4>
 5115140:	e1d020d1 	ldrsb	r2, [r0, #1]
 5115144:	e263c001 	rsb	ip, r3, #1
 5115148:	ea000000 	b	5115150 <shellWritePrompt.part.0+0xa4>
 511514c:	e1f320d1 	ldrsb	r2, [r3, #1]!
        count ++;
 5115150:	e08c1003 	add	r1, ip, r3
    while(*p++)
 5115154:	e3520000 	cmp	r2, #0
 5115158:	e6ff1071 	uxth	r1, r1
 511515c:	1afffffa 	bne	511514c <shellWritePrompt.part.0+0xa0>
    return shell->write((char *)string, count);
 5115160:	e12fff35 	blx	r5
    SHELL_ASSERT(shell->write, return 0);
 5115164:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5115168:	e3540000 	cmp	r4, #0
 511516c:	08bd8070 	popeq	{r4, r5, r6, pc}
 5115170:	e59f2088 	ldr	r2, [pc, #136]	; 5115200 <shellWritePrompt.part.0+0x154>
 5115174:	e3a03020 	mov	r3, #32
    unsigned short count = 0;
 5115178:	e3a01000 	mov	r1, #0
 511517c:	ea000000 	b	5115184 <shellWritePrompt.part.0+0xd8>
    while(*p++)
 5115180:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115184:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115188:	e3530000 	cmp	r3, #0
        count ++;
 511518c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115190:	1afffffa 	bne	5115180 <shellWritePrompt.part.0+0xd4>
    return shell->write((char *)string, count);
 5115194:	e30d07bc 	movw	r0, #55228	; 0xd7bc
 5115198:	e3400512 	movt	r0, #1298	; 0x512
 511519c:	e12fff34 	blx	r4
}
 51151a0:	e8bd8070 	pop	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 51151a4:	e5905068 	ldr	r5, [r0, #104]	; 0x68
 51151a8:	e3550000 	cmp	r5, #0
 51151ac:	08bd8070 	popeq	{r4, r5, r6, pc}
 51151b0:	e59f204c 	ldr	r2, [pc, #76]	; 5115204 <shellWritePrompt.part.0+0x158>
 51151b4:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 51151b8:	e3a01000 	mov	r1, #0
 51151bc:	ea000000 	b	51151c4 <shellWritePrompt.part.0+0x118>
    while(*p++)
 51151c0:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51151c4:	e2811001 	add	r1, r1, #1
    while(*p++)
 51151c8:	e3530000 	cmp	r3, #0
        count ++;
 51151cc:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51151d0:	1afffffa 	bne	51151c0 <shellWritePrompt.part.0+0x114>
    return shell->write((char *)string, count);
 51151d4:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 51151d8:	e3400512 	movt	r0, #1298	; 0x512
 51151dc:	e12fff35 	blx	r5
 51151e0:	eaffffb5 	b	51150bc <shellWritePrompt.part.0+0x10>
    SHELL_ASSERT(shell->write, return 0);
 51151e4:	e3550000 	cmp	r5, #0
 51151e8:	08bd8070 	popeq	{r4, r5, r6, pc}
 51151ec:	e1a02000 	mov	r2, r0
        shellWriteString(shell, shell->info.path ? shell->info.path : "/");
 51151f0:	e30d07b8 	movw	r0, #55224	; 0xd7b8
 51151f4:	e3400512 	movt	r0, #1298	; 0x512
    while(*p++)
 51151f8:	e2803001 	add	r3, r0, #1
 51151fc:	eaffffd0 	b	5115144 <shellWritePrompt.part.0+0x98>
 5115200:	0512d7bd 	.word	0x0512d7bd
 5115204:	0512d3e1 	.word	0x0512d3e1

05115208 <shellToDec>:
    buffer[11] = 0;
 5115208:	e3a03000 	mov	r3, #0
    while (v)
 511520c:	e1500003 	cmp	r0, r3
{
 5115210:	e92d4030 	push	{r4, r5, lr}
    buffer[11] = 0;
 5115214:	e5c1300b 	strb	r3, [r1, #11]
 5115218:	e020efc0 	eor	lr, r0, r0, asr #31
 511521c:	e04eefc0 	sub	lr, lr, r0, asr #31
    while (v)
 5115220:	0a000015 	beq	511527c <shellToDec+0x74>
        buffer[--i] = v % 10 + 48;
 5115224:	e30c4ccd 	movw	r4, #52429	; 0xcccd
    unsigned char i = 11;
 5115228:	e3a0c00b 	mov	ip, #11
        buffer[--i] = v % 10 + 48;
 511522c:	e34c4ccc 	movt	r4, #52428	; 0xcccc
 5115230:	e0832e94 	umull	r2, r3, r4, lr
 5115234:	e1a0500c 	mov	r5, ip
 5115238:	e24c2001 	sub	r2, ip, #1
 511523c:	e1a031a3 	lsr	r3, r3, #3
 5115240:	e6efc072 	uxtb	ip, r2
 5115244:	e0832103 	add	r2, r3, r3, lsl #2
 5115248:	e04e2082 	sub	r2, lr, r2, lsl #1
    while (v)
 511524c:	e253e000 	subs	lr, r3, #0
        buffer[--i] = v % 10 + 48;
 5115250:	e2823030 	add	r3, r2, #48	; 0x30
 5115254:	e7c1300c 	strb	r3, [r1, ip]
    while (v)
 5115258:	1afffff4 	bne	5115230 <shellToDec+0x28>
    if (value < 0)
 511525c:	e3500000 	cmp	r0, #0
        buffer[--i] = '-';
 5115260:	b3a0302d 	movlt	r3, #45	; 0x2d
 5115264:	b245c002 	sublt	ip, r5, #2
 5115268:	b6efc07c 	uxtblt	ip, ip
 511526c:	b7c1300c 	strblt	r3, [r1, ip]
    return 11 - i;
 5115270:	e26c000b 	rsb	r0, ip, #11
 5115274:	e6af0070 	sxtb	r0, r0
}
 5115278:	e8bd8030 	pop	{r4, r5, pc}
        buffer[--i] = '0';
 511527c:	e3a03030 	mov	r3, #48	; 0x30
 5115280:	e3a0c00a 	mov	ip, #10
 5115284:	e5c1300a 	strb	r3, [r1, #10]
 5115288:	eafffff8 	b	5115270 <shellToDec+0x68>

0511528c <shellWriteReturnValue>:
    char buffer[12] = "00000000000";
 511528c:	e30d37d4 	movw	r3, #55252	; 0xd7d4
 5115290:	e3403512 	movt	r3, #1298	; 0x512
{
 5115294:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    SHELL_ASSERT(shell->write, return 0);
 5115298:	e5907068 	ldr	r7, [r0, #104]	; 0x68
{
 511529c:	e24dd014 	sub	sp, sp, #20
 51152a0:	e1a05000 	mov	r5, r0
    char buffer[12] = "00000000000";
 51152a4:	e28d6004 	add	r6, sp, #4
{
 51152a8:	e1a04001 	mov	r4, r1
    SHELL_ASSERT(shell->write, return 0);
 51152ac:	e3570000 	cmp	r7, #0
    char buffer[12] = "00000000000";
 51152b0:	e8930007 	ldm	r3, {r0, r1, r2}
 51152b4:	e8860007 	stm	r6, {r0, r1, r2}
    SHELL_ASSERT(shell->write, return 0);
 51152b8:	0a00000b 	beq	51152ec <shellWriteReturnValue+0x60>
 51152bc:	e59f21c0 	ldr	r2, [pc, #448]	; 5115484 <shellWriteReturnValue+0x1f8>
 51152c0:	e3a03065 	mov	r3, #101	; 0x65
    unsigned short count = 0;
 51152c4:	e3a01000 	mov	r1, #0
 51152c8:	ea000000 	b	51152d0 <shellWriteReturnValue+0x44>
    while(*p++)
 51152cc:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51152d0:	e2811001 	add	r1, r1, #1
    while(*p++)
 51152d4:	e3530000 	cmp	r3, #0
        count ++;
 51152d8:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51152dc:	1afffffa 	bne	51152cc <shellWriteReturnValue+0x40>
    return shell->write((char *)string, count);
 51152e0:	e30d07c0 	movw	r0, #55232	; 0xd7c0
 51152e4:	e3400512 	movt	r0, #1298	; 0x512
 51152e8:	e12fff37 	blx	r7
    shellWriteString(shell, &buffer[11 - shellToDec(value, buffer)]);
 51152ec:	e3053208 	movw	r3, #21000	; 0x5208
 51152f0:	e1a01006 	mov	r1, r6
 51152f4:	e1a00004 	mov	r0, r4
 51152f8:	e3403511 	movt	r3, #1297	; 0x511
 51152fc:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 5115300:	e5957068 	ldr	r7, [r5, #104]	; 0x68
 5115304:	e3570000 	cmp	r7, #0
    shellWriteString(shell, &buffer[11 - shellToDec(value, buffer)]);
 5115308:	e260300b 	rsb	r3, r0, #11
 511530c:	e0860003 	add	r0, r6, r3
    SHELL_ASSERT(shell->write, return 0);
 5115310:	0a000050 	beq	5115458 <shellWriteReturnValue+0x1cc>
    while(*p++)
 5115314:	e28d2010 	add	r2, sp, #16
 5115318:	e0823003 	add	r3, r2, r3
 511531c:	e15310dc 	ldrsb	r1, [r3, #-12]
 5115320:	e3510000 	cmp	r1, #0
 5115324:	e2803001 	add	r3, r0, #1
 5115328:	0a000005 	beq	5115344 <shellWriteReturnValue+0xb8>
 511532c:	e263c001 	rsb	ip, r3, #1
        count ++;
 5115330:	e083100c 	add	r1, r3, ip
    while(*p++)
 5115334:	e0d320d1 	ldrsb	r2, [r3], #1
 5115338:	e3520000 	cmp	r2, #0
 511533c:	e6ff1071 	uxth	r1, r1
 5115340:	1afffffa 	bne	5115330 <shellWriteReturnValue+0xa4>
    return shell->write((char *)string, count);
 5115344:	e12fff37 	blx	r7
    SHELL_ASSERT(shell->write, return 0);
 5115348:	e5952068 	ldr	r2, [r5, #104]	; 0x68
 511534c:	e3520000 	cmp	r2, #0
 5115350:	0a000040 	beq	5115458 <shellWriteReturnValue+0x1cc>
 5115354:	e59f312c 	ldr	r3, [pc, #300]	; 5115488 <shellWriteReturnValue+0x1fc>
 5115358:	e3a07020 	mov	r7, #32
    unsigned short count = 0;
 511535c:	e3a01000 	mov	r1, #0
 5115360:	ea000000 	b	5115368 <shellWriteReturnValue+0xdc>
    while(*p++)
 5115364:	e1f370d1 	ldrsb	r7, [r3, #1]!
        count ++;
 5115368:	e2811001 	add	r1, r1, #1
    while(*p++)
 511536c:	e3570000 	cmp	r7, #0
        count ++;
 5115370:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115374:	1afffffa 	bne	5115364 <shellWriteReturnValue+0xd8>
    return shell->write((char *)string, count);
 5115378:	e30d07cc 	movw	r0, #55244	; 0xd7cc
 511537c:	e3400512 	movt	r0, #1298	; 0x512
 5115380:	e12fff32 	blx	r2
        buffer[i] = '0';
 5115384:	e3033030 	movw	r3, #12336	; 0x3030
 5115388:	e3433030 	movt	r3, #12336	; 0x3030
    while (value)
 511538c:	e2541000 	subs	r1, r4, #0
        buffer[i] = '0';
 5115390:	e5863004 	str	r3, [r6, #4]
    SHELL_ASSERT(shell->write, return 0);
 5115394:	e5954068 	ldr	r4, [r5, #104]	; 0x68
        buffer[i] = '0';
 5115398:	e58d3004 	str	r3, [sp, #4]
 511539c:	e5863007 	str	r3, [r6, #7]
    buffer[8] = 0;
 51153a0:	e5cd700c 	strb	r7, [sp, #12]
    while (value)
 51153a4:	0a00000c 	beq	51153dc <shellWriteReturnValue+0x150>
    unsigned char i = 8;
 51153a8:	e3a02008 	mov	r2, #8
        byte = value & 0x0000000F;
 51153ac:	e201300f 	and	r3, r1, #15
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 51153b0:	e2830057 	add	r0, r3, #87	; 0x57
 51153b4:	e2422001 	sub	r2, r2, #1
 51153b8:	e3530009 	cmp	r3, #9
 51153bc:	e6ef2072 	uxtb	r2, r2
 51153c0:	e2833030 	add	r3, r3, #48	; 0x30
 51153c4:	c6af3070 	sxtbgt	r3, r0
 51153c8:	e28d0010 	add	r0, sp, #16
 51153cc:	e0800002 	add	r0, r0, r2
    while (value)
 51153d0:	e1b01221 	lsrs	r1, r1, #4
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 51153d4:	e540300c 	strb	r3, [r0, #-12]
    while (value)
 51153d8:	1afffff3 	bne	51153ac <shellWriteReturnValue+0x120>
    SHELL_ASSERT(shell->write, return 0);
 51153dc:	e3540000 	cmp	r4, #0
 51153e0:	0a00001a 	beq	5115450 <shellWriteReturnValue+0x1c4>
    while(*p++)
 51153e4:	e1dd10d4 	ldrsb	r1, [sp, #4]
 51153e8:	e3510000 	cmp	r1, #0
 51153ec:	0a000006 	beq	511540c <shellWriteReturnValue+0x180>
    unsigned short count = 0;
 51153f0:	e3a01000 	mov	r1, #0
    while(*p++)
 51153f4:	e28d3005 	add	r3, sp, #5
        count ++;
 51153f8:	e2811001 	add	r1, r1, #1
    while(*p++)
 51153fc:	e0d320d1 	ldrsb	r2, [r3], #1
 5115400:	e3520000 	cmp	r2, #0
        count ++;
 5115404:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115408:	1afffffa 	bne	51153f8 <shellWriteReturnValue+0x16c>
    return shell->write((char *)string, count);
 511540c:	e1a00006 	mov	r0, r6
 5115410:	e12fff34 	blx	r4
    SHELL_ASSERT(shell->write, return 0);
 5115414:	e5954068 	ldr	r4, [r5, #104]	; 0x68
 5115418:	e3540000 	cmp	r4, #0
 511541c:	0a00000b 	beq	5115450 <shellWriteReturnValue+0x1c4>
 5115420:	e59f2064 	ldr	r2, [pc, #100]	; 511548c <shellWriteReturnValue+0x200>
 5115424:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5115428:	e3a01000 	mov	r1, #0
 511542c:	ea000000 	b	5115434 <shellWriteReturnValue+0x1a8>
    while(*p++)
 5115430:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115434:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115438:	e3530000 	cmp	r3, #0
        count ++;
 511543c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115440:	1afffffa 	bne	5115430 <shellWriteReturnValue+0x1a4>
    return shell->write((char *)string, count);
 5115444:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5115448:	e3400512 	movt	r0, #1298	; 0x512
 511544c:	e12fff34 	blx	r4
}
 5115450:	e28dd014 	add	sp, sp, #20
 5115454:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        buffer[i] = '0';
 5115458:	e3032030 	movw	r2, #12336	; 0x3030
    buffer[8] = 0;
 511545c:	e3a03000 	mov	r3, #0
        buffer[i] = '0';
 5115460:	e3432030 	movt	r2, #12336	; 0x3030
    while (value)
 5115464:	e2541000 	subs	r1, r4, #0
        buffer[i] = '0';
 5115468:	e5862004 	str	r2, [r6, #4]
    while (value)
 511546c:	11a04003 	movne	r4, r3
        buffer[i] = '0';
 5115470:	e58d2004 	str	r2, [sp, #4]
 5115474:	e5862007 	str	r2, [r6, #7]
    buffer[8] = 0;
 5115478:	e5cd300c 	strb	r3, [sp, #12]
    while (value)
 511547c:	1affffc9 	bne	51153a8 <shellWriteReturnValue+0x11c>
 5115480:	eafffff2 	b	5115450 <shellWriteReturnValue+0x1c4>
 5115484:	0512d7c1 	.word	0x0512d7c1
 5115488:	0512d7cd 	.word	0x0512d7cd
 511548c:	0512d3e1 	.word	0x0512d3e1

05115490 <shellListItem>:
{
 5115490:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5115494:	e1a06000 	mov	r6, r0
    spaceLength = /*22*/30 - shellWriteString(shell, shellGetCommandName(item));
 5115498:	e3043eb4 	movw	r3, #20148	; 0x4eb4
 511549c:	e1a00001 	mov	r0, r1
{
 51154a0:	e24dd008 	sub	sp, sp, #8
 51154a4:	e1a07001 	mov	r7, r1
    spaceLength = /*22*/30 - shellWriteString(shell, shellGetCommandName(item));
 51154a8:	e3403511 	movt	r3, #1297	; 0x511
 51154ac:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 51154b0:	e5962068 	ldr	r2, [r6, #104]	; 0x68
 51154b4:	e3520000 	cmp	r2, #0
    spaceLength = /*22*/30 - shellWriteString(shell, shellGetCommandName(item));
 51154b8:	03a0401e 	moveq	r4, #30
    SHELL_ASSERT(shell->write, return 0);
 51154bc:	0a00000f 	beq	5115500 <shellListItem+0x70>
    while(*p++)
 51154c0:	e1a03000 	mov	r3, r0
 51154c4:	e0d310d1 	ldrsb	r1, [r3], #1
 51154c8:	e3510000 	cmp	r1, #0
 51154cc:	0a000005 	beq	51154e8 <shellListItem+0x58>
 51154d0:	e263e001 	rsb	lr, r3, #1
        count ++;
 51154d4:	e083100e 	add	r1, r3, lr
    while(*p++)
 51154d8:	e0d3c0d1 	ldrsb	ip, [r3], #1
 51154dc:	e35c0000 	cmp	ip, #0
 51154e0:	e6ff1071 	uxth	r1, r1
 51154e4:	1afffffa 	bne	51154d4 <shellListItem+0x44>
    return shell->write((char *)string, count);
 51154e8:	e12fff32 	blx	r2
    shell->write(&data, 1);
 51154ec:	e5962068 	ldr	r2, [r6, #104]	; 0x68
    spaceLength = /*22*/30 - shellWriteString(shell, shellGetCommandName(item));
 51154f0:	e260301e 	rsb	r3, r0, #30
 51154f4:	e6bf4073 	sxth	r4, r3
    spaceLength = (spaceLength > 0) ? spaceLength : 4;
 51154f8:	e3540000 	cmp	r4, #0
 51154fc:	d3a04004 	movle	r4, #4
 5115500:	e3a08020 	mov	r8, #32
 5115504:	ea000000 	b	511550c <shellListItem+0x7c>
    shell->write(&data, 1);
 5115508:	e5962068 	ldr	r2, [r6, #104]	; 0x68
 511550c:	e3a01001 	mov	r1, #1
 5115510:	e28d0007 	add	r0, sp, #7
 5115514:	e5cd8007 	strb	r8, [sp, #7]
 5115518:	e12fff32 	blx	r2
    } while (--spaceLength);
 511551c:	e2443001 	sub	r3, r4, #1
 5115520:	e6ff5073 	uxth	r5, r3
 5115524:	e3550000 	cmp	r5, #0
 5115528:	e6bf4073 	sxth	r4, r3
 511552c:	1afffff5 	bne	5115508 <shellListItem+0x78>
    if (item->attr.attrs.type <= SHELL_TYPE_CMD_FUNC)
 5115530:	e5d73001 	ldrb	r3, [r7, #1]
    SHELL_ASSERT(shell->write, return 0);
 5115534:	e5962068 	ldr	r2, [r6, #104]	; 0x68
    if (item->attr.attrs.type <= SHELL_TYPE_CMD_FUNC)
 5115538:	e203300f 	and	r3, r3, #15
 511553c:	e3530001 	cmp	r3, #1
 5115540:	9a000088 	bls	5115768 <shellListItem+0x2d8>
    else if (item->attr.attrs.type <= SHELL_TYPE_VAR_NODE)
 5115544:	e3530007 	cmp	r3, #7
 5115548:	9a000075 	bls	5115724 <shellListItem+0x294>
    else if (item->attr.attrs.type <= SHELL_TYPE_USER)
 511554c:	e3530008 	cmp	r3, #8
 5115550:	0a0000a2 	beq	51157e0 <shellListItem+0x350>
    else if (item->attr.attrs.type <= SHELL_TYPE_KEY)
 5115554:	e3530009 	cmp	r3, #9
 5115558:	0a000091 	beq	51157a4 <shellListItem+0x314>
    SHELL_ASSERT(shell->write, return 0);
 511555c:	e3520000 	cmp	r2, #0
 5115560:	0a00001b 	beq	51155d4 <shellListItem+0x144>
 5115564:	e59f02b0 	ldr	r0, [pc, #688]	; 511581c <shellListItem+0x38c>
    unsigned short count = 0;
 5115568:	e1a01005 	mov	r1, r5
    SHELL_ASSERT(shell->write, return 0);
 511556c:	e3a0304f 	mov	r3, #79	; 0x4f
 5115570:	ea000000 	b	5115578 <shellListItem+0xe8>
    while(*p++)
 5115574:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 5115578:	e2811001 	add	r1, r1, #1
    while(*p++)
 511557c:	e3530000 	cmp	r3, #0
        count ++;
 5115580:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115584:	1afffffa 	bne	5115574 <shellListItem+0xe4>
    return shell->write((char *)string, count);
 5115588:	e30d0800 	movw	r0, #55296	; 0xd800
 511558c:	e3400512 	movt	r0, #1298	; 0x512
 5115590:	e12fff32 	blx	r2
    SHELL_ASSERT(shell->write, return 0);
 5115594:	e5962068 	ldr	r2, [r6, #104]	; 0x68
 5115598:	e3520000 	cmp	r2, #0
 511559c:	0a00000c 	beq	51155d4 <shellListItem+0x144>
 51155a0:	e59f0278 	ldr	r0, [pc, #632]	; 5115820 <shellListItem+0x390>
    unsigned short count = 0;
 51155a4:	e3a01000 	mov	r1, #0
    SHELL_ASSERT(shell->write, return 0);
 51155a8:	e3a03020 	mov	r3, #32
 51155ac:	ea000000 	b	51155b4 <shellListItem+0x124>
    while(*p++)
 51155b0:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 51155b4:	e2811001 	add	r1, r1, #1
    while(*p++)
 51155b8:	e3530000 	cmp	r3, #0
        count ++;
 51155bc:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51155c0:	1afffffa 	bne	51155b0 <shellListItem+0x120>
    return shell->write((char *)string, count);
 51155c4:	e30d0808 	movw	r0, #55304	; 0xd808
 51155c8:	e3400512 	movt	r0, #1298	; 0x512
 51155cc:	e12fff32 	blx	r2
    shell->write(&data, 1);
 51155d0:	e5962068 	ldr	r2, [r6, #104]	; 0x68
    SHELL_ASSERT(shell->write, return 0);
 51155d4:	e3a04007 	mov	r4, #7
 51155d8:	ea000000 	b	51155e0 <shellListItem+0x150>
    shell->write(&data, 1);
 51155dc:	e5962068 	ldr	r2, [r6, #104]	; 0x68
        shellWriteByte(shell, item->attr.attrs.permission & (1 << i) ? 'x' : '-');
 51155e0:	e5d73000 	ldrb	r3, [r7]
    shell->write(&data, 1);
 51155e4:	e3a01001 	mov	r1, #1
        shellWriteByte(shell, item->attr.attrs.permission & (1 << i) ? 'x' : '-');
 51155e8:	e1a03453 	asr	r3, r3, r4
 51155ec:	e3130001 	tst	r3, #1
 51155f0:	13a03078 	movne	r3, #120	; 0x78
 51155f4:	03a0302d 	moveq	r3, #45	; 0x2d
    shell->write(&data, 1);
 51155f8:	e28d0007 	add	r0, sp, #7
 51155fc:	e5cd3007 	strb	r3, [sp, #7]
    for (signed char i = 7; i >= 0; i--)
 5115600:	e2444001 	sub	r4, r4, #1
    shell->write(&data, 1);
 5115604:	e12fff32 	blx	r2
    for (signed char i = 7; i >= 0; i--)
 5115608:	e3740001 	cmn	r4, #1
 511560c:	1afffff2 	bne	51155dc <shellListItem+0x14c>
    SHELL_ASSERT(shell->write, return 0);
 5115610:	e5964068 	ldr	r4, [r6, #104]	; 0x68
 5115614:	e3540000 	cmp	r4, #0
 5115618:	0a00000c 	beq	5115650 <shellListItem+0x1c0>
 511561c:	e59f21fc 	ldr	r2, [pc, #508]	; 5115820 <shellListItem+0x390>
    unsigned short count = 0;
 5115620:	e3a01000 	mov	r1, #0
    SHELL_ASSERT(shell->write, return 0);
 5115624:	e3a03020 	mov	r3, #32
 5115628:	ea000000 	b	5115630 <shellListItem+0x1a0>
    while(*p++)
 511562c:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115630:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115634:	e3530000 	cmp	r3, #0
        count ++;
 5115638:	e6ff1071 	uxth	r1, r1
    while(*p++)
 511563c:	1afffffa 	bne	511562c <shellListItem+0x19c>
    return shell->write((char *)string, count);
 5115640:	e30d0808 	movw	r0, #55304	; 0xd808
 5115644:	e3400512 	movt	r0, #1298	; 0x512
 5115648:	e12fff34 	blx	r4
    SHELL_ASSERT(shell->write, return 0);
 511564c:	e5964068 	ldr	r4, [r6, #104]	; 0x68
        return command->data.cmd.desc;
 5115650:	e597000c 	ldr	r0, [r7, #12]
    SHELL_ASSERT(shell->write, return 0);
 5115654:	e3540000 	cmp	r4, #0
 5115658:	0a00002f 	beq	511571c <shellListItem+0x28c>
    while (*p && *p != '\r' && *p != '\n')
 511565c:	e1d030d0 	ldrsb	r3, [r0]
 5115660:	e353000d 	cmp	r3, #13
 5115664:	13530000 	cmpne	r3, #0
 5115668:	13a01001 	movne	r1, #1
 511566c:	03a01000 	moveq	r1, #0
 5115670:	e353000a 	cmp	r3, #10
 5115674:	03a01000 	moveq	r1, #0
 5115678:	12011001 	andne	r1, r1, #1
 511567c:	e3510000 	cmp	r1, #0
 5115680:	0a000036 	beq	5115760 <shellListItem+0x2d0>
 5115684:	e1a0c000 	mov	ip, r0
 5115688:	e260e001 	rsb	lr, r0, #1
        count++;
 511568c:	e08e100c 	add	r1, lr, ip
    while (*p && *p != '\r' && *p != '\n')
 5115690:	e1fc20d1 	ldrsb	r2, [ip, #1]!
 5115694:	e3520000 	cmp	r2, #0
 5115698:	1352000d 	cmpne	r2, #13
 511569c:	13a03001 	movne	r3, #1
 51156a0:	03a03000 	moveq	r3, #0
 51156a4:	e6ff1071 	uxth	r1, r1
 51156a8:	e352000a 	cmp	r2, #10
 51156ac:	03a03000 	moveq	r3, #0
 51156b0:	12033001 	andne	r3, r3, #1
 51156b4:	e3530000 	cmp	r3, #0
 51156b8:	1afffff3 	bne	511568c <shellListItem+0x1fc>
    if (count > 36)
 51156bc:	e3510024 	cmp	r1, #36	; 0x24
 51156c0:	9a000026 	bls	5115760 <shellListItem+0x2d0>
        shell->write((char *)string, 36);
 51156c4:	e3a01024 	mov	r1, #36	; 0x24
 51156c8:	e12fff34 	blx	r4
        shell->write("...", 3);
 51156cc:	e30d080c 	movw	r0, #55308	; 0xd80c
 51156d0:	e5963068 	ldr	r3, [r6, #104]	; 0x68
 51156d4:	e3a01003 	mov	r1, #3
 51156d8:	e3400512 	movt	r0, #1298	; 0x512
 51156dc:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 51156e0:	e5964068 	ldr	r4, [r6, #104]	; 0x68
 51156e4:	e3540000 	cmp	r4, #0
 51156e8:	0a00000b 	beq	511571c <shellListItem+0x28c>
 51156ec:	e59f2130 	ldr	r2, [pc, #304]	; 5115824 <shellListItem+0x394>
 51156f0:	e3a0300a 	mov	r3, #10
 51156f4:	ea000000 	b	51156fc <shellListItem+0x26c>
    while(*p++)
 51156f8:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51156fc:	e2855001 	add	r5, r5, #1
    while(*p++)
 5115700:	e3530000 	cmp	r3, #0
        count ++;
 5115704:	e6ff5075 	uxth	r5, r5
    while(*p++)
 5115708:	1afffffa 	bne	51156f8 <shellListItem+0x268>
    return shell->write((char *)string, count);
 511570c:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5115710:	e1a01005 	mov	r1, r5
 5115714:	e3400512 	movt	r0, #1298	; 0x512
 5115718:	e12fff34 	blx	r4
}
 511571c:	e28dd008 	add	sp, sp, #8
 5115720:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 5115724:	e3520000 	cmp	r2, #0
 5115728:	0affffa9 	beq	51155d4 <shellListItem+0x144>
 511572c:	e59f00f4 	ldr	r0, [pc, #244]	; 5115828 <shellListItem+0x398>
    unsigned short count = 0;
 5115730:	e1a01005 	mov	r1, r5
    SHELL_ASSERT(shell->write, return 0);
 5115734:	e3a03041 	mov	r3, #65	; 0x41
 5115738:	ea000000 	b	5115740 <shellListItem+0x2b0>
    while(*p++)
 511573c:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 5115740:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115744:	e3530000 	cmp	r3, #0
        count ++;
 5115748:	e6ff1071 	uxth	r1, r1
    while(*p++)
 511574c:	1afffffa 	bne	511573c <shellListItem+0x2ac>
    return shell->write((char *)string, count);
 5115750:	e30d07e8 	movw	r0, #55272	; 0xd7e8
 5115754:	e3400512 	movt	r0, #1298	; 0x512
 5115758:	e12fff32 	blx	r2
 511575c:	eaffff8c 	b	5115594 <shellListItem+0x104>
        shell->write((char *)string, count);
 5115760:	e12fff34 	blx	r4
    return count > 36 ? 36 : 39;
 5115764:	eaffffdd 	b	51156e0 <shellListItem+0x250>
    SHELL_ASSERT(shell->write, return 0);
 5115768:	e3520000 	cmp	r2, #0
 511576c:	0affff98 	beq	51155d4 <shellListItem+0x144>
 5115770:	e59f00b4 	ldr	r0, [pc, #180]	; 511582c <shellListItem+0x39c>
    unsigned short count = 0;
 5115774:	e1a01005 	mov	r1, r5
    SHELL_ASSERT(shell->write, return 0);
 5115778:	e3a0304d 	mov	r3, #77	; 0x4d
 511577c:	ea000000 	b	5115784 <shellListItem+0x2f4>
    while(*p++)
 5115780:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 5115784:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115788:	e3530000 	cmp	r3, #0
        count ++;
 511578c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115790:	1afffffa 	bne	5115780 <shellListItem+0x2f0>
    return shell->write((char *)string, count);
 5115794:	e30d07e0 	movw	r0, #55264	; 0xd7e0
 5115798:	e3400512 	movt	r0, #1298	; 0x512
 511579c:	e12fff32 	blx	r2
 51157a0:	eaffff7b 	b	5115594 <shellListItem+0x104>
    SHELL_ASSERT(shell->write, return 0);
 51157a4:	e3520000 	cmp	r2, #0
 51157a8:	0affff89 	beq	51155d4 <shellListItem+0x144>
 51157ac:	e59f007c 	ldr	r0, [pc, #124]	; 5115830 <shellListItem+0x3a0>
    unsigned short count = 0;
 51157b0:	e1a01005 	mov	r1, r5
    SHELL_ASSERT(shell->write, return 0);
 51157b4:	e3a03045 	mov	r3, #69	; 0x45
 51157b8:	ea000000 	b	51157c0 <shellListItem+0x330>
    while(*p++)
 51157bc:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 51157c0:	e2811001 	add	r1, r1, #1
    while(*p++)
 51157c4:	e3530000 	cmp	r3, #0
        count ++;
 51157c8:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51157cc:	1afffffa 	bne	51157bc <shellListItem+0x32c>
    return shell->write((char *)string, count);
 51157d0:	e30d07f8 	movw	r0, #55288	; 0xd7f8
 51157d4:	e3400512 	movt	r0, #1298	; 0x512
 51157d8:	e12fff32 	blx	r2
 51157dc:	eaffff6c 	b	5115594 <shellListItem+0x104>
    SHELL_ASSERT(shell->write, return 0);
 51157e0:	e3520000 	cmp	r2, #0
 51157e4:	0affff7a 	beq	51155d4 <shellListItem+0x144>
 51157e8:	e59f0044 	ldr	r0, [pc, #68]	; 5115834 <shellListItem+0x3a4>
    unsigned short count = 0;
 51157ec:	e1a01005 	mov	r1, r5
    SHELL_ASSERT(shell->write, return 0);
 51157f0:	e3a03053 	mov	r3, #83	; 0x53
 51157f4:	ea000000 	b	51157fc <shellListItem+0x36c>
    while(*p++)
 51157f8:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 51157fc:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115800:	e3530000 	cmp	r3, #0
        count ++;
 5115804:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115808:	1afffffa 	bne	51157f8 <shellListItem+0x368>
    return shell->write((char *)string, count);
 511580c:	e30d07f0 	movw	r0, #55280	; 0xd7f0
 5115810:	e3400512 	movt	r0, #1298	; 0x512
 5115814:	e12fff32 	blx	r2
 5115818:	eaffff5d 	b	5115594 <shellListItem+0x104>
 511581c:	0512d801 	.word	0x0512d801
 5115820:	0512d809 	.word	0x0512d809
 5115824:	0512d3e1 	.word	0x0512d3e1
 5115828:	0512d7e9 	.word	0x0512d7e9
 511582c:	0512d7e1 	.word	0x0512d7e1
 5115830:	0512d7f9 	.word	0x0512d7f9
 5115834:	0512d7f1 	.word	0x0512d7f1

05115838 <shellListCommand>:
{
 5115838:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    SHELL_ASSERT(shell->write, return 0);
 511583c:	e5904068 	ldr	r4, [r0, #104]	; 0x68
{
 5115840:	e1a05000 	mov	r5, r0
    ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5115844:	e5906058 	ldr	r6, [r0, #88]	; 0x58
    SHELL_ASSERT(shell->write, return 0);
 5115848:	e3540000 	cmp	r4, #0
 511584c:	0a00000b 	beq	5115880 <shellListCommand+0x48>
 5115850:	e59f20b8 	ldr	r2, [pc, #184]	; 5115910 <shellListCommand+0xd8>
 5115854:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5115858:	e3a01000 	mov	r1, #0
 511585c:	ea000000 	b	5115864 <shellListCommand+0x2c>
    while(*p++)
 5115860:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115864:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115868:	e3530000 	cmp	r3, #0
        count ++;
 511586c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115870:	1afffffa 	bne	5115860 <shellListCommand+0x28>
    return shell->write((char *)string, count);
 5115874:	e30d0810 	movw	r0, #55312	; 0xd810
 5115878:	e3400512 	movt	r0, #1298	; 0x512
 511587c:	e12fff34 	blx	r4
    for (short i = 0; i < shell->commandList.count; i++)
 5115880:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115884:	e35c0000 	cmp	ip, #0
 5115888:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 511588c:	e3057490 	movw	r7, #21648	; 0x5490
    for (short i = 0; i < shell->commandList.count; i++)
 5115890:	e3a04000 	mov	r4, #0
            shellListItem(shell, &base[i]);
 5115894:	e3407511 	movt	r7, #1297	; 0x511
 5115898:	ea000003 	b	51158ac <shellListCommand+0x74>
    for (short i = 0; i < shell->commandList.count; i++)
 511589c:	e2844001 	add	r4, r4, #1
 51158a0:	e6bf4074 	sxth	r4, r4
 51158a4:	e154000c 	cmp	r4, ip
 51158a8:	a8bd81f0 	popge	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 51158ac:	e1a00005 	mov	r0, r5
        if (base[i].attr.attrs.type <= SHELL_TYPE_CMD_FUNC
 51158b0:	e0861204 	add	r1, r6, r4, lsl #4
 51158b4:	e5d13001 	ldrb	r3, [r1, #1]
 51158b8:	e203200f 	and	r2, r3, #15
 51158bc:	e3520001 	cmp	r2, #1
 51158c0:	8afffff5 	bhi	511589c <shellListCommand+0x64>
                || command->attr.attrs.type == SHELL_TYPE_USER
 51158c4:	e1a0e002 	mov	lr, r2
    return ((!command->attr.attrs.permission
 51158c8:	e7d62204 	ldrb	r2, [r6, r4, lsl #4]
            ? 0 : -1;
 51158cc:	e3520000 	cmp	r2, #0
 51158d0:	0a000005 	beq	51158ec <shellListCommand+0xb4>
                || command->attr.attrs.type == SHELL_TYPE_USER
 51158d4:	e35e0008 	cmp	lr, #8
 51158d8:	0a000003 	beq	51158ec <shellListCommand+0xb4>
                    & shell->info.user->attr.attrs.permission))
 51158dc:	e595e000 	ldr	lr, [r5]
                || (command->attr.attrs.permission 
 51158e0:	e5dee000 	ldrb	lr, [lr]
 51158e4:	e112000e 	tst	r2, lr
 51158e8:	0affffeb 	beq	511589c <shellListCommand+0x64>
            && (shell->status.isChecked
 51158ec:	e5d52060 	ldrb	r2, [r5, #96]	; 0x60
 51158f0:	e3120001 	tst	r2, #1
 51158f4:	0a000002 	beq	5115904 <shellListCommand+0xcc>
            shellListItem(shell, &base[i]);
 51158f8:	e12fff37 	blx	r7
 51158fc:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115900:	eaffffe5 	b	511589c <shellListCommand+0x64>
                || command->attr.attrs.enableUnchecked))
 5115904:	e3130010 	tst	r3, #16
 5115908:	1afffffa 	bne	51158f8 <shellListCommand+0xc0>
 511590c:	eaffffe2 	b	511589c <shellListCommand+0x64>
 5115910:	0512d811 	.word	0x0512d811

05115914 <shellCmds>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115914:	e30831d8 	movw	r3, #33240	; 0x81d8
 5115918:	e3403513 	movt	r3, #1299	; 0x513
 511591c:	e2831014 	add	r1, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 5115920:	e4930004 	ldr	r0, [r3], #4
 5115924:	e3500000 	cmp	r0, #0
 5115928:	0a000002 	beq	5115938 <shellCmds+0x24>
 511592c:	e5d02060 	ldrb	r2, [r0, #96]	; 0x60
 5115930:	e3120002 	tst	r2, #2
 5115934:	1a000002 	bne	5115944 <shellCmds+0x30>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115938:	e1530001 	cmp	r3, r1
 511593c:	1afffff7 	bne	5115920 <shellCmds+0xc>
 5115940:	e12fff1e 	bx	lr
        shellListCommand(shell);
 5115944:	e3053838 	movw	r3, #22584	; 0x5838
 5115948:	e3403511 	movt	r3, #1297	; 0x511
{
 511594c:	e92d4010 	push	{r4, lr}
        shellListCommand(shell);
 5115950:	e12fff33 	blx	r3
}
 5115954:	e8bd8010 	pop	{r4, pc}

05115958 <shellListVar>:
{
 5115958:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    SHELL_ASSERT(shell->write, return 0);
 511595c:	e5904068 	ldr	r4, [r0, #104]	; 0x68
{
 5115960:	e1a05000 	mov	r5, r0
    ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5115964:	e5906058 	ldr	r6, [r0, #88]	; 0x58
    SHELL_ASSERT(shell->write, return 0);
 5115968:	e3540000 	cmp	r4, #0
 511596c:	0a00000b 	beq	51159a0 <shellListVar+0x48>
 5115970:	e59f20b8 	ldr	r2, [pc, #184]	; 5115a30 <shellListVar+0xd8>
 5115974:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5115978:	e3a01000 	mov	r1, #0
 511597c:	ea000000 	b	5115984 <shellListVar+0x2c>
    while(*p++)
 5115980:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115984:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115988:	e3530000 	cmp	r3, #0
        count ++;
 511598c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115990:	1afffffa 	bne	5115980 <shellListVar+0x28>
    return shell->write((char *)string, count);
 5115994:	e30d0824 	movw	r0, #55332	; 0xd824
 5115998:	e3400512 	movt	r0, #1298	; 0x512
 511599c:	e12fff34 	blx	r4
    for (short i = 0; i < shell->commandList.count; i++)
 51159a0:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 51159a4:	e35c0000 	cmp	ip, #0
 51159a8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 51159ac:	e3057490 	movw	r7, #21648	; 0x5490
    for (short i = 0; i < shell->commandList.count; i++)
 51159b0:	e3a04000 	mov	r4, #0
            shellListItem(shell, &base[i]);
 51159b4:	e3407511 	movt	r7, #1297	; 0x511
 51159b8:	ea000005 	b	51159d4 <shellListVar+0x7c>
 51159bc:	e12fff37 	blx	r7
 51159c0:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
    for (short i = 0; i < shell->commandList.count; i++)
 51159c4:	e2844001 	add	r4, r4, #1
 51159c8:	e6bf4074 	sxth	r4, r4
 51159cc:	e154000c 	cmp	r4, ip
 51159d0:	a8bd81f0 	popge	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 51159d4:	e1a00005 	mov	r0, r5
        if (base[i].attr.attrs.type > SHELL_TYPE_CMD_FUNC
 51159d8:	e0861204 	add	r1, r6, r4, lsl #4
 51159dc:	e5d12001 	ldrb	r2, [r1, #1]
            && base[i].attr.attrs.type <= SHELL_TYPE_VAR_NODE
 51159e0:	e282300e 	add	r3, r2, #14
        if (base[i].attr.attrs.type > SHELL_TYPE_CMD_FUNC
 51159e4:	e203300f 	and	r3, r3, #15
 51159e8:	e3530005 	cmp	r3, #5
 51159ec:	8afffff4 	bhi	51159c4 <shellListVar+0x6c>
    return ((!command->attr.attrs.permission
 51159f0:	e7d63204 	ldrb	r3, [r6, r4, lsl #4]
            ? 0 : -1;
 51159f4:	e3530000 	cmp	r3, #0
                || command->attr.attrs.type == SHELL_TYPE_USER
 51159f8:	e202e00f 	and	lr, r2, #15
            ? 0 : -1;
 51159fc:	0a000005 	beq	5115a18 <shellListVar+0xc0>
                || command->attr.attrs.type == SHELL_TYPE_USER
 5115a00:	e35e0008 	cmp	lr, #8
 5115a04:	0a000003 	beq	5115a18 <shellListVar+0xc0>
                    & shell->info.user->attr.attrs.permission))
 5115a08:	e595e000 	ldr	lr, [r5]
                || (command->attr.attrs.permission 
 5115a0c:	e5dee000 	ldrb	lr, [lr]
 5115a10:	e113000e 	tst	r3, lr
 5115a14:	0affffea 	beq	51159c4 <shellListVar+0x6c>
            && (shell->status.isChecked
 5115a18:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5115a1c:	e3130001 	tst	r3, #1
 5115a20:	1affffe5 	bne	51159bc <shellListVar+0x64>
                || command->attr.attrs.enableUnchecked))
 5115a24:	e3120010 	tst	r2, #16
 5115a28:	1affffe3 	bne	51159bc <shellListVar+0x64>
 5115a2c:	eaffffe4 	b	51159c4 <shellListVar+0x6c>
 5115a30:	0512d825 	.word	0x0512d825

05115a34 <shellVars>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115a34:	e30831d8 	movw	r3, #33240	; 0x81d8
 5115a38:	e3403513 	movt	r3, #1299	; 0x513
 5115a3c:	e2831014 	add	r1, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 5115a40:	e4930004 	ldr	r0, [r3], #4
 5115a44:	e3500000 	cmp	r0, #0
 5115a48:	0a000002 	beq	5115a58 <shellVars+0x24>
 5115a4c:	e5d02060 	ldrb	r2, [r0, #96]	; 0x60
 5115a50:	e3120002 	tst	r2, #2
 5115a54:	1a000002 	bne	5115a64 <shellVars+0x30>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115a58:	e1530001 	cmp	r3, r1
 5115a5c:	1afffff7 	bne	5115a40 <shellVars+0xc>
 5115a60:	e12fff1e 	bx	lr
        shellListVar(shell);
 5115a64:	e3053958 	movw	r3, #22872	; 0x5958
 5115a68:	e3403511 	movt	r3, #1297	; 0x511
{
 5115a6c:	e92d4010 	push	{r4, lr}
        shellListVar(shell);
 5115a70:	e12fff33 	blx	r3
}
 5115a74:	e8bd8010 	pop	{r4, pc}

05115a78 <shellListUser>:
{
 5115a78:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    SHELL_ASSERT(shell->write, return 0);
 5115a7c:	e5904068 	ldr	r4, [r0, #104]	; 0x68
{
 5115a80:	e1a05000 	mov	r5, r0
    ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5115a84:	e5906058 	ldr	r6, [r0, #88]	; 0x58
    SHELL_ASSERT(shell->write, return 0);
 5115a88:	e3540000 	cmp	r4, #0
 5115a8c:	0a00000b 	beq	5115ac0 <shellListUser+0x48>
 5115a90:	e59f208c 	ldr	r2, [pc, #140]	; 5115b24 <shellListUser+0xac>
 5115a94:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5115a98:	e3a01000 	mov	r1, #0
 5115a9c:	ea000000 	b	5115aa4 <shellListUser+0x2c>
    while(*p++)
 5115aa0:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115aa4:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115aa8:	e3530000 	cmp	r3, #0
        count ++;
 5115aac:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115ab0:	1afffffa 	bne	5115aa0 <shellListUser+0x28>
    return shell->write((char *)string, count);
 5115ab4:	e30d0834 	movw	r0, #55348	; 0xd834
 5115ab8:	e3400512 	movt	r0, #1298	; 0x512
 5115abc:	e12fff34 	blx	r4
    for (short i = 0; i < shell->commandList.count; i++)
 5115ac0:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115ac4:	e35c0000 	cmp	ip, #0
 5115ac8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 5115acc:	e3057490 	movw	r7, #21648	; 0x5490
    for (short i = 0; i < shell->commandList.count; i++)
 5115ad0:	e3a04000 	mov	r4, #0
            shellListItem(shell, &base[i]);
 5115ad4:	e3407511 	movt	r7, #1297	; 0x511
 5115ad8:	ea000003 	b	5115aec <shellListUser+0x74>
    for (short i = 0; i < shell->commandList.count; i++)
 5115adc:	e2844001 	add	r4, r4, #1
 5115ae0:	e6bf4074 	sxth	r4, r4
 5115ae4:	e154000c 	cmp	r4, ip
 5115ae8:	a8bd81f0 	popge	{r4, r5, r6, r7, r8, pc}
        if (base[i].attr.attrs.type > SHELL_TYPE_VAR_NODE
 5115aec:	e0861204 	add	r1, r6, r4, lsl #4
            && base[i].attr.attrs.type <= SHELL_TYPE_USER
 5115af0:	e5d13001 	ldrb	r3, [r1, #1]
        if (base[i].attr.attrs.type > SHELL_TYPE_VAR_NODE
 5115af4:	e203200f 	and	r2, r3, #15
 5115af8:	e3520008 	cmp	r2, #8
 5115afc:	1afffff6 	bne	5115adc <shellListUser+0x64>
            && (shell->status.isChecked
 5115b00:	e5d52060 	ldrb	r2, [r5, #96]	; 0x60
                || command->attr.attrs.enableUnchecked))
 5115b04:	e2033010 	and	r3, r3, #16
            shellListItem(shell, &base[i]);
 5115b08:	e1a00005 	mov	r0, r5
            && (shell->status.isChecked
 5115b0c:	e2022001 	and	r2, r2, #1
                || command->attr.attrs.enableUnchecked))
 5115b10:	e1923003 	orrs	r3, r2, r3
 5115b14:	0afffff0 	beq	5115adc <shellListUser+0x64>
            shellListItem(shell, &base[i]);
 5115b18:	e12fff37 	blx	r7
 5115b1c:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115b20:	eaffffed 	b	5115adc <shellListUser+0x64>
 5115b24:	0512d835 	.word	0x0512d835

05115b28 <shellUsers>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115b28:	e30831d8 	movw	r3, #33240	; 0x81d8
 5115b2c:	e3403513 	movt	r3, #1299	; 0x513
 5115b30:	e2831014 	add	r1, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 5115b34:	e4930004 	ldr	r0, [r3], #4
 5115b38:	e3500000 	cmp	r0, #0
 5115b3c:	0a000002 	beq	5115b4c <shellUsers+0x24>
 5115b40:	e5d02060 	ldrb	r2, [r0, #96]	; 0x60
 5115b44:	e3120002 	tst	r2, #2
 5115b48:	1a000002 	bne	5115b58 <shellUsers+0x30>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115b4c:	e1530001 	cmp	r3, r1
 5115b50:	1afffff7 	bne	5115b34 <shellUsers+0xc>
 5115b54:	e12fff1e 	bx	lr
        shellListUser(shell);
 5115b58:	e3053a78 	movw	r3, #23160	; 0x5a78
 5115b5c:	e3403511 	movt	r3, #1297	; 0x511
{
 5115b60:	e92d4010 	push	{r4, lr}
        shellListUser(shell);
 5115b64:	e12fff33 	blx	r3
}
 5115b68:	e8bd8010 	pop	{r4, pc}

05115b6c <shellListKey>:
{
 5115b6c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    SHELL_ASSERT(shell->write, return 0);
 5115b70:	e5904068 	ldr	r4, [r0, #104]	; 0x68
{
 5115b74:	e1a05000 	mov	r5, r0
    ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5115b78:	e5906058 	ldr	r6, [r0, #88]	; 0x58
    SHELL_ASSERT(shell->write, return 0);
 5115b7c:	e3540000 	cmp	r4, #0
 5115b80:	0a00000b 	beq	5115bb4 <shellListKey+0x48>
 5115b84:	e59f20a8 	ldr	r2, [pc, #168]	; 5115c34 <shellListKey+0xc8>
 5115b88:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5115b8c:	e3a01000 	mov	r1, #0
 5115b90:	ea000000 	b	5115b98 <shellListKey+0x2c>
    while(*p++)
 5115b94:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115b98:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115b9c:	e3530000 	cmp	r3, #0
        count ++;
 5115ba0:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115ba4:	1afffffa 	bne	5115b94 <shellListKey+0x28>
    return shell->write((char *)string, count);
 5115ba8:	e30d0844 	movw	r0, #55364	; 0xd844
 5115bac:	e3400512 	movt	r0, #1298	; 0x512
 5115bb0:	e12fff34 	blx	r4
    for (short i = 0; i < shell->commandList.count; i++)
 5115bb4:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115bb8:	e35c0000 	cmp	ip, #0
 5115bbc:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
            shellListItem(shell, &base[i]);
 5115bc0:	e3057490 	movw	r7, #21648	; 0x5490
    for (short i = 0; i < shell->commandList.count; i++)
 5115bc4:	e3a04000 	mov	r4, #0
            shellListItem(shell, &base[i]);
 5115bc8:	e3407511 	movt	r7, #1297	; 0x511
 5115bcc:	ea000003 	b	5115be0 <shellListKey+0x74>
    for (short i = 0; i < shell->commandList.count; i++)
 5115bd0:	e2844001 	add	r4, r4, #1
 5115bd4:	e6bf4074 	sxth	r4, r4
 5115bd8:	e154000c 	cmp	r4, ip
 5115bdc:	a8bd81f0 	popge	{r4, r5, r6, r7, r8, pc}
        if (base[i].attr.attrs.type > SHELL_TYPE_USER
 5115be0:	e0861204 	add	r1, r6, r4, lsl #4
            && base[i].attr.attrs.type <= SHELL_TYPE_KEY
 5115be4:	e5d13001 	ldrb	r3, [r1, #1]
        if (base[i].attr.attrs.type > SHELL_TYPE_USER
 5115be8:	e203200f 	and	r2, r3, #15
 5115bec:	e3520009 	cmp	r2, #9
 5115bf0:	1afffff6 	bne	5115bd0 <shellListKey+0x64>
    return ((!command->attr.attrs.permission
 5115bf4:	e7d62204 	ldrb	r2, [r6, r4, lsl #4]
            ? 0 : -1;
 5115bf8:	e3520000 	cmp	r2, #0
            shellListItem(shell, &base[i]);
 5115bfc:	e1a00005 	mov	r0, r5
                || command->attr.attrs.enableUnchecked))
 5115c00:	e2033010 	and	r3, r3, #16
            ? 0 : -1;
 5115c04:	0a000003 	beq	5115c18 <shellListKey+0xac>
                    & shell->info.user->attr.attrs.permission))
 5115c08:	e595e000 	ldr	lr, [r5]
                || (command->attr.attrs.permission 
 5115c0c:	e5dee000 	ldrb	lr, [lr]
 5115c10:	e112000e 	tst	r2, lr
 5115c14:	0affffed 	beq	5115bd0 <shellListKey+0x64>
            && (shell->status.isChecked
 5115c18:	e5d52060 	ldrb	r2, [r5, #96]	; 0x60
 5115c1c:	e2022001 	and	r2, r2, #1
                || command->attr.attrs.enableUnchecked))
 5115c20:	e1923003 	orrs	r3, r2, r3
 5115c24:	0affffe9 	beq	5115bd0 <shellListKey+0x64>
            shellListItem(shell, &base[i]);
 5115c28:	e12fff37 	blx	r7
 5115c2c:	e1d5c5bc 	ldrh	ip, [r5, #92]	; 0x5c
 5115c30:	eaffffe6 	b	5115bd0 <shellListKey+0x64>
 5115c34:	0512d845 	.word	0x0512d845

05115c38 <shellKeys>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115c38:	e30831d8 	movw	r3, #33240	; 0x81d8
 5115c3c:	e3403513 	movt	r3, #1299	; 0x513
 5115c40:	e2831014 	add	r1, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 5115c44:	e4930004 	ldr	r0, [r3], #4
 5115c48:	e3500000 	cmp	r0, #0
 5115c4c:	0a000002 	beq	5115c5c <shellKeys+0x24>
 5115c50:	e5d02060 	ldrb	r2, [r0, #96]	; 0x60
 5115c54:	e3120002 	tst	r2, #2
 5115c58:	1a000002 	bne	5115c68 <shellKeys+0x30>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5115c5c:	e1530001 	cmp	r3, r1
 5115c60:	1afffff7 	bne	5115c44 <shellKeys+0xc>
 5115c64:	e12fff1e 	bx	lr
        shellListKey(shell);
 5115c68:	e3053b6c 	movw	r3, #23404	; 0x5b6c
 5115c6c:	e3403511 	movt	r3, #1297	; 0x511
{
 5115c70:	e92d4010 	push	{r4, lr}
        shellListKey(shell);
 5115c74:	e12fff33 	blx	r3
}
 5115c78:	e8bd8010 	pop	{r4, pc}

05115c7c <shellClearCommandLine>:
    for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 5115c7c:	e1d020bc 	ldrh	r2, [r0, #12]
 5115c80:	e1d030be 	ldrh	r3, [r0, #14]
 5115c84:	e0423003 	sub	r3, r2, r3
{
 5115c88:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 5115c8c:	e1a05000 	mov	r5, r0
    for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 5115c90:	e6bf4073 	sxth	r4, r3
 5115c94:	e3540000 	cmp	r4, #0
{
 5115c98:	e24dd00c 	sub	sp, sp, #12
    for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 5115c9c:	da00000b 	ble	5115cd0 <shellClearCommandLine+0x54>
 5115ca0:	e3a06020 	mov	r6, #32
    shell->write(&data, 1);
 5115ca4:	e5953068 	ldr	r3, [r5, #104]	; 0x68
 5115ca8:	e3a01001 	mov	r1, #1
 5115cac:	e5cd6007 	strb	r6, [sp, #7]
 5115cb0:	e28d0007 	add	r0, sp, #7
 5115cb4:	e12fff33 	blx	r3
    for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 5115cb8:	e2443001 	sub	r3, r4, #1
 5115cbc:	e6ff2073 	uxth	r2, r3
 5115cc0:	e3520000 	cmp	r2, #0
 5115cc4:	e6bf4073 	sxth	r4, r3
 5115cc8:	1afffff5 	bne	5115ca4 <shellClearCommandLine+0x28>
    shellDeleteCommandLine(shell, shell->parser.length);
 5115ccc:	e1d520bc 	ldrh	r2, [r5, #12]
    while (length--)
 5115cd0:	e21240ff 	ands	r4, r2, #255	; 0xff
 5115cd4:	0a000012 	beq	5115d24 <shellClearCommandLine+0xa8>
    return shell->write((char *)string, count);
 5115cd8:	e30d7854 	movw	r7, #55380	; 0xd854
 5115cdc:	e3407512 	movt	r7, #1298	; 0x512
    SHELL_ASSERT(shell->write, return 0);
 5115ce0:	e5956068 	ldr	r6, [r5, #104]	; 0x68
 5115ce4:	e3560000 	cmp	r6, #0
 5115ce8:	0a00000a 	beq	5115d18 <shellClearCommandLine+0x9c>
 5115cec:	e59f2038 	ldr	r2, [pc, #56]	; 5115d2c <shellClearCommandLine+0xb0>
 5115cf0:	e3a03020 	mov	r3, #32
    unsigned short count = 0;
 5115cf4:	e3a01000 	mov	r1, #0
 5115cf8:	ea000000 	b	5115d00 <shellClearCommandLine+0x84>
    while(*p++)
 5115cfc:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5115d00:	e2811001 	add	r1, r1, #1
    while(*p++)
 5115d04:	e3530000 	cmp	r3, #0
        count ++;
 5115d08:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5115d0c:	1afffffa 	bne	5115cfc <shellClearCommandLine+0x80>
    return shell->write((char *)string, count);
 5115d10:	e1a00007 	mov	r0, r7
 5115d14:	e12fff36 	blx	r6
    while (length--)
 5115d18:	e2443001 	sub	r3, r4, #1
 5115d1c:	e21340ff 	ands	r4, r3, #255	; 0xff
 5115d20:	1affffee 	bne	5115ce0 <shellClearCommandLine+0x64>
}
 5115d24:	e28dd00c 	add	sp, sp, #12
 5115d28:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
 5115d2c:	0512d855 	.word	0x0512d855

05115d30 <shellUp>:
                shell->history.number : shell->history.record))
 5115d30:	e1d035b2 	ldrh	r3, [r0, #82]	; 0x52
 5115d34:	e1d025b0 	ldrh	r2, [r0, #80]	; 0x50
 5115d38:	e1530002 	cmp	r3, r2
        if (shell->history.offset-- <= 
 5115d3c:	e1d015f4 	ldrsh	r1, [r0, #84]	; 0x54
                shell->history.number : shell->history.record))
 5115d40:	31a03002 	movcc	r3, r2
    shellClearCommandLine(shell);
 5115d44:	e3052c7c 	movw	r2, #23676	; 0x5c7c
            -((shell->history.number > shell->history.record) ?
 5115d48:	e2633000 	rsb	r3, r3, #0
            shell->history.offset = -((shell->history.number > shell->history.record)
 5115d4c:	e1510003 	cmp	r1, r3
 5115d50:	c2413001 	subgt	r3, r1, #1
{
 5115d54:	e92d4070 	push	{r4, r5, r6, lr}
            shell->history.offset = -((shell->history.number > shell->history.record)
 5115d58:	e1c035b4 	strh	r3, [r0, #84]	; 0x54
    shellClearCommandLine(shell);
 5115d5c:	e3402511 	movt	r2, #1297	; 0x511
{
 5115d60:	e1a04000 	mov	r4, r0
    shellClearCommandLine(shell);
 5115d64:	e12fff32 	blx	r2
    if (shell->history.offset == 0)
 5115d68:	e1d415f4 	ldrsh	r1, [r4, #84]	; 0x54
 5115d6c:	e3510000 	cmp	r1, #0
 5115d70:	1a000001 	bne	5115d7c <shellUp+0x4c>
        shell->parser.cursor = shell->parser.length = 0;
 5115d74:	e584100c 	str	r1, [r4, #12]
 5115d78:	e8bd8070 	pop	{r4, r5, r6, pc}
                shell->history.item[(shell->history.record + SHELL_HISTORY_MAX_NUMBER
 5115d7c:	e1d435b2 	ldrh	r3, [r4, #82]	; 0x52
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 5115d80:	e3062667 	movw	r2, #26215	; 0x6667
                shell->history.item[(shell->history.record + SHELL_HISTORY_MAX_NUMBER
 5115d84:	e2833005 	add	r3, r3, #5
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 5115d88:	e0833001 	add	r3, r3, r1
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 5115d8c:	e594c010 	ldr	ip, [r4, #16]
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 5115d90:	e3462666 	movt	r2, #26214	; 0x6666
 5115d94:	e0c12392 	smull	r2, r1, r2, r3
 5115d98:	e1a02fc3 	asr	r2, r3, #31
 5115d9c:	e06220c1 	rsb	r2, r2, r1, asr #1
 5115da0:	e0822102 	add	r2, r2, r2, lsl #2
 5115da4:	e0433002 	sub	r3, r3, r2
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 5115da8:	e0843103 	add	r3, r4, r3, lsl #2
 5115dac:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
    while (*(src + count))
 5115db0:	e1d010d0 	ldrsb	r1, [r0]
 5115db4:	e3510000 	cmp	r1, #0
 5115db8:	0a00001d 	beq	5115e34 <shellUp+0x104>
    unsigned short count = 0;
 5115dbc:	e3a03000 	mov	r3, #0
    while (*(src + count))
 5115dc0:	e1a02003 	mov	r2, r3
        *(dest + count) = *(src + count);
 5115dc4:	e7cc1002 	strb	r1, [ip, r2]
        count++;
 5115dc8:	e2833001 	add	r3, r3, #1
 5115dcc:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 5115dd0:	e19010d3 	ldrsb	r1, [r0, r3]
 5115dd4:	e1a02003 	mov	r2, r3
 5115dd8:	e3510000 	cmp	r1, #0
 5115ddc:	1afffff8 	bne	5115dc4 <shellUp+0x94>
    *(dest + count) = 0;
 5115de0:	e7cc1003 	strb	r1, [ip, r3]
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 5115de4:	e3530000 	cmp	r3, #0
 5115de8:	e1c430bc 	strh	r3, [r4, #12]
 5115dec:	08bd8070 	popeq	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 5115df0:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shell->parser.cursor = shell->parser.length;
 5115df4:	e1c430be 	strh	r3, [r4, #14]
    SHELL_ASSERT(shell->write, return 0);
 5115df8:	e3550000 	cmp	r5, #0
 5115dfc:	08bd8070 	popeq	{r4, r5, r6, pc}
        shellWriteString(shell, shell->parser.buffer);
 5115e00:	e5940010 	ldr	r0, [r4, #16]
    while(*p++)
 5115e04:	e1a03000 	mov	r3, r0
 5115e08:	e0d320d1 	ldrsb	r2, [r3], #1
 5115e0c:	e3520000 	cmp	r2, #0
 5115e10:	0a000005 	beq	5115e2c <shellUp+0xfc>
 5115e14:	e263c001 	rsb	ip, r3, #1
        count ++;
 5115e18:	e083100c 	add	r1, r3, ip
    while(*p++)
 5115e1c:	e0d320d1 	ldrsb	r2, [r3], #1
 5115e20:	e3520000 	cmp	r2, #0
 5115e24:	e6ff1071 	uxth	r1, r1
 5115e28:	1afffffa 	bne	5115e18 <shellUp+0xe8>
    return shell->write((char *)string, count);
 5115e2c:	e12fff35 	blx	r5
}
 5115e30:	e8bd8070 	pop	{r4, r5, r6, pc}
    *(dest + count) = 0;
 5115e34:	e5cc1000 	strb	r1, [ip]
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 5115e38:	e1c410bc 	strh	r1, [r4, #12]
 5115e3c:	e8bd8070 	pop	{r4, r5, r6, pc}

05115e40 <shellTab>:
{
 5115e40:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (shell->parser.length == 0)
 5115e44:	e1d060bc 	ldrh	r6, [r0, #12]
 5115e48:	e3560000 	cmp	r6, #0
{
 5115e4c:	e1a05000 	mov	r5, r0
 5115e50:	e24dd014 	sub	sp, sp, #20
    if (shell->parser.length == 0)
 5115e54:	0a0000b0 	beq	511611c <shellTab+0x2dc>
        shell->parser.buffer[shell->parser.length] = 0;
 5115e58:	e5903010 	ldr	r3, [r0, #16]
 5115e5c:	e3a04000 	mov	r4, #0
    unsigned short maxMatch = shell->parser.bufferSize;
 5115e60:	e1d023b4 	ldrh	r2, [r0, #52]	; 0x34
 5115e64:	e58d2004 	str	r2, [sp, #4]
        shell->parser.buffer[shell->parser.length] = 0;
 5115e68:	e7c34006 	strb	r4, [r3, r6]
        for (short i = 0; i < shell->commandList.count; i++)
 5115e6c:	e1d025bc 	ldrh	r2, [r0, #92]	; 0x5c
        ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5115e70:	e5909058 	ldr	r9, [r0, #88]	; 0x58
        for (short i = 0; i < shell->commandList.count; i++)
 5115e74:	e1520004 	cmp	r2, r4
 5115e78:	0a000075 	beq	5116054 <shellTab+0x214>
                    shellListItem(shell, &base[lastMatchIndex]);
 5115e7c:	e3053490 	movw	r3, #21648	; 0x5490
                                   (char *)shellGetCommandName(&base[i]))
 5115e80:	e3047eb4 	movw	r7, #20148	; 0x4eb4
                    shellListItem(shell, &base[lastMatchIndex]);
 5115e84:	e3403511 	movt	r3, #1297	; 0x511
    unsigned short matchNum = 0;
 5115e88:	e1a06004 	mov	r6, r4
                                   (char *)shellGetCommandName(&base[i]))
 5115e8c:	e3407511 	movt	r7, #1297	; 0x511
                    shellListItem(shell, &base[lastMatchIndex]);
 5115e90:	e58d3008 	str	r3, [sp, #8]
    return shell->write((char *)string, count);
 5115e94:	e30d33e0 	movw	r3, #54240	; 0xd3e0
    unsigned short lastMatchIndex = 0;
 5115e98:	e1a08004 	mov	r8, r4
    return shell->write((char *)string, count);
 5115e9c:	e3403512 	movt	r3, #1298	; 0x512
 5115ea0:	e58d300c 	str	r3, [sp, #12]
    return ((!command->attr.attrs.permission
 5115ea4:	e7d93204 	ldrb	r3, [r9, r4, lsl #4]
            ? 0 : -1;
 5115ea8:	e3530000 	cmp	r3, #0
            if (shellCheckPermission(shell, &base[i]) == 0
 5115eac:	e089a204 	add	sl, r9, r4, lsl #4
            ? 0 : -1;
 5115eb0:	0a000007 	beq	5115ed4 <shellTab+0x94>
                || command->attr.attrs.type == SHELL_TYPE_USER
 5115eb4:	e5da1001 	ldrb	r1, [sl, #1]
 5115eb8:	e201100f 	and	r1, r1, #15
 5115ebc:	e3510008 	cmp	r1, #8
 5115ec0:	0a000003 	beq	5115ed4 <shellTab+0x94>
                    & shell->info.user->attr.attrs.permission))
 5115ec4:	e5951000 	ldr	r1, [r5]
                || (command->attr.attrs.permission 
 5115ec8:	e5d11000 	ldrb	r1, [r1]
 5115ecc:	e1130001 	tst	r3, r1
 5115ed0:	0a000064 	beq	5116068 <shellTab+0x228>
            && (shell->status.isChecked
 5115ed4:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5115ed8:	e3130001 	tst	r3, #1
 5115edc:	0a00005e 	beq	511605c <shellTab+0x21c>
                && shellStringCompare(shell->parser.buffer,
 5115ee0:	e595b010 	ldr	fp, [r5, #16]
                                   (char *)shellGetCommandName(&base[i]))
 5115ee4:	e1a0000a 	mov	r0, sl
 5115ee8:	e12fff37 	blx	r7
    while (*(dest +i) && *(src + i))
 5115eec:	e1dbc0d0 	ldrsb	ip, [fp]
 5115ef0:	e35c0000 	cmp	ip, #0
    unsigned short match = 0;
 5115ef4:	01a0200c 	moveq	r2, ip
    while (*(dest +i) && *(src + i))
 5115ef8:	0a00000f 	beq	5115f3c <shellTab+0xfc>
 5115efc:	e3a03000 	mov	r3, #0
    unsigned short match = 0;
 5115f00:	e1a02003 	mov	r2, r3
 5115f04:	ea000004 	b	5115f1c <shellTab+0xdc>
        match ++;
 5115f08:	e6ff207e 	uxth	r2, lr
    while (*(dest +i) && *(src + i))
 5115f0c:	e19bc0d2 	ldrsb	ip, [fp, r2]
 5115f10:	e1a03002 	mov	r3, r2
 5115f14:	e35c0000 	cmp	ip, #0
 5115f18:	0a000007 	beq	5115f3c <shellTab+0xfc>
 5115f1c:	e19010d3 	ldrsb	r1, [r0, r3]
 5115f20:	e16f3f11 	clz	r3, r1
        match ++;
 5115f24:	e282e001 	add	lr, r2, #1
    while (*(dest +i) && *(src + i))
 5115f28:	e1a032a3 	lsr	r3, r3, #5
        if (*(dest + i) != *(src +i))
 5115f2c:	e151000c 	cmp	r1, ip
 5115f30:	13833001 	orrne	r3, r3, #1
 5115f34:	e3530000 	cmp	r3, #0
 5115f38:	0afffff2 	beq	5115f08 <shellTab+0xc8>
                && shellStringCompare(shell->parser.buffer,
 5115f3c:	e1d530bc 	ldrh	r3, [r5, #12]
 5115f40:	e1530002 	cmp	r3, r2
 5115f44:	0a000049 	beq	5116070 <shellTab+0x230>
 5115f48:	e6ff4074 	uxth	r4, r4
 5115f4c:	e1d525bc 	ldrh	r2, [r5, #92]	; 0x5c
        for (short i = 0; i < shell->commandList.count; i++)
 5115f50:	e2844001 	add	r4, r4, #1
 5115f54:	e6bf4074 	sxth	r4, r4
 5115f58:	e1540002 	cmp	r4, r2
 5115f5c:	baffffd0 	blt	5115ea4 <shellTab+0x64>
        if (matchNum == 0)
 5115f60:	e3560000 	cmp	r6, #0
 5115f64:	0a00003a 	beq	5116054 <shellTab+0x214>
        if (matchNum == 1)
 5115f68:	e3560001 	cmp	r6, #1
 5115f6c:	0a00009e 	beq	51161ec <shellTab+0x3ac>
                                (char *)shellGetCommandName(&base[lastMatchIndex]));
 5115f70:	e3043eb4 	movw	r3, #20148	; 0x4eb4
 5115f74:	e0898208 	add	r8, r9, r8, lsl #4
 5115f78:	e1a00008 	mov	r0, r8
 5115f7c:	e3403511 	movt	r3, #1297	; 0x511
                shellStringCopy(shell->parser.buffer,
 5115f80:	e5954010 	ldr	r4, [r5, #16]
                                (char *)shellGetCommandName(&base[lastMatchIndex]));
 5115f84:	e12fff33 	blx	r3
    while (*(src + count))
 5115f88:	e1d020d0 	ldrsb	r2, [r0]
 5115f8c:	e3520000 	cmp	r2, #0
 5115f90:	0a0000f3 	beq	5116364 <shellTab+0x524>
    unsigned short count = 0;
 5115f94:	e3a03000 	mov	r3, #0
    while (*(src + count))
 5115f98:	e1a0c003 	mov	ip, r3
        *(dest + count) = *(src + count);
 5115f9c:	e7c4200c 	strb	r2, [r4, ip]
        count++;
 5115fa0:	e2833001 	add	r3, r3, #1
 5115fa4:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 5115fa8:	e19020d3 	ldrsb	r2, [r0, r3]
 5115fac:	e1a0c003 	mov	ip, r3
 5115fb0:	e3520000 	cmp	r2, #0
 5115fb4:	1afffff8 	bne	5115f9c <shellTab+0x15c>
    *(dest + count) = 0;
 5115fb8:	e0844003 	add	r4, r4, r3
 5115fbc:	e3a02000 	mov	r2, #0
        if (matchNum > 1)
 5115fc0:	e3560001 	cmp	r6, #1
    *(dest + count) = 0;
 5115fc4:	e5c42000 	strb	r2, [r4]
            shell->parser.length = 
 5115fc8:	e1c530bc 	strh	r3, [r5, #12]
        if (matchNum > 1)
 5115fcc:	1a000065 	bne	5116168 <shellTab+0x328>
        shell->parser.buffer[shell->parser.length] = 0;
 5115fd0:	e5952010 	ldr	r2, [r5, #16]
 5115fd4:	e3a01000 	mov	r1, #0
 5115fd8:	e7c21003 	strb	r1, [r2, r3]
        shell->parser.cursor = shell->parser.length;
 5115fdc:	e1d530bc 	ldrh	r3, [r5, #12]
    SHELL_ASSERT(shell->write, return 0);
 5115fe0:	e5954068 	ldr	r4, [r5, #104]	; 0x68
        shell->parser.cursor = shell->parser.length;
 5115fe4:	e1c530be 	strh	r3, [r5, #14]
    SHELL_ASSERT(shell->write, return 0);
 5115fe8:	e1540001 	cmp	r4, r1
 5115fec:	0a00000b 	beq	5116020 <shellTab+0x1e0>
        shellWriteString(shell, shell->parser.buffer);
 5115ff0:	e5950010 	ldr	r0, [r5, #16]
    while(*p++)
 5115ff4:	e1a03000 	mov	r3, r0
 5115ff8:	e0d310d1 	ldrsb	r1, [r3], #1
 5115ffc:	e3510000 	cmp	r1, #0
 5116000:	0a000005 	beq	511601c <shellTab+0x1dc>
 5116004:	e263c001 	rsb	ip, r3, #1
        count ++;
 5116008:	e083100c 	add	r1, r3, ip
    while(*p++)
 511600c:	e0d320d1 	ldrsb	r2, [r3], #1
 5116010:	e3520000 	cmp	r2, #0
 5116014:	e6ff1071 	uxth	r1, r1
 5116018:	1afffffa 	bne	5116008 <shellTab+0x1c8>
    return shell->write((char *)string, count);
 511601c:	e12fff34 	blx	r4
    if (SHELL_GET_TICK())
 5116020:	e3014ca4 	movw	r4, #7332	; 0x1ca4
 5116024:	e3404511 	movt	r4, #1297	; 0x511
 5116028:	e12fff34 	blx	r4
 511602c:	e3500000 	cmp	r0, #0
 5116030:	0a000007 	beq	5116054 <shellTab+0x214>
        if (matchNum == 1
 5116034:	e3560001 	cmp	r6, #1
 5116038:	1a000002 	bne	5116048 <shellTab+0x208>
            && shell->status.tabFlag
 511603c:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5116040:	e3130004 	tst	r3, #4
 5116044:	1a00008b 	bne	5116278 <shellTab+0x438>
            shell->status.tabFlag = 1;
 5116048:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 511604c:	e3833004 	orr	r3, r3, #4
 5116050:	e5c53060 	strb	r3, [r5, #96]	; 0x60
}
 5116054:	e28dd014 	add	sp, sp, #20
 5116058:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                || command->attr.attrs.enableUnchecked))
 511605c:	e5da3001 	ldrb	r3, [sl, #1]
 5116060:	e3130010 	tst	r3, #16
 5116064:	1affff9d 	bne	5115ee0 <shellTab+0xa0>
 5116068:	e6ff4074 	uxth	r4, r4
 511606c:	eaffffb7 	b	5115f50 <shellTab+0x110>
                if (matchNum != 0)
 5116070:	e3560000 	cmp	r6, #0
 5116074:	0a000022 	beq	5116104 <shellTab+0x2c4>
                    if (matchNum == 1)
 5116078:	e3560001 	cmp	r6, #1
 511607c:	0a00006e 	beq	511623c <shellTab+0x3fc>
                    shellListItem(shell, &base[lastMatchIndex]);
 5116080:	e59d3008 	ldr	r3, [sp, #8]
 5116084:	e0898208 	add	r8, r9, r8, lsl #4
 5116088:	e1a01008 	mov	r1, r8
 511608c:	e1a00005 	mov	r0, r5
 5116090:	e12fff33 	blx	r3
                        shellStringCompare((char *)shellGetCommandName(&base[lastMatchIndex]),
 5116094:	e1a00008 	mov	r0, r8
 5116098:	e12fff37 	blx	r7
 511609c:	e1a08000 	mov	r8, r0
                                           (char *)shellGetCommandName(&base[i]));
 51160a0:	e1a0000a 	mov	r0, sl
 51160a4:	e12fff37 	blx	r7
    while (*(dest +i) && *(src + i))
 51160a8:	e1d830d0 	ldrsb	r3, [r8]
 51160ac:	e3530000 	cmp	r3, #0
 51160b0:	13a01000 	movne	r1, #0
    unsigned short match = 0;
 51160b4:	11a02001 	movne	r2, r1
    while (*(dest +i) && *(src + i))
 51160b8:	1a000005 	bne	51160d4 <shellTab+0x294>
 51160bc:	ea00000f 	b	5116100 <shellTab+0x2c0>
        match ++;
 51160c0:	e6ff207c 	uxth	r2, ip
    while (*(dest +i) && *(src + i))
 51160c4:	e19830d2 	ldrsb	r3, [r8, r2]
 51160c8:	e1a01002 	mov	r1, r2
 51160cc:	e3530000 	cmp	r3, #0
 51160d0:	0a000007 	beq	51160f4 <shellTab+0x2b4>
 51160d4:	e19010d1 	ldrsb	r1, [r0, r1]
        if (*(dest + i) != *(src +i))
 51160d8:	e0513003 	subs	r3, r1, r3
 51160dc:	13a03001 	movne	r3, #1
        match ++;
 51160e0:	e282c001 	add	ip, r2, #1
        if (*(dest + i) != *(src +i))
 51160e4:	e3510000 	cmp	r1, #0
 51160e8:	03833001 	orreq	r3, r3, #1
 51160ec:	e3530000 	cmp	r3, #0
 51160f0:	0afffff2 	beq	51160c0 <shellTab+0x280>
                    maxMatch = (maxMatch > length) ? length : maxMatch;
 51160f4:	e59d3004 	ldr	r3, [sp, #4]
 51160f8:	e1530002 	cmp	r3, r2
 51160fc:	21a03002 	movcs	r3, r2
 5116100:	e58d3004 	str	r3, [sp, #4]
                matchNum++;
 5116104:	e2866001 	add	r6, r6, #1
 5116108:	e1d525bc 	ldrh	r2, [r5, #92]	; 0x5c
 511610c:	e6ff8074 	uxth	r8, r4
 5116110:	e1a04008 	mov	r4, r8
 5116114:	e6ff6076 	uxth	r6, r6
 5116118:	eaffff8c 	b	5115f50 <shellTab+0x110>
    shellListCommand(shell);
 511611c:	e3053838 	movw	r3, #22584	; 0x5838
 5116120:	e3403511 	movt	r3, #1297	; 0x511
 5116124:	e12fff33 	blx	r3
    if (shell->status.isChecked)
 5116128:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 511612c:	e3130001 	tst	r3, #1
 5116130:	0a00001d 	beq	51161ac <shellTab+0x36c>
 5116134:	e30530ac 	movw	r3, #20652	; 0x50ac
 5116138:	e3a01001 	mov	r1, #1
 511613c:	e1a00005 	mov	r0, r5
 5116140:	e3403511 	movt	r3, #1297	; 0x511
 5116144:	e12fff33 	blx	r3
    if (SHELL_GET_TICK())
 5116148:	e3013ca4 	movw	r3, #7332	; 0x1ca4
 511614c:	e3403511 	movt	r3, #1297	; 0x511
 5116150:	e12fff33 	blx	r3
 5116154:	e3500000 	cmp	r0, #0
            shell->status.tabFlag = 1;
 5116158:	15d53060 	ldrbne	r3, [r5, #96]	; 0x60
 511615c:	13833004 	orrne	r3, r3, #4
 5116160:	15c53060 	strbne	r3, [r5, #96]	; 0x60
 5116164:	eaffffba 	b	5116054 <shellTab+0x214>
            shellListItem(shell, &base[lastMatchIndex]);
 5116168:	e3053490 	movw	r3, #21648	; 0x5490
 511616c:	e1a01008 	mov	r1, r8
 5116170:	e1a00005 	mov	r0, r5
 5116174:	e3403511 	movt	r3, #1297	; 0x511
 5116178:	e12fff33 	blx	r3
    if (shell->status.isChecked)
 511617c:	e5d53060 	ldrb	r3, [r5, #96]	; 0x60
 5116180:	e2131001 	ands	r1, r3, #1
 5116184:	0a00001d 	beq	5116200 <shellTab+0x3c0>
 5116188:	e30530ac 	movw	r3, #20652	; 0x50ac
 511618c:	e3a01001 	mov	r1, #1
 5116190:	e1a00005 	mov	r0, r5
 5116194:	e3403511 	movt	r3, #1297	; 0x511
 5116198:	e12fff33 	blx	r3
            shell->parser.length = maxMatch;
 511619c:	e59d2004 	ldr	r2, [sp, #4]
 51161a0:	e1c520bc 	strh	r2, [r5, #12]
 51161a4:	e1a03002 	mov	r3, r2
 51161a8:	eaffff88 	b	5115fd0 <shellTab+0x190>
    SHELL_ASSERT(shell->write, return 0);
 51161ac:	e5954068 	ldr	r4, [r5, #104]	; 0x68
 51161b0:	e3540000 	cmp	r4, #0
 51161b4:	0affffe3 	beq	5116148 <shellTab+0x308>
 51161b8:	e59f21b4 	ldr	r2, [pc, #436]	; 5116374 <shellTab+0x534>
 51161bc:	e3a0300a 	mov	r3, #10
 51161c0:	ea000000 	b	51161c8 <shellTab+0x388>
    while(*p++)
 51161c4:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51161c8:	e2866001 	add	r6, r6, #1
    while(*p++)
 51161cc:	e3530000 	cmp	r3, #0
        count ++;
 51161d0:	e6ff6076 	uxth	r6, r6
    while(*p++)
 51161d4:	1afffffa 	bne	51161c4 <shellTab+0x384>
    return shell->write((char *)string, count);
 51161d8:	e30d0858 	movw	r0, #55384	; 0xd858
 51161dc:	e1a01006 	mov	r1, r6
 51161e0:	e3400512 	movt	r0, #1298	; 0x512
 51161e4:	e12fff34 	blx	r4
 51161e8:	eaffffd6 	b	5116148 <shellTab+0x308>
            shellClearCommandLine(shell);
 51161ec:	e3053c7c 	movw	r3, #23676	; 0x5c7c
 51161f0:	e1a00005 	mov	r0, r5
 51161f4:	e3403511 	movt	r3, #1297	; 0x511
 51161f8:	e12fff33 	blx	r3
 51161fc:	eaffff5b 	b	5115f70 <shellTab+0x130>
    SHELL_ASSERT(shell->write, return 0);
 5116200:	e5954068 	ldr	r4, [r5, #104]	; 0x68
 5116204:	e3540000 	cmp	r4, #0
 5116208:	0affffe3 	beq	511619c <shellTab+0x35c>
 511620c:	e59f2160 	ldr	r2, [pc, #352]	; 5116374 <shellTab+0x534>
 5116210:	e3a0300a 	mov	r3, #10
 5116214:	ea000000 	b	511621c <shellTab+0x3dc>
    while(*p++)
 5116218:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 511621c:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116220:	e3530000 	cmp	r3, #0
        count ++;
 5116224:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116228:	1afffffa 	bne	5116218 <shellTab+0x3d8>
    return shell->write((char *)string, count);
 511622c:	e30d0858 	movw	r0, #55384	; 0xd858
 5116230:	e3400512 	movt	r0, #1298	; 0x512
 5116234:	e12fff34 	blx	r4
 5116238:	eaffffd7 	b	511619c <shellTab+0x35c>
    SHELL_ASSERT(shell->write, return 0);
 511623c:	e5953068 	ldr	r3, [r5, #104]	; 0x68
 5116240:	e3530000 	cmp	r3, #0
 5116244:	0affff8d 	beq	5116080 <shellTab+0x240>
 5116248:	e59f0128 	ldr	r0, [pc, #296]	; 5116378 <shellTab+0x538>
 511624c:	e3a0200a 	mov	r2, #10
    unsigned short count = 0;
 5116250:	e3a01000 	mov	r1, #0
 5116254:	ea000000 	b	511625c <shellTab+0x41c>
    while(*p++)
 5116258:	e1f020d1 	ldrsb	r2, [r0, #1]!
        count ++;
 511625c:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116260:	e3520000 	cmp	r2, #0
        count ++;
 5116264:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116268:	1afffffa 	bne	5116258 <shellTab+0x418>
    return shell->write((char *)string, count);
 511626c:	e59d000c 	ldr	r0, [sp, #12]
 5116270:	e12fff33 	blx	r3
 5116274:	eaffff81 	b	5116080 <shellTab+0x240>
            && SHELL_GET_TICK() - shell->info.activeTime < SHELL_DOUBLE_CLICK_TIME)
 5116278:	e12fff34 	blx	r4
 511627c:	e5953004 	ldr	r3, [r5, #4]
 5116280:	e0400003 	sub	r0, r0, r3
 5116284:	e35000c7 	cmp	r0, #199	; 0xc7
 5116288:	8affff6e 	bhi	5116048 <shellTab+0x208>
            shellClearCommandLine(shell);
 511628c:	e3053c7c 	movw	r3, #23676	; 0x5c7c
 5116290:	e1a00005 	mov	r0, r5
 5116294:	e3403511 	movt	r3, #1297	; 0x511
 5116298:	e12fff33 	blx	r3
            for (short i = shell->parser.length; i >= 0; i--)
 511629c:	e1d500bc 	ldrh	r0, [r5, #12]
 51162a0:	e6bf2070 	sxth	r2, r0
 51162a4:	e3520000 	cmp	r2, #0
 51162a8:	a0420000 	subge	r0, r2, r0
 51162ac:	ba000005 	blt	51162c8 <shellTab+0x488>
                shell->parser.buffer[i + 5] = shell->parser.buffer[i];
 51162b0:	e5953010 	ldr	r3, [r5, #16]
            for (short i = shell->parser.length; i >= 0; i--)
 51162b4:	e1500002 	cmp	r0, r2
                shell->parser.buffer[i + 5] = shell->parser.buffer[i];
 51162b8:	e1b310d2 	ldrsb	r1, [r3, r2]!
 51162bc:	e5c31005 	strb	r1, [r3, #5]
            for (short i = shell->parser.length; i >= 0; i--)
 51162c0:	e2422001 	sub	r2, r2, #1
 51162c4:	1afffff9 	bne	51162b0 <shellTab+0x470>
    unsigned short count = 0;
 51162c8:	e3a03000 	mov	r3, #0
 51162cc:	e30d0874 	movw	r0, #55412	; 0xd874
            shellStringCopy(shell->parser.buffer, "help");
 51162d0:	e595c010 	ldr	ip, [r5, #16]
    while (*(src + count))
 51162d4:	e3a02068 	mov	r2, #104	; 0x68
 51162d8:	e1a01003 	mov	r1, r3
 51162dc:	e3400512 	movt	r0, #1298	; 0x512
        *(dest + count) = *(src + count);
 51162e0:	e7cc2001 	strb	r2, [ip, r1]
        count++;
 51162e4:	e2833001 	add	r3, r3, #1
 51162e8:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 51162ec:	e19020d3 	ldrsb	r2, [r0, r3]
 51162f0:	e1a01003 	mov	r1, r3
 51162f4:	e3520000 	cmp	r2, #0
 51162f8:	1afffff8 	bne	51162e0 <shellTab+0x4a0>
    *(dest + count) = 0;
 51162fc:	e7cc2003 	strb	r2, [ip, r3]
            shell->parser.buffer[4] = ' ';
 5116300:	e3a01020 	mov	r1, #32
 5116304:	e5953010 	ldr	r3, [r5, #16]
 5116308:	e5c31004 	strb	r1, [r3, #4]
            shell->parser.length += 5;
 511630c:	e1d530bc 	ldrh	r3, [r5, #12]
    SHELL_ASSERT(shell->write, return 0);
 5116310:	e5954068 	ldr	r4, [r5, #104]	; 0x68
            shell->parser.length += 5;
 5116314:	e2833005 	add	r3, r3, #5
    SHELL_ASSERT(shell->write, return 0);
 5116318:	e3540000 	cmp	r4, #0
            shell->parser.length += 5;
 511631c:	e6ff3073 	uxth	r3, r3
 5116320:	e1c530bc 	strh	r3, [r5, #12]
            shell->parser.cursor = shell->parser.length;
 5116324:	e1c530be 	strh	r3, [r5, #14]
    SHELL_ASSERT(shell->write, return 0);
 5116328:	0affff49 	beq	5116054 <shellTab+0x214>
            shellWriteString(shell, shell->parser.buffer);
 511632c:	e5950010 	ldr	r0, [r5, #16]
    while(*p++)
 5116330:	e1a03000 	mov	r3, r0
 5116334:	e0d310d1 	ldrsb	r1, [r3], #1
 5116338:	e3510000 	cmp	r1, #0
 511633c:	0a00000a 	beq	511636c <shellTab+0x52c>
 5116340:	e1a02003 	mov	r2, r3
 5116344:	e263c001 	rsb	ip, r3, #1
        count ++;
 5116348:	e082300c 	add	r3, r2, ip
 511634c:	e6ff1073 	uxth	r1, r3
    while(*p++)
 5116350:	e0d230d1 	ldrsb	r3, [r2], #1
 5116354:	e3530000 	cmp	r3, #0
 5116358:	1afffffa 	bne	5116348 <shellTab+0x508>
    return shell->write((char *)string, count);
 511635c:	e12fff34 	blx	r4
 5116360:	eaffff3b 	b	5116054 <shellTab+0x214>
    unsigned short count = 0;
 5116364:	e1a03002 	mov	r3, r2
 5116368:	eaffff13 	b	5115fbc <shellTab+0x17c>
    unsigned short count = 0;
 511636c:	e1a01002 	mov	r1, r2
 5116370:	eafffff9 	b	511635c <shellTab+0x51c>
 5116374:	0512d859 	.word	0x0512d859
 5116378:	0512d3e1 	.word	0x0512d3e1

0511637c <shellDown>:
        if (++shell->history.offset > 0)
 511637c:	e1d035b4 	ldrh	r3, [r0, #84]	; 0x54
 5116380:	e2833001 	add	r3, r3, #1
{
 5116384:	e92d4070 	push	{r4, r5, r6, lr}
 5116388:	e1a04000 	mov	r4, r0
        if (++shell->history.offset > 0)
 511638c:	e6bf3073 	sxth	r3, r3
 5116390:	e3530000 	cmp	r3, #0
 5116394:	e1c035b4 	strh	r3, [r0, #84]	; 0x54
 5116398:	ca000035 	bgt	5116474 <shellDown+0xf8>
    shellClearCommandLine(shell);
 511639c:	e3053c7c 	movw	r3, #23676	; 0x5c7c
 51163a0:	e3403511 	movt	r3, #1297	; 0x511
 51163a4:	e12fff33 	blx	r3
    if (shell->history.offset == 0)
 51163a8:	e1d415f4 	ldrsh	r1, [r4, #84]	; 0x54
 51163ac:	e3510000 	cmp	r1, #0
 51163b0:	0a00002d 	beq	511646c <shellDown+0xf0>
                shell->history.item[(shell->history.record + SHELL_HISTORY_MAX_NUMBER
 51163b4:	e1d435b2 	ldrh	r3, [r4, #82]	; 0x52
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 51163b8:	e3062667 	movw	r2, #26215	; 0x6667
                shell->history.item[(shell->history.record + SHELL_HISTORY_MAX_NUMBER
 51163bc:	e2833005 	add	r3, r3, #5
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 51163c0:	e0833001 	add	r3, r3, r1
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 51163c4:	e594c010 	ldr	ip, [r4, #16]
                    + shell->history.offset) % SHELL_HISTORY_MAX_NUMBER])) == 0)
 51163c8:	e3462666 	movt	r2, #26214	; 0x6666
 51163cc:	e0c12392 	smull	r2, r1, r2, r3
 51163d0:	e1a02fc3 	asr	r2, r3, #31
 51163d4:	e06220c1 	rsb	r2, r2, r1, asr #1
 51163d8:	e0822102 	add	r2, r2, r2, lsl #2
 51163dc:	e0433002 	sub	r3, r3, r2
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 51163e0:	e0843103 	add	r3, r4, r3, lsl #2
 51163e4:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
    while (*(src + count))
 51163e8:	e1d010d0 	ldrsb	r1, [r0]
 51163ec:	e3510000 	cmp	r1, #0
 51163f0:	0a000022 	beq	5116480 <shellDown+0x104>
    unsigned short count = 0;
 51163f4:	e3a03000 	mov	r3, #0
    while (*(src + count))
 51163f8:	e1a02003 	mov	r2, r3
        *(dest + count) = *(src + count);
 51163fc:	e7cc1002 	strb	r1, [ip, r2]
        count++;
 5116400:	e2833001 	add	r3, r3, #1
 5116404:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 5116408:	e19010d3 	ldrsb	r1, [r0, r3]
 511640c:	e1a02003 	mov	r2, r3
 5116410:	e3510000 	cmp	r1, #0
 5116414:	1afffff8 	bne	51163fc <shellDown+0x80>
    *(dest + count) = 0;
 5116418:	e7cc1003 	strb	r1, [ip, r3]
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 511641c:	e3530000 	cmp	r3, #0
 5116420:	e1c430bc 	strh	r3, [r4, #12]
 5116424:	08bd8070 	popeq	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 5116428:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shell->parser.cursor = shell->parser.length;
 511642c:	e1c430be 	strh	r3, [r4, #14]
    SHELL_ASSERT(shell->write, return 0);
 5116430:	e3550000 	cmp	r5, #0
 5116434:	08bd8070 	popeq	{r4, r5, r6, pc}
        shellWriteString(shell, shell->parser.buffer);
 5116438:	e5940010 	ldr	r0, [r4, #16]
    while(*p++)
 511643c:	e1a03000 	mov	r3, r0
 5116440:	e0d320d1 	ldrsb	r2, [r3], #1
 5116444:	e3520000 	cmp	r2, #0
 5116448:	0a000005 	beq	5116464 <shellDown+0xe8>
 511644c:	e263c001 	rsb	ip, r3, #1
        count ++;
 5116450:	e083100c 	add	r1, r3, ip
    while(*p++)
 5116454:	e0d320d1 	ldrsb	r2, [r3], #1
 5116458:	e3520000 	cmp	r2, #0
 511645c:	e6ff1071 	uxth	r1, r1
 5116460:	1afffffa 	bne	5116450 <shellDown+0xd4>
    return shell->write((char *)string, count);
 5116464:	e12fff35 	blx	r5
}
 5116468:	e8bd8070 	pop	{r4, r5, r6, pc}
        shell->parser.cursor = shell->parser.length = 0;
 511646c:	e584100c 	str	r1, [r4, #12]
 5116470:	e8bd8070 	pop	{r4, r5, r6, pc}
            shell->history.offset = 0;
 5116474:	e3a03000 	mov	r3, #0
 5116478:	e1c035b4 	strh	r3, [r0, #84]	; 0x54
            return;
 511647c:	e8bd8070 	pop	{r4, r5, r6, pc}
    *(dest + count) = 0;
 5116480:	e5cc1000 	strb	r1, [ip]
        if ((shell->parser.length = shellStringCopy(shell->parser.buffer,
 5116484:	e1c410bc 	strh	r1, [r4, #12]
 5116488:	e8bd8070 	pop	{r4, r5, r6, pc}

0511648c <shellInsertByte>:
    if (shell->parser.length >= shell->parser.bufferSize - 1)
 511648c:	e1d023b4 	ldrh	r2, [r0, #52]	; 0x34
 5116490:	e2422001 	sub	r2, r2, #1
 5116494:	e1d030bc 	ldrh	r3, [r0, #12]
 5116498:	e1530002 	cmp	r3, r2
{
 511649c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 51164a0:	e1a04000 	mov	r4, r0
 51164a4:	e24dd00c 	sub	sp, sp, #12
    if (shell->parser.length >= shell->parser.bufferSize - 1)
 51164a8:	aa000056 	bge	5116608 <shellInsertByte+0x17c>
    if (shell->parser.cursor == shell->parser.length)
 51164ac:	e1d020be 	ldrh	r2, [r0, #14]
 51164b0:	e1a05001 	mov	r5, r1
 51164b4:	e1530002 	cmp	r3, r2
 51164b8:	0a000040 	beq	51165c0 <shellInsertByte+0x134>
    else if (shell->parser.cursor < shell->parser.length)
 51164bc:	9a00003d 	bls	51165b8 <shellInsertByte+0x12c>
        for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 51164c0:	e0433002 	sub	r3, r3, r2
 51164c4:	e6ffe073 	uxth	lr, r3
 51164c8:	e6bf3073 	sxth	r3, r3
 51164cc:	e3530000 	cmp	r3, #0
 51164d0:	da000009 	ble	51164fc <shellInsertByte+0x70>
 51164d4:	e043e00e 	sub	lr, r3, lr
                shell->parser.buffer[shell->parser.cursor + i - 1];
 51164d8:	e5940010 	ldr	r0, [r4, #16]
 51164dc:	e0822003 	add	r2, r2, r3
        for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 51164e0:	e2433001 	sub	r3, r3, #1
 51164e4:	e15e0003 	cmp	lr, r3
                shell->parser.buffer[shell->parser.cursor + i - 1];
 51164e8:	e080c002 	add	ip, r0, r2
 51164ec:	e15cc0d1 	ldrsb	ip, [ip, #-1]
            shell->parser.buffer[shell->parser.cursor + i] = 
 51164f0:	e7c0c002 	strb	ip, [r0, r2]
                shell->parser.buffer[shell->parser.cursor + i - 1];
 51164f4:	e1d420be 	ldrh	r2, [r4, #14]
        for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 51164f8:	1afffff6 	bne	51164d8 <shellInsertByte+0x4c>
        shell->parser.buffer[shell->parser.cursor++] = data;
 51164fc:	e5943010 	ldr	r3, [r4, #16]
 5116500:	e2821001 	add	r1, r2, #1
 5116504:	e1c410be 	strh	r1, [r4, #14]
        shell->parser.buffer[++shell->parser.length] = 0;
 5116508:	e3a01000 	mov	r1, #0
        shell->parser.buffer[shell->parser.cursor++] = data;
 511650c:	e7c35002 	strb	r5, [r3, r2]
        shell->parser.buffer[++shell->parser.length] = 0;
 5116510:	e1d430bc 	ldrh	r3, [r4, #12]
 5116514:	e5942010 	ldr	r2, [r4, #16]
 5116518:	e2833001 	add	r3, r3, #1
 511651c:	e6ff3073 	uxth	r3, r3
 5116520:	e1c430bc 	strh	r3, [r4, #12]
 5116524:	e7c21003 	strb	r1, [r2, r3]
        for (short i = shell->parser.cursor - 1; i < shell->parser.length; i++)
 5116528:	e1d420be 	ldrh	r2, [r4, #14]
 511652c:	e2425001 	sub	r5, r2, #1
 5116530:	e1d430bc 	ldrh	r3, [r4, #12]
 5116534:	e6bf5075 	sxth	r5, r5
 5116538:	e1550003 	cmp	r5, r3
 511653c:	aa00000d 	bge	5116578 <shellInsertByte+0xec>
 5116540:	e28d6007 	add	r6, sp, #7
            shellWriteByte(shell, shell->parser.buffer[i]);
 5116544:	e5942010 	ldr	r2, [r4, #16]
 5116548:	e19220d5 	ldrsb	r2, [r2, r5]
    shell->write(&data, 1);
 511654c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 5116550:	e2855001 	add	r5, r5, #1
 5116554:	e3a01001 	mov	r1, #1
 5116558:	e1a00006 	mov	r0, r6
 511655c:	e5cd2007 	strb	r2, [sp, #7]
 5116560:	e6bf5075 	sxth	r5, r5
 5116564:	e12fff33 	blx	r3
        for (short i = shell->parser.cursor - 1; i < shell->parser.length; i++)
 5116568:	e1d430bc 	ldrh	r3, [r4, #12]
 511656c:	e1550003 	cmp	r5, r3
 5116570:	bafffff3 	blt	5116544 <shellInsertByte+0xb8>
        for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 5116574:	e1d420be 	ldrh	r2, [r4, #14]
 5116578:	e0433002 	sub	r3, r3, r2
 511657c:	e6bf5073 	sxth	r5, r3
 5116580:	e3550000 	cmp	r5, #0
 5116584:	da00000b 	ble	51165b8 <shellInsertByte+0x12c>
 5116588:	e3a07008 	mov	r7, #8
 511658c:	e28d6007 	add	r6, sp, #7
    shell->write(&data, 1);
 5116590:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 5116594:	e3a01001 	mov	r1, #1
 5116598:	e5cd7007 	strb	r7, [sp, #7]
 511659c:	e1a00006 	mov	r0, r6
 51165a0:	e12fff33 	blx	r3
        for (short i = shell->parser.length - shell->parser.cursor; i > 0; i--)
 51165a4:	e2453001 	sub	r3, r5, #1
 51165a8:	e6ff2073 	uxth	r2, r3
 51165ac:	e3520000 	cmp	r2, #0
 51165b0:	e6bf5073 	sxth	r5, r3
 51165b4:	1afffff5 	bne	5116590 <shellInsertByte+0x104>
}
 51165b8:	e28dd00c 	add	sp, sp, #12
 51165bc:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        shell->parser.buffer[shell->parser.length++] = data;
 51165c0:	e5902010 	ldr	r2, [r0, #16]
 51165c4:	e2831001 	add	r1, r3, #1
 51165c8:	e1c010bc 	strh	r1, [r0, #12]
        shell->parser.buffer[shell->parser.length] = 0;
 51165cc:	e3a01000 	mov	r1, #0
        shell->parser.buffer[shell->parser.length++] = data;
 51165d0:	e7c25003 	strb	r5, [r2, r3]
        shell->parser.buffer[shell->parser.length] = 0;
 51165d4:	e1d030bc 	ldrh	r3, [r0, #12]
 51165d8:	e5902010 	ldr	r2, [r0, #16]
 51165dc:	e7c21003 	strb	r1, [r2, r3]
        shell->parser.cursor++;
 51165e0:	e1d030be 	ldrh	r3, [r0, #14]
    shell->write(&data, 1);
 51165e4:	e5902068 	ldr	r2, [r0, #104]	; 0x68
        shell->parser.cursor++;
 51165e8:	e2833001 	add	r3, r3, #1
 51165ec:	e5cd5007 	strb	r5, [sp, #7]
    shell->write(&data, 1);
 51165f0:	e3a01001 	mov	r1, #1
        shell->parser.cursor++;
 51165f4:	e1c030be 	strh	r3, [r0, #14]
    shell->write(&data, 1);
 51165f8:	e28d0007 	add	r0, sp, #7
 51165fc:	e12fff32 	blx	r2
}
 5116600:	e28dd00c 	add	sp, sp, #12
 5116604:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    SHELL_ASSERT(shell->write, return 0);
 5116608:	e5902068 	ldr	r2, [r0, #104]	; 0x68
 511660c:	e3520000 	cmp	r2, #0
 5116610:	0a000034 	beq	51166e8 <shellInsertByte+0x25c>
 5116614:	e59f30dc 	ldr	r3, [pc, #220]	; 51166f8 <shellInsertByte+0x26c>
 5116618:	e3a0500a 	mov	r5, #10
    unsigned short count = 0;
 511661c:	e3a01000 	mov	r1, #0
 5116620:	ea000000 	b	5116628 <shellInsertByte+0x19c>
    while(*p++)
 5116624:	e1f350d1 	ldrsb	r5, [r3, #1]!
        count ++;
 5116628:	e2811001 	add	r1, r1, #1
    while(*p++)
 511662c:	e3550000 	cmp	r5, #0
        count ++;
 5116630:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116634:	1afffffa 	bne	5116624 <shellInsertByte+0x198>
    return shell->write((char *)string, count);
 5116638:	e30d087c 	movw	r0, #55420	; 0xd87c
 511663c:	e3400512 	movt	r0, #1298	; 0x512
 5116640:	e12fff32 	blx	r2
    if (shell->status.isChecked)
 5116644:	e5d43060 	ldrb	r3, [r4, #96]	; 0x60
 5116648:	e3130001 	tst	r3, #1
 511664c:	0a000015 	beq	51166a8 <shellInsertByte+0x21c>
 5116650:	e30530ac 	movw	r3, #20652	; 0x50ac
 5116654:	e3a01001 	mov	r1, #1
 5116658:	e1a00004 	mov	r0, r4
 511665c:	e3403511 	movt	r3, #1297	; 0x511
 5116660:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 5116664:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shellWriteString(shell, shell->parser.buffer);
 5116668:	e5940010 	ldr	r0, [r4, #16]
    SHELL_ASSERT(shell->write, return 0);
 511666c:	e3550000 	cmp	r5, #0
 5116670:	0affffd0 	beq	51165b8 <shellInsertByte+0x12c>
    while(*p++)
 5116674:	e1a03000 	mov	r3, r0
 5116678:	e0d310d1 	ldrsb	r1, [r3], #1
 511667c:	e3510000 	cmp	r1, #0
 5116680:	0a000005 	beq	511669c <shellInsertByte+0x210>
 5116684:	e263c001 	rsb	ip, r3, #1
        count ++;
 5116688:	e083100c 	add	r1, r3, ip
    while(*p++)
 511668c:	e0d320d1 	ldrsb	r2, [r3], #1
 5116690:	e3520000 	cmp	r2, #0
 5116694:	e6ff1071 	uxth	r1, r1
 5116698:	1afffffa 	bne	5116688 <shellInsertByte+0x1fc>
    return shell->write((char *)string, count);
 511669c:	e12fff35 	blx	r5
}
 51166a0:	e28dd00c 	add	sp, sp, #12
 51166a4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    SHELL_ASSERT(shell->write, return 0);
 51166a8:	e5946068 	ldr	r6, [r4, #104]	; 0x68
 51166ac:	e3560000 	cmp	r6, #0
 51166b0:	0affffc0 	beq	51165b8 <shellInsertByte+0x12c>
 51166b4:	e59f2040 	ldr	r2, [pc, #64]	; 51166fc <shellInsertByte+0x270>
 51166b8:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 51166bc:	e1a01005 	mov	r1, r5
 51166c0:	ea000000 	b	51166c8 <shellInsertByte+0x23c>
    while(*p++)
 51166c4:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51166c8:	e2811001 	add	r1, r1, #1
    while(*p++)
 51166cc:	e3530000 	cmp	r3, #0
        count ++;
 51166d0:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51166d4:	1afffffa 	bne	51166c4 <shellInsertByte+0x238>
    return shell->write((char *)string, count);
 51166d8:	e30d0858 	movw	r0, #55384	; 0xd858
 51166dc:	e3400512 	movt	r0, #1298	; 0x512
 51166e0:	e12fff36 	blx	r6
 51166e4:	eaffffde 	b	5116664 <shellInsertByte+0x1d8>
    if (shell->status.isChecked)
 51166e8:	e5d03060 	ldrb	r3, [r0, #96]	; 0x60
 51166ec:	e3130001 	tst	r3, #1
 51166f0:	1affffd6 	bne	5116650 <shellInsertByte+0x1c4>
 51166f4:	eaffffaf 	b	51165b8 <shellInsertByte+0x12c>
 51166f8:	0512d87d 	.word	0x0512d87d
 51166fc:	0512d859 	.word	0x0512d859

05116700 <shellHandler.part.0>:
void shellHandler(Shell *shell, char data)
 5116700:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
 5116704:	e1a06000 	mov	r6, r0
 5116708:	e1a07001 	mov	r7, r1
    SHELL_LOCK(shell);
 511670c:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
 5116710:	e12fff33 	blx	r3
    if ((shell->parser.keyValue & 0x0000FF00) != 0x00000000)
 5116714:	e5963038 	ldr	r3, [r6, #56]	; 0x38
 5116718:	e3130cff 	tst	r3, #65280	; 0xff00
 511671c:	1a000047 	bne	5116840 <shellHandler.part.0+0x140>
    else if ((shell->parser.keyValue & 0x00FF0000) != 0x00000000)
 5116720:	e21308ff 	ands	r0, r3, #16711680	; 0xff0000
 5116724:	1a000041 	bne	5116830 <shellHandler.part.0+0x130>
    else if ((shell->parser.keyValue & 0xFF000000) != 0x00000000)
 5116728:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
        keyFilter = 0xFF000000;
 511672c:	e3530000 	cmp	r3, #0
 5116730:	13a004ff 	movne	r0, #-16777216	; 0xff000000
 5116734:	03a08018 	moveq	r8, #24
 5116738:	13a08010 	movne	r8, #16
    for (short i = 0; i < shell->commandList.count; i++)
 511673c:	e1d655bc 	ldrh	r5, [r6, #92]	; 0x5c
    ShellCommand *base = (ShellCommand *)shell->commandList.base;
 5116740:	e5964058 	ldr	r4, [r6, #88]	; 0x58
    for (short i = 0; i < shell->commandList.count; i++)
 5116744:	e3550000 	cmp	r5, #0
 5116748:	0a00002d 	beq	5116804 <shellHandler.part.0+0x104>
                && (base[i].data.key.value & (0xFF << keyByteOffset))
 511674c:	e3a010ff 	mov	r1, #255	; 0xff
                    || (base[i].data.key.value & (0xFF << (keyByteOffset - 8)))
 5116750:	e2489008 	sub	r9, r8, #8
    for (short i = 0; i < shell->commandList.count; i++)
 5116754:	e3a03000 	mov	r3, #0
                    || (base[i].data.key.value & (0xFF << (keyByteOffset - 8)))
 5116758:	e1a09911 	lsl	r9, r1, r9
                && (base[i].data.key.value & (0xFF << keyByteOffset))
 511675c:	e1a01811 	lsl	r1, r1, r8
 5116760:	ea000003 	b	5116774 <shellHandler.part.0+0x74>
    for (short i = 0; i < shell->commandList.count; i++)
 5116764:	e2833001 	add	r3, r3, #1
 5116768:	e6bf3073 	sxth	r3, r3
 511676c:	e1530005 	cmp	r3, r5
 5116770:	aa000023 	bge	5116804 <shellHandler.part.0+0x104>
        if (base[i].attr.attrs.type == SHELL_TYPE_KEY
 5116774:	e084c203 	add	ip, r4, r3, lsl #4
 5116778:	e5dc2001 	ldrb	r2, [ip, #1]
 511677c:	e202e00f 	and	lr, r2, #15
 5116780:	e35e0009 	cmp	lr, #9
 5116784:	1afffff6 	bne	5116764 <shellHandler.part.0+0x64>
    return ((!command->attr.attrs.permission
 5116788:	e7d4e203 	ldrb	lr, [r4, r3, lsl #4]
            ? 0 : -1;
 511678c:	e35e0000 	cmp	lr, #0
                || command->attr.attrs.enableUnchecked))
 5116790:	e2022010 	and	r2, r2, #16
            ? 0 : -1;
 5116794:	0a000003 	beq	51167a8 <shellHandler.part.0+0xa8>
                    & shell->info.user->attr.attrs.permission))
 5116798:	e596a000 	ldr	sl, [r6]
                || (command->attr.attrs.permission 
 511679c:	e5daa000 	ldrb	sl, [sl]
 51167a0:	e11e000a 	tst	lr, sl
 51167a4:	0affffee 	beq	5116764 <shellHandler.part.0+0x64>
            && (shell->status.isChecked
 51167a8:	e5d6e060 	ldrb	lr, [r6, #96]	; 0x60
 51167ac:	e20ee001 	and	lr, lr, #1
                || command->attr.attrs.enableUnchecked))
 51167b0:	e19e2002 	orrs	r2, lr, r2
 51167b4:	0affffea 	beq	5116764 <shellHandler.part.0+0x64>
            if ((base[i].data.key.value & keyFilter) == shell->parser.keyValue
 51167b8:	e59c2004 	ldr	r2, [ip, #4]
 51167bc:	e596a038 	ldr	sl, [r6, #56]	; 0x38
 51167c0:	e002e000 	and	lr, r2, r0
 51167c4:	e15e000a 	cmp	lr, sl
 51167c8:	1affffe5 	bne	5116764 <shellHandler.part.0+0x64>
                && (base[i].data.key.value & (0xFF << keyByteOffset))
 51167cc:	e002a001 	and	sl, r2, r1
 51167d0:	e15a0817 	cmp	sl, r7, lsl r8
 51167d4:	1affffe2 	bne	5116764 <shellHandler.part.0+0x64>
                shell->parser.keyValue |= data << keyByteOffset;
 51167d8:	e18ee00a 	orr	lr, lr, sl
                if (keyByteOffset == 0 
 51167dc:	e3580000 	cmp	r8, #0
                shell->parser.keyValue |= data << keyByteOffset;
 51167e0:	e586e038 	str	lr, [r6, #56]	; 0x38
                if (keyByteOffset == 0 
 51167e4:	0a000026 	beq	5116884 <shellHandler.part.0+0x184>
                    || (base[i].data.key.value & (0xFF << (keyByteOffset - 8)))
 51167e8:	e1120009 	tst	r2, r9
 51167ec:	0a000024 	beq	5116884 <shellHandler.part.0+0x184>
                data = 0x00;
 51167f0:	e3a07000 	mov	r7, #0
    for (short i = 0; i < shell->commandList.count; i++)
 51167f4:	e2833001 	add	r3, r3, #1
 51167f8:	e6bf3073 	sxth	r3, r3
 51167fc:	e1530005 	cmp	r3, r5
 5116800:	baffffdb 	blt	5116774 <shellHandler.part.0+0x74>
    if (data != 0x00)
 5116804:	e3570000 	cmp	r7, #0
 5116808:	1a000012 	bne	5116858 <shellHandler.part.0+0x158>
    if (SHELL_GET_TICK())
 511680c:	e3014ca4 	movw	r4, #7332	; 0x1ca4
 5116810:	e3404511 	movt	r4, #1297	; 0x511
 5116814:	e12fff34 	blx	r4
 5116818:	e3500000 	cmp	r0, #0
 511681c:	1a00000a 	bne	511684c <shellHandler.part.0+0x14c>
    SHELL_UNLOCK(shell);
 5116820:	e5963070 	ldr	r3, [r6, #112]	; 0x70
 5116824:	e1a00006 	mov	r0, r6
 5116828:	e12fff33 	blx	r3
}
 511682c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        keyFilter = 0xFFFF0000;
 5116830:	e3a00000 	mov	r0, #0
        keyByteOffset = 8;
 5116834:	e3a08008 	mov	r8, #8
        keyFilter = 0xFFFF0000;
 5116838:	e34f0fff 	movt	r0, #65535	; 0xffff
 511683c:	eaffffbe 	b	511673c <shellHandler.part.0+0x3c>
        keyByteOffset = 0;
 5116840:	e3a08000 	mov	r8, #0
        keyFilter = 0xFFFFFF00;
 5116844:	e3e000ff 	mvn	r0, #255	; 0xff
 5116848:	eaffffbb 	b	511673c <shellHandler.part.0+0x3c>
        shell->info.activeTime = SHELL_GET_TICK();
 511684c:	e12fff34 	blx	r4
 5116850:	e5860004 	str	r0, [r6, #4]
 5116854:	eafffff1 	b	5116820 <shellHandler.part.0+0x120>
        shell->parser.keyValue = 0x00000000;
 5116858:	e3a0c000 	mov	ip, #0
    shell->status.tabFlag = 0;
 511685c:	e5d62060 	ldrb	r2, [r6, #96]	; 0x60
    shellInsertByte(shell, data);
 5116860:	e306348c 	movw	r3, #25740	; 0x648c
    shell->status.tabFlag = 0;
 5116864:	e7c2211c 	bfi	r2, ip, #2, #1
    shellInsertByte(shell, data);
 5116868:	e1a01007 	mov	r1, r7
 511686c:	e1a00006 	mov	r0, r6
        shell->parser.keyValue = 0x00000000;
 5116870:	e586c038 	str	ip, [r6, #56]	; 0x38
    shellInsertByte(shell, data);
 5116874:	e3403511 	movt	r3, #1297	; 0x511
    shell->status.tabFlag = 0;
 5116878:	e5c62060 	strb	r2, [r6, #96]	; 0x60
    shellInsertByte(shell, data);
 511687c:	e12fff33 	blx	r3
}
 5116880:	eaffffe1 	b	511680c <shellHandler.part.0+0x10c>
                    if (base[i].data.key.function)
 5116884:	e59c3008 	ldr	r3, [ip, #8]
 5116888:	e3530000 	cmp	r3, #0
 511688c:	0a000001 	beq	5116898 <shellHandler.part.0+0x198>
                        base[i].data.key.function(shell);
 5116890:	e1a00006 	mov	r0, r6
 5116894:	e12fff33 	blx	r3
                    shell->parser.keyValue = 0x00000000;
 5116898:	e3a03000 	mov	r3, #0
 511689c:	e5863038 	str	r3, [r6, #56]	; 0x38
    if (data != 0x00)
 51168a0:	eaffffd9 	b	511680c <shellHandler.part.0+0x10c>

051168a4 <shellDeleteByte>:
{
 51168a4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    if ((shell->parser.cursor == 0 && direction == 1)
 51168a8:	e1d0e0be 	ldrh	lr, [r0, #14]
 51168ac:	e3510001 	cmp	r1, #1
 51168b0:	035e0000 	cmpeq	lr, #0
 51168b4:	03a02001 	moveq	r2, #1
{
 51168b8:	e24dd00c 	sub	sp, sp, #12
    if ((shell->parser.cursor == 0 && direction == 1)
 51168bc:	13a02000 	movne	r2, #0
 51168c0:	0a000054 	beq	5116a18 <shellDeleteByte+0x174>
 51168c4:	e1a04000 	mov	r4, r0
        || (shell->parser.cursor == shell->parser.length && direction == -1))
 51168c8:	e1d000bc 	ldrh	r0, [r0, #12]
 51168cc:	e15e0000 	cmp	lr, r0
 51168d0:	0a000052 	beq	5116a20 <shellDeleteByte+0x17c>
    char offset = (direction == -1) ? 1 : 0;
 51168d4:	e3710001 	cmn	r1, #1
 51168d8:	13a03000 	movne	r3, #0
 51168dc:	03a03001 	moveq	r3, #1
        for (short i = offset; i < shell->parser.length - shell->parser.cursor; i++)
 51168e0:	e1a0c003 	mov	ip, r3
 51168e4:	e040200e 	sub	r2, r0, lr
 51168e8:	e1520003 	cmp	r2, r3
 51168ec:	e1a0200e 	mov	r2, lr
 51168f0:	e6bf3073 	sxth	r3, r3
 51168f4:	da00000c 	ble	511692c <shellDeleteByte+0x88>
                shell->parser.buffer[shell->parser.cursor + i];
 51168f8:	e5940010 	ldr	r0, [r4, #16]
 51168fc:	e2833001 	add	r3, r3, #1
 5116900:	e08c2002 	add	r2, ip, r2
 5116904:	e1b020d2 	ldrsb	r2, [r0, r2]!	; <UNPREDICTABLE>
            shell->parser.buffer[shell->parser.cursor + i - 1] = 
 5116908:	e5402001 	strb	r2, [r0, #-1]
        for (short i = offset; i < shell->parser.length - shell->parser.cursor; i++)
 511690c:	e6bf3073 	sxth	r3, r3
 5116910:	e1d420be 	ldrh	r2, [r4, #14]
 5116914:	e1d400bc 	ldrh	r0, [r4, #12]
 5116918:	e1a0c003 	mov	ip, r3
 511691c:	e040e002 	sub	lr, r0, r2
 5116920:	e153000e 	cmp	r3, lr
 5116924:	e1a0e002 	mov	lr, r2
 5116928:	bafffff2 	blt	51168f8 <shellDeleteByte+0x54>
        shell->parser.length--;
 511692c:	e2400001 	sub	r0, r0, #1
        if (!offset)
 5116930:	e3710001 	cmn	r1, #1
        shell->parser.length--;
 5116934:	e6ff0070 	uxth	r0, r0
 5116938:	028d6007 	addeq	r6, sp, #7
 511693c:	e1c400bc 	strh	r0, [r4, #12]
        if (!offset)
 5116940:	0a000009 	beq	511696c <shellDeleteByte+0xc8>
 5116944:	e24ee001 	sub	lr, lr, #1
            shell->parser.cursor--;
 5116948:	e3a02008 	mov	r2, #8
    shell->write(&data, 1);
 511694c:	e28d6007 	add	r6, sp, #7
 5116950:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 5116954:	e3a01001 	mov	r1, #1
            shell->parser.cursor--;
 5116958:	e1c4e0be 	strh	lr, [r4, #14]
    shell->write(&data, 1);
 511695c:	e1a00006 	mov	r0, r6
 5116960:	e5cd2007 	strb	r2, [sp, #7]
 5116964:	e12fff33 	blx	r3
        shell->parser.buffer[shell->parser.length] = 0;
 5116968:	e1d400bc 	ldrh	r0, [r4, #12]
 511696c:	e5943010 	ldr	r3, [r4, #16]
 5116970:	e3a02000 	mov	r2, #0
 5116974:	e7c32000 	strb	r2, [r3, r0]
        for (short i = shell->parser.cursor; i < shell->parser.length; i++)
 5116978:	e1d450fe 	ldrsh	r5, [r4, #14]
 511697c:	e1d430bc 	ldrh	r3, [r4, #12]
 5116980:	e1550003 	cmp	r5, r3
 5116984:	aa00000b 	bge	51169b8 <shellDeleteByte+0x114>
            shellWriteByte(shell, shell->parser.buffer[i]);
 5116988:	e5942010 	ldr	r2, [r4, #16]
 511698c:	e19220d5 	ldrsb	r2, [r2, r5]
    shell->write(&data, 1);
 5116990:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 5116994:	e2855001 	add	r5, r5, #1
 5116998:	e3a01001 	mov	r1, #1
 511699c:	e1a00006 	mov	r0, r6
 51169a0:	e5cd2007 	strb	r2, [sp, #7]
 51169a4:	e6bf5075 	sxth	r5, r5
 51169a8:	e12fff33 	blx	r3
        for (short i = shell->parser.cursor; i < shell->parser.length; i++)
 51169ac:	e1d430bc 	ldrh	r3, [r4, #12]
 51169b0:	e1550003 	cmp	r5, r3
 51169b4:	bafffff3 	blt	5116988 <shellDeleteByte+0xe4>
        shellWriteByte(shell, ' ');
 51169b8:	e3a02020 	mov	r2, #32
    shell->write(&data, 1);
 51169bc:	e3a01001 	mov	r1, #1
 51169c0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 51169c4:	e1a00006 	mov	r0, r6
 51169c8:	e5cd2007 	strb	r2, [sp, #7]
 51169cc:	e12fff33 	blx	r3
        for (short i = shell->parser.length - shell->parser.cursor + 1; i > 0; i--)
 51169d0:	e1d430bc 	ldrh	r3, [r4, #12]
 51169d4:	e2833001 	add	r3, r3, #1
 51169d8:	e1d450be 	ldrh	r5, [r4, #14]
 51169dc:	e0433005 	sub	r3, r3, r5
 51169e0:	e6bf5073 	sxth	r5, r3
 51169e4:	e3550000 	cmp	r5, #0
 51169e8:	da00000a 	ble	5116a18 <shellDeleteByte+0x174>
 51169ec:	e3a07008 	mov	r7, #8
    shell->write(&data, 1);
 51169f0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
 51169f4:	e3a01001 	mov	r1, #1
 51169f8:	e5cd7007 	strb	r7, [sp, #7]
 51169fc:	e1a00006 	mov	r0, r6
 5116a00:	e12fff33 	blx	r3
        for (short i = shell->parser.length - shell->parser.cursor + 1; i > 0; i--)
 5116a04:	e2453001 	sub	r3, r5, #1
 5116a08:	e6ff2073 	uxth	r2, r3
 5116a0c:	e3520000 	cmp	r2, #0
 5116a10:	e6bf5073 	sxth	r5, r3
 5116a14:	1afffff5 	bne	51169f0 <shellDeleteByte+0x14c>
}
 5116a18:	e28dd00c 	add	sp, sp, #12
 5116a1c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        || (shell->parser.cursor == shell->parser.length && direction == -1))
 5116a20:	e3710001 	cmn	r1, #1
 5116a24:	0afffffb 	beq	5116a18 <shellDeleteByte+0x174>
    if (shell->parser.cursor == shell->parser.length && direction == 1)
 5116a28:	e3510001 	cmp	r1, #1
 5116a2c:	0a00000a 	beq	5116a5c <shellDeleteByte+0x1b8>
    char offset = (direction == -1) ? 1 : 0;
 5116a30:	e3710001 	cmn	r1, #1
 5116a34:	13a03000 	movne	r3, #0
 5116a38:	03a03001 	moveq	r3, #1
        for (short i = offset; i < shell->parser.length - shell->parser.cursor; i++)
 5116a3c:	e1a0c003 	mov	ip, r3
 5116a40:	e1520003 	cmp	r2, r3
 5116a44:	e1a0200e 	mov	r2, lr
 5116a48:	e6bf3073 	sxth	r3, r3
 5116a4c:	caffffa9 	bgt	51168f8 <shellDeleteByte+0x54>
        shell->parser.length--;
 5116a50:	e24ee001 	sub	lr, lr, #1
 5116a54:	e1c4e0bc 	strh	lr, [r4, #12]
        if (!offset)
 5116a58:	eaffffba 	b	5116948 <shellDeleteByte+0xa4>
        shell->parser.buffer[shell->parser.length] = 0;
 5116a5c:	e5941010 	ldr	r1, [r4, #16]
        shell->parser.cursor--;
 5116a60:	e24ee001 	sub	lr, lr, #1
 5116a64:	e1c4e0be 	strh	lr, [r4, #14]
        shell->parser.length--;
 5116a68:	e6ff307e 	uxth	r3, lr
 5116a6c:	e1c430bc 	strh	r3, [r4, #12]
        shell->parser.buffer[shell->parser.length] = 0;
 5116a70:	e7c12003 	strb	r2, [r1, r3]
    SHELL_ASSERT(shell->write, return 0);
 5116a74:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5116a78:	e3540000 	cmp	r4, #0
 5116a7c:	0affffe5 	beq	5116a18 <shellDeleteByte+0x174>
 5116a80:	e59f0030 	ldr	r0, [pc, #48]	; 5116ab8 <shellDeleteByte+0x214>
 5116a84:	e3a03020 	mov	r3, #32
    unsigned short count = 0;
 5116a88:	e1a01002 	mov	r1, r2
 5116a8c:	ea000000 	b	5116a94 <shellDeleteByte+0x1f0>
    while(*p++)
 5116a90:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 5116a94:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116a98:	e3530000 	cmp	r3, #0
        count ++;
 5116a9c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116aa0:	1afffffa 	bne	5116a90 <shellDeleteByte+0x1ec>
    return shell->write((char *)string, count);
 5116aa4:	e30d0854 	movw	r0, #55380	; 0xd854
 5116aa8:	e3400512 	movt	r0, #1298	; 0x512
 5116aac:	e12fff34 	blx	r4
}
 5116ab0:	e28dd00c 	add	sp, sp, #12
 5116ab4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
 5116ab8:	0512d855 	.word	0x0512d855

05116abc <shellBackspace>:
    shellDeleteByte(shell, 1);
 5116abc:	e30638a4 	movw	r3, #26788	; 0x68a4
 5116ac0:	e3a01001 	mov	r1, #1
 5116ac4:	e3403511 	movt	r3, #1297	; 0x511
{
 5116ac8:	e92d4010 	push	{r4, lr}
    shellDeleteByte(shell, 1);
 5116acc:	e12fff33 	blx	r3
}
 5116ad0:	e8bd8010 	pop	{r4, pc}

05116ad4 <shellDelete>:
    shellDeleteByte(shell, -1);
 5116ad4:	e30638a4 	movw	r3, #26788	; 0x68a4
 5116ad8:	e3e01000 	mvn	r1, #0
 5116adc:	e3403511 	movt	r3, #1297	; 0x511
{
 5116ae0:	e92d4010 	push	{r4, lr}
    shellDeleteByte(shell, -1);
 5116ae4:	e12fff33 	blx	r3
}
 5116ae8:	e8bd8010 	pop	{r4, pc}

05116aec <shellSeekCommand>:
{
 5116aec:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5116af0:	e1a0b003 	mov	fp, r3
 5116af4:	e1a09001 	mov	r9, r1
        ((int)base - (int)shell->commandList.base) / sizeof(ShellCommand);
 5116af8:	e5903058 	ldr	r3, [r0, #88]	; 0x58
{
 5116afc:	e24dd00c 	sub	sp, sp, #12
        ((int)base - (int)shell->commandList.base) / sizeof(ShellCommand);
 5116b00:	e0421003 	sub	r1, r2, r3
    unsigned short count = shell->commandList.count -
 5116b04:	e1d035bc 	ldrh	r3, [r0, #92]	; 0x5c
 5116b08:	e0433221 	sub	r3, r3, r1, lsr #4
 5116b0c:	e6ff3073 	uxth	r3, r3
    for (unsigned short i = 0; i < count; i++)
 5116b10:	e3530000 	cmp	r3, #0
 5116b14:	0a000043 	beq	5116c28 <shellSeekCommand+0x13c>
 5116b18:	e2433001 	sub	r3, r3, #1
        buffer[i] = '0';
 5116b1c:	e30851cc 	movw	r5, #33228	; 0x81cc
 5116b20:	e2828010 	add	r8, r2, #16
 5116b24:	e3036030 	movw	r6, #12336	; 0x3030
 5116b28:	e6ff3073 	uxth	r3, r3
 5116b2c:	e1a07000 	mov	r7, r0
 5116b30:	e1a04002 	mov	r4, r2
 5116b34:	e0888203 	add	r8, r8, r3, lsl #4
            if (strncmp(cmd, name, compareLength) == 0)
 5116b38:	e30a3709 	movw	r3, #42761	; 0xa709
        buffer[i] = '0';
 5116b3c:	e3405513 	movt	r5, #1299	; 0x513
            if (strncmp(cmd, name, compareLength) == 0)
 5116b40:	e3403511 	movt	r3, #1297	; 0x511
        buffer[i] = '0';
 5116b44:	e3436030 	movt	r6, #12336	; 0x3030
            if (strncmp(cmd, name, compareLength) == 0)
 5116b48:	e58d3000 	str	r3, [sp]
            if (strcmp(cmd, name) == 0)
 5116b4c:	e300331d 	movw	r3, #797	; 0x31d
 5116b50:	e3403511 	movt	r3, #1297	; 0x511
 5116b54:	e58d3004 	str	r3, [sp, #4]
        if (base[i].attr.attrs.type == SHELL_TYPE_KEY
 5116b58:	e5d41001 	ldrb	r1, [r4, #1]
 5116b5c:	e1a0a004 	mov	sl, r4
 5116b60:	e201000f 	and	r0, r1, #15
 5116b64:	e3500009 	cmp	r0, #9
 5116b68:	0a00002b 	beq	5116c1c <shellSeekCommand+0x130>
    return ((!command->attr.attrs.permission
 5116b6c:	e5d4c000 	ldrb	ip, [r4]
                || command->attr.attrs.type == SHELL_TYPE_USER
 5116b70:	e35c0000 	cmp	ip, #0
 5116b74:	13500008 	cmpne	r0, #8
 5116b78:	1a00003a 	bne	5116c68 <shellSeekCommand+0x17c>
                || command->attr.attrs.enableUnchecked))
 5116b7c:	e2011010 	and	r1, r1, #16
            && (shell->status.isChecked
 5116b80:	e5d70060 	ldrb	r0, [r7, #96]	; 0x60
 5116b84:	e2000001 	and	r0, r0, #1
                || command->attr.attrs.enableUnchecked))
 5116b88:	e1903001 	orrs	r3, r0, r1
 5116b8c:	0a000022 	beq	5116c1c <shellSeekCommand+0x130>
        buffer[i] = '0';
 5116b90:	e5856000 	str	r6, [r5]
 5116b94:	e5856004 	str	r6, [r5, #4]
 5116b98:	e5c56008 	strb	r6, [r5, #8]
    if (command->attr.attrs.type <= SHELL_TYPE_CMD_FUNC)
 5116b9c:	e5d41001 	ldrb	r1, [r4, #1]
 5116ba0:	e201100f 	and	r1, r1, #15
 5116ba4:	e3510001 	cmp	r1, #1
 5116ba8:	9a000022 	bls	5116c38 <shellSeekCommand+0x14c>
    else if (command->attr.attrs.type <= SHELL_TYPE_VAR_NODE)
 5116bac:	e3510007 	cmp	r1, #7
 5116bb0:	9a000020 	bls	5116c38 <shellSeekCommand+0x14c>
    else if (command->attr.attrs.type <= SHELL_TYPE_USER)
 5116bb4:	e3510008 	cmp	r1, #8
 5116bb8:	0a00001e 	beq	5116c38 <shellSeekCommand+0x14c>
        shellToHex(command->data.key.value, buffer);
 5116bbc:	e594c004 	ldr	ip, [r4, #4]
    buffer[8] = 0;
 5116bc0:	e3a03000 	mov	r3, #0
 5116bc4:	e5c53008 	strb	r3, [r5, #8]
    while (value)
 5116bc8:	e35c0000 	cmp	ip, #0
 5116bcc:	0a00000a 	beq	5116bfc <shellSeekCommand+0x110>
    unsigned char i = 8;
 5116bd0:	e3a00008 	mov	r0, #8
        byte = value & 0x0000000F;
 5116bd4:	e20c300f 	and	r3, ip, #15
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 5116bd8:	e2832057 	add	r2, r3, #87	; 0x57
 5116bdc:	e2400001 	sub	r0, r0, #1
 5116be0:	e3530009 	cmp	r3, #9
 5116be4:	e6ef0070 	uxtb	r0, r0
 5116be8:	e2833030 	add	r3, r3, #48	; 0x30
 5116bec:	c6af3072 	sxtbgt	r3, r2
    while (value)
 5116bf0:	e1b0c22c 	lsrs	ip, ip, #4
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 5116bf4:	e7c53000 	strb	r3, [r5, r0]
    while (value)
 5116bf8:	1afffff5 	bne	5116bd4 <shellSeekCommand+0xe8>
    unsigned char i = 8;
 5116bfc:	e1a01005 	mov	r1, r5
        if (!compareLength)
 5116c00:	e35b0000 	cmp	fp, #0
 5116c04:	1a00000e 	bne	5116c44 <shellSeekCommand+0x158>
            if (strcmp(cmd, name) == 0)
 5116c08:	e59d3004 	ldr	r3, [sp, #4]
 5116c0c:	e1a00009 	mov	r0, r9
 5116c10:	e12fff33 	blx	r3
 5116c14:	e3500000 	cmp	r0, #0
 5116c18:	0a000003 	beq	5116c2c <shellSeekCommand+0x140>
    for (unsigned short i = 0; i < count; i++)
 5116c1c:	e2844010 	add	r4, r4, #16
 5116c20:	e1580004 	cmp	r8, r4
 5116c24:	1affffcb 	bne	5116b58 <shellSeekCommand+0x6c>
    return NULL;
 5116c28:	e3a0a000 	mov	sl, #0
}
 5116c2c:	e1a0000a 	mov	r0, sl
 5116c30:	e28dd00c 	add	sp, sp, #12
 5116c34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return command->data.user.name;
 5116c38:	e5941004 	ldr	r1, [r4, #4]
        if (!compareLength)
 5116c3c:	e35b0000 	cmp	fp, #0
 5116c40:	0afffff0 	beq	5116c08 <shellSeekCommand+0x11c>
            if (strncmp(cmd, name, compareLength) == 0)
 5116c44:	e59d3000 	ldr	r3, [sp]
 5116c48:	e1a0200b 	mov	r2, fp
 5116c4c:	e1a00009 	mov	r0, r9
 5116c50:	e12fff33 	blx	r3
 5116c54:	e3500000 	cmp	r0, #0
 5116c58:	1affffef 	bne	5116c1c <shellSeekCommand+0x130>
}
 5116c5c:	e1a0000a 	mov	r0, sl
 5116c60:	e28dd00c 	add	sp, sp, #12
 5116c64:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    & shell->info.user->attr.attrs.permission))
 5116c68:	e5970000 	ldr	r0, [r7]
                || (command->attr.attrs.permission 
 5116c6c:	e5d00000 	ldrb	r0, [r0]
 5116c70:	e11c0000 	tst	ip, r0
 5116c74:	1affffc0 	bne	5116b7c <shellSeekCommand+0x90>
 5116c78:	eaffffe7 	b	5116c1c <shellSeekCommand+0x130>

05116c7c <shellInit>:
{
 5116c7c:	e92d4070 	push	{r4, r5, r6, lr}
 5116c80:	e1a04000 	mov	r4, r0
    shell->status.isChecked = 1;
 5116c84:	e5d00060 	ldrb	r0, [r0, #96]	; 0x60
    shell->parser.length = 0;
 5116c88:	e3a03000 	mov	r3, #0
    shell->status.isChecked = 1;
 5116c8c:	e3800001 	orr	r0, r0, #1
    shell->parser.buffer = buffer;
 5116c90:	e5841010 	str	r1, [r4, #16]
    shell->status.isChecked = 1;
 5116c94:	e5c40060 	strb	r0, [r4, #96]	; 0x60
    shell->parser.bufferSize = size / (SHELL_HISTORY_MAX_NUMBER + 1);
 5116c98:	e30a0aab 	movw	r0, #43691	; 0xaaab
    shell->parser.length = 0;
 5116c9c:	e584300c 	str	r3, [r4, #12]
    shell->parser.bufferSize = size / (SHELL_HISTORY_MAX_NUMBER + 1);
 5116ca0:	e34a0aaa 	movt	r0, #43690	; 0xaaaa
    shell->info.user = NULL;
 5116ca4:	e5843000 	str	r3, [r4]
    shell->parser.bufferSize = size / (SHELL_HISTORY_MAX_NUMBER + 1);
 5116ca8:	e0820290 	umull	r0, r2, r0, r2
    shell->history.number = 0;
 5116cac:	e5843050 	str	r3, [r4, #80]	; 0x50
 5116cb0:	e2840050 	add	r0, r4, #80	; 0x50
    shell->history.offset = 0;
 5116cb4:	e1c435b4 	strh	r3, [r4, #84]	; 0x54
 5116cb8:	e284303c 	add	r3, r4, #60	; 0x3c
    shell->parser.bufferSize = size / (SHELL_HISTORY_MAX_NUMBER + 1);
 5116cbc:	e1a02122 	lsr	r2, r2, #2
 5116cc0:	e0811002 	add	r1, r1, r2
 5116cc4:	e1c423b4 	strh	r2, [r4, #52]	; 0x34
        shell->history.item[i] = buffer + shell->parser.bufferSize * (i + 1);
 5116cc8:	e4831004 	str	r1, [r3], #4
    for (short i = 0; i < SHELL_HISTORY_MAX_NUMBER; i++)
 5116ccc:	e1530000 	cmp	r3, r0
 5116cd0:	e0811002 	add	r1, r1, r2
 5116cd4:	1afffffb 	bne	5116cc8 <shellInit+0x4c>
        shell->commandList.base = (ShellCommand *)(&_shell_command_start);
 5116cd8:	e30e2174 	movw	r2, #57716	; 0xe174
                                - (unsigned int)(&_shell_command_start))
 5116cdc:	e30e3324 	movw	r3, #58148	; 0xe324
        shell->commandList.base = (ShellCommand *)(&_shell_command_start);
 5116ce0:	e3402512 	movt	r2, #1298	; 0x512
 5116ce4:	e30801d8 	movw	r0, #33240	; 0x81d8
                                - (unsigned int)(&_shell_command_start))
 5116ce8:	e3403512 	movt	r3, #1298	; 0x512
 5116cec:	e0433002 	sub	r3, r3, r2
        shell->commandList.base = (ShellCommand *)(&_shell_command_start);
 5116cf0:	e5842058 	str	r2, [r4, #88]	; 0x58
        shell->commandList.count = ((unsigned int)(&_shell_command_end)
 5116cf4:	e3400513 	movt	r0, #1299	; 0x513
 5116cf8:	e1a02000 	mov	r2, r0
                                / sizeof(ShellCommand);
 5116cfc:	e1a01223 	lsr	r1, r3, #4
        shell->commandList.count = ((unsigned int)(&_shell_command_end)
 5116d00:	e3a03000 	mov	r3, #0
 5116d04:	e1c415bc 	strh	r1, [r4, #92]	; 0x5c
        if (shellList[i] == NULL)
 5116d08:	e4921004 	ldr	r1, [r2], #4
 5116d0c:	e3510000 	cmp	r1, #0
 5116d10:	0a000028 	beq	5116db8 <shellInit+0x13c>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5116d14:	e2833001 	add	r3, r3, #1
 5116d18:	e3530005 	cmp	r3, #5
 5116d1c:	1afffff9 	bne	5116d08 <shellInit+0x8c>
    shellSetUser(shell, shellSeekCommand(shell,
 5116d20:	e30e2174 	movw	r2, #57716	; 0xe174
 5116d24:	e30d11b0 	movw	r1, #53680	; 0xd1b0
 5116d28:	e3065aec 	movw	r5, #27372	; 0x6aec
 5116d2c:	e3a03000 	mov	r3, #0
 5116d30:	e3402512 	movt	r2, #1298	; 0x512
 5116d34:	e3401512 	movt	r1, #1298	; 0x512
 5116d38:	e1a00004 	mov	r0, r4
 5116d3c:	e3405511 	movt	r5, #1297	; 0x511
 5116d40:	e12fff35 	blx	r5
 5116d44:	e3043fbc 	movw	r3, #20412	; 0x4fbc
 5116d48:	e3403511 	movt	r3, #1297	; 0x511
 5116d4c:	e1a01000 	mov	r1, r0
 5116d50:	e1a00004 	mov	r0, r4
 5116d54:	e12fff33 	blx	r3
    if (shell->status.isChecked)
 5116d58:	e5d41060 	ldrb	r1, [r4, #96]	; 0x60
 5116d5c:	e2111001 	ands	r1, r1, #1
 5116d60:	0a000005 	beq	5116d7c <shellInit+0x100>
 5116d64:	e30530ac 	movw	r3, #20652	; 0x50ac
 5116d68:	e3a01001 	mov	r1, #1
 5116d6c:	e1a00004 	mov	r0, r4
 5116d70:	e3403511 	movt	r3, #1297	; 0x511
 5116d74:	e12fff33 	blx	r3
 5116d78:	e8bd8070 	pop	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 5116d7c:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5116d80:	e3540000 	cmp	r4, #0
 5116d84:	08bd8070 	popeq	{r4, r5, r6, pc}
 5116d88:	e59f2030 	ldr	r2, [pc, #48]	; 5116dc0 <shellInit+0x144>
 5116d8c:	e3a0300a 	mov	r3, #10
 5116d90:	ea000000 	b	5116d98 <shellInit+0x11c>
    while(*p++)
 5116d94:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5116d98:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116d9c:	e3530000 	cmp	r3, #0
        count ++;
 5116da0:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116da4:	1afffffa 	bne	5116d94 <shellInit+0x118>
    return shell->write((char *)string, count);
 5116da8:	e30d0858 	movw	r0, #55384	; 0xd858
 5116dac:	e3400512 	movt	r0, #1298	; 0x512
 5116db0:	e12fff34 	blx	r4
}
 5116db4:	e8bd8070 	pop	{r4, r5, r6, pc}
            shellList[i] = shell;
 5116db8:	e7804103 	str	r4, [r0, r3, lsl #2]
            return;
 5116dbc:	eaffffd7 	b	5116d20 <shellInit+0xa4>
 5116dc0:	0512d859 	.word	0x0512d859

05116dc4 <shellHelp>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5116dc4:	e30831d8 	movw	r3, #33240	; 0x81d8
 5116dc8:	e3403513 	movt	r3, #1299	; 0x513
 5116dcc:	e283c014 	add	ip, r3, #20
{
 5116dd0:	e92d4070 	push	{r4, r5, r6, lr}
        if (shellList[i] && shellList[i]->status.isActive)
 5116dd4:	e4934004 	ldr	r4, [r3], #4
 5116dd8:	e3540000 	cmp	r4, #0
 5116ddc:	0a000002 	beq	5116dec <shellHelp+0x28>
 5116de0:	e5d42060 	ldrb	r2, [r4, #96]	; 0x60
 5116de4:	e3120002 	tst	r2, #2
 5116de8:	1a000002 	bne	5116df8 <shellHelp+0x34>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 5116dec:	e153000c 	cmp	r3, ip
 5116df0:	1afffff7 	bne	5116dd4 <shellHelp+0x10>
 5116df4:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (argc == 1)
 5116df8:	e3500001 	cmp	r0, #1
 5116dfc:	0a000068 	beq	5116fa4 <shellHelp+0x1e0>
    else if (argc > 1)
 5116e00:	d8bd8070 	pople	{r4, r5, r6, pc}
    ShellCommand *command = shellSeekCommand(shell,
 5116e04:	e3065aec 	movw	r5, #27372	; 0x6aec
 5116e08:	e3a03000 	mov	r3, #0
 5116e0c:	e5942058 	ldr	r2, [r4, #88]	; 0x58
 5116e10:	e3405511 	movt	r5, #1297	; 0x511
 5116e14:	e5911004 	ldr	r1, [r1, #4]
 5116e18:	e1a00004 	mov	r0, r4
 5116e1c:	e12fff35 	blx	r5
    if (command)
 5116e20:	e2505000 	subs	r5, r0, #0
 5116e24:	0a00004e 	beq	5116f64 <shellHelp+0x1a0>
    SHELL_ASSERT(shell->write, return 0);
 5116e28:	e5946068 	ldr	r6, [r4, #104]	; 0x68
 5116e2c:	e3560000 	cmp	r6, #0
 5116e30:	0a00000b 	beq	5116e64 <shellHelp+0xa0>
 5116e34:	e59f217c 	ldr	r2, [pc, #380]	; 5116fb8 <shellHelp+0x1f4>
 5116e38:	e3a0306f 	mov	r3, #111	; 0x6f
    unsigned short count = 0;
 5116e3c:	e3a01000 	mov	r1, #0
 5116e40:	ea000000 	b	5116e48 <shellHelp+0x84>
    while(*p++)
 5116e44:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5116e48:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116e4c:	e3530000 	cmp	r3, #0
        count ++;
 5116e50:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116e54:	1afffffa 	bne	5116e44 <shellHelp+0x80>
    return shell->write((char *)string, count);
 5116e58:	e30d08a0 	movw	r0, #55456	; 0xd8a0
 5116e5c:	e3400512 	movt	r0, #1298	; 0x512
 5116e60:	e12fff36 	blx	r6
        shellWriteString(shell, shellGetCommandName(command));
 5116e64:	e3043eb4 	movw	r3, #20148	; 0x4eb4
 5116e68:	e1a00005 	mov	r0, r5
 5116e6c:	e3403511 	movt	r3, #1297	; 0x511
 5116e70:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 5116e74:	e5942068 	ldr	r2, [r4, #104]	; 0x68
 5116e78:	e3520000 	cmp	r2, #0
 5116e7c:	0a00001a 	beq	5116eec <shellHelp+0x128>
    while(*p++)
 5116e80:	e1a03000 	mov	r3, r0
 5116e84:	e0d310d1 	ldrsb	r1, [r3], #1
 5116e88:	e3510000 	cmp	r1, #0
 5116e8c:	0a000005 	beq	5116ea8 <shellHelp+0xe4>
 5116e90:	e263e001 	rsb	lr, r3, #1
        count ++;
 5116e94:	e083100e 	add	r1, r3, lr
    while(*p++)
 5116e98:	e0d3c0d1 	ldrsb	ip, [r3], #1
 5116e9c:	e35c0000 	cmp	ip, #0
 5116ea0:	e6ff1071 	uxth	r1, r1
 5116ea4:	1afffffa 	bne	5116e94 <shellHelp+0xd0>
    return shell->write((char *)string, count);
 5116ea8:	e12fff32 	blx	r2
    SHELL_ASSERT(shell->write, return 0);
 5116eac:	e5942068 	ldr	r2, [r4, #104]	; 0x68
 5116eb0:	e3520000 	cmp	r2, #0
 5116eb4:	0a00000c 	beq	5116eec <shellHelp+0x128>
 5116eb8:	e59f00fc 	ldr	r0, [pc, #252]	; 5116fbc <shellHelp+0x1f8>
 5116ebc:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5116ec0:	e3a01000 	mov	r1, #0
 5116ec4:	ea000000 	b	5116ecc <shellHelp+0x108>
    while(*p++)
 5116ec8:	e1f030d1 	ldrsb	r3, [r0, #1]!
        count ++;
 5116ecc:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116ed0:	e3530000 	cmp	r3, #0
        count ++;
 5116ed4:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116ed8:	1afffffa 	bne	5116ec8 <shellHelp+0x104>
    return shell->write((char *)string, count);
 5116edc:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5116ee0:	e3400512 	movt	r0, #1298	; 0x512
 5116ee4:	e12fff32 	blx	r2
    SHELL_ASSERT(shell->write, return 0);
 5116ee8:	e5942068 	ldr	r2, [r4, #104]	; 0x68
        return command->data.cmd.desc;
 5116eec:	e595000c 	ldr	r0, [r5, #12]
    SHELL_ASSERT(shell->write, return 0);
 5116ef0:	e3520000 	cmp	r2, #0
 5116ef4:	08bd8070 	popeq	{r4, r5, r6, pc}
    while(*p++)
 5116ef8:	e1a03000 	mov	r3, r0
 5116efc:	e0d310d1 	ldrsb	r1, [r3], #1
 5116f00:	e3510000 	cmp	r1, #0
 5116f04:	0a000005 	beq	5116f20 <shellHelp+0x15c>
 5116f08:	e263e001 	rsb	lr, r3, #1
        count ++;
 5116f0c:	e083100e 	add	r1, r3, lr
    while(*p++)
 5116f10:	e0d3c0d1 	ldrsb	ip, [r3], #1
 5116f14:	e35c0000 	cmp	ip, #0
 5116f18:	e6ff1071 	uxth	r1, r1
 5116f1c:	1afffffa 	bne	5116f0c <shellHelp+0x148>
    return shell->write((char *)string, count);
 5116f20:	e12fff32 	blx	r2
    SHELL_ASSERT(shell->write, return 0);
 5116f24:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5116f28:	e3540000 	cmp	r4, #0
 5116f2c:	08bd8070 	popeq	{r4, r5, r6, pc}
 5116f30:	e59f2084 	ldr	r2, [pc, #132]	; 5116fbc <shellHelp+0x1f8>
 5116f34:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5116f38:	e3a01000 	mov	r1, #0
 5116f3c:	ea000000 	b	5116f44 <shellHelp+0x180>
    while(*p++)
 5116f40:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5116f44:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116f48:	e3530000 	cmp	r3, #0
        count ++;
 5116f4c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116f50:	1afffffa 	bne	5116f40 <shellHelp+0x17c>
    return shell->write((char *)string, count);
 5116f54:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5116f58:	e3400512 	movt	r0, #1298	; 0x512
 5116f5c:	e12fff34 	blx	r4
 5116f60:	e8bd8070 	pop	{r4, r5, r6, pc}
    SHELL_ASSERT(shell->write, return 0);
 5116f64:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5116f68:	e3540000 	cmp	r4, #0
 5116f6c:	08bd8070 	popeq	{r4, r5, r6, pc}
 5116f70:	e59f2048 	ldr	r2, [pc, #72]	; 5116fc0 <shellHelp+0x1fc>
 5116f74:	e3a0306f 	mov	r3, #111	; 0x6f
    unsigned short count = 0;
 5116f78:	e1a01005 	mov	r1, r5
 5116f7c:	ea000000 	b	5116f84 <shellHelp+0x1c0>
    while(*p++)
 5116f80:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5116f84:	e2811001 	add	r1, r1, #1
    while(*p++)
 5116f88:	e3530000 	cmp	r3, #0
        count ++;
 5116f8c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5116f90:	1afffffa 	bne	5116f80 <shellHelp+0x1bc>
    return shell->write((char *)string, count);
 5116f94:	e30d08b4 	movw	r0, #55476	; 0xd8b4
 5116f98:	e3400512 	movt	r0, #1298	; 0x512
 5116f9c:	e12fff34 	blx	r4
}
 5116fa0:	e8bd8070 	pop	{r4, r5, r6, pc}
    shellListCommand(shell);
 5116fa4:	e3053838 	movw	r3, #22584	; 0x5838
 5116fa8:	e1a00004 	mov	r0, r4
 5116fac:	e3403511 	movt	r3, #1297	; 0x511
 5116fb0:	e12fff33 	blx	r3
}
 5116fb4:	e8bd8070 	pop	{r4, r5, r6, pc}
 5116fb8:	0512d8a1 	.word	0x0512d8a1
 5116fbc:	0512d3e1 	.word	0x0512d3e1
 5116fc0:	0512d8b5 	.word	0x0512d8b5

05116fc4 <shellGetVarValue>:
    switch (command->attr.attrs.type)
 5116fc4:	e5d13001 	ldrb	r3, [r1, #1]
 5116fc8:	e203300f 	and	r3, r3, #15
 5116fcc:	e2433002 	sub	r3, r3, #2
 5116fd0:	e3530005 	cmp	r3, #5
 5116fd4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 5116fd8:	ea000018 	b	5117040 <shellGetVarValue+0x7c>
 5116fdc:	0511701c 	.word	0x0511701c
 5116fe0:	05117028 	.word	0x05117028
 5116fe4:	05117034 	.word	0x05117034
 5116fe8:	05116ff4 	.word	0x05116ff4
 5116fec:	05116ff4 	.word	0x05116ff4
 5116ff0:	05116ffc 	.word	0x05116ffc
        value = (int)(command->data.var.value);
 5116ff4:	e5910008 	ldr	r0, [r1, #8]
        break;
 5116ff8:	e12fff1e 	bx	lr
 5116ffc:	e5912008 	ldr	r2, [r1, #8]
        value = ((ShellNodeVarAttr *)command->data.var.value)->get ?
 5117000:	e5923004 	ldr	r3, [r2, #4]
                        ->get(((ShellNodeVarAttr *)command->data.var.value)->var) : 0;
 5117004:	e3530000 	cmp	r3, #0
 5117008:	0a00000c 	beq	5117040 <shellGetVarValue+0x7c>
                    ((ShellNodeVarAttr *)command->data.var.value)
 511700c:	e5920000 	ldr	r0, [r2]
{
 5117010:	e92d4010 	push	{r4, lr}
                    ((ShellNodeVarAttr *)command->data.var.value)
 5117014:	e12fff33 	blx	r3
}
 5117018:	e8bd8010 	pop	{r4, pc}
        value = *((int *)(command->data.var.value));
 511701c:	e5913008 	ldr	r3, [r1, #8]
 5117020:	e5930000 	ldr	r0, [r3]
        break;
 5117024:	e12fff1e 	bx	lr
        value = *((short *)(command->data.var.value));
 5117028:	e5913008 	ldr	r3, [r1, #8]
 511702c:	e1d300f0 	ldrsh	r0, [r3]
        break;
 5117030:	e12fff1e 	bx	lr
        value = *((char *)(command->data.var.value));
 5117034:	e5913008 	ldr	r3, [r1, #8]
 5117038:	e1d300d0 	ldrsb	r0, [r3]
        break;
 511703c:	e12fff1e 	bx	lr
    switch (command->attr.attrs.type)
 5117040:	e3a00000 	mov	r0, #0
 5117044:	e12fff1e 	bx	lr

05117048 <shellShowVar>:
    char buffer[12] = "00000000000";
 5117048:	e30d37d4 	movw	r3, #55252	; 0xd7d4
 511704c:	e3403512 	movt	r3, #1298	; 0x512
{
 5117050:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5117054:	e1a05000 	mov	r5, r0
 5117058:	e24dd010 	sub	sp, sp, #16
 511705c:	e1a07001 	mov	r7, r1
    char buffer[12] = "00000000000";
 5117060:	e28d6004 	add	r6, sp, #4
 5117064:	e8930007 	ldm	r3, {r0, r1, r2}
    int value = shellGetVarValue(shell, command);
 5117068:	e3064fc4 	movw	r4, #28612	; 0x6fc4
    char buffer[12] = "00000000000";
 511706c:	e8860007 	stm	r6, {r0, r1, r2}
    int value = shellGetVarValue(shell, command);
 5117070:	e1a01007 	mov	r1, r7
 5117074:	e3404511 	movt	r4, #1297	; 0x511
 5117078:	e1a00005 	mov	r0, r5
 511707c:	e12fff34 	blx	r4
    SHELL_ASSERT(shell->write, return 0);
 5117080:	e5952068 	ldr	r2, [r5, #104]	; 0x68
 5117084:	e3520000 	cmp	r2, #0
    int value = shellGetVarValue(shell, command);
 5117088:	e1a04000 	mov	r4, r0
    SHELL_ASSERT(shell->write, return 0);
 511708c:	0a00001b 	beq	5117100 <shellShowVar+0xb8>
    shellWriteString(shell, command->data.var.name);
 5117090:	e5970004 	ldr	r0, [r7, #4]
    while(*p++)
 5117094:	e1a03000 	mov	r3, r0
 5117098:	e0d310d1 	ldrsb	r1, [r3], #1
 511709c:	e3510000 	cmp	r1, #0
 51170a0:	0a000005 	beq	51170bc <shellShowVar+0x74>
 51170a4:	e263e001 	rsb	lr, r3, #1
        count ++;
 51170a8:	e083100e 	add	r1, r3, lr
    while(*p++)
 51170ac:	e0d3c0d1 	ldrsb	ip, [r3], #1
 51170b0:	e35c0000 	cmp	ip, #0
 51170b4:	e6ff1071 	uxth	r1, r1
 51170b8:	1afffffa 	bne	51170a8 <shellShowVar+0x60>
    return shell->write((char *)string, count);
 51170bc:	e12fff32 	blx	r2
    SHELL_ASSERT(shell->write, return 0);
 51170c0:	e5958068 	ldr	r8, [r5, #104]	; 0x68
 51170c4:	e3580000 	cmp	r8, #0
 51170c8:	0a00000c 	beq	5117100 <shellShowVar+0xb8>
 51170cc:	e59f1254 	ldr	r1, [pc, #596]	; 5117328 <shellShowVar+0x2e0>
 51170d0:	e3a0203d 	mov	r2, #61	; 0x3d
    unsigned short count = 0;
 51170d4:	e3a03000 	mov	r3, #0
 51170d8:	ea000000 	b	51170e0 <shellShowVar+0x98>
    while(*p++)
 51170dc:	e1f120d1 	ldrsb	r2, [r1, #1]!
        count ++;
 51170e0:	e2833001 	add	r3, r3, #1
    while(*p++)
 51170e4:	e3520000 	cmp	r2, #0
        count ++;
 51170e8:	e6ff3073 	uxth	r3, r3
    while(*p++)
 51170ec:	1afffffa 	bne	51170dc <shellShowVar+0x94>
    return shell->write((char *)string, count);
 51170f0:	e30d08c8 	movw	r0, #55496	; 0xd8c8
 51170f4:	e1a01003 	mov	r1, r3
 51170f8:	e3400512 	movt	r0, #1298	; 0x512
 51170fc:	e12fff38 	blx	r8
    switch (command->attr.attrs.type)
 5117100:	e5d73001 	ldrb	r3, [r7, #1]
 5117104:	e203300f 	and	r3, r3, #15
 5117108:	e3530005 	cmp	r3, #5
 511710c:	0a00005c 	beq	5117284 <shellShowVar+0x23c>
        shellWriteString(shell, &buffer[11 - shellToDec(value, buffer)]);
 5117110:	e3053208 	movw	r3, #21000	; 0x5208
 5117114:	e1a01006 	mov	r1, r6
 5117118:	e1a00004 	mov	r0, r4
 511711c:	e3403511 	movt	r3, #1297	; 0x511
 5117120:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 5117124:	e5957068 	ldr	r7, [r5, #104]	; 0x68
 5117128:	e3570000 	cmp	r7, #0
        shellWriteString(shell, &buffer[11 - shellToDec(value, buffer)]);
 511712c:	e260300b 	rsb	r3, r0, #11
 5117130:	e0860003 	add	r0, r6, r3
    SHELL_ASSERT(shell->write, return 0);
 5117134:	0a000070 	beq	51172fc <shellShowVar+0x2b4>
    while(*p++)
 5117138:	e28d2010 	add	r2, sp, #16
 511713c:	e0823003 	add	r3, r2, r3
 5117140:	e15310dc 	ldrsb	r1, [r3, #-12]
 5117144:	e3510000 	cmp	r1, #0
 5117148:	e2803001 	add	r3, r0, #1
 511714c:	0a000005 	beq	5117168 <shellShowVar+0x120>
 5117150:	e263c001 	rsb	ip, r3, #1
        count ++;
 5117154:	e083100c 	add	r1, r3, ip
    while(*p++)
 5117158:	e0d320d1 	ldrsb	r2, [r3], #1
 511715c:	e3520000 	cmp	r2, #0
 5117160:	e6ff1071 	uxth	r1, r1
 5117164:	1afffffa 	bne	5117154 <shellShowVar+0x10c>
    return shell->write((char *)string, count);
 5117168:	e12fff37 	blx	r7
    SHELL_ASSERT(shell->write, return 0);
 511716c:	e5952068 	ldr	r2, [r5, #104]	; 0x68
 5117170:	e3520000 	cmp	r2, #0
 5117174:	0a000060 	beq	51172fc <shellShowVar+0x2b4>
 5117178:	e59f31ac 	ldr	r3, [pc, #428]	; 511732c <shellShowVar+0x2e4>
 511717c:	e3a08020 	mov	r8, #32
    unsigned short count = 0;
 5117180:	e3a01000 	mov	r1, #0
 5117184:	ea000000 	b	511718c <shellShowVar+0x144>
    while(*p++)
 5117188:	e1f380d1 	ldrsb	r8, [r3, #1]!
        count ++;
 511718c:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117190:	e3580000 	cmp	r8, #0
        count ++;
 5117194:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117198:	1afffffa 	bne	5117188 <shellShowVar+0x140>
    return shell->write((char *)string, count);
 511719c:	e30d07cc 	movw	r0, #55244	; 0xd7cc
 51171a0:	e3400512 	movt	r0, #1298	; 0x512
 51171a4:	e12fff32 	blx	r2
            buffer[i] = '0';
 51171a8:	e3033030 	movw	r3, #12336	; 0x3030
 51171ac:	e3433030 	movt	r3, #12336	; 0x3030
    SHELL_ASSERT(shell->write, return 0);
 51171b0:	e5957068 	ldr	r7, [r5, #104]	; 0x68
    while (value)
 51171b4:	e3540000 	cmp	r4, #0
            buffer[i] = '0';
 51171b8:	e5863004 	str	r3, [r6, #4]
        shellToHex(value, buffer);
 51171bc:	e1a01004 	mov	r1, r4
            buffer[i] = '0';
 51171c0:	e58d3004 	str	r3, [sp, #4]
 51171c4:	e5863007 	str	r3, [r6, #7]
    buffer[8] = 0;
 51171c8:	e5cd800c 	strb	r8, [sp, #12]
    while (value)
 51171cc:	0a00000c 	beq	5117204 <shellShowVar+0x1bc>
    unsigned char i = 8;
 51171d0:	e3a02008 	mov	r2, #8
        byte = value & 0x0000000F;
 51171d4:	e201300f 	and	r3, r1, #15
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 51171d8:	e2830057 	add	r0, r3, #87	; 0x57
 51171dc:	e2422001 	sub	r2, r2, #1
 51171e0:	e3530009 	cmp	r3, #9
 51171e4:	e6ef2072 	uxtb	r2, r2
 51171e8:	e2833030 	add	r3, r3, #48	; 0x30
 51171ec:	c6af3070 	sxtbgt	r3, r0
 51171f0:	e28d0010 	add	r0, sp, #16
 51171f4:	e0800002 	add	r0, r0, r2
    while (value)
 51171f8:	e1b01221 	lsrs	r1, r1, #4
        buffer[--i] = (byte > 9) ? (byte + 87) : (byte + 48);
 51171fc:	e540300c 	strb	r3, [r0, #-12]
    while (value)
 5117200:	1afffff3 	bne	51171d4 <shellShowVar+0x18c>
    SHELL_ASSERT(shell->write, return 0);
 5117204:	e3570000 	cmp	r7, #0
 5117208:	0a00001a 	beq	5117278 <shellShowVar+0x230>
    while(*p++)
 511720c:	e1dd10d4 	ldrsb	r1, [sp, #4]
 5117210:	e3510000 	cmp	r1, #0
 5117214:	0a000006 	beq	5117234 <shellShowVar+0x1ec>
    unsigned short count = 0;
 5117218:	e3a01000 	mov	r1, #0
    while(*p++)
 511721c:	e28d3005 	add	r3, sp, #5
        count ++;
 5117220:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117224:	e0d320d1 	ldrsb	r2, [r3], #1
 5117228:	e3520000 	cmp	r2, #0
        count ++;
 511722c:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117230:	1afffffa 	bne	5117220 <shellShowVar+0x1d8>
    return shell->write((char *)string, count);
 5117234:	e1a00006 	mov	r0, r6
 5117238:	e12fff37 	blx	r7
    SHELL_ASSERT(shell->write, return 0);
 511723c:	e5955068 	ldr	r5, [r5, #104]	; 0x68
 5117240:	e3550000 	cmp	r5, #0
 5117244:	0a00000b 	beq	5117278 <shellShowVar+0x230>
 5117248:	e59f20e0 	ldr	r2, [pc, #224]	; 5117330 <shellShowVar+0x2e8>
 511724c:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 5117250:	e3a01000 	mov	r1, #0
 5117254:	ea000000 	b	511725c <shellShowVar+0x214>
    while(*p++)
 5117258:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 511725c:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117260:	e3530000 	cmp	r3, #0
        count ++;
 5117264:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117268:	1afffffa 	bne	5117258 <shellShowVar+0x210>
    return shell->write((char *)string, count);
 511726c:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5117270:	e3400512 	movt	r0, #1298	; 0x512
 5117274:	e12fff35 	blx	r5
}
 5117278:	e1a00004 	mov	r0, r4
 511727c:	e28dd010 	add	sp, sp, #16
 5117280:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 5117284:	e5953068 	ldr	r3, [r5, #104]	; 0x68
 5117288:	e3530000 	cmp	r3, #0
 511728c:	0afffff9 	beq	5117278 <shellShowVar+0x230>
    return shell->write((char *)string, count);
 5117290:	e30d08cc 	movw	r0, #55500	; 0xd8cc
 5117294:	e3a01001 	mov	r1, #1
 5117298:	e3400512 	movt	r0, #1298	; 0x512
 511729c:	e12fff33 	blx	r3
    SHELL_ASSERT(shell->write, return 0);
 51172a0:	e5956068 	ldr	r6, [r5, #104]	; 0x68
 51172a4:	e3560000 	cmp	r6, #0
 51172a8:	0afffff2 	beq	5117278 <shellShowVar+0x230>
    while(*p++)
 51172ac:	e1a03004 	mov	r3, r4
 51172b0:	e0d310d1 	ldrsb	r1, [r3], #1
 51172b4:	e3510000 	cmp	r1, #0
 51172b8:	0a000005 	beq	51172d4 <shellShowVar+0x28c>
        count ++;
 51172bc:	e0431004 	sub	r1, r3, r4
    while(*p++)
 51172c0:	e1d320d0 	ldrsb	r2, [r3]
 51172c4:	e3520000 	cmp	r2, #0
 51172c8:	e6ff1071 	uxth	r1, r1
 51172cc:	e2833001 	add	r3, r3, #1
 51172d0:	1afffff9 	bne	51172bc <shellShowVar+0x274>
    return shell->write((char *)string, count);
 51172d4:	e1a00004 	mov	r0, r4
 51172d8:	e12fff36 	blx	r6
    SHELL_ASSERT(shell->write, return 0);
 51172dc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
 51172e0:	e3530000 	cmp	r3, #0
 51172e4:	0affffe3 	beq	5117278 <shellShowVar+0x230>
    return shell->write((char *)string, count);
 51172e8:	e30d08cc 	movw	r0, #55500	; 0xd8cc
 51172ec:	e3a01001 	mov	r1, #1
 51172f0:	e3400512 	movt	r0, #1298	; 0x512
 51172f4:	e12fff33 	blx	r3
 51172f8:	eaffffcf 	b	511723c <shellShowVar+0x1f4>
            buffer[i] = '0';
 51172fc:	e3033030 	movw	r3, #12336	; 0x3030
    buffer[8] = 0;
 5117300:	e3a07000 	mov	r7, #0
            buffer[i] = '0';
 5117304:	e3433030 	movt	r3, #12336	; 0x3030
        shellToHex(value, buffer);
 5117308:	e1a01004 	mov	r1, r4
    while (value)
 511730c:	e3540000 	cmp	r4, #0
            buffer[i] = '0';
 5117310:	e5863004 	str	r3, [r6, #4]
 5117314:	e58d3004 	str	r3, [sp, #4]
 5117318:	e5863007 	str	r3, [r6, #7]
    buffer[8] = 0;
 511731c:	e5cd700c 	strb	r7, [sp, #12]
    while (value)
 5117320:	1affffaa 	bne	51171d0 <shellShowVar+0x188>
 5117324:	eaffffd3 	b	5117278 <shellShowVar+0x230>
 5117328:	0512d8c9 	.word	0x0512d8c9
 511732c:	0512d7cd 	.word	0x0512d7cd
 5117330:	0512d3e1 	.word	0x0512d3e1

05117334 <shellSetVarValue>:
    if (command->attr.attrs.readOnly)
 5117334:	e5d13001 	ldrb	r3, [r1, #1]
 5117338:	e3130040 	tst	r3, #64	; 0x40
{
 511733c:	e92d4070 	push	{r4, r5, r6, lr}
 5117340:	e1a04001 	mov	r4, r1
 5117344:	e1a05000 	mov	r5, r0
    if (command->attr.attrs.readOnly)
 5117348:	1a00000a 	bne	5117378 <shellSetVarValue+0x44>
        switch (command->attr.attrs.type)
 511734c:	e203300f 	and	r3, r3, #15
 5117350:	e2433002 	sub	r3, r3, #2
 5117354:	e3530005 	cmp	r3, #5
 5117358:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
 511735c:	ea000015 	b	51173b8 <shellSetVarValue+0x84>
 5117360:	051173f8 	.word	0x051173f8
 5117364:	05117404 	.word	0x05117404
 5117368:	05117410 	.word	0x05117410
 511736c:	0511741c 	.word	0x0511741c
 5117370:	05117460 	.word	0x05117460
 5117374:	051173d0 	.word	0x051173d0
    SHELL_ASSERT(shell->write, return 0);
 5117378:	e5906068 	ldr	r6, [r0, #104]	; 0x68
 511737c:	e3560000 	cmp	r6, #0
 5117380:	0a00000c 	beq	51173b8 <shellSetVarValue+0x84>
 5117384:	e59f1120 	ldr	r1, [pc, #288]	; 51174ac <shellSetVarValue+0x178>
 5117388:	e3a02061 	mov	r2, #97	; 0x61
    unsigned short count = 0;
 511738c:	e3a03000 	mov	r3, #0
 5117390:	ea000000 	b	5117398 <shellSetVarValue+0x64>
    while(*p++)
 5117394:	e1f120d1 	ldrsb	r2, [r1, #1]!
        count ++;
 5117398:	e2833001 	add	r3, r3, #1
    while(*p++)
 511739c:	e3520000 	cmp	r2, #0
        count ++;
 51173a0:	e6ff3073 	uxth	r3, r3
    while(*p++)
 51173a4:	1afffffa 	bne	5117394 <shellSetVarValue+0x60>
    return shell->write((char *)string, count);
 51173a8:	e30d08d0 	movw	r0, #55504	; 0xd8d0
 51173ac:	e1a01003 	mov	r1, r3
 51173b0:	e3400512 	movt	r0, #1298	; 0x512
 51173b4:	e12fff36 	blx	r6
    return shellShowVar(shell, command);
 51173b8:	e3073048 	movw	r3, #28744	; 0x7048
 51173bc:	e1a01004 	mov	r1, r4
 51173c0:	e1a00005 	mov	r0, r5
 51173c4:	e3403511 	movt	r3, #1297	; 0x511
 51173c8:	e12fff33 	blx	r3
}
 51173cc:	e8bd8070 	pop	{r4, r5, r6, pc}
            if (((ShellNodeVarAttr *)command->data.var.value)->set)
 51173d0:	e5911008 	ldr	r1, [r1, #8]
 51173d4:	e5913008 	ldr	r3, [r1, #8]
 51173d8:	e3530000 	cmp	r3, #0
 51173dc:	0afffff5 	beq	51173b8 <shellSetVarValue+0x84>
                if (((ShellNodeVarAttr *)command->data.var.value)->var)
 51173e0:	e5910000 	ldr	r0, [r1]
 51173e4:	e3500000 	cmp	r0, #0
 51173e8:	0a00002c 	beq	51174a0 <shellSetVarValue+0x16c>
                    ((ShellNodeVarAttr *)command->data.var.value)
 51173ec:	e1a01002 	mov	r1, r2
 51173f0:	e12fff33 	blx	r3
 51173f4:	eaffffef 	b	51173b8 <shellSetVarValue+0x84>
            *((int *)(command->data.var.value)) = value;
 51173f8:	e5913008 	ldr	r3, [r1, #8]
 51173fc:	e5832000 	str	r2, [r3]
            break;
 5117400:	eaffffec 	b	51173b8 <shellSetVarValue+0x84>
            *((short *)(command->data.var.value)) = value;
 5117404:	e5913008 	ldr	r3, [r1, #8]
 5117408:	e1c320b0 	strh	r2, [r3]
            break;
 511740c:	eaffffe9 	b	51173b8 <shellSetVarValue+0x84>
            *((char *)(command->data.var.value)) = value;
 5117410:	e5913008 	ldr	r3, [r1, #8]
 5117414:	e5c32000 	strb	r2, [r3]
            break;
 5117418:	eaffffe6 	b	51173b8 <shellSetVarValue+0x84>
    while (*(src + count))
 511741c:	e1d210d0 	ldrsb	r1, [r2]
            shellStringCopy(((char *)(command->data.var.value)), (char *)value);
 5117420:	e594c008 	ldr	ip, [r4, #8]
    while (*(src + count))
 5117424:	e3510000 	cmp	r1, #0
 5117428:	0a000009 	beq	5117454 <shellSetVarValue+0x120>
    unsigned short count = 0;
 511742c:	e3a03000 	mov	r3, #0
    while (*(src + count))
 5117430:	e1a00003 	mov	r0, r3
        *(dest + count) = *(src + count);
 5117434:	e7cc1000 	strb	r1, [ip, r0]
        count++;
 5117438:	e2833001 	add	r3, r3, #1
 511743c:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 5117440:	e19210d3 	ldrsb	r1, [r2, r3]
 5117444:	e1a00003 	mov	r0, r3
 5117448:	e3510000 	cmp	r1, #0
 511744c:	1afffff8 	bne	5117434 <shellSetVarValue+0x100>
    *(dest + count) = 0;
 5117450:	e08cc003 	add	ip, ip, r3
 5117454:	e3a03000 	mov	r3, #0
 5117458:	e5cc3000 	strb	r3, [ip]
    return count;
 511745c:	eaffffd5 	b	51173b8 <shellSetVarValue+0x84>
    SHELL_ASSERT(shell->write, return 0);
 5117460:	e5906068 	ldr	r6, [r0, #104]	; 0x68
 5117464:	e3560000 	cmp	r6, #0
 5117468:	0affffd2 	beq	51173b8 <shellSetVarValue+0x84>
 511746c:	e59f203c 	ldr	r2, [pc, #60]	; 51174b0 <shellSetVarValue+0x17c>
 5117470:	e3a03061 	mov	r3, #97	; 0x61
    unsigned short count = 0;
 5117474:	e3a01000 	mov	r1, #0
 5117478:	ea000000 	b	5117480 <shellSetVarValue+0x14c>
    while(*p++)
 511747c:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5117480:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117484:	e3530000 	cmp	r3, #0
        count ++;
 5117488:	e6ff1071 	uxth	r1, r1
    while(*p++)
 511748c:	1afffffa 	bne	511747c <shellSetVarValue+0x148>
    return shell->write((char *)string, count);
 5117490:	e30d08ec 	movw	r0, #55532	; 0xd8ec
 5117494:	e3400512 	movt	r0, #1298	; 0x512
 5117498:	e12fff36 	blx	r6
 511749c:	eaffffc5 	b	51173b8 <shellSetVarValue+0x84>
                    ((ShellNodeVarAttr *)command->data.var.value)->set((void *)value);
 51174a0:	e1a00002 	mov	r0, r2
 51174a4:	e12fff33 	blx	r3
 51174a8:	eaffffc2 	b	51173b8 <shellSetVarValue+0x84>
 51174ac:	0512d8d1 	.word	0x0512d8d1
 51174b0:	0512d8ed 	.word	0x0512d8ed

051174b4 <shellSetVar>:
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 51174b4:	e30831d8 	movw	r3, #33240	; 0x81d8
 51174b8:	e3403513 	movt	r3, #1299	; 0x513
{
 51174bc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 51174c0:	e1a05000 	mov	r5, r0
 51174c4:	e1a06001 	mov	r6, r1
 51174c8:	e2830014 	add	r0, r3, #20
        if (shellList[i] && shellList[i]->status.isActive)
 51174cc:	e4934004 	ldr	r4, [r3], #4
 51174d0:	e3540000 	cmp	r4, #0
 51174d4:	0a000002 	beq	51174e4 <shellSetVar+0x30>
 51174d8:	e5d4c060 	ldrb	ip, [r4, #96]	; 0x60
 51174dc:	e31c0002 	tst	ip, #2
 51174e0:	1a000003 	bne	51174f4 <shellSetVar+0x40>
    for (short i = 0; i < SHELL_MAX_NUMBER; i++)
 51174e4:	e1530000 	cmp	r3, r0
 51174e8:	1afffff7 	bne	51174cc <shellSetVar+0x18>
        return 0;
 51174ec:	e3a00000 	mov	r0, #0
 51174f0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ShellCommand *command = shellSeekCommand(shell,
 51174f4:	e3067aec 	movw	r7, #27372	; 0x6aec
 51174f8:	e1a01005 	mov	r1, r5
 51174fc:	e5942058 	ldr	r2, [r4, #88]	; 0x58
 5117500:	e3a03000 	mov	r3, #0
 5117504:	e1a00004 	mov	r0, r4
 5117508:	e3407511 	movt	r7, #1297	; 0x511
 511750c:	e12fff37 	blx	r7
    if (!command)
 5117510:	e2501000 	subs	r1, r0, #0
 5117514:	0a00002a 	beq	51175c4 <shellSetVar+0x110>
    if (command->attr.attrs.type < SHELL_TYPE_VAR_INT
 5117518:	e5d12001 	ldrb	r2, [r1, #1]
        || command->attr.attrs.type > SHELL_TYPE_VAR_NODE)
 511751c:	e282200e 	add	r2, r2, #14
    if (command->attr.attrs.type < SHELL_TYPE_VAR_INT
 5117520:	e202200f 	and	r2, r2, #15
 5117524:	e3520005 	cmp	r2, #5
 5117528:	8a000005 	bhi	5117544 <shellSetVar+0x90>
    return shellSetVarValue(shell, command, value);
 511752c:	e3075334 	movw	r5, #29492	; 0x7334
 5117530:	e1a02006 	mov	r2, r6
 5117534:	e1a00004 	mov	r0, r4
 5117538:	e3405511 	movt	r5, #1297	; 0x511
 511753c:	e12fff35 	blx	r5
}
 5117540:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 5117544:	e5946068 	ldr	r6, [r4, #104]	; 0x68
 5117548:	e3560000 	cmp	r6, #0
 511754c:	0affffe6 	beq	51174ec <shellSetVar+0x38>
    while(*p++)
 5117550:	e1a03005 	mov	r3, r5
 5117554:	e0d310d1 	ldrsb	r1, [r3], #1
 5117558:	e3510000 	cmp	r1, #0
 511755c:	0a000005 	beq	5117578 <shellSetVar+0xc4>
 5117560:	e2630001 	rsb	r0, r3, #1
        count ++;
 5117564:	e0831000 	add	r1, r3, r0
    while(*p++)
 5117568:	e0d320d1 	ldrsb	r2, [r3], #1
 511756c:	e3520000 	cmp	r2, #0
 5117570:	e6ff1071 	uxth	r1, r1
 5117574:	1afffffa 	bne	5117564 <shellSetVar+0xb0>
    return shell->write((char *)string, count);
 5117578:	e1a00005 	mov	r0, r5
 511757c:	e12fff36 	blx	r6
    SHELL_ASSERT(shell->write, return 0);
 5117580:	e5942068 	ldr	r2, [r4, #104]	; 0x68
 5117584:	e3520000 	cmp	r2, #0
 5117588:	0affffd7 	beq	51174ec <shellSetVar+0x38>
 511758c:	e59f3070 	ldr	r3, [pc, #112]	; 5117604 <shellSetVar+0x150>
 5117590:	e3a04069 	mov	r4, #105	; 0x69
    unsigned short count = 0;
 5117594:	e3a01000 	mov	r1, #0
 5117598:	ea000000 	b	51175a0 <shellSetVar+0xec>
    while(*p++)
 511759c:	e1f340d1 	ldrsb	r4, [r3, #1]!
        count ++;
 51175a0:	e2811001 	add	r1, r1, #1
    while(*p++)
 51175a4:	e3540000 	cmp	r4, #0
        count ++;
 51175a8:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51175ac:	1afffffa 	bne	511759c <shellSetVar+0xe8>
    return shell->write((char *)string, count);
 51175b0:	e30d0910 	movw	r0, #55568	; 0xd910
 51175b4:	e3400512 	movt	r0, #1298	; 0x512
 51175b8:	e12fff32 	blx	r2
        return 0;
 51175bc:	e1a00004 	mov	r0, r4
    return shell->write((char *)string, count);
 51175c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 51175c4:	e5945068 	ldr	r5, [r4, #104]	; 0x68
 51175c8:	e3550000 	cmp	r5, #0
 51175cc:	0affffc6 	beq	51174ec <shellSetVar+0x38>
 51175d0:	e59f2030 	ldr	r2, [pc, #48]	; 5117608 <shellSetVar+0x154>
 51175d4:	e3a04061 	mov	r4, #97	; 0x61
 51175d8:	ea000000 	b	51175e0 <shellSetVar+0x12c>
    while(*p++)
 51175dc:	e1f240d1 	ldrsb	r4, [r2, #1]!
        count ++;
 51175e0:	e2811001 	add	r1, r1, #1
    while(*p++)
 51175e4:	e3540000 	cmp	r4, #0
        count ++;
 51175e8:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51175ec:	1afffffa 	bne	51175dc <shellSetVar+0x128>
    return shell->write((char *)string, count);
 51175f0:	e30d0900 	movw	r0, #55552	; 0xd900
 51175f4:	e3400512 	movt	r0, #1298	; 0x512
 51175f8:	e12fff35 	blx	r5
        return 0;
 51175fc:	e1a00004 	mov	r0, r4
    return shell->write((char *)string, count);
 5117600:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5117604:	0512d911 	.word	0x0512d911
 5117608:	0512d901 	.word	0x0512d901

0511760c <shellRunCommand>:
    shell->status.isActive = 1;
 511760c:	e5d03060 	ldrb	r3, [r0, #96]	; 0x60
 5117610:	e3833002 	orr	r3, r3, #2
{
 5117614:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    shell->status.isActive = 1;
 5117618:	e5c03060 	strb	r3, [r0, #96]	; 0x60
    if (command->attr.attrs.type == SHELL_TYPE_CMD_MAIN)
 511761c:	e5d13001 	ldrb	r3, [r1, #1]
{
 5117620:	e1a04000 	mov	r4, r0
    if (command->attr.attrs.type == SHELL_TYPE_CMD_MAIN)
 5117624:	e213800f 	ands	r8, r3, #15
{
 5117628:	e1a05001 	mov	r5, r1
    if (command->attr.attrs.type == SHELL_TYPE_CMD_MAIN)
 511762c:	0a00000c 	beq	5117664 <shellRunCommand+0x58>
    else if (command->attr.attrs.type == SHELL_TYPE_CMD_FUNC)
 5117630:	e3580001 	cmp	r8, #1
 5117634:	0a000033 	beq	5117708 <shellRunCommand+0xfc>
        && command->attr.attrs.type <= SHELL_TYPE_VAR_NODE)
 5117638:	e283300e 	add	r3, r3, #14
    else if (command->attr.attrs.type >= SHELL_TYPE_VAR_INT
 511763c:	e203300f 	and	r3, r3, #15
 5117640:	e3530005 	cmp	r3, #5
 5117644:	9a00002a 	bls	51176f4 <shellRunCommand+0xe8>
    else if (command->attr.attrs.type == SHELL_TYPE_USER)
 5117648:	e3580008 	cmp	r8, #8
 511764c:	13a00000 	movne	r0, #0
 5117650:	0a00003b 	beq	5117744 <shellRunCommand+0x138>
    shell->status.isActive = 0;
 5117654:	e5d43060 	ldrb	r3, [r4, #96]	; 0x60
 5117658:	e7c1309f 	bfc	r3, #1, #1
 511765c:	e5c43060 	strb	r3, [r4, #96]	; 0x60
}
 5117660:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    for (unsigned short i = 0; i < shell->parser.paramCount; i++)
 5117664:	e1d003b6 	ldrh	r0, [r0, #54]	; 0x36
 5117668:	e3500000 	cmp	r0, #0
 511766c:	0a000017 	beq	51176d0 <shellRunCommand+0xc4>
 5117670:	e3006331 	movw	r6, #817	; 0x331
            shell->parser.param[i][0] = 0;
 5117674:	e1a07008 	mov	r7, r8
 5117678:	e3406511 	movt	r6, #1297	; 0x511
        paramLength = strlen(shell->parser.param[i]);
 511767c:	e6ff3078 	uxth	r3, r8
 5117680:	e2888001 	add	r8, r8, #1
 5117684:	e0843103 	add	r3, r4, r3, lsl #2
        if (shell->parser.param[i][0] == '\"')
 5117688:	e5939014 	ldr	r9, [r3, #20]
 511768c:	e1d920d0 	ldrsb	r2, [r9]
 5117690:	e3520022 	cmp	r2, #34	; 0x22
            shell->parser.param[i][0] = 0;
 5117694:	05c97000 	strbeq	r7, [r9]
            shell->parser.param[i] = &shell->parser.param[i][1];
 5117698:	05939014 	ldreq	r9, [r3, #20]
 511769c:	02899001 	addeq	r9, r9, #1
        paramLength = strlen(shell->parser.param[i]);
 51176a0:	e1a00009 	mov	r0, r9
            shell->parser.param[i] = &shell->parser.param[i][1];
 51176a4:	05839014 	streq	r9, [r3, #20]
        paramLength = strlen(shell->parser.param[i]);
 51176a8:	e12fff36 	blx	r6
    for (unsigned short i = 0; i < shell->parser.paramCount; i++)
 51176ac:	e6ff2078 	uxth	r2, r8
        if (shell->parser.param[i][paramLength - 1] == '\"')
 51176b0:	e6ff0070 	uxth	r0, r0
 51176b4:	e2403001 	sub	r3, r0, #1
 51176b8:	e19910d3 	ldrsb	r1, [r9, r3]
 51176bc:	e3510022 	cmp	r1, #34	; 0x22
            shell->parser.param[i][paramLength - 1] = 0;
 51176c0:	07c97003 	strbeq	r7, [r9, r3]
    for (unsigned short i = 0; i < shell->parser.paramCount; i++)
 51176c4:	e1d403b6 	ldrh	r0, [r4, #54]	; 0x36
 51176c8:	e1500002 	cmp	r0, r2
 51176cc:	8affffea 	bhi	511767c <shellRunCommand+0x70>
        returnValue = command->data.cmd.function(shell->parser.paramCount,
 51176d0:	e5953008 	ldr	r3, [r5, #8]
 51176d4:	e2841014 	add	r1, r4, #20
 51176d8:	e12fff33 	blx	r3
        if (!command->attr.attrs.disableReturn)
 51176dc:	e5d53001 	ldrb	r3, [r5, #1]
 51176e0:	e3130020 	tst	r3, #32
        returnValue = command->data.cmd.function(shell->parser.paramCount,
 51176e4:	e1a05000 	mov	r5, r0
        if (!command->attr.attrs.disableReturn)
 51176e8:	0a00000f 	beq	511772c <shellRunCommand+0x120>
    return returnValue;
 51176ec:	e1a00005 	mov	r0, r5
 51176f0:	eaffffd7 	b	5117654 <shellRunCommand+0x48>
        shellShowVar(shell, command);
 51176f4:	e3073048 	movw	r3, #28744	; 0x7048
 51176f8:	e3403511 	movt	r3, #1297	; 0x511
 51176fc:	e12fff33 	blx	r3
 5117700:	e3a00000 	mov	r0, #0
 5117704:	eaffffd2 	b	5117654 <shellRunCommand+0x48>
        returnValue = shellExtRun(shell,
 5117708:	e3046c90 	movw	r6, #19600	; 0x4c90
 511770c:	e2803014 	add	r3, r0, #20
 5117710:	e3406511 	movt	r6, #1297	; 0x511
 5117714:	e1d023b6 	ldrh	r2, [r0, #54]	; 0x36
 5117718:	e12fff36 	blx	r6
        if (!command->attr.attrs.disableReturn)
 511771c:	e5d53001 	ldrb	r3, [r5, #1]
 5117720:	e3130020 	tst	r3, #32
        returnValue = shellExtRun(shell,
 5117724:	e1a05000 	mov	r5, r0
        if (!command->attr.attrs.disableReturn)
 5117728:	1affffef 	bne	51176ec <shellRunCommand+0xe0>
            shellWriteReturnValue(shell, returnValue);
 511772c:	e305328c 	movw	r3, #21132	; 0x528c
 5117730:	e1a01005 	mov	r1, r5
 5117734:	e1a00004 	mov	r0, r4
 5117738:	e3403511 	movt	r3, #1297	; 0x511
 511773c:	e12fff33 	blx	r3
 5117740:	eaffffe9 	b	51176ec <shellRunCommand+0xe0>
        shellSetUser(shell, command);
 5117744:	e3043fbc 	movw	r3, #20412	; 0x4fbc
 5117748:	e3403511 	movt	r3, #1297	; 0x511
 511774c:	e12fff33 	blx	r3
 5117750:	e3a00000 	mov	r0, #0
 5117754:	eaffffbe 	b	5117654 <shellRunCommand+0x48>

05117758 <shellExec>:
    if (shell->parser.length == 0)
 5117758:	e1d030bc 	ldrh	r3, [r0, #12]
 511775c:	e3530000 	cmp	r3, #0
 5117760:	012fff1e 	bxeq	lr
    shell->parser.buffer[shell->parser.length] = 0;
 5117764:	e5901010 	ldr	r1, [r0, #16]
 5117768:	e3a02000 	mov	r2, #0
{
 511776c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    shell->parser.buffer[shell->parser.length] = 0;
 5117770:	e7c12003 	strb	r2, [r1, r3]
    if (shell->status.isChecked)
 5117774:	e5d06060 	ldrb	r6, [r0, #96]	; 0x60
 5117778:	e1a04000 	mov	r4, r0
 511777c:	e2165001 	ands	r5, r6, #1
 5117780:	0a000050 	beq	51178c8 <shellExec+0x170>
    if (shell->history.number > 0
 5117784:	e1d035b0 	ldrh	r3, [r0, #80]	; 0x50
    shell->history.offset = 0;
 5117788:	e1c025b4 	strh	r2, [r0, #84]	; 0x54
    if (shell->history.number > 0
 511778c:	e1530002 	cmp	r3, r2
 5117790:	1a000074 	bne	5117968 <shellExec+0x210>
                shell->parser.buffer) == 0)
 5117794:	e5906010 	ldr	r6, [r0, #16]
        && strcmp(shell->history.item[(shell->history.record == 0 ? 
 5117798:	e1d075b2 	ldrh	r7, [r0, #82]	; 0x52
    if (shellStringCopy(shell->history.item[shell->history.record],
 511779c:	e0847107 	add	r7, r4, r7, lsl #2
    while (*(src + count))
 51177a0:	e1d620d0 	ldrsb	r2, [r6]
 51177a4:	e3520000 	cmp	r2, #0
    if (shellStringCopy(shell->history.item[shell->history.record],
 51177a8:	e597103c 	ldr	r1, [r7, #60]	; 0x3c
    while (*(src + count))
 51177ac:	0a0000c1 	beq	5117ab8 <shellExec+0x360>
    unsigned short count = 0;
 51177b0:	e3a03000 	mov	r3, #0
    while (*(src + count))
 51177b4:	e1a00003 	mov	r0, r3
        *(dest + count) = *(src + count);
 51177b8:	e7c12000 	strb	r2, [r1, r0]
        count++;
 51177bc:	e2833001 	add	r3, r3, #1
 51177c0:	e6ff3073 	uxth	r3, r3
    while (*(src + count))
 51177c4:	e19620d3 	ldrsb	r2, [r6, r3]
 51177c8:	e1a00003 	mov	r0, r3
 51177cc:	e3520000 	cmp	r2, #0
 51177d0:	1afffff8 	bne	51177b8 <shellExec+0x60>
    *(dest + count) = 0;
 51177d4:	e7c12003 	strb	r2, [r1, r3]
    if (shellStringCopy(shell->history.item[shell->history.record],
 51177d8:	e3530000 	cmp	r3, #0
        shell->history.record++;
 51177dc:	e1d425b2 	ldrh	r2, [r4, #82]	; 0x52
 51177e0:	12822001 	addne	r2, r2, #1
 51177e4:	16ff2072 	uxthne	r2, r2
 51177e8:	11c425b2 	strhne	r2, [r4, #82]	; 0x52
    if (++shell->history.number > SHELL_HISTORY_MAX_NUMBER)
 51177ec:	e1d435b0 	ldrh	r3, [r4, #80]	; 0x50
 51177f0:	e2833001 	add	r3, r3, #1
 51177f4:	e6ff3073 	uxth	r3, r3
 51177f8:	e3530005 	cmp	r3, #5
        shell->history.number = SHELL_HISTORY_MAX_NUMBER;
 51177fc:	83a03005 	movhi	r3, #5
    if (shell->history.record >= SHELL_HISTORY_MAX_NUMBER)
 5117800:	e3520004 	cmp	r2, #4
        shell->history.number = SHELL_HISTORY_MAX_NUMBER;
 5117804:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
        shell->history.record = 0;
 5117808:	83a03000 	movhi	r3, #0
 511780c:	81c435b2 	strhhi	r3, [r4, #82]	; 0x52
        shell->parser.param[i] = NULL;
 5117810:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 5117814:	e3a02020 	mov	r2, #32
 5117818:	e3a01000 	mov	r1, #0
 511781c:	e3403511 	movt	r3, #1297	; 0x511
 5117820:	e2840014 	add	r0, r4, #20
 5117824:	e12fff33 	blx	r3
    shell->parser.paramCount = 0;
 5117828:	e3a03000 	mov	r3, #0
    for (unsigned short i = 0; i < shell->parser.length; i++)
 511782c:	e1d4e0bc 	ldrh	lr, [r4, #12]
 5117830:	e15e0003 	cmp	lr, r3
    shell->parser.paramCount = 0;
 5117834:	e1c433b6 	strh	r3, [r4, #54]	; 0x36
    for (unsigned short i = 0; i < shell->parser.length; i++)
 5117838:	0a00009c 	beq	5117ab0 <shellExec+0x358>
            || (shell->parser.buffer[i] != ' '
 511783c:	e594c010 	ldr	ip, [r4, #16]
    unsigned char record = 1;
 5117840:	e1a01005 	mov	r1, r5
    unsigned char quotes = 0;
 5117844:	e1a06003 	mov	r6, r3
 5117848:	ea00000c 	b	5117880 <shellExec+0x128>
            if (record == 1)
 511784c:	e3510001 	cmp	r1, #1
 5117850:	0a000062 	beq	51179e0 <shellExec+0x288>
            if (shell->parser.buffer[i] == '\\'
 5117854:	e352005c 	cmp	r2, #92	; 0x5c
 5117858:	1a000003 	bne	511786c <shellExec+0x114>
                && shell->parser.buffer[i + 1] != 0)
 511785c:	e1d020d1 	ldrsb	r2, [r0, #1]
 5117860:	e3520000 	cmp	r2, #0
                i++;
 5117864:	12833001 	addne	r3, r3, #1
 5117868:	16ff3073 	uxthne	r3, r3
    for (unsigned short i = 0; i < shell->parser.length; i++)
 511786c:	e3a01000 	mov	r1, #0
 5117870:	e2833001 	add	r3, r3, #1
 5117874:	e6ff3073 	uxth	r3, r3
 5117878:	e15e0003 	cmp	lr, r3
 511787c:	9a00005b 	bls	51179f0 <shellExec+0x298>
        if (quotes != 0
 5117880:	e3560000 	cmp	r6, #0
 5117884:	0a00002a 	beq	5117934 <shellExec+0x1dc>
            if (shell->parser.buffer[i] == '\"')
 5117888:	e08c0003 	add	r0, ip, r3
 511788c:	e19c20d3 	ldrsb	r2, [ip, r3]
 5117890:	e3520022 	cmp	r2, #34	; 0x22
 5117894:	1affffec 	bne	511784c <shellExec+0xf4>
            if (record == 1)
 5117898:	e3510001 	cmp	r1, #1
 511789c:	e2266001 	eor	r6, r6, #1
 51178a0:	1afffff1 	bne	511786c <shellExec+0x114>
                if (shell->parser.paramCount < SHELL_PARAMETER_MAX_NUMBER)
 51178a4:	e1d413b6 	ldrh	r1, [r4, #54]	; 0x36
 51178a8:	e3510007 	cmp	r1, #7
 51178ac:	8affffee 	bhi	511786c <shellExec+0x114>
                    shell->parser.param[shell->parser.paramCount++] =
 51178b0:	e2812001 	add	r2, r1, #1
 51178b4:	e0841101 	add	r1, r4, r1, lsl #2
 51178b8:	e1c423b6 	strh	r2, [r4, #54]	; 0x36
 51178bc:	e5810014 	str	r0, [r1, #20]
            if (shell->parser.buffer[i] == '\\'
 51178c0:	e1d020d0 	ldrsb	r2, [r0]
 51178c4:	eaffffe2 	b	5117854 <shellExec+0xfc>
    if (strcmp(shell->parser.buffer, shell->info.user->data.user.password) == 0)
 51178c8:	e5903000 	ldr	r3, [r0]
 51178cc:	e5900010 	ldr	r0, [r0, #16]
 51178d0:	e5931008 	ldr	r1, [r3, #8]
 51178d4:	e300331d 	movw	r3, #797	; 0x31d
 51178d8:	e3403511 	movt	r3, #1297	; 0x511
 51178dc:	e12fff33 	blx	r3
 51178e0:	e2501000 	subs	r1, r0, #0
 51178e4:	1a00002d 	bne	51179a0 <shellExec+0x248>
    SHELL_ASSERT(shell->write, return 0);
 51178e8:	e5945068 	ldr	r5, [r4, #104]	; 0x68
        shell->status.isChecked = 1;
 51178ec:	e3866001 	orr	r6, r6, #1
 51178f0:	e5c46060 	strb	r6, [r4, #96]	; 0x60
    SHELL_ASSERT(shell->write, return 0);
 51178f4:	e3550000 	cmp	r5, #0
 51178f8:	0a00000a 	beq	5117928 <shellExec+0x1d0>
 51178fc:	e59f21c0 	ldr	r2, [pc, #448]	; 5117ac4 <shellExec+0x36c>
 5117900:	e3a0300a 	mov	r3, #10
 5117904:	ea000000 	b	511790c <shellExec+0x1b4>
    while(*p++)
 5117908:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 511790c:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117910:	e3530000 	cmp	r3, #0
        count ++;
 5117914:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117918:	1afffffa 	bne	5117908 <shellExec+0x1b0>
    return shell->write((char *)string, count);
 511791c:	e30d065c 	movw	r0, #54876	; 0xd65c
 5117920:	e3400512 	movt	r0, #1298	; 0x512
 5117924:	e12fff35 	blx	r5
    shell->parser.length = 0;
 5117928:	e3a03000 	mov	r3, #0
 511792c:	e584300c 	str	r3, [r4, #12]
}
 5117930:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
            || (shell->parser.buffer[i] != ' '
 5117934:	e19c20d3 	ldrsb	r2, [ip, r3]
 5117938:	e3d28020 	bics	r8, r2, #32
    for (unsigned short i = 0; i < shell->parser.length; i++)
 511793c:	e2837001 	add	r7, r3, #1
            || (shell->parser.buffer[i] != ' '
 5117940:	e08c0003 	add	r0, ip, r3
 5117944:	1affffd1 	bne	5117890 <shellExec+0x138>
            shell->parser.buffer[i] = 0;
 5117948:	e7cc8003 	strb	r8, [ip, r3]
    for (unsigned short i = 0; i < shell->parser.length; i++)
 511794c:	e6ff3077 	uxth	r3, r7
 5117950:	e1d4e0bc 	ldrh	lr, [r4, #12]
            record = 1;
 5117954:	e1a01005 	mov	r1, r5
    for (unsigned short i = 0; i < shell->parser.length; i++)
 5117958:	e15e0003 	cmp	lr, r3
 511795c:	9a000023 	bls	51179f0 <shellExec+0x298>
            || (shell->parser.buffer[i] != ' '
 5117960:	e594c010 	ldr	ip, [r4, #16]
 5117964:	eafffff2 	b	5117934 <shellExec+0x1dc>
        && strcmp(shell->history.item[(shell->history.record == 0 ? 
 5117968:	e1d075b2 	ldrh	r7, [r0, #82]	; 0x52
                shell->parser.buffer) == 0)
 511796c:	e5906010 	ldr	r6, [r0, #16]
        && strcmp(shell->history.item[(shell->history.record == 0 ? 
 5117970:	e1a01006 	mov	r1, r6
                SHELL_HISTORY_MAX_NUMBER : shell->history.record) - 1],
 5117974:	e3570000 	cmp	r7, #0
 5117978:	03a03004 	moveq	r3, #4
 511797c:	12473001 	subne	r3, r7, #1
        && strcmp(shell->history.item[(shell->history.record == 0 ? 
 5117980:	e0803103 	add	r3, r0, r3, lsl #2
 5117984:	e593003c 	ldr	r0, [r3, #60]	; 0x3c
 5117988:	e300331d 	movw	r3, #797	; 0x31d
 511798c:	e3403511 	movt	r3, #1297	; 0x511
 5117990:	e12fff33 	blx	r3
 5117994:	e3500000 	cmp	r0, #0
 5117998:	1affff7f 	bne	511779c <shellExec+0x44>
 511799c:	eaffff9b 	b	5117810 <shellExec+0xb8>
    SHELL_ASSERT(shell->write, return 0);
 51179a0:	e5946068 	ldr	r6, [r4, #104]	; 0x68
 51179a4:	e3560000 	cmp	r6, #0
 51179a8:	0affffde 	beq	5117928 <shellExec+0x1d0>
 51179ac:	e59f2114 	ldr	r2, [pc, #276]	; 5117ac8 <shellExec+0x370>
 51179b0:	e3a0300a 	mov	r3, #10
    unsigned short count = 0;
 51179b4:	e1a01005 	mov	r1, r5
 51179b8:	ea000000 	b	51179c0 <shellExec+0x268>
    while(*p++)
 51179bc:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 51179c0:	e2811001 	add	r1, r1, #1
    while(*p++)
 51179c4:	e3530000 	cmp	r3, #0
        count ++;
 51179c8:	e6ff1071 	uxth	r1, r1
    while(*p++)
 51179cc:	1afffffa 	bne	51179bc <shellExec+0x264>
    return shell->write((char *)string, count);
 51179d0:	e30d0920 	movw	r0, #55584	; 0xd920
 51179d4:	e3400512 	movt	r0, #1298	; 0x512
 51179d8:	e12fff36 	blx	r6
 51179dc:	eaffffd1 	b	5117928 <shellExec+0x1d0>
                if (shell->parser.paramCount < SHELL_PARAMETER_MAX_NUMBER)
 51179e0:	e1d413b6 	ldrh	r1, [r4, #54]	; 0x36
 51179e4:	e3510007 	cmp	r1, #7
 51179e8:	8affff99 	bhi	5117854 <shellExec+0xfc>
 51179ec:	eaffffaf 	b	51178b0 <shellExec+0x158>
        shell->parser.length = shell->parser.cursor = 0;
 51179f0:	e3a01000 	mov	r1, #0
        if (shell->parser.paramCount == 0)
 51179f4:	e1d433b6 	ldrh	r3, [r4, #54]	; 0x36
 51179f8:	e1530001 	cmp	r3, r1
        shell->parser.length = shell->parser.cursor = 0;
 51179fc:	e584100c 	str	r1, [r4, #12]
        if (shell->parser.paramCount == 0)
 5117a00:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 5117a04:	e5945068 	ldr	r5, [r4, #104]	; 0x68
 5117a08:	e1550001 	cmp	r5, r1
 5117a0c:	0a00000a 	beq	5117a3c <shellExec+0x2e4>
 5117a10:	e59f20b4 	ldr	r2, [pc, #180]	; 5117acc <shellExec+0x374>
 5117a14:	e3a0300a 	mov	r3, #10
 5117a18:	ea000000 	b	5117a20 <shellExec+0x2c8>
    while(*p++)
 5117a1c:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5117a20:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117a24:	e3530000 	cmp	r3, #0
        count ++;
 5117a28:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117a2c:	1afffffa 	bne	5117a1c <shellExec+0x2c4>
    return shell->write((char *)string, count);
 5117a30:	e30d03e0 	movw	r0, #54240	; 0xd3e0
 5117a34:	e3400512 	movt	r0, #1298	; 0x512
 5117a38:	e12fff35 	blx	r5
        ShellCommand *command = shellSeekCommand(shell,
 5117a3c:	e3065aec 	movw	r5, #27372	; 0x6aec
 5117a40:	e3a03000 	mov	r3, #0
 5117a44:	e5941014 	ldr	r1, [r4, #20]
 5117a48:	e3405511 	movt	r5, #1297	; 0x511
 5117a4c:	e5942058 	ldr	r2, [r4, #88]	; 0x58
 5117a50:	e1a00004 	mov	r0, r4
 5117a54:	e12fff35 	blx	r5
        if (command != NULL)
 5117a58:	e2501000 	subs	r1, r0, #0
 5117a5c:	0a000004 	beq	5117a74 <shellExec+0x31c>
            shellRunCommand(shell, command);
 5117a60:	e307360c 	movw	r3, #30220	; 0x760c
 5117a64:	e1a00004 	mov	r0, r4
 5117a68:	e3403511 	movt	r3, #1297	; 0x511
 5117a6c:	e12fff33 	blx	r3
 5117a70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    SHELL_ASSERT(shell->write, return 0);
 5117a74:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5117a78:	e3540000 	cmp	r4, #0
 5117a7c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
 5117a80:	e59f2048 	ldr	r2, [pc, #72]	; 5117ad0 <shellExec+0x378>
 5117a84:	e3a0306f 	mov	r3, #111	; 0x6f
 5117a88:	ea000000 	b	5117a90 <shellExec+0x338>
    while(*p++)
 5117a8c:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5117a90:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117a94:	e3530000 	cmp	r3, #0
        count ++;
 5117a98:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117a9c:	1afffffa 	bne	5117a8c <shellExec+0x334>
    return shell->write((char *)string, count);
 5117aa0:	e30d08b4 	movw	r0, #55476	; 0xd8b4
 5117aa4:	e3400512 	movt	r0, #1298	; 0x512
 5117aa8:	e12fff34 	blx	r4
 5117aac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        shell->parser.length = shell->parser.cursor = 0;
 5117ab0:	e584e00c 	str	lr, [r4, #12]
        if (shell->parser.paramCount == 0)
 5117ab4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    *(dest + count) = 0;
 5117ab8:	e5c12000 	strb	r2, [r1]
    if (shell->history.record >= SHELL_HISTORY_MAX_NUMBER)
 5117abc:	e1d425b2 	ldrh	r2, [r4, #82]	; 0x52
 5117ac0:	eaffff49 	b	51177ec <shellExec+0x94>
 5117ac4:	0512d65d 	.word	0x0512d65d
 5117ac8:	0512d921 	.word	0x0512d921
 5117acc:	0512d3e1 	.word	0x0512d3e1
 5117ad0:	0512d8b5 	.word	0x0512d8b5

05117ad4 <shellEnter>:
    shellExec(shell);
 5117ad4:	e3073758 	movw	r3, #30552	; 0x7758
{
 5117ad8:	e92d4010 	push	{r4, lr}
 5117adc:	e1a04000 	mov	r4, r0
    shellExec(shell);
 5117ae0:	e3403511 	movt	r3, #1297	; 0x511
 5117ae4:	e12fff33 	blx	r3
    if (shell->status.isChecked)
 5117ae8:	e5d41060 	ldrb	r1, [r4, #96]	; 0x60
 5117aec:	e2111001 	ands	r1, r1, #1
 5117af0:	0a000005 	beq	5117b0c <shellEnter+0x38>
 5117af4:	e30530ac 	movw	r3, #20652	; 0x50ac
 5117af8:	e3a01001 	mov	r1, #1
 5117afc:	e1a00004 	mov	r0, r4
 5117b00:	e3403511 	movt	r3, #1297	; 0x511
 5117b04:	e12fff33 	blx	r3
 5117b08:	e8bd8010 	pop	{r4, pc}
    SHELL_ASSERT(shell->write, return 0);
 5117b0c:	e5944068 	ldr	r4, [r4, #104]	; 0x68
 5117b10:	e3540000 	cmp	r4, #0
 5117b14:	08bd8010 	popeq	{r4, pc}
 5117b18:	e59f2028 	ldr	r2, [pc, #40]	; 5117b48 <shellEnter+0x74>
 5117b1c:	e3a0300a 	mov	r3, #10
 5117b20:	ea000000 	b	5117b28 <shellEnter+0x54>
    while(*p++)
 5117b24:	e1f230d1 	ldrsb	r3, [r2, #1]!
        count ++;
 5117b28:	e2811001 	add	r1, r1, #1
    while(*p++)
 5117b2c:	e3530000 	cmp	r3, #0
        count ++;
 5117b30:	e6ff1071 	uxth	r1, r1
    while(*p++)
 5117b34:	1afffffa 	bne	5117b24 <shellEnter+0x50>
    return shell->write((char *)string, count);
 5117b38:	e30d0858 	movw	r0, #55384	; 0xd858
 5117b3c:	e3400512 	movt	r0, #1298	; 0x512
 5117b40:	e12fff34 	blx	r4
}
 5117b44:	e8bd8010 	pop	{r4, pc}
 5117b48:	0512d859 	.word	0x0512d859

05117b4c <shellHandler>:
    SHELL_ASSERT(data, return);
 5117b4c:	e3510000 	cmp	r1, #0
 5117b50:	012fff1e 	bxeq	lr
 5117b54:	e3063700 	movw	r3, #26368	; 0x6700
 5117b58:	e3403511 	movt	r3, #1297	; 0x511
{
 5117b5c:	e92d4010 	push	{r4, lr}
 5117b60:	e12fff33 	blx	r3
}
 5117b64:	e8bd8010 	pop	{r4, pc}

05117b68 <cpu_gicd_set_enable>:
    addr = CPU_GIC_GICD_ISENABLER0_ADDR + (intr_id >> 5 << 2);
    shift = intr_id & 0x1f;
    //data = *((volatile unsigned long*)addr);
    //data = data | (1 << shift);
    //*((volatile unsigned long*)addr) = data;
    REG_WRITE32(addr,(1 << shift));
 5117b68:	e3a03001 	mov	r3, #1
    shift = intr_id & 0x1f;
 5117b6c:	e200101f 	and	r1, r0, #31
    addr = CPU_GIC_GICD_ISENABLER0_ADDR + (intr_id >> 5 << 2);
 5117b70:	e3a02c91 	mov	r2, #37120	; 0x9100
 5117b74:	e1a002a0 	lsr	r0, r0, #5
 5117b78:	e3432120 	movt	r2, #12576	; 0x3120
    REG_WRITE32(addr,(1 << shift));
 5117b7c:	e1a03113 	lsl	r3, r3, r1
 5117b80:	e7823100 	str	r3, [r2, r0, lsl #2]
	
	//hprintf(TSENV, "\nenbale reg 0x%x = 0x%x",addr,REG32(addr));
}
 5117b84:	e12fff1e 	bx	lr

05117b88 <cpu_gicc_get_iar>:
    CPU_GIC_GICC_PMR = priority;
}

unsigned long cpu_gicc_get_iar(void)
{
    return CPU_GIC_GICC_IAR;
 5117b88:	e3a03a0a 	mov	r3, #40960	; 0xa000
 5117b8c:	e3433120 	movt	r3, #12576	; 0x3120
 5117b90:	e593000c 	ldr	r0, [r3, #12]
}
 5117b94:	e12fff1e 	bx	lr

05117b98 <cpu_gicc_set_eoir>:

void cpu_gicc_set_eoir(unsigned long eoi)
{
    CPU_GIC_GICC_EOIR = eoi;
 5117b98:	e3a03a0a 	mov	r3, #40960	; 0xa000
 5117b9c:	e3433120 	movt	r3, #12576	; 0x3120
 5117ba0:	e5830010 	str	r0, [r3, #16]
}
 5117ba4:	e12fff1e 	bx	lr

05117ba8 <cpu_gic_config_nonsecure>:
    CPU_GIC_GICC_PMR = priority;
 5117ba8:	e3a03a0a 	mov	r3, #40960	; 0xa000
 5117bac:	e3a010ff 	mov	r1, #255	; 0xff
    CPU_GIC_GICD_CTLR |= 2;
 5117bb0:	e3a02a09 	mov	r2, #36864	; 0x9000
    CPU_GIC_GICC_PMR = priority;
 5117bb4:	e3433120 	movt	r3, #12576	; 0x3120
    CPU_GIC_GICD_CTLR |= 2;
 5117bb8:	e3432120 	movt	r2, #12576	; 0x3120
    CPU_GIC_GICC_PMR = priority;
 5117bbc:	e5831004 	str	r1, [r3, #4]
    CPU_GIC_GICC_CTLR |= (1 << 10);
 5117bc0:	e5931000 	ldr	r1, [r3]
 5117bc4:	e3811b01 	orr	r1, r1, #1024	; 0x400
 5117bc8:	e5831000 	str	r1, [r3]
    CPU_GIC_GICD_CTLR |= 2;
 5117bcc:	e5921000 	ldr	r1, [r2]
 5117bd0:	e3811002 	orr	r1, r1, #2
 5117bd4:	e5821000 	str	r1, [r2]
    CPU_GIC_GICC_CTLR |= 2;
 5117bd8:	e5931000 	ldr	r1, [r3]
 5117bdc:	e3811002 	orr	r1, r1, #2
 5117be0:	e5831000 	str	r1, [r3]
    CPU_GIC_GICD_CTLR |= 1;
 5117be4:	e5921000 	ldr	r1, [r2]
 5117be8:	e3811001 	orr	r1, r1, #1
 5117bec:	e5821000 	str	r1, [r2]
    CPU_GIC_GICC_CTLR |= (1 << 3) | 1;
 5117bf0:	e5932000 	ldr	r2, [r3]
 5117bf4:	e3822009 	orr	r2, r2, #9
 5117bf8:	e5832000 	str	r2, [r3]
    CPU_GIC_GICC_CTLR &= ~(1<<2);
 5117bfc:	e5932000 	ldr	r2, [r3]
 5117c00:	e3c22004 	bic	r2, r2, #4
 5117c04:	e5832000 	str	r2, [r3]
    
    //fiq enable
    cpu_gicd_enable_grp0();
    cpu_gicc_enable_grp0();   
    cpu_gicc_disable_ackctl();
}
 5117c08:	e12fff1e 	bx	lr

05117c0c <cpu_gic_config>:
}

void cpu_gic_config(isr_cfg_t *irq_cfg)
{
    /*Set gic group*/
    cpu_gicd_set_group(irq_cfg->isrId, irq_cfg->isrGroup);
 5117c0c:	e5903004 	ldr	r3, [r0, #4]
    addr = CPU_GIC_GICD_IGROUPR0_ADDR + (intr_id >> 5 << 2);
 5117c10:	e3091080 	movw	r1, #36992	; 0x9080
    if(group)
 5117c14:	e590200c 	ldr	r2, [r0, #12]
    addr = CPU_GIC_GICD_IGROUPR0_ADDR + (intr_id >> 5 << 2);
 5117c18:	e3431120 	movt	r1, #12576	; 0x3120
{
 5117c1c:	e92d4070 	push	{r4, r5, r6, lr}
    data = (data & ~(0xff << shift)) | ((priority & 0xff) << shift);
 5117c20:	e5d06010 	ldrb	r6, [r0, #16]
    addr = CPU_GIC_GICD_IGROUPR0_ADDR + (intr_id >> 5 << 2);
 5117c24:	e1a0c2a3 	lsr	ip, r3, #5
    if(group)
 5117c28:	e3520000 	cmp	r2, #0
    addr = CPU_GIC_GICD_IGROUPR0_ADDR + (intr_id >> 5 << 2);
 5117c2c:	e081e10c 	add	lr, r1, ip, lsl #2
    data = REG_READ32(addr);
 5117c30:	e791210c 	ldr	r2, [r1, ip, lsl #2]
        data = data | (1 << shift);
 5117c34:	e3a01001 	mov	r1, #1
    addr = CPU_GIC_GICD_ICFGR0_ADDR + (intr_id >> 4 << 2);
 5117c38:	e3a0cb27 	mov	ip, #39936	; 0x9c00
    shift = intr_id & 0x1f;
 5117c3c:	e203401f 	and	r4, r3, #31
        data = data | (1 << shift);
 5117c40:	11822411 	orrne	r2, r2, r1, lsl r4
        data = data & ~(1 << shift);
 5117c44:	01c22411 	biceq	r2, r2, r1, lsl r4
    addr = CPU_GIC_GICD_ICFGR0_ADDR + (intr_id >> 4 << 2);
 5117c48:	e343c120 	movt	ip, #12576	; 0x3120
    REG_WRITE32(addr, data);
 5117c4c:	e58e2000 	str	r2, [lr]
    addr = CPU_GIC_GICD_ICFGR0_ADDR + (intr_id >> 4 << 2);
 5117c50:	e1a04223 	lsr	r4, r3, #4
    data = (data & ~(3 << shift)) | ((control & 3) << shift);
 5117c54:	e3a0e003 	mov	lr, #3
    shift = (intr_id & 0xf) << 1;
 5117c58:	e1a02083 	lsl	r2, r3, #1

    //set level trigger
    cpu_gicd_set_control(irq_cfg->isrId, IS_EDGE(irq_cfg->attr));

    //set isr targets 
    cpu_gicd_set_targets(irq_cfg->isrId, (1 << irq_cfg->isrCoreId));
 5117c5c:	e5905008 	ldr	r5, [r0, #8]
    shift = (intr_id & 0xf) << 1;
 5117c60:	e202101e 	and	r1, r2, #30
    data = REG_READ32(addr);
 5117c64:	e79c2104 	ldr	r2, [ip, r4, lsl #2]
    data = (data & ~(3 << shift)) | ((control & 3) << shift);
 5117c68:	e1c2211e 	bic	r2, r2, lr, lsl r1
    cpu_gicd_set_control(irq_cfg->isrId, IS_EDGE(irq_cfg->attr));
 5117c6c:	e1d0e1b6 	ldrh	lr, [r0, #22]
    cpu_gicd_set_targets(irq_cfg->isrId, (1 << irq_cfg->isrCoreId));
 5117c70:	e3a00001 	mov	r0, #1
    cpu_gicd_set_control(irq_cfg->isrId, IS_EDGE(irq_cfg->attr));
 5117c74:	e20ee003 	and	lr, lr, #3
    data = (data & ~(3 << shift)) | ((control & 3) << shift);
 5117c78:	e182211e 	orr	r2, r2, lr, lsl r1
    addr = CPU_GIC_GICD_ITARGETSR0_ADDR + (intr_id & 0x7fc);
 5117c7c:	e300e7fc 	movw	lr, #2044	; 0x7fc
    cpu_gicd_set_targets(irq_cfg->isrId, (1 << irq_cfg->isrCoreId));
 5117c80:	e1a05510 	lsl	r5, r0, r5
    REG_WRITE32(addr, data);
 5117c84:	e78c2104 	str	r2, [ip, r4, lsl #2]
    addr = CPU_GIC_GICD_ITARGETSR0_ADDR + (intr_id & 0x7fc);
 5117c88:	e3a04b26 	mov	r4, #38912	; 0x9800
 5117c8c:	e00ee003 	and	lr, lr, r3
 5117c90:	e3434120 	movt	r4, #12576	; 0x3120
    shift  = (intr_id & 0x3) << 3;
 5117c94:	e1a02183 	lsl	r2, r3, #3
 5117c98:	e2021018 	and	r1, r2, #24
    data = (data & ~(0xff << shift)) | (targets << shift);
 5117c9c:	e3a020ff 	mov	r2, #255	; 0xff
    addr = CPU_GIC_GICD_IPRIORITYR0_ADDR + (intr_id >> 2 << 2);
 5117ca0:	e3c33003 	bic	r3, r3, #3
    data = REG_READ32(addr);
 5117ca4:	e79e0004 	ldr	r0, [lr, r4]
    data = (data & ~(0xff << shift)) | (targets << shift);
 5117ca8:	e1e0c112 	mvn	ip, r2, lsl r1
 5117cac:	e000000c 	and	r0, r0, ip
 5117cb0:	e1800115 	orr	r0, r0, r5, lsl r1
    REG_WRITE32(addr, data);
 5117cb4:	e78e0004 	str	r0, [lr, r4]
    addr = CPU_GIC_GICD_IPRIORITYR0_ADDR + (intr_id >> 2 << 2);
 5117cb8:	e3a00b25 	mov	r0, #37888	; 0x9400
 5117cbc:	e3430120 	movt	r0, #12576	; 0x3120
    data = REG_READ32(addr);
 5117cc0:	e7932000 	ldr	r2, [r3, r0]
    data = (data & ~(0xff << shift)) | ((priority & 0xff) << shift);
 5117cc4:	e002200c 	and	r2, r2, ip
 5117cc8:	e1822116 	orr	r2, r2, r6, lsl r1
    REG_WRITE32(addr, data);
 5117ccc:	e7832000 	str	r2, [r3, r0]

    /*set isr priority */
    cpu_gicd_set_priority(irq_cfg->isrId, irq_cfg->isrPrio);
}
 5117cd0:	e8bd8070 	pop	{r4, r5, r6, pc}

05117cd4 <ipc_hw_recv_msg_notify>:
			       const rw_msg_t *msg)
{
	rw_msg_t spec_msg;
	int32_t ret = -1;

	if (msg->header.typ != SIMPLE_IPC_CMD_TYPE)
 5117cd4:	e5d23005 	ldrb	r3, [r2, #5]
 5117cd8:	e203300f 	and	r3, r3, #15
 5117cdc:	e353000f 	cmp	r3, #15
{
 5117ce0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 5117ce4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	if (msg->header.typ != SIMPLE_IPC_CMD_TYPE)
 5117ce8:	0a000024 	beq	5117d80 <ipc_hw_recv_msg_notify+0xac>
	{
        if (recv_cb != NULL && g_addr != NULL)
 5117cec:	e3083234 	movw	r3, #33332	; 0x8234
 5117cf0:	e3403513 	movt	r3, #1299	; 0x513
 5117cf4:	e5935000 	ldr	r5, [r3]
 5117cf8:	e3550000 	cmp	r5, #0
 5117cfc:	0a00002a 	beq	5117dac <ipc_hw_recv_msg_notify+0xd8>
 5117d00:	e30831f0 	movw	r3, #33264	; 0x81f0
 5117d04:	e3403513 	movt	r3, #1299	; 0x513
 5117d08:	e5936000 	ldr	r6, [r3]
 5117d0c:	e3560000 	cmp	r6, #0
 5117d10:	0a000025 	beq	5117dac <ipc_hw_recv_msg_notify+0xd8>
        {
			// special case for user defined msg
			if (msg->header.typ == USERDEFINED_IPC_CMD_TYPE && msg->header.cmd == 0xFF)
 5117d14:	e300eaff 	movw	lr, #2815	; 0xaff
 5117d18:	e1d230b4 	ldrh	r3, [r2, #4]
 5117d1c:	e1a0c002 	mov	ip, r2
 5117d20:	e7eb3053 	ubfx	r3, r3, #0, #12
 5117d24:	e153000e 	cmp	r3, lr
 5117d28:	0a000003 	beq	5117d3c <ipc_hw_recv_msg_notify+0x68>
				spec_msg.payload[0] = fid << 4;
				ret = ((recv_ntf)recv_cb)(g_addr, 0, &spec_msg);
			}
			else
			{
				ret = ((recv_ntf)recv_cb)(g_addr, fid, msg);
 5117d2c:	e1a00006 	mov	r0, r6
 5117d30:	e12fff35 	blx	r5
			ret = ((recv_ntf)recv_simple_cb)(g_addr, fid, msg);
        }
    }

    return ret;
}
 5117d34:	e28dd02c 	add	sp, sp, #44	; 0x2c
 5117d38:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
				spec_msg = *msg;
 5117d3c:	e1a0400d 	mov	r4, sp
				spec_msg.payload[0] = fid << 4;
 5117d40:	e1a0e201 	lsl	lr, r1, #4
				spec_msg = *msg;
 5117d44:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
 5117d48:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
 5117d4c:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
				spec_msg.payload[0] = fid << 4;
 5117d50:	e3a07000 	mov	r7, #0
				spec_msg = *msg;
 5117d54:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
 5117d58:	e89c0003 	ldm	ip, {r0, r1}
				ret = ((recv_ntf)recv_cb)(g_addr, 0, &spec_msg);
 5117d5c:	e1a0200d 	mov	r2, sp
				spec_msg = *msg;
 5117d60:	e8840003 	stm	r4, {r0, r1}
				ret = ((recv_ntf)recv_cb)(g_addr, 0, &spec_msg);
 5117d64:	e1a00006 	mov	r0, r6
				spec_msg.payload[0] = fid << 4;
 5117d68:	e58de008 	str	lr, [sp, #8]
				ret = ((recv_ntf)recv_cb)(g_addr, 0, &spec_msg);
 5117d6c:	e1a01007 	mov	r1, r7
				spec_msg.payload[0] = fid << 4;
 5117d70:	e58d700c 	str	r7, [sp, #12]
				ret = ((recv_ntf)recv_cb)(g_addr, 0, &spec_msg);
 5117d74:	e12fff35 	blx	r5
}
 5117d78:	e28dd02c 	add	sp, sp, #44	; 0x2c
 5117d7c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        if(recv_simple_cb != NULL)
 5117d80:	e3083238 	movw	r3, #33336	; 0x8238
 5117d84:	e3403513 	movt	r3, #1299	; 0x513
 5117d88:	e5934000 	ldr	r4, [r3]
 5117d8c:	e3540000 	cmp	r4, #0
 5117d90:	0a000005 	beq	5117dac <ipc_hw_recv_msg_notify+0xd8>
			ret = ((recv_ntf)recv_simple_cb)(g_addr, fid, msg);
 5117d94:	e30831f0 	movw	r3, #33264	; 0x81f0
 5117d98:	e3403513 	movt	r3, #1299	; 0x513
 5117d9c:	e5930000 	ldr	r0, [r3]
 5117da0:	e12fff34 	blx	r4
}
 5117da4:	e28dd02c 	add	sp, sp, #44	; 0x2c
 5117da8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	int32_t ret = -1;
 5117dac:	e3e00000 	mvn	r0, #0
    return ret;
 5117db0:	eaffffdf 	b	5117d34 <ipc_hw_recv_msg_notify+0x60>

05117db4 <ipc_hw_err_msg_notify>:
int32_t ipc_hw_err_msg_notify(const uint8_t endid, const uint8_t fid)
{
#ifdef IPC_STATE_MGT_ENABLE
	// get err msg and call function
	msgbx_err_msg_t err_msg;
	g_hw_ctl_ops.ipc_hw_get_err_msg(endid, fid, &err_msg);
 5117db4:	e30831f4 	movw	r3, #33268	; 0x81f4
 5117db8:	e3403513 	movt	r3, #1299	; 0x513
{
 5117dbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	g_hw_ctl_ops.ipc_hw_get_err_msg(endid, fid, &err_msg);
 5117dc0:	e5933038 	ldr	r3, [r3, #56]	; 0x38
{
 5117dc4:	e24dd00c 	sub	sp, sp, #12
	g_hw_ctl_ops.ipc_hw_get_err_msg(endid, fid, &err_msg);
 5117dc8:	e1a0200d 	mov	r2, sp
 5117dcc:	e12fff33 	blx	r3
	if (err_cb != NULL) {
 5117dd0:	e30831ec 	movw	r3, #33260	; 0x81ec
 5117dd4:	e3403513 	movt	r3, #1299	; 0x513
 5117dd8:	e5932000 	ldr	r2, [r3]
 5117ddc:	e3520000 	cmp	r2, #0
 5117de0:	0a000004 	beq	5117df8 <ipc_hw_err_msg_notify+0x44>
		((err_msg_callback)err_cb)(g_addr, &err_msg);
 5117de4:	e30831f0 	movw	r3, #33264	; 0x81f0
 5117de8:	e1a0100d 	mov	r1, sp
 5117dec:	e3403513 	movt	r3, #1299	; 0x513
 5117df0:	e5930000 	ldr	r0, [r3]
 5117df4:	e12fff32 	blx	r2
	}
#endif
	return 0;
}
 5117df8:	e3a00000 	mov	r0, #0
 5117dfc:	e28dd00c 	add	sp, sp, #12
 5117e00:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

05117e04 <msgbx_isr_process>:
 * 
 * @param intr_state intr status
 * @param fid   filter num
 */
static void msgbx_isr_process(uint32_t fid)
{
 5117e04:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t reg_base = 0;
    uint32_t read_addr = 0;
    uint32_t read_len = 0, i = 0;
    msgbox_data_t *msg_ptr;

    reg_base = MSGBX_BASE_ADDR + (fid * 0x200);
 5117e08:	e2805962 	add	r5, r0, #1605632	; 0x188000
 5117e0c:	e2855c12 	add	r5, r5, #4608	; 0x1200
    if(0 == fid)    /*defaulte filter num */
 5117e10:	e3500000 	cmp	r0, #0
{
 5117e14:	e24dd00c 	sub	sp, sp, #12
    reg_base = MSGBX_BASE_ADDR + (fid * 0x200);
 5117e18:	e1a05485 	lsl	r5, r5, #9
    if(0 == fid)    /*defaulte filter num */
 5117e1c:	0a000035 	beq	5117ef8 <msgbx_isr_process+0xf4>
        /*clean intr status*/
        REG_WRITE32((reg_base+END_STATUSR_OFFSET), reg_data);
    }
    else if(MSGBX_FILTER_END_NUM > fid)
    {
        reg_data = REG_READ32(reg_base + END_FILTER_INTRR_OFFSET);
 5117e20:	e5959138 	ldr	r9, [r5, #312]	; 0x138
        if(reg_data & END_FILTER_INTRR_FILTER_THRS_INTR_U32)
 5117e24:	e1a06000 	mov	r6, r0
 5117e28:	e3190001 	tst	r9, #1
 5117e2c:	0a00002c 	beq	5117ee4 <msgbx_isr_process+0xe0>
        {
            msg_num = REG_READ32(reg_base + END_FILTER_RXFIFO_STATUSR_OFFSET);
 5117e30:	e5958120 	ldr	r8, [r5, #288]	; 0x120
            for (; msg_num > 0; msg_num--)
 5117e34:	e3580000 	cmp	r8, #0
 5117e38:	0a000029 	beq	5117ee4 <msgbx_isr_process+0xe0>
 5117e3c:	e3084240 	movw	r4, #33344	; 0x8240

                    if(!msg_ptr->header.bit.is_64bit) /*32bit system need trans to 64bit system len.*/
                    {
                        recv_msg_data.header.len = (recv_msg_data.header.len >> 1);
                    }
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117e40:	e307acd4 	movw	sl, #31956	; 0x7cd4
 5117e44:	e3404513 	movt	r4, #1299	; 0x513
                read_addr = reg_base + MSGBX_END_DE_RXFIFO_OFFSET;
 5117e48:	e2857801 	add	r7, r5, #65536	; 0x10000
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117e4c:	e340a511 	movt	sl, #1297	; 0x511
 5117e50:	e1a0b004 	mov	fp, r4
 5117e54:	e6ef1070 	uxtb	r1, r0
 5117e58:	ea000005 	b	5117e74 <msgbx_isr_process+0x70>
                read_len = msg_ptr->header.bit.is_64bit ? ((msg_ptr->header.bit.len << 1) + 1) : (msg_ptr->header.bit.len);
 5117e5c:	e1a03083 	lsl	r3, r3, #1
 5117e60:	e2833001 	add	r3, r3, #1
                if(read_len <= MSGBX_PAYLOAD_MAX_LEN)
 5117e64:	e3530009 	cmp	r3, #9
 5117e68:	da00000c 	ble	5117ea0 <msgbx_isr_process+0x9c>
            for (; msg_num > 0; msg_num--)
 5117e6c:	e2588001 	subs	r8, r8, #1
 5117e70:	0a00001b 	beq	5117ee4 <msgbx_isr_process+0xe0>
                msg_ptr->header.data = REG_READ32(read_addr);
 5117e74:	e5972000 	ldr	r2, [r7]
 5117e78:	e5842000 	str	r2, [r4]
                read_len = msg_ptr->header.bit.is_64bit ? ((msg_ptr->header.bit.len << 1) + 1) : (msg_ptr->header.bit.len);
 5117e7c:	e5d43002 	ldrb	r3, [r4, #2]
 5117e80:	e7e72852 	ubfx	r2, r2, #16, #8
 5117e84:	e2122010 	ands	r2, r2, #16
 5117e88:	e203300f 	and	r3, r3, #15
 5117e8c:	1afffff2 	bne	5117e5c <msgbx_isr_process+0x58>
                if(read_len <= MSGBX_PAYLOAD_MAX_LEN)
 5117e90:	e3530009 	cmp	r3, #9
 5117e94:	8afffff4 	bhi	5117e6c <msgbx_isr_process+0x68>
                    for (i = 0; i < read_len; i++)
 5117e98:	e3530000 	cmp	r3, #0
 5117e9c:	0a00005b 	beq	5118010 <msgbx_isr_process+0x20c>
 5117ea0:	e308c240 	movw	ip, #33344	; 0x8240
{
 5117ea4:	e3a00000 	mov	r0, #0
 5117ea8:	e340c513 	movt	ip, #1299	; 0x513
                        msg_ptr->payload[i] = REG_READ32(read_addr);
 5117eac:	e597e000 	ldr	lr, [r7]
                    for (i = 0; i < read_len; i++)
 5117eb0:	e2800001 	add	r0, r0, #1
                        msg_ptr->payload[i] = REG_READ32(read_addr);
 5117eb4:	e5ace004 	str	lr, [ip, #4]!
                    for (i = 0; i < read_len; i++)
 5117eb8:	e1530000 	cmp	r3, r0
 5117ebc:	8afffffa 	bhi	5117eac <msgbx_isr_process+0xa8>
                    if(!msg_ptr->header.bit.is_64bit) /*32bit system need trans to 64bit system len.*/
 5117ec0:	e3520000 	cmp	r2, #0
 5117ec4:	0a000051 	beq	5118010 <msgbx_isr_process+0x20c>
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117ec8:	e1a0200b 	mov	r2, fp
 5117ecc:	e3a00000 	mov	r0, #0
 5117ed0:	e58d1004 	str	r1, [sp, #4]
 5117ed4:	e12fff3a 	blx	sl
 5117ed8:	e59d1004 	ldr	r1, [sp, #4]
            for (; msg_num > 0; msg_num--)
 5117edc:	e2588001 	subs	r8, r8, #1
 5117ee0:	1affffe3 	bne	5117e74 <msgbx_isr_process+0x70>
                }
            }
        }
#ifdef IPC_STATE_MGT_ENABLE 
        if(reg_data & (END_FILTER_INTRR_FILTER_UNDERFLOW_INTR_U32 | 
 5117ee4:	e3190006 	tst	r9, #6
 5117ee8:	1a00003c 	bne	5117fe0 <msgbx_isr_process+0x1dc>
        {
            ipc_hw_err_msg_notify(0,fid);
        }
#endif
        /*clean intr status*/
        REG_WRITE32((reg_base+END_FILTER_STATUSR_OFFSET), reg_data);
 5117eec:	e5859128 	str	r9, [r5, #296]	; 0x128
    }
}
 5117ef0:	e28dd00c 	add	sp, sp, #12
 5117ef4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        reg_data = REG_READ32(reg_base+END_INTRR_OFFSET);
 5117ef8:	e5958068 	ldr	r8, [r5, #104]	; 0x68
        if(reg_data & END_INTRR_DEFAULT_RX_THRS_INTR_U32)
 5117efc:	e3180001 	tst	r8, #1
 5117f00:	0a00002c 	beq	5117fb8 <msgbx_isr_process+0x1b4>
            msg_num = REG_READ32(MSGBX_BASE_ADDR + END_DEFAULT_RXFIFO_STATUSR_OFFSET);
 5117f04:	e3a03000 	mov	r3, #0
 5117f08:	e3433124 	movt	r3, #12580	; 0x3124
 5117f0c:	e5937038 	ldr	r7, [r3, #56]	; 0x38
            for (; msg_num > 0; msg_num--)
 5117f10:	e3570000 	cmp	r7, #0
 5117f14:	0a000027 	beq	5117fb8 <msgbx_isr_process+0x1b4>
 5117f18:	e3084240 	movw	r4, #33344	; 0x8240
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117f1c:	e3079cd4 	movw	r9, #31956	; 0x7cd4
 5117f20:	e3404513 	movt	r4, #1299	; 0x513
                read_addr = reg_base + MSGBX_END_DE_RXFIFO_OFFSET;
 5117f24:	e2856801 	add	r6, r5, #65536	; 0x10000
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117f28:	e1a0a004 	mov	sl, r4
 5117f2c:	e3409511 	movt	r9, #1297	; 0x511
 5117f30:	ea000005 	b	5117f4c <msgbx_isr_process+0x148>
                read_len = msg_ptr->header.bit.is_64bit ? ((msg_ptr->header.bit.len << 1) + 1) : (msg_ptr->header.bit.len);
 5117f34:	e1a03083 	lsl	r3, r3, #1
 5117f38:	e2833001 	add	r3, r3, #1
                if(read_len <= MSGBX_PAYLOAD_MAX_LEN)
 5117f3c:	e3530009 	cmp	r3, #9
 5117f40:	da00000c 	ble	5117f78 <msgbx_isr_process+0x174>
            for (; msg_num > 0; msg_num--)
 5117f44:	e2577001 	subs	r7, r7, #1
 5117f48:	0a00001a 	beq	5117fb8 <msgbx_isr_process+0x1b4>
                msg_ptr->header.data = REG_READ32(read_addr);
 5117f4c:	e5963000 	ldr	r3, [r6]
 5117f50:	e5843000 	str	r3, [r4]
                read_len = msg_ptr->header.bit.is_64bit ? ((msg_ptr->header.bit.len << 1) + 1) : (msg_ptr->header.bit.len);
 5117f54:	e7e73853 	ubfx	r3, r3, #16, #8
 5117f58:	e2131010 	ands	r1, r3, #16
 5117f5c:	e5d43002 	ldrb	r3, [r4, #2]
 5117f60:	e203300f 	and	r3, r3, #15
 5117f64:	1afffff2 	bne	5117f34 <msgbx_isr_process+0x130>
                if(read_len <= MSGBX_PAYLOAD_MAX_LEN)
 5117f68:	e3530009 	cmp	r3, #9
 5117f6c:	8afffff4 	bhi	5117f44 <msgbx_isr_process+0x140>
                    for (i = 0; i < read_len; i++)
 5117f70:	e3530000 	cmp	r3, #0
 5117f74:	0a000014 	beq	5117fcc <msgbx_isr_process+0x1c8>
 5117f78:	e3080240 	movw	r0, #33344	; 0x8240
{
 5117f7c:	e3a02000 	mov	r2, #0
 5117f80:	e3400513 	movt	r0, #1299	; 0x513
                        msg_ptr->payload[i] = REG_READ32(read_addr);
 5117f84:	e596c000 	ldr	ip, [r6]
                    for (i = 0; i < read_len; i++)
 5117f88:	e2822001 	add	r2, r2, #1
                        msg_ptr->payload[i] = REG_READ32(read_addr);
 5117f8c:	e5a0c004 	str	ip, [r0, #4]!
                    for (i = 0; i < read_len; i++)
 5117f90:	e1530002 	cmp	r3, r2
 5117f94:	8afffffa 	bhi	5117f84 <msgbx_isr_process+0x180>
                    if(!msg_ptr->header.bit.is_64bit) /*32bit system need trans to 64bit system len.*/
 5117f98:	e3510000 	cmp	r1, #0
 5117f9c:	0a00000a 	beq	5117fcc <msgbx_isr_process+0x1c8>
                    ipc_hw_recv_msg_notify(0, fid, &recv_msg_data);
 5117fa0:	e3a01000 	mov	r1, #0
 5117fa4:	e1a0200a 	mov	r2, sl
 5117fa8:	e1a00001 	mov	r0, r1
 5117fac:	e12fff39 	blx	r9
            for (; msg_num > 0; msg_num--)
 5117fb0:	e2577001 	subs	r7, r7, #1
 5117fb4:	1affffe4 	bne	5117f4c <msgbx_isr_process+0x148>
        if(reg_data & (END_INTRR_DEFAULT_RX_UNDERFLOW_INTR_U32 | 
 5117fb8:	e3180016 	tst	r8, #22
 5117fbc:	1a00000d 	bne	5117ff8 <msgbx_isr_process+0x1f4>
        REG_WRITE32((reg_base+END_STATUSR_OFFSET), reg_data);
 5117fc0:	e5858058 	str	r8, [r5, #88]	; 0x58
}
 5117fc4:	e28dd00c 	add	sp, sp, #12
 5117fc8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        recv_msg_data.header.len = (recv_msg_data.header.len >> 1);
 5117fcc:	e5d43002 	ldrb	r3, [r4, #2]
 5117fd0:	e7e220d3 	ubfx	r2, r3, #1, #3
 5117fd4:	e7c33012 	bfi	r3, r2, #0, #4
 5117fd8:	e5c43002 	strb	r3, [r4, #2]
 5117fdc:	eaffffef 	b	5117fa0 <msgbx_isr_process+0x19c>
            ipc_hw_err_msg_notify(0,fid);
 5117fe0:	e3073db4 	movw	r3, #32180	; 0x7db4
 5117fe4:	e6ef1076 	uxtb	r1, r6
 5117fe8:	e3a00000 	mov	r0, #0
 5117fec:	e3403511 	movt	r3, #1297	; 0x511
 5117ff0:	e12fff33 	blx	r3
 5117ff4:	eaffffbc 	b	5117eec <msgbx_isr_process+0xe8>
            ipc_hw_err_msg_notify(0,fid);
 5117ff8:	e3a01000 	mov	r1, #0
 5117ffc:	e3073db4 	movw	r3, #32180	; 0x7db4
 5118000:	e1a00001 	mov	r0, r1
 5118004:	e3403511 	movt	r3, #1297	; 0x511
 5118008:	e12fff33 	blx	r3
 511800c:	eaffffeb 	b	5117fc0 <msgbx_isr_process+0x1bc>
                        recv_msg_data.header.len = (recv_msg_data.header.len >> 1);
 5118010:	e5d43002 	ldrb	r3, [r4, #2]
 5118014:	e7e220d3 	ubfx	r2, r3, #1, #3
 5118018:	e7c33012 	bfi	r3, r2, #0, #4
 511801c:	e5c43002 	strb	r3, [r4, #2]
 5118020:	eaffffa8 	b	5117ec8 <msgbx_isr_process+0xc4>

05118024 <msgbx_node_isr_handle>:
 */
void msgbx_node_isr_handle(void *param)
{
    uint32_t int_num = (uint32_t)param;

    switch(int_num)
 5118024:	e2400041 	sub	r0, r0, #65	; 0x41
{
 5118028:	e92d4010 	push	{r4, lr}
 511802c:	e3500003 	cmp	r0, #3
 5118030:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
 5118034:	ea000007 	b	5118058 <msgbx_node_isr_handle+0x34>
 5118038:	05118084 	.word	0x05118084
 511803c:	05118070 	.word	0x05118070
 5118040:	0511805c 	.word	0x0511805c
 5118044:	05118048 	.word	0x05118048
        break;
    case MSGBX_FILTER_2_INTR:
        msgbx_isr_process(2);
        break;
    case MSGBX_FILTER_3_INTR:
        msgbx_isr_process(3);
 5118048:	e3073e04 	movw	r3, #32260	; 0x7e04
 511804c:	e3a00003 	mov	r0, #3
 5118050:	e3403511 	movt	r3, #1297	; 0x511
 5118054:	e12fff33 	blx	r3
        break;
    default:
        break;
    }
}
 5118058:	e8bd8010 	pop	{r4, pc}
        msgbx_isr_process(2);
 511805c:	e3073e04 	movw	r3, #32260	; 0x7e04
 5118060:	e3a00002 	mov	r0, #2
 5118064:	e3403511 	movt	r3, #1297	; 0x511
 5118068:	e12fff33 	blx	r3
        break;
 511806c:	e8bd8010 	pop	{r4, pc}
        msgbx_isr_process(1);
 5118070:	e3073e04 	movw	r3, #32260	; 0x7e04
 5118074:	e3a00001 	mov	r0, #1
 5118078:	e3403511 	movt	r3, #1297	; 0x511
 511807c:	e12fff33 	blx	r3
        break;
 5118080:	e8bd8010 	pop	{r4, pc}
        msgbx_isr_process(0);
 5118084:	e3073e04 	movw	r3, #32260	; 0x7e04
 5118088:	e3a00000 	mov	r0, #0
 511808c:	e3403511 	movt	r3, #1297	; 0x511
 5118090:	e12fff33 	blx	r3
        break;
 5118094:	e8bd8010 	pop	{r4, pc}

05118098 <get_sem_lock>:
uint32 ipc_hw_get_sem_lock(un_sem_id sem_id, un_bank_id bank_id, un_mst_id mst_id)
{
    uint32 data = -1;
    un_reg_sem_u sem_reg;
    
    if (sem_id < SEM_ID_MAX && bank_id < SEM_BANK_ID_MAX && mst_id < SEM_MST_MAX)
 5118098:	e350000f 	cmp	r0, #15
 511809c:	8a000009 	bhi	51180c8 <get_sem_lock+0x30>
    {
        sem_reg.data = IPC_SEM_BASE_ADDR;
 51180a0:	e3a03000 	mov	r3, #0
        sem_reg.bit.sem_id = sem_id;
 51180a4:	e200000f 	and	r0, r0, #15
        sem_reg.data = IPC_SEM_BASE_ADDR;
 51180a8:	e3433010 	movt	r3, #12304	; 0x3010
        sem_reg.bit.sem_id = sem_id;
 51180ac:	e1830100 	orr	r0, r3, r0, lsl #2
 51180b0:	e3800c02 	orr	r0, r0, #512	; 0x200
 51180b4:	e7cf3010 	bfi	r3, r0, #0, #16
        sem_reg.bit.bank_id = bank_id;
        sem_reg.bit.mst_id = mst_id;

        do
        {
            data = REG_READ32(sem_reg.data);
 51180b8:	e5930000 	ldr	r0, [r3]
        } while (data != 0);
 51180bc:	e3500000 	cmp	r0, #0
 51180c0:	1afffffc 	bne	51180b8 <get_sem_lock+0x20>
 51180c4:	e12fff1e 	bx	lr
    uint32 data = -1;
 51180c8:	e3e00000 	mvn	r0, #0
}
 51180cc:	e12fff1e 	bx	lr

051180d0 <release_sem_lock>:
uint32 ipc_hw_release_sem_lock(un_sem_id sem_id, un_bank_id bank_id, un_mst_id mst_id)
{
    uint32 ret = -1;
    un_reg_sem_u sem_reg;

    if (sem_id < SEM_ID_MAX && bank_id < SEM_BANK_ID_MAX && mst_id < SEM_MST_MAX)
 51180d0:	e350000f 	cmp	r0, #15
    {
        sem_reg.data = IPC_SEM_BASE_ADDR;
 51180d4:	93a02000 	movls	r2, #0
        sem_reg.bit.sem_id = sem_id;
 51180d8:	9200300f 	andls	r3, r0, #15
        sem_reg.bit.bank_id = bank_id;
        sem_reg.bit.mst_id = mst_id;

        REG_WRITE32(sem_reg.data, 0x01);
 51180dc:	93a01001 	movls	r1, #1
        sem_reg.data = IPC_SEM_BASE_ADDR;
 51180e0:	93432010 	movtls	r2, #12304	; 0x3010
        sem_reg.bit.mst_id = mst_id;
 51180e4:	93a00000 	movls	r0, #0
        sem_reg.bit.sem_id = sem_id;
 51180e8:	91823103 	orrls	r3, r2, r3, lsl #2
 51180ec:	93833c02 	orrls	r3, r3, #512	; 0x200
 51180f0:	97cf2013 	bfils	r2, r3, #0, #16
    uint32 ret = -1;
 51180f4:	83e00000 	mvnhi	r0, #0
        REG_WRITE32(sem_reg.data, 0x01);
 51180f8:	95821000 	strls	r1, [r2]
}
 51180fc:	e12fff1e 	bx	lr

05118100 <fifo_Init>:
 * @param data  : reference to data buffer.
 * @param size  : size of the fifo.
 * @return uint8 OK if memory allocation succeeds or ERROR if fails.
 */
uint8 fifo_Init(fifo_TypeDef * _fifo, uint8* data, uint32 size)
{
 5118100:	e92d4070 	push	{r4, r5, r6, lr}
    /* check for a valid pointer */
    if (_fifo == NULL)
 5118104:	e2504000 	subs	r4, r0, #0
 5118108:	0a000010 	beq	5118150 <fifo_Init+0x50>
 511810c:	e1a05002 	mov	r5, r2
    {
        return ERROR;
    }
    
    /* if fifo size is null nothing to do */
    if ( size == 0)
 5118110:	e3520000 	cmp	r2, #0
 5118114:	0a00000f 	beq	5118158 <fifo_Init+0x58>
 5118118:	e1a00001 	mov	r0, r1
    }
    else
    {
        /* allocate fifo space. */
        _fifo->baseAddr = data;
        if (_fifo->baseAddr == NULL)
 511811c:	e3510000 	cmp	r1, #0
        _fifo->baseAddr = data;
 5118120:	e584100c 	str	r1, [r4, #12]
        if (_fifo->baseAddr == NULL)
 5118124:	0a000009 	beq	5118150 <fifo_Init+0x50>
            
            return ERROR;
        }
        else
        {
            memset((uint8 *)_fifo->baseAddr, 0x00, sizeof(uint8) * size);
 5118128:	e3093cbb 	movw	r3, #40123	; 0x9cbb
 511812c:	e3a01000 	mov	r1, #0
 5118130:	e3403511 	movt	r3, #1297	; 0x511
 5118134:	e12fff33 	blx	r3
            /* tail = head --> empty fifo */
            _fifo->head = 0;
            _fifo->tail = 0;
            _fifo->size = size;
 5118138:	e5845008 	str	r5, [r4, #8]
            _fifo->head = 0;
 511813c:	e3a03000 	mov	r3, #0
            return OK;
 5118140:	e1a00003 	mov	r0, r3
            _fifo->head = 0;
 5118144:	e5843000 	str	r3, [r4]
            _fifo->tail = 0;
 5118148:	e5843004 	str	r3, [r4, #4]
        }
    }
}
 511814c:	e8bd8070 	pop	{r4, r5, r6, pc}
        return ERROR;
 5118150:	e3a00001 	mov	r0, #1
 5118154:	e8bd8070 	pop	{r4, r5, r6, pc}
        memset((uint8 *)_fifo, 0x00, sizeof(fifo_TypeDef));
 5118158:	e5842000 	str	r2, [r4]
        return ERROR;
 511815c:	e3a00001 	mov	r0, #1
        memset((uint8 *)_fifo, 0x00, sizeof(fifo_TypeDef));
 5118160:	e5842004 	str	r2, [r4, #4]
 5118164:	e5842008 	str	r2, [r4, #8]
 5118168:	e584200c 	str	r2, [r4, #12]
        return ERROR;
 511816c:	e8bd8070 	pop	{r4, r5, r6, pc}

05118170 <fifo_GetLen>:
 * @param _fifo     : reference to _fifo struct.
 * @return uint32   length of the fifo.
 */
uint32 fifo_GetLen(fifo_TypeDef * _fifo)
{
    if (_fifo == NULL)
 5118170:	e3500000 	cmp	r0, #0
    {
        return 0;
    }
    else
    {
        return (_fifo->tail - _fifo->head);
 5118174:	18900009 	ldmne	r0, {r0, r3}
 5118178:	10430000 	subne	r0, r3, r0
    }
}
 511817c:	e12fff1e 	bx	lr

05118180 <fifo_insert>:
{
	uint32 real_len;
	uint32 offset;
	uint32 end;

    if (_fifo != NULL && data != NULL && len != 0)
 5118180:	e3510000 	cmp	r1, #0
 5118184:	13520000 	cmpne	r2, #0
 5118188:	13a03001 	movne	r3, #1
 511818c:	03a03000 	moveq	r3, #0
{
 5118190:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    if (_fifo != NULL && data != NULL && len != 0)
 5118194:	e3500000 	cmp	r0, #0
 5118198:	03a03000 	moveq	r3, #0
 511819c:	12033001 	andne	r3, r3, #1
 51181a0:	e3530000 	cmp	r3, #0
        memcpy(_fifo->baseAddr, data + end, real_len - end);
        _fifo->tail += real_len;
    }
    else
    {
        real_len = 0;
 51181a4:	01a04003 	moveq	r4, r3
    if (_fifo != NULL && data != NULL && len != 0)
 51181a8:	1a000001 	bne	51181b4 <fifo_insert+0x34>
    }

	return real_len;
}
 51181ac:	e1a00004 	mov	r0, r4
 51181b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        offset = _fifo->size - (_fifo->tail - _fifo->head);
 51181b4:	e1a05000 	mov	r5, r0
        memcpy(_fifo->baseAddr + offset, data, end);
 51181b8:	e3098ca1 	movw	r8, #40097	; 0x9ca1
        offset = _fifo->size - (_fifo->tail - _fifo->head);
 51181bc:	e9901001 	ldmib	r0, {r0, ip}
        real_len = MIN_VAL(len, offset);
 51181c0:	e1a06001 	mov	r6, r1
        memcpy(_fifo->baseAddr + offset, data, end);
 51181c4:	e3408511 	movt	r8, #1297	; 0x511
        offset = _fifo->size - (_fifo->tail - _fifo->head);
 51181c8:	e5953000 	ldr	r3, [r5]
 51181cc:	e08c3003 	add	r3, ip, r3
 51181d0:	e0433000 	sub	r3, r3, r0
        real_len = MIN_VAL(len, offset);
 51181d4:	e1530002 	cmp	r3, r2
 51181d8:	31a04003 	movcc	r4, r3
 51181dc:	21a04002 	movcs	r4, r2
        offset = _fifo->tail % _fifo->size;
 51181e0:	e733fc10 	udiv	r3, r0, ip
 51181e4:	e060039c 	mls	r0, ip, r3, r0
        memcpy(_fifo->baseAddr + offset, data, end);
 51181e8:	e595300c 	ldr	r3, [r5, #12]
        end = MIN_VAL(real_len, _fifo->size - offset);
 51181ec:	e04cc000 	sub	ip, ip, r0
 51181f0:	e15c0004 	cmp	ip, r4
 51181f4:	31a0700c 	movcc	r7, ip
 51181f8:	21a07004 	movcs	r7, r4
        memcpy(_fifo->baseAddr + offset, data, end);
 51181fc:	e1a02007 	mov	r2, r7
 5118200:	e0830000 	add	r0, r3, r0
 5118204:	e12fff38 	blx	r8
        memcpy(_fifo->baseAddr, data + end, real_len - end);
 5118208:	e595000c 	ldr	r0, [r5, #12]
 511820c:	e0861007 	add	r1, r6, r7
 5118210:	e0442007 	sub	r2, r4, r7
 5118214:	e12fff38 	blx	r8
        _fifo->tail += real_len;
 5118218:	e5953004 	ldr	r3, [r5, #4]
}
 511821c:	e1a00004 	mov	r0, r4
        _fifo->tail += real_len;
 5118220:	e0833004 	add	r3, r3, r4
 5118224:	e5853004 	str	r3, [r5, #4]
}
 5118228:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

0511822c <fifo_retrieve>:
{
	uint32 real_len = 0;
	uint32 offset;
	uint32 end;
  
    if(_fifo != NULL && data != NULL && len != 0)
 511822c:	e3510000 	cmp	r1, #0
 5118230:	13520000 	cmpne	r2, #0
 5118234:	13a03001 	movne	r3, #1
 5118238:	03a03000 	moveq	r3, #0
{
 511823c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    if(_fifo != NULL && data != NULL && len != 0)
 5118240:	e3500000 	cmp	r0, #0
 5118244:	03a03000 	moveq	r3, #0
 5118248:	12033001 	andne	r3, r3, #1
 511824c:	e3530000 	cmp	r3, #0

        _fifo->head += real_len;
    }
    else
    {
        real_len = 0;
 5118250:	01a04003 	moveq	r4, r3
    if(_fifo != NULL && data != NULL && len != 0)
 5118254:	1a000001 	bne	5118260 <fifo_retrieve+0x34>
    }

    return real_len;
}
 5118258:	e1a00004 	mov	r0, r4
 511825c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        offset = _fifo->tail - _fifo->head;
 5118260:	e590c000 	ldr	ip, [r0]
        real_len = MIN_VAL(len, offset);
 5118264:	e1a05000 	mov	r5, r0
        offset = _fifo->tail - _fifo->head;
 5118268:	e5903004 	ldr	r3, [r0, #4]
 511826c:	e1a06001 	mov	r6, r1
        offset = _fifo->head % _fifo->size;
 5118270:	e5907008 	ldr	r7, [r0, #8]
        memcpy(data, _fifo->baseAddr + offset, end);
 5118274:	e3098ca1 	movw	r8, #40097	; 0x9ca1
 5118278:	e590100c 	ldr	r1, [r0, #12]
        offset = _fifo->tail - _fifo->head;
 511827c:	e043300c 	sub	r3, r3, ip
        real_len = MIN_VAL(len, offset);
 5118280:	e1530002 	cmp	r3, r2
 5118284:	31a04003 	movcc	r4, r3
 5118288:	21a04002 	movcs	r4, r2
        offset = _fifo->head % _fifo->size;
 511828c:	e733f71c 	udiv	r3, ip, r7
        memcpy(data, _fifo->baseAddr + offset, end);
 5118290:	e1a00006 	mov	r0, r6
 5118294:	e3408511 	movt	r8, #1297	; 0x511
        offset = _fifo->head % _fifo->size;
 5118298:	e06cc397 	mls	ip, r7, r3, ip
        end = MIN_VAL(real_len, _fifo->size - offset);
 511829c:	e047700c 	sub	r7, r7, ip
 51182a0:	e1570004 	cmp	r7, r4
 51182a4:	21a07004 	movcs	r7, r4
        memcpy(data, _fifo->baseAddr + offset, end);
 51182a8:	e081100c 	add	r1, r1, ip
 51182ac:	e1a02007 	mov	r2, r7
 51182b0:	e12fff38 	blx	r8
        memcpy(data + end, _fifo->baseAddr, real_len - end);
 51182b4:	e595100c 	ldr	r1, [r5, #12]
 51182b8:	e0860007 	add	r0, r6, r7
 51182bc:	e0442007 	sub	r2, r4, r7
 51182c0:	e12fff38 	blx	r8
        _fifo->head += real_len;
 51182c4:	e5953000 	ldr	r3, [r5]
}
 51182c8:	e1a00004 	mov	r0, r4
        _fifo->head += real_len;
 51182cc:	e0833004 	add	r3, r3, r4
 51182d0:	e5853000 	str	r3, [r5]
}
 51182d4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

051182d8 <delaySoft>:
#include <stddef.h>
#include <stdio.h>
#include "utility_lite.h"

void delaySoft(uint32 loopcnt){
    while (loopcnt-- > 0){
 51182d8:	e3500000 	cmp	r0, #0
 51182dc:	e2400001 	sub	r0, r0, #1
 51182e0:	012fff1e 	bxeq	lr
        __asm__("nop");
 51182e4:	e320f000 	nop	{0}
    while (loopcnt-- > 0){
 51182e8:	e2500001 	subs	r0, r0, #1
 51182ec:	312fff1e 	bxcc	lr
 51182f0:	eafffffb 	b	51182e4 <delaySoft+0xc>

051182f4 <myprintf>:
}

#if (STD_ON == MY_PRINTF_EN)
static unsigned char g_pcOutBuf[MY_PRINTF_BUFF_SIZE]={0};
int myprintf(const char *fmt, ...)
{
 51182f4:	e92d000f 	push	{r0, r1, r2, r3}
 51182f8:	e92d4030 	push	{r4, r5, lr}
    int i;
    int len;
    va_list args;

    va_start(args, fmt);
    len = vsnprintf((char *)g_pcOutBuf,MY_PRINTF_BUFF_SIZE-1,fmt,args);
 51182fc:	e3084268 	movw	r4, #33384	; 0x8268
{
 5118300:	e24dd00c 	sub	sp, sp, #12
    va_start(args, fmt);
 5118304:	e28d301c 	add	r3, sp, #28
    len = vsnprintf((char *)g_pcOutBuf,MY_PRINTF_BUFF_SIZE-1,fmt,args);
 5118308:	e30a58fd 	movw	r5, #43261	; 0xa8fd
 511830c:	e3404513 	movt	r4, #1299	; 0x513
 5118310:	e59d2018 	ldr	r2, [sp, #24]
 5118314:	e30013ff 	movw	r1, #1023	; 0x3ff
 5118318:	e1a00004 	mov	r0, r4
 511831c:	e3405511 	movt	r5, #1297	; 0x511
    va_start(args, fmt);
 5118320:	e58d3004 	str	r3, [sp, #4]
    len = vsnprintf((char *)g_pcOutBuf,MY_PRINTF_BUFF_SIZE-1,fmt,args);
 5118324:	e12fff35 	blx	r5
    va_end(args);
    //for (i = 0; i < strlen((const char *)g_pcOutBuf); i++)
    for (i = 0; i < len; i++)
 5118328:	e3500000 	cmp	r0, #0
 511832c:	da00000d 	ble	5118368 <myprintf+0x74>
            while (REG_READ32(UART0_BASE_ADDR + 0x80) > 250)
 5118330:	e3a02a03 	mov	r2, #12288	; 0x3000
 5118334:	e1a01004 	mov	r1, r4
 5118338:	e084e000 	add	lr, r4, r0
            REG_WRITE32(UART0_BASE_ADDR, c);
 511833c:	e3a0400d 	mov	r4, #13
            while (REG_READ32(UART0_BASE_ADDR + 0x80) > 250)
 5118340:	e3462802 	movt	r2, #26626	; 0x6802
    {
        if ('\n' == g_pcOutBuf[i])
 5118344:	e4d1c001 	ldrb	ip, [r1], #1
 5118348:	e35c000a 	cmp	ip, #10
 511834c:	0a000009 	beq	5118378 <myprintf+0x84>
            while (REG_READ32(UART0_BASE_ADDR + 0x80) > 250)
 5118350:	e5923080 	ldr	r3, [r2, #128]	; 0x80
 5118354:	e35300fa 	cmp	r3, #250	; 0xfa
 5118358:	8afffffc 	bhi	5118350 <myprintf+0x5c>
            REG_WRITE32(UART0_BASE_ADDR, c);
 511835c:	e582c000 	str	ip, [r2]
    for (i = 0; i < len; i++)
 5118360:	e151000e 	cmp	r1, lr
 5118364:	1afffff6 	bne	5118344 <myprintf+0x50>
             test_putc(MY_PRINTF_UART_CH, '\r');
        }
        test_putc(MY_PRINTF_UART_CH, g_pcOutBuf[i]);
    }
    return len;
}
 5118368:	e28dd00c 	add	sp, sp, #12
 511836c:	e8bd4030 	pop	{r4, r5, lr}
 5118370:	e28dd010 	add	sp, sp, #16
 5118374:	e12fff1e 	bx	lr
            while (REG_READ32(UART0_BASE_ADDR + 0x80) > 250)
 5118378:	e5923080 	ldr	r3, [r2, #128]	; 0x80
 511837c:	e35300fa 	cmp	r3, #250	; 0xfa
 5118380:	8afffffc 	bhi	5118378 <myprintf+0x84>
            REG_WRITE32(UART0_BASE_ADDR, c);
 5118384:	e5824000 	str	r4, [r2]
        test_putc(MY_PRINTF_UART_CH, g_pcOutBuf[i]);
 5118388:	e551c001 	ldrb	ip, [r1, #-1]
}
 511838c:	eaffffef 	b	5118350 <myprintf+0x5c>

05118390 <_atoi>:
{
    uint32 uAalue = 0;
	uint32 uHalue = 0U;
    uint8 isHex = 0U;
 
	size_t uTempSize = strlen(lpszHexStr);
 5118390:	e3003331 	movw	r3, #817	; 0x331
{
 5118394:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5118398:	e1a07000 	mov	r7, r0
	size_t uTempSize = strlen(lpszHexStr);
 511839c:	e3403511 	movt	r3, #1297	; 0x511
{
 51183a0:	e1a04001 	mov	r4, r1
	size_t uTempSize = strlen(lpszHexStr);
 51183a4:	e12fff33 	blx	r3
 51183a8:	e1a0e000 	mov	lr, r0
	const char * lpszTempPtr = lpszHexStr;

    if(uTempSize > 0x02U) {
 51183ac:	e3500002 	cmp	r0, #2
 51183b0:	9a000010 	bls	51183f8 <_atoi+0x68>
        if( ('0' == lpszTempPtr[0]) && (('x' == lpszTempPtr[1]) || ('X' == lpszTempPtr[1])) ) {
 51183b4:	e1d720d0 	ldrsb	r2, [r7]
 51183b8:	e3520030 	cmp	r2, #48	; 0x30
 51183bc:	0a000011 	beq	5118408 <_atoi+0x78>
{
 51183c0:	e1a03007 	mov	r3, r7
 51183c4:	e1a0c002 	mov	ip, r2
            uTempSize -= 2U;
        }
    }
    
    if(isHex == 0U) {
        for(int i=0; i<uTempSize; i++) {
 51183c8:	e2671001 	rsb	r1, r7, #1
 51183cc:	ea000004 	b	51183e4 <_atoi+0x54>
            if( (lpszHexStr[i] >= '0')  && (*lpszTempPtr <= '9') ) {
 51183d0:	e3520039 	cmp	r2, #57	; 0x39
 51183d4:	ca000005 	bgt	51183f0 <_atoi+0x60>
        for(int i=0; i<uTempSize; i++) {
 51183d8:	e155000e 	cmp	r5, lr
 51183dc:	2a000030 	bcs	51184a4 <_atoi+0x114>
            if( (lpszHexStr[i] >= '0')  && (*lpszTempPtr <= '9') ) {
 51183e0:	e1f3c0d1 	ldrsb	ip, [r3, #1]!
 51183e4:	e35c002f 	cmp	ip, #47	; 0x2f
        for(int i=0; i<uTempSize; i++) {
 51183e8:	e0815003 	add	r5, r1, r3
            if( (lpszHexStr[i] >= '0')  && (*lpszTempPtr <= '9') ) {
 51183ec:	cafffff7 	bgt	51183d0 <_atoi+0x40>

            }
            else {
                return -1;
 51183f0:	e3e00000 	mvn	r0, #0
    }
 
    *out = uHalue;

	return 0;
}
 51183f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        for(int i=0; i<uTempSize; i++) {
 51183f8:	e3500000 	cmp	r0, #0
 51183fc:	0a000025 	beq	5118498 <_atoi+0x108>
        if( ('0' == lpszTempPtr[0]) && (('x' == lpszTempPtr[1]) || ('X' == lpszTempPtr[1])) ) {
 5118400:	e1d720d0 	ldrsb	r2, [r7]
 5118404:	eaffffed 	b	51183c0 <_atoi+0x30>
 5118408:	e1d730d1 	ldrsb	r3, [r7, #1]
 511840c:	e3c33020 	bic	r3, r3, #32
 5118410:	e3530058 	cmp	r3, #88	; 0x58
 5118414:	1affffe9 	bne	51183c0 <_atoi+0x30>
        if ((*lpszTempPtr >= '0') && (*lpszTempPtr <= '9'))
 5118418:	e1d720d2 	ldrsb	r2, [r7, #2]
            isHex = 1U;
 511841c:	e3a03001 	mov	r3, #1
            uTempSize -= 2U;
 5118420:	e240e002 	sub	lr, r0, #2
            lpszTempPtr += 2U;
 5118424:	e2877002 	add	r7, r7, #2
    while (uTempSize--)
 5118428:	e1a01007 	mov	r1, r7
 511842c:	e3530000 	cmp	r3, #0
 5118430:	13a07010 	movne	r7, #16
 5118434:	e24ee001 	sub	lr, lr, #1
 5118438:	03a0700a 	moveq	r7, #10
 511843c:	e081600e 	add	r6, r1, lr
 5118440:	e3a0e000 	mov	lr, #0
 5118444:	ea000000 	b	511844c <_atoi+0xbc>
        if ((*lpszTempPtr >= '0') && (*lpszTempPtr <= '9'))
 5118448:	e1f120d1 	ldrsb	r2, [r1, #1]!
 511844c:	e6efc072 	uxtb	ip, r2
 5118450:	e24c0030 	sub	r0, ip, #48	; 0x30
            uAalue = *lpszTempPtr - '0';
 5118454:	e2423030 	sub	r3, r2, #48	; 0x30
        if ((*lpszTempPtr >= '0') && (*lpszTempPtr <= '9'))
 5118458:	e3500009 	cmp	r0, #9
        else if ((*lpszTempPtr >= 'a') && (*lpszTempPtr <= 'f'))
 511845c:	e24c5061 	sub	r5, ip, #97	; 0x61
            uAalue = *lpszTempPtr - '0';
 5118460:	e6af3073 	sxtb	r3, r3
        if ((*lpszTempPtr >= '0') && (*lpszTempPtr <= '9'))
 5118464:	9a000008 	bls	511848c <_atoi+0xfc>
            uAalue = *lpszTempPtr - 'A' + 10;
 5118468:	e2423037 	sub	r3, r2, #55	; 0x37
        else if ((*lpszTempPtr >= 'a') && (*lpszTempPtr <= 'f'))
 511846c:	e3550005 	cmp	r5, #5
            uAalue = *lpszTempPtr - 'a' + 10;
 5118470:	e2422057 	sub	r2, r2, #87	; 0x57
            uAalue = *lpszTempPtr - 'A' + 10;
 5118474:	e6af3073 	sxtb	r3, r3
        else if ((*lpszTempPtr >= 'A') && (*lpszTempPtr <= 'F'))
 5118478:	e24cc041 	sub	ip, ip, #65	; 0x41
            uAalue = *lpszTempPtr - 'a' + 10;
 511847c:	96af3072 	sxtbls	r3, r2
        else if ((*lpszTempPtr >= 'a') && (*lpszTempPtr <= 'f'))
 5118480:	9a000001 	bls	511848c <_atoi+0xfc>
        else if ((*lpszTempPtr >= 'A') && (*lpszTempPtr <= 'F'))
 5118484:	e35c0005 	cmp	ip, #5
 5118488:	8affffd8 	bhi	51183f0 <_atoi+0x60>
    while (uTempSize--)
 511848c:	e1560001 	cmp	r6, r1
        uHalue += uAalue;
 5118490:	e02e379e 	mla	lr, lr, r7, r3
    while (uTempSize--)
 5118494:	1affffeb 	bne	5118448 <_atoi+0xb8>
    *out = uHalue;
 5118498:	e584e000 	str	lr, [r4]
	return 0;
 511849c:	e3a00000 	mov	r0, #0
 51184a0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 51184a4:	e3a03000 	mov	r3, #0
 51184a8:	eaffffde 	b	5118428 <_atoi+0x98>

051184ac <Det_ReportError>:
/*******************************************************************************************************************/


FUNC(Std_ReturnType, DET_CODE) Det_ReportError(VAR(uint16, AUTOMATIC) ModuleId, VAR(uint8, AUTOMATIC) InstanceId, VAR(uint8, AUTOMATIC) ApiId, VAR(uint8, AUTOMATIC) ErrorId)
{ 
    Det_ModuleId = ModuleId; 
 51184ac:	e308c66c 	movw	ip, #34412	; 0x866c
 51184b0:	e340c513 	movt	ip, #1299	; 0x513
 51184b4:	e1cc00b0 	strh	r0, [ip]
    Det_InstanceId = InstanceId;
 51184b8:	e308c66a 	movw	ip, #34410	; 0x866a
    Det_ApiId = ApiId; 
 51184bc:	e3080668 	movw	r0, #34408	; 0x8668
    Det_InstanceId = InstanceId;
 51184c0:	e340c513 	movt	ip, #1299	; 0x513
    Det_ApiId = ApiId; 
 51184c4:	e3400513 	movt	r0, #1299	; 0x513
    Det_InstanceId = InstanceId;
 51184c8:	e5cc1000 	strb	r1, [ip]
    Det_ErrorId = ErrorId;
 51184cc:	e3081669 	movw	r1, #34409	; 0x8669
    Det_ApiId = ApiId; 
 51184d0:	e5c02000 	strb	r2, [r0]
    Det_ErrorId = ErrorId;
 51184d4:	e3401513 	movt	r1, #1299	; 0x513

    return E_OK;
}
 51184d8:	e3a00000 	mov	r0, #0
    Det_ErrorId = ErrorId;
 51184dc:	e5c13000 	strb	r3, [r1]
}
 51184e0:	e12fff1e 	bx	lr

051184e4 <Uart0_IRQHandler>:
 *  \note       -
 *********************************************************************************************************************/
FUNC(void, UART_CODE) Uart0_IRQHandler(void *param)
{
    uint32 TempReg = 0;
    TempReg = Uart_HwModuleAddr[LSP0_UART0]->FCR_IIR.IIR & 0x0F;
 51184e4:	e3a03a03 	mov	r3, #12288	; 0x3000
 51184e8:	e3463802 	movt	r3, #26626	; 0x6802
{
 51184ec:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    TempReg = Uart_HwModuleAddr[LSP0_UART0]->FCR_IIR.IIR & 0x0F;
 51184f0:	e5933008 	ldr	r3, [r3, #8]

    if(TempReg == RECEIVED_DATA_AVAILABLE || TempReg == CHARACTER_TIMEOUT)
 51184f4:	e2032007 	and	r2, r3, #7
 51184f8:	e3520004 	cmp	r2, #4
 51184fc:	0a000036 	beq	51185dc <Uart0_IRQHandler+0xf8>
    TempReg = Uart_HwModuleAddr[LSP0_UART0]->FCR_IIR.IIR & 0x0F;
 5118500:	e203300f 	and	r3, r3, #15
    {
        UART_DRV_RxIrqHandler(LSP0_UART0);
    }
    else if(TempReg == THR_EMPTY)
 5118504:	e3530002 	cmp	r3, #2
 5118508:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
    uint8 Channel = 0;
    uint16 TxFifoLevel;


    /*find channel for hwunit*/
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 511850c:	e3083694 	movw	r3, #34452	; 0x8694
 5118510:	e3403513 	movt	r3, #1299	; 0x513
 5118514:	e5933000 	ldr	r3, [r3]
 5118518:	e5d34004 	ldrb	r4, [r3, #4]
 511851c:	e3540000 	cmp	r4, #0
 5118520:	0a0000a1 	beq	51187ac <Uart0_IRQHandler+0x2c8>
    {
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 5118524:	e593c000 	ldr	ip, [r3]
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 5118528:	e3a02000 	mov	r2, #0
 511852c:	e1a0300c 	mov	r3, ip
 5118530:	ea000002 	b	5118540 <Uart0_IRQHandler+0x5c>
 5118534:	e6ef2070 	uxtb	r2, r0
 5118538:	e1520004 	cmp	r2, r4
 511853c:	0a00007e 	beq	511873c <Uart0_IRQHandler+0x258>
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 5118540:	e5d31008 	ldrb	r1, [r3, #8]
 5118544:	e1a07003 	mov	r7, r3
 5118548:	e3510000 	cmp	r1, #0
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 511854c:	e2820001 	add	r0, r2, #1
 5118550:	e2833020 	add	r3, r3, #32
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 5118554:	1afffff6 	bne	5118534 <Uart0_IRQHandler+0x50>
        {
            break;
        }
    }
    ChannelInfoPtr = &Uart_ChannelInfo[Channel];
 5118558:	e1a04002 	mov	r4, r2
    ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);

    if(ChannelInfoPtr->TxBuffPtr == NULL_PTR)
 511855c:	e3086670 	movw	r6, #34416	; 0x8670
 5118560:	e0842184 	add	r2, r4, r4, lsl #3
 5118564:	e3406513 	movt	r6, #1299	; 0x513
 5118568:	e0862102 	add	r2, r6, r2, lsl #2
 511856c:	e1a08184 	lsl	r8, r4, #3
 5118570:	e5923004 	ldr	r3, [r2, #4]
 5118574:	e3530000 	cmp	r3, #0
 5118578:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
    {
        return;
    }
    /* Update the internal state */
    if (ChannelConfigPtr->DataLength == UART_8_BITS_PER_CHAR)
 511857c:	e5d7300a 	ldrb	r3, [r7, #10]
 5118580:	e3530003 	cmp	r3, #3
    else
    {

    }
    /* Finish reception if this was the last byte received */
    if (ChannelInfoPtr->TxDataLeft == 0U)
 5118584:	11d2e1ba 	ldrhne	lr, [r2, #26]
    if (ChannelConfigPtr->DataLength == UART_8_BITS_PER_CHAR)
 5118588:	0a00006e 	beq	5118748 <Uart0_IRQHandler+0x264>
    if (ChannelInfoPtr->TxDataLeft == 0U)
 511858c:	e35e0000 	cmp	lr, #0
 5118590:	030d5b40 	movweq	r5, #56128	; 0xdb40
 5118594:	03405512 	movteq	r5, #1298	; 0x512
 5118598:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
    {
        /* Invoke callback if there is one */
        if (ChannelConfigPtr->UartNotif.UartTransmitNotifPtr != 0)
 511859c:	e5973010 	ldr	r3, [r7, #16]
 51185a0:	e3530000 	cmp	r3, #0
 51185a4:	0a000001 	beq	51185b0 <Uart0_IRQHandler+0xcc>
        {
            ChannelConfigPtr->UartNotif.UartTransmitNotifPtr(UART_E_NO_ERR);
 51185a8:	e3a00000 	mov	r0, #0
 51185ac:	e12fff33 	blx	r3
        }
        Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER &= (~(0x01<<1));
 51185b0:	e5d73008 	ldrb	r3, [r7, #8]
 51185b4:	e7951103 	ldr	r1, [r5, r3, lsl #2]
        ChannelInfoPtr->TxBuffPtr = NULL_PTR;
 51185b8:	e3a00000 	mov	r0, #0
 51185bc:	e0882004 	add	r2, r8, r4
        Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER &= (~(0x01<<1));
 51185c0:	e5913004 	ldr	r3, [r1, #4]
        ChannelInfoPtr->TxBuffPtr = NULL_PTR;
 51185c4:	e0866102 	add	r6, r6, r2, lsl #2
 51185c8:	e5860004 	str	r0, [r6, #4]
        Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER &= (~(0x01<<1));
 51185cc:	e3c33002 	bic	r3, r3, #2
        /* Set Uart channel state to init */
        ChannelInfoPtr->ChanTxState = UART_TX_IDLE;
 51185d0:	e5c60018 	strb	r0, [r6, #24]
        Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER &= (~(0x01<<1));
 51185d4:	e5813004 	str	r3, [r1, #4]
}
 51185d8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 51185dc:	e3083694 	movw	r3, #34452	; 0x8694
 51185e0:	e3403513 	movt	r3, #1299	; 0x513
 51185e4:	e5933000 	ldr	r3, [r3]
 51185e8:	e5d34004 	ldrb	r4, [r3, #4]
 51185ec:	e3540000 	cmp	r4, #0
 51185f0:	0a00006b 	beq	51187a4 <Uart0_IRQHandler+0x2c0>
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 51185f4:	e593e000 	ldr	lr, [r3]
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 51185f8:	e3a02000 	mov	r2, #0
 51185fc:	e1a0300e 	mov	r3, lr
 5118600:	ea000002 	b	5118610 <Uart0_IRQHandler+0x12c>
 5118604:	e6ef2070 	uxtb	r2, r0
 5118608:	e1520004 	cmp	r2, r4
 511860c:	0a000021 	beq	5118698 <Uart0_IRQHandler+0x1b4>
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 5118610:	e5d31008 	ldrb	r1, [r3, #8]
 5118614:	e1a0c003 	mov	ip, r3
 5118618:	e3510000 	cmp	r1, #0
    for(Channel = 0; Channel < Uart_ConfigPtr->NoOfChannels; Channel++)
 511861c:	e2820001 	add	r0, r2, #1
 5118620:	e2833020 	add	r3, r3, #32
        if(Uart_ConfigPtr->ChannelConfigPtr[Channel].HwModule == HWuint)
 5118624:	1afffff6 	bne	5118604 <Uart0_IRQHandler+0x120>
    ChannelInfoPtr = &Uart_ChannelInfo[Channel];
 5118628:	e1a04002 	mov	r4, r2
    if (ChannelConfigPtr->DataLength == UART_8_BITS_PER_CHAR)
 511862c:	e5dc300a 	ldrb	r3, [ip, #10]
 5118630:	e3530003 	cmp	r3, #3
 5118634:	0a00001c 	beq	51186ac <Uart0_IRQHandler+0x1c8>
        ChannelInfoPtr->RxBuffPtr = &ChannelInfoPtr->RxBuffPtr[2];
 5118638:	e3086670 	movw	r6, #34416	; 0x8670
 511863c:	e0843184 	add	r3, r4, r4, lsl #3
 5118640:	e3406513 	movt	r6, #1299	; 0x513
 5118644:	e1a02103 	lsl	r2, r3, #2
 5118648:	e0863103 	add	r3, r6, r3, lsl #2
        ChannelInfoPtr->RxDataLeft -= 2U;
 511864c:	e1d301bc 	ldrh	r0, [r3, #28]
 5118650:	e2400002 	sub	r0, r0, #2
        ChannelInfoPtr->RxBuffPtr = &ChannelInfoPtr->RxBuffPtr[2];
 5118654:	e1a07184 	lsl	r7, r4, #3
        ChannelInfoPtr->RxDataLeft -= 2U;
 5118658:	e6ff0070 	uxth	r0, r0
 511865c:	e1c301bc 	strh	r0, [r3, #28]
        ChannelInfoPtr->RxBuffPtr = &ChannelInfoPtr->RxBuffPtr[2];
 5118660:	e7963002 	ldr	r3, [r6, r2]
 5118664:	e2833002 	add	r3, r3, #2
 5118668:	e7863002 	str	r3, [r6, r2]
    if (ChannelInfoPtr->RxDataLeft == 0U)
 511866c:	e3500000 	cmp	r0, #0
 5118670:	18bd87f0 	popne	{r4, r5, r6, r7, r8, r9, sl, pc}
        if (ChannelConfigPtr->UartNotif.UartReceiveNotifPtr != 0)
 5118674:	e59c3014 	ldr	r3, [ip, #20]
 5118678:	e3530000 	cmp	r3, #0
 511867c:	0a000000 	beq	5118684 <Uart0_IRQHandler+0x1a0>
            ChannelConfigPtr->UartNotif.UartReceiveNotifPtr(UART_E_NO_ERR);
 5118680:	e12fff33 	blx	r3
		ChannelInfoPtr->RxDataLeft = ChannelInfoPtr->RxDataLen;
 5118684:	e0872004 	add	r2, r7, r4
 5118688:	e0866102 	add	r6, r6, r2, lsl #2
 511868c:	e596300c 	ldr	r3, [r6, #12]
 5118690:	e1c631bc 	strh	r3, [r6, #28]
 5118694:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 5118698:	e1a04002 	mov	r4, r2
 511869c:	e08ec282 	add	ip, lr, r2, lsl #5
    if (ChannelConfigPtr->DataLength == UART_8_BITS_PER_CHAR)
 51186a0:	e5dc300a 	ldrb	r3, [ip, #10]
 51186a4:	e3530003 	cmp	r3, #3
 51186a8:	1affffe2 	bne	5118638 <Uart0_IRQHandler+0x154>
 51186ac:	e3086670 	movw	r6, #34416	; 0x8670
                offset = ChannelInfoPtr->RxWritePointer;
 51186b0:	e0843184 	add	r3, r4, r4, lsl #3
 51186b4:	e30d5b40 	movw	r5, #56128	; 0xdb40
 51186b8:	e3406513 	movt	r6, #1299	; 0x513
 51186bc:	e3a01c01 	mov	r1, #256	; 0x100
 51186c0:	e3405512 	movt	r5, #1298	; 0x512
 51186c4:	e0863103 	add	r3, r6, r3, lsl #2
                    ChannelInfoPtr->RxWritePointer = 0;
 51186c8:	e3a09000 	mov	r9, #0
 51186cc:	e1a07184 	lsl	r7, r4, #3
 51186d0:	ea00000e 	b	5118710 <Uart0_IRQHandler+0x22c>
                offset = ChannelInfoPtr->RxWritePointer;
 51186d4:	e593e010 	ldr	lr, [r3, #16]
                --ChannelInfoPtr->RxDataLeft;
 51186d8:	e1d301bc 	ldrh	r0, [r3, #28]
                rxData = (Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.RBR);
 51186dc:	e5928000 	ldr	r8, [r2]
                --ChannelInfoPtr->RxDataLeft;
 51186e0:	e2400001 	sub	r0, r0, #1
                if(ChannelInfoPtr->RxWritePointer >= ChannelInfoPtr->RxDataLen)
 51186e4:	e593a00c 	ldr	sl, [r3, #12]
                ChannelInfoPtr->RxWritePointer++;
 51186e8:	e28e2001 	add	r2, lr, #1
                --ChannelInfoPtr->RxDataLeft;
 51186ec:	e6ff0070 	uxth	r0, r0
                    ChannelInfoPtr->RxWritePointer = 0;
 51186f0:	e152000a 	cmp	r2, sl
                rxData = (Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.RBR);
 51186f4:	e593a000 	ldr	sl, [r3]
                    ChannelInfoPtr->RxWritePointer = 0;
 51186f8:	21a02009 	movcs	r2, r9
                rxData = (Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.RBR);
 51186fc:	e7ca800e 	strb	r8, [sl, lr]
        for(RxFifoLevel = 0; RxFifoLevel < UART_RX_HW_FIFO_SIZE; RxFifoLevel++)
 5118700:	e3510000 	cmp	r1, #0
                --ChannelInfoPtr->RxDataLeft;
 5118704:	e1c301bc 	strh	r0, [r3, #28]
                    ChannelInfoPtr->RxWritePointer = 0;
 5118708:	e5832010 	str	r2, [r3, #16]
        for(RxFifoLevel = 0; RxFifoLevel < UART_RX_HW_FIFO_SIZE; RxFifoLevel++)
 511870c:	0affffd6 	beq	511866c <Uart0_IRQHandler+0x188>
            if((Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->USR & BIT3) == BIT3)
 5118710:	e5dc2008 	ldrb	r2, [ip, #8]
 5118714:	e7952102 	ldr	r2, [r5, r2, lsl #2]
        for(RxFifoLevel = 0; RxFifoLevel < UART_RX_HW_FIFO_SIZE; RxFifoLevel++)
 5118718:	e2411001 	sub	r1, r1, #1
            if((Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->USR & BIT3) == BIT3)
 511871c:	e592007c 	ldr	r0, [r2, #124]	; 0x7c
        for(RxFifoLevel = 0; RxFifoLevel < UART_RX_HW_FIFO_SIZE; RxFifoLevel++)
 5118720:	e6ff1071 	uxth	r1, r1
            if((Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->USR & BIT3) == BIT3)
 5118724:	e3100008 	tst	r0, #8
 5118728:	1affffe9 	bne	51186d4 <Uart0_IRQHandler+0x1f0>
    if (ChannelInfoPtr->RxDataLeft == 0U)
 511872c:	e0873004 	add	r3, r7, r4
 5118730:	e0863103 	add	r3, r6, r3, lsl #2
 5118734:	e1d301bc 	ldrh	r0, [r3, #28]
 5118738:	eaffffcb 	b	511866c <Uart0_IRQHandler+0x188>
    ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 511873c:	e1a04002 	mov	r4, r2
 5118740:	e08c7282 	add	r7, ip, r2, lsl #5
 5118744:	eaffff84 	b	511855c <Uart0_IRQHandler+0x78>
            if (ChannelInfoPtr->TxDataLeft != 0U)
 5118748:	e1d231ba 	ldrh	r3, [r2, #26]
 511874c:	e30d5b40 	movw	r5, #56128	; 0xdb40
 5118750:	e243e080 	sub	lr, r3, #128	; 0x80
 5118754:	e3405512 	movt	r5, #1298	; 0x512
 5118758:	e6ffe07e 	uxth	lr, lr
 511875c:	ea00000b 	b	5118790 <Uart0_IRQHandler+0x2ac>
                if((Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->USR & BIT1) == BIT1)
 5118760:	e5d71008 	ldrb	r1, [r7, #8]
 5118764:	e7950101 	ldr	r0, [r5, r1, lsl #2]
 5118768:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
 511876c:	e3110002 	tst	r1, #2
 5118770:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
                    Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.THR = *ChannelInfoPtr->TxBuffPtr;
 5118774:	e5921004 	ldr	r1, [r2, #4]
        for(TxFifoLevel = 0; TxFifoLevel < UART_TX_HW_FIFO_SIZE/2; TxFifoLevel++)
 5118778:	e15e0003 	cmp	lr, r3
                    Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.THR = *ChannelInfoPtr->TxBuffPtr;
 511877c:	e4d1c001 	ldrb	ip, [r1], #1
                    --ChannelInfoPtr->TxDataLeft;
 5118780:	e1c231ba 	strh	r3, [r2, #26]
                    Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.THR = *ChannelInfoPtr->TxBuffPtr;
 5118784:	e580c000 	str	ip, [r0]
                    ++ChannelInfoPtr->TxBuffPtr;
 5118788:	e5821004 	str	r1, [r2, #4]
        for(TxFifoLevel = 0; TxFifoLevel < UART_TX_HW_FIFO_SIZE/2; TxFifoLevel++)
 511878c:	0affff7e 	beq	511858c <Uart0_IRQHandler+0xa8>
            if (ChannelInfoPtr->TxDataLeft != 0U)
 5118790:	e3530000 	cmp	r3, #0
                    --ChannelInfoPtr->TxDataLeft;
 5118794:	e2433001 	sub	r3, r3, #1
 5118798:	e6ff3073 	uxth	r3, r3
            if (ChannelInfoPtr->TxDataLeft != 0U)
 511879c:	1affffef 	bne	5118760 <Uart0_IRQHandler+0x27c>
 51187a0:	eaffff7d 	b	511859c <Uart0_IRQHandler+0xb8>
    ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 51187a4:	e593c000 	ldr	ip, [r3]
 51187a8:	eaffff9f 	b	511862c <Uart0_IRQHandler+0x148>
 51187ac:	e5937000 	ldr	r7, [r3]
 51187b0:	eaffff69 	b	511855c <Uart0_IRQHandler+0x78>

051187b4 <Uart_IsrTransmit>:
    switch (HwUnit)
 51187b4:	e3500000 	cmp	r0, #0
 51187b8:	112fff1e 	bxne	lr
        Uart0_IRQHandler((void *)LSP0_UART0);
 51187bc:	e30834e4 	movw	r3, #34020	; 0x84e4
 51187c0:	e3403511 	movt	r3, #1297	; 0x511
{
 51187c4:	e92d4010 	push	{r4, lr}
        Uart0_IRQHandler((void *)LSP0_UART0);
 51187c8:	e12fff33 	blx	r3
}
 51187cc:	e8bd8010 	pop	{r4, pc}

051187d0 <Uart_Init>:
**                                                                            **
** Description     : Uart driver Initialization function. Function initialize **
**                   all Uart configured channels.                            **
*******************************************************************************/
FUNC(void, UART_CODE) Uart_Init(P2CONST(Uart_ConfigType, AUTOMATIC, UART_APPL_DATA) ConfigPtr)
{
 51187d0:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    Uart_ChannelInfoType *ChannelInfoPtr;
    const Uart_ChannelConfigType *ChannelConfigPtr;
    uint8 ChannelCounter;
    uint8 MaxChannel;
    volatile uint32 TempReg = 0;
 51187d4:	e3a0c000 	mov	ip, #0
{
 51187d8:	e24dd00c 	sub	sp, sp, #12
#if (UART_DEV_ERROR_DETECT == STD_ON)
    if (NULL_PTR != ConfigPtr)
 51187dc:	e2501000 	subs	r1, r0, #0
    volatile uint32 TempReg = 0;
 51187e0:	e58dc004 	str	ip, [sp, #4]
    if (NULL_PTR != ConfigPtr)
 51187e4:	0a000065 	beq	5118980 <Uart_Init+0x1b0>
#endif
    {
        MaxChannel = ConfigPtr->NoOfChannels;
 51187e8:	e5d10004 	ldrb	r0, [r1, #4]
        for (ChannelCounter = 0; ChannelCounter < MaxChannel; ChannelCounter++)
 51187ec:	e150000c 	cmp	r0, ip
 51187f0:	0a000059 	beq	511895c <Uart_Init+0x18c>
 51187f4:	e5912000 	ldr	r2, [r1]
 51187f8:	e2400001 	sub	r0, r0, #1
 51187fc:	e3084670 	movw	r4, #34416	; 0x8670
 5118800:	e30d6b40 	movw	r6, #56128	; 0xdb40
 5118804:	e6ef0070 	uxtb	r0, r0
 5118808:	e2825020 	add	r5, r2, #32
 511880c:	e3404513 	movt	r4, #1299	; 0x513
 5118810:	e0850280 	add	r0, r5, r0, lsl #5
            TempReg |= ((TempReg & ~0x30) | (((uint32)ChannelConfigPtr->TxFifoTrigger & 0x03) << 4)); /*Set tx fifo trigger*/
            TempReg |= ((TempReg & ~0xC0) | (((uint32)ChannelConfigPtr->RxFifoTrigger & 0x03) << 6)); /*Set rx fifo trigger*/
            TempReg |= 0x01;                                                                          /*enable fifo*/
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->FCR_IIR.FCR = TempReg;

            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->MCR = 2; /*disable flow ctrl*/
 5118814:	e3a07002 	mov	r7, #2
 5118818:	e3406512 	movt	r6, #1298	; 0x512
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER = 0; /*disable interrupt*/
 511881c:	e5d23008 	ldrb	r3, [r2, #8]
 5118820:	e7963103 	ldr	r3, [r6, r3, lsl #2]
 5118824:	e583c004 	str	ip, [r3, #4]
        for (ChannelCounter = 0; ChannelCounter < MaxChannel; ChannelCounter++)
 5118828:	e2844024 	add	r4, r4, #36	; 0x24
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->FCR_IIR.FCR = 0; /*disable fifo*/
 511882c:	e583c008 	str	ip, [r3, #8]
            TempReg |= ((TempReg & ~0x30) | (((uint32)ChannelConfigPtr->TxFifoTrigger & 0x03) << 4)); /*Set tx fifo trigger*/
 5118830:	e5d2e00e 	ldrb	lr, [r2, #14]
            TempReg = 0x00;
 5118834:	e58dc004 	str	ip, [sp, #4]
            TempReg |= ((TempReg & ~0x30) | (((uint32)ChannelConfigPtr->TxFifoTrigger & 0x03) << 4)); /*Set tx fifo trigger*/
 5118838:	e1a0e20e 	lsl	lr, lr, #4
 511883c:	e59d8004 	ldr	r8, [sp, #4]
 5118840:	e20ee030 	and	lr, lr, #48	; 0x30
 5118844:	e59d9004 	ldr	r9, [sp, #4]
 5118848:	e3c88030 	bic	r8, r8, #48	; 0x30
 511884c:	e1888009 	orr	r8, r8, r9
 5118850:	e18ee008 	orr	lr, lr, r8
 5118854:	e58de004 	str	lr, [sp, #4]
            TempReg |= ((TempReg & ~0xC0) | (((uint32)ChannelConfigPtr->RxFifoTrigger & 0x03) << 6)); /*Set rx fifo trigger*/
 5118858:	e5d2e00f 	ldrb	lr, [r2, #15]
 511885c:	e59d8004 	ldr	r8, [sp, #4]
 5118860:	e1a0e30e 	lsl	lr, lr, #6
 5118864:	e59d9004 	ldr	r9, [sp, #4]
 5118868:	e3c880c0 	bic	r8, r8, #192	; 0xc0
 511886c:	e1888009 	orr	r8, r8, r9
 5118870:	e6efe07e 	uxtb	lr, lr
 5118874:	e18ee008 	orr	lr, lr, r8
 5118878:	e58de004 	str	lr, [sp, #4]
            TempReg |= 0x01;                                                                          /*enable fifo*/
 511887c:	e59de004 	ldr	lr, [sp, #4]
 5118880:	e38ee001 	orr	lr, lr, #1
 5118884:	e58de004 	str	lr, [sp, #4]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->FCR_IIR.FCR = TempReg;
 5118888:	e59de004 	ldr	lr, [sp, #4]
 511888c:	e583e008 	str	lr, [r3, #8]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->MCR = 2; /*disable flow ctrl*/
 5118890:	e5837010 	str	r7, [r3, #16]

            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR = (Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR | (0x1 << 7));    /*enable access DLL & DLH*/
 5118894:	e593e00c 	ldr	lr, [r3, #12]
 5118898:	e38ee080 	orr	lr, lr, #128	; 0x80
 511889c:	e583e00c 	str	lr, [r3, #12]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.DLL = (ChannelConfigPtr->DivInteger & 0xFF);                    /*set baud rate*/
 51188a0:	e592e000 	ldr	lr, [r2]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.DLH = ((ChannelConfigPtr->DivInteger >> 8) & 0xFF);                 /*set baud rate*/
 51188a4:	e7e7845e 	ubfx	r8, lr, #8, #8
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->RBR_DLL_THR.DLL = (ChannelConfigPtr->DivInteger & 0xFF);                    /*set baud rate*/
 51188a8:	e6efe07e 	uxtb	lr, lr
 51188ac:	e583e000 	str	lr, [r3]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.DLH = ((ChannelConfigPtr->DivInteger >> 8) & 0xFF);                 /*set baud rate*/
 51188b0:	e5838004 	str	r8, [r3, #4]
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLF = ChannelConfigPtr->DivDecimal;                                         /*set baud rate fractional part*/
 51188b4:	e592e004 	ldr	lr, [r2, #4]
 51188b8:	e583e0c0 	str	lr, [r3, #192]	; 0xc0
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR = (Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR & (~(0x1 << 7))); /*clear DLAB bit*/
 51188bc:	e593e00c 	ldr	lr, [r3, #12]
 51188c0:	e3cee080 	bic	lr, lr, #128	; 0x80
 51188c4:	e583e00c 	str	lr, [r3, #12]

            TempReg = Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR;
 51188c8:	e593e00c 	ldr	lr, [r3, #12]
 51188cc:	e58de004 	str	lr, [sp, #4]
            TempReg = (TempReg & ~0x03) | ((uint32)ChannelConfigPtr->DataLength & 0x03U);      /*Set data length*/
 51188d0:	e5d2e00a 	ldrb	lr, [r2, #10]
 51188d4:	e59d8004 	ldr	r8, [sp, #4]
 51188d8:	e20ee003 	and	lr, lr, #3
 51188dc:	e3c88003 	bic	r8, r8, #3
 51188e0:	e18ee008 	orr	lr, lr, r8
 51188e4:	e58de004 	str	lr, [sp, #4]
            TempReg = (TempReg & ~0x04) | (((uint32)ChannelConfigPtr->StopBits & 0x01U) << 2); /*Set stop bits*/
 51188e8:	e59d9004 	ldr	r9, [sp, #4]
 51188ec:	e5d2e009 	ldrb	lr, [r2, #9]
 51188f0:	e1a0e10e 	lsl	lr, lr, #2
            if (ChannelConfigPtr->Parity == UART_PARITY_DISABLE)
 51188f4:	e5d2800b 	ldrb	r8, [r2, #11]
            TempReg = (TempReg & ~0x04) | (((uint32)ChannelConfigPtr->StopBits & 0x01U) << 2); /*Set stop bits*/
 51188f8:	e3c99004 	bic	r9, r9, #4
 51188fc:	e20e2004 	and	r2, lr, #4
 5118900:	e1822009 	orr	r2, r2, r9
            if (ChannelConfigPtr->Parity == UART_PARITY_DISABLE)
 5118904:	e3580002 	cmp	r8, #2
            TempReg = (TempReg & ~0x04) | (((uint32)ChannelConfigPtr->StopBits & 0x01U) << 2); /*Set stop bits*/
 5118908:	e58d2004 	str	r2, [sp, #4]
                TempReg = (TempReg & ~0x08); /*Disable parity*/
            }
            else
            {
                TempReg |= 0x08U;                                                                /*Enable parity*/
                TempReg = (TempReg & ~0x10) | (((uint32)ChannelConfigPtr->Parity & 0x01U) << 4); /*Set parity*/
 511890c:	e1a08208 	lsl	r8, r8, #4
                TempReg = (TempReg & ~0x08); /*Disable parity*/
 5118910:	e59d2004 	ldr	r2, [sp, #4]
                TempReg = (TempReg & ~0x10) | (((uint32)ChannelConfigPtr->Parity & 0x01U) << 4); /*Set parity*/
 5118914:	e2088010 	and	r8, r8, #16
                TempReg |= 0x08U;                                                                /*Enable parity*/
 5118918:	13822008 	orrne	r2, r2, #8
                TempReg = (TempReg & ~0x08); /*Disable parity*/
 511891c:	03c22008 	biceq	r2, r2, #8
                TempReg |= 0x08U;                                                                /*Enable parity*/
 5118920:	158d2004 	strne	r2, [sp, #4]
                TempReg = (TempReg & ~0x10) | (((uint32)ChannelConfigPtr->Parity & 0x01U) << 4); /*Set parity*/
 5118924:	159d2004 	ldrne	r2, [sp, #4]
                TempReg = (TempReg & ~0x08); /*Disable parity*/
 5118928:	058d2004 	streq	r2, [sp, #4]
                TempReg = (TempReg & ~0x10) | (((uint32)ChannelConfigPtr->Parity & 0x01U) << 4); /*Set parity*/
 511892c:	13c22010 	bicne	r2, r2, #16
 5118930:	11888002 	orrne	r8, r8, r2
 5118934:	158d8004 	strne	r8, [sp, #4]
        for (ChannelCounter = 0; ChannelCounter < MaxChannel; ChannelCounter++)
 5118938:	e1500005 	cmp	r0, r5
            }
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->LCR = TempReg;
 511893c:	e59d2004 	ldr	r2, [sp, #4]
 5118940:	e583200c 	str	r2, [r3, #12]
        for (ChannelCounter = 0; ChannelCounter < MaxChannel; ChannelCounter++)
 5118944:	e1a02005 	mov	r2, r5
            Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER = 0x00;
 5118948:	e583c004 	str	ip, [r3, #4]

            /* Set Uart channel state to init */
            ChannelInfoPtr->ChanTxState = UART_TX_IDLE;
 511894c:	e544c00c 	strb	ip, [r4, #-12]
            ChannelInfoPtr->ChanRxState = UART_RX_IDLE;
 5118950:	e544c00b 	strb	ip, [r4, #-11]
        for (ChannelCounter = 0; ChannelCounter < MaxChannel; ChannelCounter++)
 5118954:	12855020 	addne	r5, r5, #32
 5118958:	1affffaf 	bne	511881c <Uart_Init+0x4c>
        }

        Uart_ConfigPtr = ConfigPtr;
 511895c:	e3082694 	movw	r2, #34452	; 0x8694
        Uart_InitStatus = UART_INITIALISED;
 5118960:	e3083698 	movw	r3, #34456	; 0x8698
        Uart_ConfigPtr = ConfigPtr;
 5118964:	e3402513 	movt	r2, #1299	; 0x513
        Uart_InitStatus = UART_INITIALISED;
 5118968:	e3a00001 	mov	r0, #1
 511896c:	e3403513 	movt	r3, #1299	; 0x513
        Uart_ConfigPtr = ConfigPtr;
 5118970:	e5821000 	str	r1, [r2]
        Uart_InitStatus = UART_INITIALISED;
 5118974:	e5c30000 	strb	r0, [r3]
    else
    {
        Det_ReportError((uint16)UART_MODULE_ID, (uint8)0, UART_SID_INIT, UART_E_PARAM_POINTER);
    }
#endif
}
 5118978:	e28dd00c 	add	sp, sp, #12
 511897c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        Det_ReportError((uint16)UART_MODULE_ID, (uint8)0, UART_SID_INIT, UART_E_PARAM_POINTER);
 5118980:	e30844ac 	movw	r4, #33964	; 0x84ac
 5118984:	e3a03002 	mov	r3, #2
 5118988:	e3a020d7 	mov	r2, #215	; 0xd7
 511898c:	e3404511 	movt	r4, #1297	; 0x511
 5118990:	e3a000ff 	mov	r0, #255	; 0xff
 5118994:	e12fff34 	blx	r4
}
 5118998:	e28dd00c 	add	sp, sp, #12
 511899c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

051189a0 <Uart_Write>:
    Uart_RegType *HwModulePtr;
    Uart_ReturnType RetVal = UART_E_OK;

#if (UART_DEV_ERROR_DETECT == STD_ON)
    /* Check uart driver is initialized  */
    if (Uart_InitStatus == UART_INITIALISED)
 51189a0:	e3083698 	movw	r3, #34456	; 0x8698
 51189a4:	e3403513 	movt	r3, #1299	; 0x513
 51189a8:	e5d3c000 	ldrb	ip, [r3]
 51189ac:	e35c0001 	cmp	ip, #1
 51189b0:	0a000001 	beq	51189bc <Uart_Write+0x1c>
    else
    {
#if (UART_RUNTIME_ERROR_DETECT == STD_ON)
        Det_ReportRuntimeError((uint16)UART_MODULE_ID, (uint8)Channel, UART_SID_WRITE, UART_E_UNINIT);
#endif
        RetVal = UART_E_NOT_OK;
 51189b4:	e3a00001 	mov	r0, #1
    }
#endif
    return RetVal;
}
 51189b8:	e12fff1e 	bx	lr
{
 51189bc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 51189c0:	e308e694 	movw	lr, #34452	; 0x8694
        ChannelInfoPtr->ChanTxState = UART_TX_PREP_IN_PROGRESS;
 51189c4:	e3083670 	movw	r3, #34416	; 0x8670
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 51189c8:	e340e513 	movt	lr, #1299	; 0x513
        ChannelInfoPtr->ChanTxState = UART_TX_PREP_IN_PROGRESS;
 51189cc:	e3403513 	movt	r3, #1299	; 0x513
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 51189d0:	e59ee000 	ldr	lr, [lr]
 51189d4:	e59ee000 	ldr	lr, [lr]
 51189d8:	e08ee280 	add	lr, lr, r0, lsl #5
        ChannelInfoPtr->ChanTxState = UART_TX_PREP_IN_PROGRESS;
 51189dc:	e0800180 	add	r0, r0, r0, lsl #3
 51189e0:	e0833100 	add	r3, r3, r0, lsl #2
 51189e4:	e5c3c018 	strb	ip, [r3, #24]
        if(ChannelConfigPtr->TxMode != UART_TX_DMA)
 51189e8:	e5de000d 	ldrb	r0, [lr, #13]
 51189ec:	e3500002 	cmp	r0, #2
 51189f0:	0a00000d 	beq	5118a2c <Uart_Write+0x8c>
        HwModulePtr = Uart_HwModuleAddr[ChannelConfigPtr->HwModule];
 51189f4:	e30dcb40 	movw	ip, #56128	; 0xdb40
 51189f8:	e5dee008 	ldrb	lr, [lr, #8]
            ChannelInfoPtr->TxDataLeft = Size;
 51189fc:	e1c321ba 	strh	r2, [r3, #26]
        HwModulePtr = Uart_HwModuleAddr[ChannelConfigPtr->HwModule];
 5118a00:	e340c512 	movt	ip, #1298	; 0x512
            ChannelInfoPtr->TxBuffPtr = MemPtr;
 5118a04:	e5831004 	str	r1, [r3, #4]
            ChannelInfoPtr->TotalDataTxd = 0U;
 5118a08:	e3a00000 	mov	r0, #0
            ChannelInfoPtr->ChanTxState = UART_TX_IN_PROGRESS;
 5118a0c:	e3a01002 	mov	r1, #2
        HwModulePtr = Uart_HwModuleAddr[ChannelConfigPtr->HwModule];
 5118a10:	e79c210e 	ldr	r2, [ip, lr, lsl #2]
            ChannelInfoPtr->TotalDataTxd = 0U;
 5118a14:	e1c301be 	strh	r0, [r3, #30]
            ChannelInfoPtr->ChanTxState = UART_TX_IN_PROGRESS;
 5118a18:	e5c31018 	strb	r1, [r3, #24]
        
    }
    else
#endif
    {
        HwModulePtr->DLH_IER.IER |= 0x82;   /*Enable transmit data interrupt*/
 5118a1c:	e5923004 	ldr	r3, [r2, #4]
 5118a20:	e3833082 	orr	r3, r3, #130	; 0x82
 5118a24:	e5823004 	str	r3, [r2, #4]
    }
}
 5118a28:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    Uart_ReturnType RetVal = UART_E_OK;
 5118a2c:	e3a00000 	mov	r0, #0
}
 5118a30:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

05118a34 <Uart_Read>:
    if (Uart_InitStatus == UART_INITIALISED)
 5118a34:	e3083698 	movw	r3, #34456	; 0x8698
 5118a38:	e3403513 	movt	r3, #1299	; 0x513
 5118a3c:	e5d33000 	ldrb	r3, [r3]
 5118a40:	e3530001 	cmp	r3, #1
 5118a44:	0a000001 	beq	5118a50 <Uart_Read+0x1c>
 5118a48:	e3a00000 	mov	r0, #0
}
 5118a4c:	e12fff1e 	bx	lr
{
 5118a50:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
        if(ChannelInfoPtr->RxWritePointer >= ChannelInfoPtr->RxReadPointer)
 5118a54:	e308e670 	movw	lr, #34416	; 0x8670
 5118a58:	e0805180 	add	r5, r0, r0, lsl #3
 5118a5c:	e340e513 	movt	lr, #1299	; 0x513
 5118a60:	e08e5105 	add	r5, lr, r5, lsl #2
 5118a64:	e1a04180 	lsl	r4, r0, #3
 5118a68:	e595c010 	ldr	ip, [r5, #16]
 5118a6c:	e5953014 	ldr	r3, [r5, #20]
 5118a70:	e15c0003 	cmp	ip, r3
            offset = ChannelInfoPtr->RxDataLen - ChannelInfoPtr->RxReadPointer + ChannelInfoPtr->RxWritePointer;
 5118a74:	3595500c 	ldrcc	r5, [r5, #12]
 5118a78:	308cc005 	addcc	ip, ip, r5
 5118a7c:	e04cc003 	sub	ip, ip, r3
        real_len = MIN_VAL(Size, offset);
 5118a80:	e152000c 	cmp	r2, ip
 5118a84:	21a0200c 	movcs	r2, ip
        if(real_len)
 5118a88:	e3520000 	cmp	r2, #0
 5118a8c:	0a000028 	beq	5118b34 <Uart_Read+0x100>
            if((ChannelInfoPtr->RxReadPointer + real_len) > ChannelInfoPtr->RxDataLen)
 5118a90:	e084c000 	add	ip, r4, r0
 5118a94:	e0836002 	add	r6, r3, r2
 5118a98:	e08ec10c 	add	ip, lr, ip, lsl #2
 5118a9c:	e59c500c 	ldr	r5, [ip, #12]
 5118aa0:	e1560005 	cmp	r6, r5
 5118aa4:	9a000024 	bls	5118b3c <Uart_Read+0x108>
                offset = ChannelInfoPtr->RxDataLen - ChannelInfoPtr->RxReadPointer;
 5118aa8:	e59c500c 	ldr	r5, [ip, #12]
                UartLocalMemcpy(MemPtr, (ChannelInfoPtr->BaseAddr + ChannelInfoPtr->RxReadPointer), offset);
 5118aac:	e59c6008 	ldr	r6, [ip, #8]
                offset = ChannelInfoPtr->RxDataLen - ChannelInfoPtr->RxReadPointer;
 5118ab0:	e0457003 	sub	r7, r5, r3
    while (TempVar > 0U)
 5118ab4:	e21780ff 	ands	r8, r7, #255	; 0xff
                end = real_len - offset;
 5118ab8:	e0435005 	sub	r5, r3, r5
 5118abc:	e0855002 	add	r5, r5, r2
    while (TempVar > 0U)
 5118ac0:	0a00000c 	beq	5118af8 <Uart_Read+0xc4>
 5118ac4:	e248c001 	sub	ip, r8, #1
 5118ac8:	e0818008 	add	r8, r1, r8
 5118acc:	e6e3c07c 	uxtab	ip, r3, ip
 5118ad0:	e2433001 	sub	r3, r3, #1
 5118ad4:	e086c00c 	add	ip, r6, ip
 5118ad8:	e0866003 	add	r6, r6, r3
        Dest[TempVar] = Src[TempVar];
 5118adc:	e45c3001 	ldrb	r3, [ip], #-1
 5118ae0:	e5683001 	strb	r3, [r8, #-1]!
    while (TempVar > 0U)
 5118ae4:	e15c0006 	cmp	ip, r6
 5118ae8:	1afffffb 	bne	5118adc <Uart_Read+0xa8>
                UartLocalMemcpy(MemPtr + offset, ChannelInfoPtr->BaseAddr, end);
 5118aec:	e0843000 	add	r3, r4, r0
 5118af0:	e08e3103 	add	r3, lr, r3, lsl #2
 5118af4:	e5936008 	ldr	r6, [r3, #8]
    while (TempVar > 0U)
 5118af8:	e21530ff 	ands	r3, r5, #255	; 0xff
 5118afc:	0a000007 	beq	5118b20 <Uart_Read+0xec>
 5118b00:	e243c001 	sub	ip, r3, #1
 5118b04:	e0863003 	add	r3, r6, r3
 5118b08:	e6e7c07c 	uxtab	ip, r7, ip
 5118b0c:	e081100c 	add	r1, r1, ip
        Dest[TempVar] = Src[TempVar];
 5118b10:	e573c001 	ldrb	ip, [r3, #-1]!
 5118b14:	e441c001 	strb	ip, [r1], #-1
    while (TempVar > 0U)
 5118b18:	e1560003 	cmp	r6, r3
 5118b1c:	1afffffb 	bne	5118b10 <Uart_Read+0xdc>
                ChannelInfoPtr->RxReadPointer = end;
 5118b20:	e0844000 	add	r4, r4, r0
    return real_len;
 5118b24:	e6ff0072 	uxth	r0, r2
                ChannelInfoPtr->RxReadPointer = end;
 5118b28:	e08ee104 	add	lr, lr, r4, lsl #2
 5118b2c:	e58e5014 	str	r5, [lr, #20]
 5118b30:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
 5118b34:	e1a00002 	mov	r0, r2
}
 5118b38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
                UartLocalMemcpy(MemPtr, (ChannelInfoPtr->BaseAddr + ChannelInfoPtr->RxReadPointer), real_len);
 5118b3c:	e59c5008 	ldr	r5, [ip, #8]
    while (TempVar > 0U)
 5118b40:	e212c0ff 	ands	ip, r2, #255	; 0xff
 5118b44:	0a00000d 	beq	5118b80 <Uart_Read+0x14c>
 5118b48:	e081100c 	add	r1, r1, ip
 5118b4c:	e24cc001 	sub	ip, ip, #1
 5118b50:	e6e3c07c 	uxtab	ip, r3, ip
 5118b54:	e2433001 	sub	r3, r3, #1
 5118b58:	e085c00c 	add	ip, r5, ip
 5118b5c:	e0853003 	add	r3, r5, r3
        Dest[TempVar] = Src[TempVar];
 5118b60:	e45c5001 	ldrb	r5, [ip], #-1
 5118b64:	e5615001 	strb	r5, [r1, #-1]!
    while (TempVar > 0U)
 5118b68:	e15c0003 	cmp	ip, r3
 5118b6c:	1afffffb 	bne	5118b60 <Uart_Read+0x12c>
                ChannelInfoPtr->RxReadPointer += real_len;
 5118b70:	e0843000 	add	r3, r4, r0
 5118b74:	e08e3103 	add	r3, lr, r3, lsl #2
 5118b78:	e5936014 	ldr	r6, [r3, #20]
 5118b7c:	e0826006 	add	r6, r2, r6
 5118b80:	e0844000 	add	r4, r4, r0
    return real_len;
 5118b84:	e6ff0072 	uxth	r0, r2
                ChannelInfoPtr->RxReadPointer += real_len;
 5118b88:	e08ee104 	add	lr, lr, r4, lsl #2
 5118b8c:	e58e6014 	str	r6, [lr, #20]
 5118b90:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

05118b94 <Uart_SetRxBuffer>:
    if (Uart_InitStatus == UART_INITIALISED)
 5118b94:	e3083698 	movw	r3, #34456	; 0x8698
 5118b98:	e3403513 	movt	r3, #1299	; 0x513
 5118b9c:	e5d33000 	ldrb	r3, [r3]
 5118ba0:	e3530001 	cmp	r3, #1
 5118ba4:	0a000001 	beq	5118bb0 <Uart_SetRxBuffer+0x1c>
        RetVal = UART_E_NOT_OK;
 5118ba8:	e3a00001 	mov	r0, #1
}
 5118bac:	e12fff1e 	bx	lr
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 5118bb0:	e308c694 	movw	ip, #34452	; 0x8694
        ChannelInfoPtr->BaseAddr = MemPtr;
 5118bb4:	e3083670 	movw	r3, #34416	; 0x8670
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 5118bb8:	e340c513 	movt	ip, #1299	; 0x513
        ChannelInfoPtr->BaseAddr = MemPtr;
 5118bbc:	e3403513 	movt	r3, #1299	; 0x513
        ChannelConfigPtr = &(Uart_ConfigPtr->ChannelConfigPtr[Channel]);
 5118bc0:	e59cc000 	ldr	ip, [ip]
 5118bc4:	e59cc000 	ldr	ip, [ip]
 5118bc8:	e08cc280 	add	ip, ip, r0, lsl #5
        ChannelInfoPtr->BaseAddr = MemPtr;
 5118bcc:	e0800180 	add	r0, r0, r0, lsl #3
        ChannelInfoPtr->RxBuffPtr = MemPtr;
 5118bd0:	e7831100 	str	r1, [r3, r0, lsl #2]
        ChannelInfoPtr->BaseAddr = MemPtr;
 5118bd4:	e0833100 	add	r3, r3, r0, lsl #2
        ChannelInfoPtr->RxWritePointer = 0;
 5118bd8:	e3a00000 	mov	r0, #0
        ChannelInfoPtr->BaseAddr = MemPtr;
 5118bdc:	e5831008 	str	r1, [r3, #8]
        ChannelInfoPtr->RxDataLeft = Size;
 5118be0:	e1c321bc 	strh	r2, [r3, #28]
        ChannelInfoPtr->RxDataLen = Size;
 5118be4:	e583200c 	str	r2, [r3, #12]
        ChannelInfoPtr->RxWritePointer = 0;
 5118be8:	e5830010 	str	r0, [r3, #16]
        ChannelInfoPtr->RxReadPointer = 0;
 5118bec:	e5830014 	str	r0, [r3, #20]
        if(ChannelConfigPtr->RxMode == UART_RX_INTERRUPT)
 5118bf0:	e5dc300c 	ldrb	r3, [ip, #12]
 5118bf4:	e3530001 	cmp	r3, #1
 5118bf8:	112fff1e 	bxne	lr
        REG_BIT_SET32(&Uart_HwModuleAddr[ChannelConfigPtr->HwModule]->DLH_IER.IER, 0x01); /*Enable receive data interrupt*/
 5118bfc:	e30d3b40 	movw	r3, #56128	; 0xdb40
 5118c00:	e5dc2008 	ldrb	r2, [ip, #8]
 5118c04:	e3403512 	movt	r3, #1298	; 0x512
 5118c08:	e7932102 	ldr	r2, [r3, r2, lsl #2]
 5118c0c:	e5923004 	ldr	r3, [r2, #4]
 5118c10:	e3833001 	orr	r3, r3, #1
 5118c14:	e5823004 	str	r3, [r2, #4]
 5118c18:	e12fff1e 	bx	lr

05118c1c <Uart_GetTxStatus>:
    TxState = Uart_ChannelInfo[Channel].ChanTxState;
 5118c1c:	e3083670 	movw	r3, #34416	; 0x8670
 5118c20:	e0800180 	add	r0, r0, r0, lsl #3
 5118c24:	e3403513 	movt	r3, #1299	; 0x513
 5118c28:	e0833100 	add	r3, r3, r0, lsl #2
}
 5118c2c:	e5d30018 	ldrb	r0, [r3, #24]
 5118c30:	e12fff1e 	bx	lr

05118c34 <xPortIsTaskPrivileged>:
    const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL );
 5118c34:	e3073204 	movw	r3, #29188	; 0x7204
 5118c38:	e3a00000 	mov	r0, #0
 5118c3c:	e3403510 	movt	r3, #1296	; 0x510
{
 5118c40:	e92d4010 	push	{r4, lr}
    const xMPU_SETTINGS * xTaskMpuSettings = xTaskGetMPUSettings( NULL );
 5118c44:	e12fff33 	blx	r3
    if( ( xTaskMpuSettings->ulTaskFlags & portTASK_IS_PRIVILEGED_FLAG ) == portTASK_IS_PRIVILEGED_FLAG )
 5118c48:	e590006c 	ldr	r0, [r0, #108]	; 0x6c
}
 5118c4c:	e7e000d0 	ubfx	r0, r0, #1, #1
 5118c50:	e8bd8010 	pop	{r4, pc}

05118c54 <prvTaskExitError>:
    configASSERT( ulPortInterruptNesting == ~0UL );
 5118c54:	e30736c0 	movw	r3, #30400	; 0x76c0
 5118c58:	e3403512 	movt	r3, #1298	; 0x512
 5118c5c:	e593300c 	ldr	r3, [r3, #12]
 5118c60:	e3730001 	cmn	r3, #1
 5118c64:	1a000000 	bne	5118c6c <prvTaskExitError+0x18>
    for( ;; )
 5118c68:	eafffffe 	b	5118c68 <prvTaskExitError+0x14>
    configASSERT( ulPortInterruptNesting == ~0UL );
 5118c6c:	e30d0b84 	movw	r0, #56196	; 0xdb84
 5118c70:	e3003900 	movw	r3, #2304	; 0x900
 5118c74:	e3001312 	movw	r1, #786	; 0x312
 5118c78:	e3400512 	movt	r0, #1298	; 0x512
 5118c7c:	e3403511 	movt	r3, #1297	; 0x511
{
 5118c80:	e92d4010 	push	{r4, lr}
    configASSERT( ulPortInterruptNesting == ~0UL );
 5118c84:	e12fff33 	blx	r3
    for( ;; )
 5118c88:	eafffffe 	b	5118c88 <prvTaskExitError+0x34>

05118c8c <bus_hw_sem_lock>:

void bus_hw_sem_lock(void *priv)
{
    struct hw_sem_lock_data *sem_data = priv;

    get_sem_lock(sem_data->hw_sem_id);
 5118c8c:	e3083098 	movw	r3, #32920	; 0x8098
 5118c90:	e5d00000 	ldrb	r0, [r0]
 5118c94:	e3403511 	movt	r3, #1297	; 0x511
{
 5118c98:	e92d4010 	push	{r4, lr}
    get_sem_lock(sem_data->hw_sem_id);
 5118c9c:	e12fff33 	blx	r3
}
 5118ca0:	e8bd8010 	pop	{r4, pc}

05118ca4 <bus_hw_sem_unlock>:

void bus_hw_sem_unlock(void *priv)
{
    struct hw_sem_lock_data *sem_data = priv;

    release_sem_lock(sem_data->hw_sem_id);
 5118ca4:	e30830d0 	movw	r3, #32976	; 0x80d0
 5118ca8:	e5d00000 	ldrb	r0, [r0]
 5118cac:	e3403511 	movt	r3, #1297	; 0x511
{
 5118cb0:	e92d4010 	push	{r4, lr}
    release_sem_lock(sem_data->hw_sem_id);
 5118cb4:	e12fff33 	blx	r3
}
 5118cb8:	e8bd8010 	pop	{r4, pc}

05118cbc <i2c_n_send_data>:

/**********************************************************************************************************************
 *  FUNCTIONS
 **********************************************************************************************************************/
uint8 i2c_n_send_data(uint8_t channel, uint8_t i2cAddress, uint8_t* txFrame, uint8_t frameSizeBytes)
{
 5118cbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    uint8 ret;
    I2c_RequestType i2c_request = {
 5118cc0:	e3a0c000 	mov	ip, #0
{
 5118cc4:	e24dd014 	sub	sp, sp, #20
    I2c_RequestType i2c_request = {
 5118cc8:	e1cd30b6 	strh	r3, [sp, #6]

        /**< @brief Buffer to Store or to transmit Serial data */
        txFrame,
    };

    ret = I2c_SyncTransmit(channel, &i2c_request);
 5118ccc:	e3093754 	movw	r3, #38740	; 0x9754
    I2c_RequestType i2c_request = {
 5118cd0:	e1cd10b0 	strh	r1, [sp]
    ret = I2c_SyncTransmit(channel, &i2c_request);
 5118cd4:	e3403511 	movt	r3, #1297	; 0x511
    I2c_RequestType i2c_request = {
 5118cd8:	e1cdc0b2 	strh	ip, [sp, #2]
    ret = I2c_SyncTransmit(channel, &i2c_request);
 5118cdc:	e1a0100d 	mov	r1, sp
    I2c_RequestType i2c_request = {
 5118ce0:	e1cdc0b4 	strh	ip, [sp, #4]
 5118ce4:	e5cdc008 	strb	ip, [sp, #8]
 5118ce8:	e58d200c 	str	r2, [sp, #12]
    ret = I2c_SyncTransmit(channel, &i2c_request);
 5118cec:	e12fff33 	blx	r3

    // LOG(DBG_INFO,"I2cApp", "line:%d, send: channel %d, i2cAddress %d, tx 0x%x\r\n", __LINE__, channel, i2cAddress, txFrame[0]);
    // LOG_ARRAY(DBG_INFO, "I2cApp", "line:%d, send data:", txFrame, 1, frameSizeBytes, 1, "");

    return ret;
}
 5118cf0:	e28dd014 	add	sp, sp, #20
 5118cf4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

05118cf8 <i2c_n_send_receive_data>:
}

uint8 i2c_n_send_receive_data(uint8_t channel, uint8_t i2cAddress,
                                uint8_t* txFrame, uint8_t txframeSizeBytes,
                                uint8_t* rxFrame, uint8_t rxframeSizeBytes)
{
 5118cf8:	e92d4010 	push	{r4, lr}

        /**< @brief Buffer to Store or to transmit Serial data */
        txFrame,
    };

    I2c_RequestType i2c_rx_request = {
 5118cfc:	e3a0c001 	mov	ip, #1
{
 5118d00:	e24dd020 	sub	sp, sp, #32

        /**< @brief Buffer to Store or to transmit Serial data */
        rxFrame,
    };

    ret = I2c_SyncTxRx(channel, &i2c_tx_request, &i2c_rx_request);
 5118d04:	e3094860 	movw	r4, #39008	; 0x9860
    I2c_RequestType i2c_tx_request = {
 5118d08:	e1cd30b6 	strh	r3, [sp, #6]
    ret = I2c_SyncTxRx(channel, &i2c_tx_request, &i2c_rx_request);
 5118d0c:	e3404511 	movt	r4, #1297	; 0x511
{
 5118d10:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    I2c_RequestType i2c_rx_request = {
 5118d14:	e58d301c 	str	r3, [sp, #28]
    I2c_RequestType i2c_tx_request = {
 5118d18:	e3a03000 	mov	r3, #0
 5118d1c:	e58d200c 	str	r2, [sp, #12]
    ret = I2c_SyncTxRx(channel, &i2c_tx_request, &i2c_rx_request);
 5118d20:	e28d2010 	add	r2, sp, #16
    I2c_RequestType i2c_tx_request = {
 5118d24:	e1cd10b0 	strh	r1, [sp]
    I2c_RequestType i2c_rx_request = {
 5118d28:	e1cd11b0 	strh	r1, [sp, #16]
    ret = I2c_SyncTxRx(channel, &i2c_tx_request, &i2c_rx_request);
 5118d2c:	e1a0100d 	mov	r1, sp
    I2c_RequestType i2c_tx_request = {
 5118d30:	e1cd30b2 	strh	r3, [sp, #2]
 5118d34:	e1cd30b4 	strh	r3, [sp, #4]
 5118d38:	e5cd3008 	strb	r3, [sp, #8]
    I2c_RequestType i2c_rx_request = {
 5118d3c:	e1cd31b2 	strh	r3, [sp, #18]
 5118d40:	e1cd31b4 	strh	r3, [sp, #20]
{
 5118d44:	e5dd302c 	ldrb	r3, [sp, #44]	; 0x2c
    I2c_RequestType i2c_rx_request = {
 5118d48:	e5cdc018 	strb	ip, [sp, #24]
 5118d4c:	e1cd31b6 	strh	r3, [sp, #22]
    ret = I2c_SyncTxRx(channel, &i2c_tx_request, &i2c_rx_request);
 5118d50:	e12fff34 	blx	r4

    return ret;
 5118d54:	e28dd020 	add	sp, sp, #32
 5118d58:	e8bd8010 	pop	{r4, pc}

05118d5c <I2c_LPI2C_MasterReceive>:
                                                                  P2VAR(I2c_RequestType, AUTOMATIC, I2C_APPL_DATA) pRequestPtr,
                                                                  CONST(I2c_ModeType, AUTOMATIC) eTransmitMode
                                                              )
{
    VAR(Std_ReturnType, AUTOMATIC) u8TmpReturn = (Std_ReturnType)E_NOT_OK;
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5118d5c:	e308c6e4 	movw	ip, #34532	; 0x86e4
#else
    /* What condition to generate at the end of a transfer */
    I2c_LPI2C_abRepeatedStart[u8Channel] = pRequestPtr->bRepeatedStart;
    
    /* Initialize the current index to 0 */
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5118d60:	e3a03000 	mov	r3, #0
{
 5118d64:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 5118d68:	e308e6bc 	movw	lr, #34492	; 0x86bc
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5118d6c:	e340c513 	movt	ip, #1299	; 0x513
    const I2c_MasterConfigType * Master = (*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].Master;
 5118d70:	e7dc4000 	ldrb	r4, [ip, r0]
    /* Initialize the transfer buffer */
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;

    u8TmpReturn = (Std_ReturnType)E_OK;
#endif
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118d74:	e30dccf8 	movw	ip, #56568	; 0xdcf8
    I2c_LPI2C_au16NumberOfBytes[u8Channel] = pRequestPtr->u16BufferSize;
 5118d78:	e30876ac 	movw	r7, #34476	; 0x86ac
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118d7c:	e340c512 	movt	ip, #1298	; 0x512
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 5118d80:	e340e513 	movt	lr, #1299	; 0x513
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5118d84:	e1a08080 	lsl	r8, r0, #1
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118d88:	e79c5100 	ldr	r5, [ip, r0, lsl #2]
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5118d8c:	e308c69c 	movw	ip, #34460	; 0x869c
 5118d90:	e340c513 	movt	ip, #1299	; 0x513
    I2c_LPI2C_au16NumberOfBytes[u8Channel] = pRequestPtr->u16BufferSize;
 5118d94:	e3407513 	movt	r7, #1299	; 0x513
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 5118d98:	e591600c 	ldr	r6, [r1, #12]

    if ((Std_ReturnType)E_OK == u8TmpReturn)
    {
        if (I2C_SYNC_MODE == eTransmitMode)
 5118d9c:	e3520001 	cmp	r2, #1
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5118da0:	e18c30b8 	strh	r3, [ip, r8]
{
 5118da4:	e24dd014 	sub	sp, sp, #20
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 5118da8:	e78e6100 	str	r6, [lr, r0, lsl #2]
    I2c_LPI2C_au16NumberOfBytes[u8Channel] = pRequestPtr->u16BufferSize;
 5118dac:	e1d1e0b6 	ldrh	lr, [r1, #6]
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118db0:	e5951040 	ldr	r1, [r5, #64]	; 0x40
    I2c_LPI2C_au16NumberOfBytes[u8Channel] = pRequestPtr->u16BufferSize;
 5118db4:	e187e0b8 	strh	lr, [r7, r8]
        if (I2C_SYNC_MODE == eTransmitMode)
 5118db8:	0a000007 	beq	5118ddc <I2c_LPI2C_MasterReceive+0x80>
        {
            /* If I2C_SyncTransmit was called receive the data blocking */
            u8TmpReturn = I2c_LPI2C_MasterSyncReceive(u8Channel);
        }
        else if (I2C_ASYNC_MODE == eTransmitMode)
 5118dbc:	e3520000 	cmp	r2, #0
    u8TmpReturn = (Std_ReturnType)E_OK;
 5118dc0:	11a00003 	movne	r0, r3
    REG_WRITE32(I2C_INTR_MASK_ADDR32(u8Channel), IC_INTR_MASTER_RX_MASK);
 5118dc4:	0300325e 	movweq	r3, #606	; 0x25e
    u8TmpReturn = (Std_ReturnType)E_OK;
 5118dc8:	01a00002 	moveq	r0, r2
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118dcc:	05951040 	ldreq	r1, [r5, #64]	; 0x40
    REG_WRITE32(I2C_INTR_MASK_ADDR32(u8Channel), IC_INTR_MASTER_RX_MASK);
 5118dd0:	05853030 	streq	r3, [r5, #48]	; 0x30
    {
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
    }

    return u8TmpReturn;
}
 5118dd4:	e28dd014 	add	sp, sp, #20
 5118dd8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118ddc:	e19c30b8 	ldrh	r3, [ip, r8]
 5118de0:	e15e0003 	cmp	lr, r3
 5118de4:	930866dc 	movwls	r6, #34524	; 0x86dc
 5118de8:	93406513 	movtls	r6, #1299	; 0x513
 5118dec:	9a000042 	bls	5118efc <I2c_LPI2C_MasterReceive+0x1a0>
            if (0 == I2c_LPI2C_au16CurrentIndex[u8Channel])
 5118df0:	e08cc008 	add	ip, ip, r8
            u32IsrStatus = REG_READ32(I2C_STATUS_ADDR32(u8Channel));
 5118df4:	e2851070 	add	r1, r5, #112	; 0x70
            REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_RESTART_MASK|IC_DATA_CMD_STOP_MASK);
 5118df8:	e2857010 	add	r7, r5, #16
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_STOP_MASK);
 5118dfc:	e3a0bc03 	mov	fp, #768	; 0x300
            else if (I2c_LPI2C_au16CurrentIndex[u8Channel] < (I2c_LPI2C_au16NumberOfBytes[u8Channel]-1))
 5118e00:	e24ea001 	sub	sl, lr, #1
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_RESTART_MASK);
 5118e04:	e3a09c05 	mov	r9, #1280	; 0x500
            REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_RESTART_MASK|IC_DATA_CMD_STOP_MASK);
 5118e08:	e3a08c07 	mov	r8, #1792	; 0x700
        if(I2c_LPI2C_au16NumberOfBytes[u8Channel] == 1) 
 5118e0c:	e35e0001 	cmp	lr, #1
            REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_RESTART_MASK|IC_DATA_CMD_STOP_MASK);
 5118e10:	05878000 	streq	r8, [r7]
        if(I2c_LPI2C_au16NumberOfBytes[u8Channel] == 1) 
 5118e14:	0a000008 	beq	5118e3c <I2c_LPI2C_MasterReceive+0xe0>
            if (0 == I2c_LPI2C_au16CurrentIndex[u8Channel])
 5118e18:	e1dc30b0 	ldrh	r3, [ip]
 5118e1c:	e3530000 	cmp	r3, #0
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_RESTART_MASK);
 5118e20:	05879000 	streq	r9, [r7]
            if (0 == I2c_LPI2C_au16CurrentIndex[u8Channel])
 5118e24:	0a000004 	beq	5118e3c <I2c_LPI2C_MasterReceive+0xe0>
            else if (I2c_LPI2C_au16CurrentIndex[u8Channel] < (I2c_LPI2C_au16NumberOfBytes[u8Channel]-1))
 5118e28:	e1dc30b0 	ldrh	r3, [ip]
 5118e2c:	e153000a 	cmp	r3, sl
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK);
 5118e30:	b3a03c01 	movlt	r3, #256	; 0x100
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK|IC_DATA_CMD_STOP_MASK);
 5118e34:	a587b000 	strge	fp, [r7]
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), IC_DATA_CMD_CMD_MASK);
 5118e38:	b5873000 	strlt	r3, [r7]
            u32IsrStatus = REG_READ32(I2C_STATUS_ADDR32(u8Channel));
 5118e3c:	e5912000 	ldr	r2, [r1]
 5118e40:	e302370f 	movw	r3, #9999	; 0x270f
 5118e44:	ea000002 	b	5118e54 <I2c_LPI2C_MasterReceive+0xf8>
 5118e48:	e5912000 	ldr	r2, [r1]
        } while ((u32Timeout > (uint32)0x0U) && (IC_STATUS_RFNE_MASK != (u32IsrStatus & IC_STATUS_RFNE_MASK)));
 5118e4c:	e2533001 	subs	r3, r3, #1
 5118e50:	0a000015 	beq	5118eac <I2c_LPI2C_MasterReceive+0x150>
 5118e54:	e3120008 	tst	r2, #8
 5118e58:	0afffffa 	beq	5118e48 <I2c_LPI2C_MasterReceive+0xec>
            u32ReceiveData = REG_READ32(I2C_DATA_CMD_ADDR32(u8Channel));
 5118e5c:	e5972000 	ldr	r2, [r7]
            I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]] = (uint8)(u32ReceiveData & IC_DATA_CMD_DATA_MASK);
 5118e60:	e1dc30b0 	ldrh	r3, [ip]
 5118e64:	e6ff3073 	uxth	r3, r3
 5118e68:	e6ef2072 	uxtb	r2, r2
 5118e6c:	e7c62003 	strb	r2, [r6, r3]
            I2c_LPI2C_au16CurrentIndex[u8Channel]++;
 5118e70:	e1dc30b0 	ldrh	r3, [ip]
 5118e74:	e2833001 	add	r3, r3, #1
 5118e78:	e6ff3073 	uxth	r3, r3
 5118e7c:	e1cc30b0 	strh	r3, [ip]
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118e80:	e1dc30b0 	ldrh	r3, [ip]
 5118e84:	e15e0003 	cmp	lr, r3
 5118e88:	8affffdf 	bhi	5118e0c <I2c_LPI2C_MasterReceive+0xb0>
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_FINISHED;
 5118e8c:	e30836dc 	movw	r3, #34524	; 0x86dc
 5118e90:	e3a02003 	mov	r2, #3
 5118e94:	e3a00000 	mov	r0, #0
 5118e98:	e3403513 	movt	r3, #1299	; 0x513
 5118e9c:	e7c32004 	strb	r2, [r3, r4]
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5118ea0:	e5953040 	ldr	r3, [r5, #64]	; 0x40
}
 5118ea4:	e28dd014 	add	sp, sp, #20
 5118ea8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5118eac:	e30866dc 	movw	r6, #34524	; 0x86dc
 5118eb0:	e3a02004 	mov	r2, #4
            LOG(DBG_ERROR, "LPI2C", "ch%d:rx fifo is empty", u8Channel);
 5118eb4:	e30d3be4 	movw	r3, #56292	; 0xdbe4
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5118eb8:	e3406513 	movt	r6, #1299	; 0x513
            LOG(DBG_ERROR, "LPI2C", "ch%d:rx fifo is empty", u8Channel);
 5118ebc:	e58d0008 	str	r0, [sp, #8]
 5118ec0:	e3403512 	movt	r3, #1298	; 0x512
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5118ec4:	e7c62004 	strb	r2, [r6, r4]
            LOG(DBG_ERROR, "LPI2C", "ch%d:rx fifo is empty", u8Channel);
 5118ec8:	e30022f3 	movw	r2, #755	; 0x2f3
 5118ecc:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 5118ed0:	e30274b0 	movw	r7, #9392	; 0x24b0
 5118ed4:	e58d3004 	str	r3, [sp, #4]
 5118ed8:	e30d3d00 	movw	r3, #56576	; 0xdd00
 5118edc:	e58d2000 	str	r2, [sp]
 5118ee0:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
 5118ee4:	e3403512 	movt	r3, #1298	; 0x512
 5118ee8:	e3402512 	movt	r2, #1298	; 0x512
 5118eec:	e3401512 	movt	r1, #1298	; 0x512
 5118ef0:	e3a00001 	mov	r0, #1
 5118ef4:	e3407511 	movt	r7, #1297	; 0x511
 5118ef8:	e12fff37 	blx	r7
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5118efc:	e3a03004 	mov	r3, #4
 5118f00:	e3a00001 	mov	r0, #1
 5118f04:	e7c63004 	strb	r3, [r6, r4]
 5118f08:	eaffffe4 	b	5118ea0 <I2c_LPI2C_MasterReceive+0x144>

05118f0c <I2c_LPI2C_MasterSyncSend>:
{
 5118f0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5118f10:	e30836e4 	movw	r3, #34532	; 0x86e4
{
 5118f14:	e24dd024 	sub	sp, sp, #36	; 0x24
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118f18:	e308669c 	movw	r6, #34460	; 0x869c
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5118f1c:	e3403513 	movt	r3, #1299	; 0x513
 5118f20:	e7d33000 	ldrb	r3, [r3, r0]
 5118f24:	e58d301c 	str	r3, [sp, #28]
        u32IsrStatus =	REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5118f28:	e30d3cf8 	movw	r3, #56568	; 0xdcf8
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118f2c:	e308b6ac 	movw	fp, #34476	; 0x86ac
        u32IsrStatus =	REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5118f30:	e3403512 	movt	r3, #1298	; 0x512
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118f34:	e1a05080 	lsl	r5, r0, #1
 5118f38:	e3406513 	movt	r6, #1299	; 0x513
 5118f3c:	e19610b5 	ldrh	r1, [r6, r5]
        u32IsrStatus =	REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5118f40:	e7937100 	ldr	r7, [r3, r0, lsl #2]
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118f44:	e340b513 	movt	fp, #1299	; 0x513
 5118f48:	e19bc0b5 	ldrh	ip, [fp, r5]
{
 5118f4c:	e1a08000 	mov	r8, r0
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118f50:	e151000c 	cmp	r1, ip
 5118f54:	2a00002c 	bcs	511900c <I2c_LPI2C_MasterSyncSend+0x100>
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]]|IC_DATA_CMD_STOP_MASK);
 5118f58:	e308a6bc 	movw	sl, #34492	; 0x86bc
                            if(0 == wait_event_timeout( ( (REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x400U) == 0x400U ), 50)) {
 5118f5c:	e30832d8 	movw	r3, #33496	; 0x82d8
 5118f60:	e3403511 	movt	r3, #1297	; 0x511
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]]|IC_DATA_CMD_STOP_MASK);
 5118f64:	e340a513 	movt	sl, #1299	; 0x513
                            if(0 == wait_event_timeout( ( (REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x400U) == 0x400U ), 50)) {
 5118f68:	e58d3018 	str	r3, [sp, #24]
            u32Status =	REG_READ32(I2C_STATUS_ADDR32(u8Channel));
 5118f6c:	e2874070 	add	r4, r7, #112	; 0x70
 5118f70:	e5940000 	ldr	r0, [r4]
 5118f74:	e302370f 	movw	r3, #9999	; 0x270f
 5118f78:	ea000002 	b	5118f88 <I2c_LPI2C_MasterSyncSend+0x7c>
 5118f7c:	e5940000 	ldr	r0, [r4]
        }while ((u32Timeout > (uint32)0x0U) && (IC_STATUS_TFNF_MASK != (u32Status & IC_STATUS_TFNF_MASK)));
 5118f80:	e2533001 	subs	r3, r3, #1
 5118f84:	0a000043 	beq	5119098 <I2c_LPI2C_MasterSyncSend+0x18c>
 5118f88:	e3100002 	tst	r0, #2
 5118f8c:	0afffffa 	beq	5118f7c <I2c_LPI2C_MasterSyncSend+0x70>
            if (0==I2c_LPI2C_au16CurrentIndex[u8Channel])
 5118f90:	e19630b5 	ldrh	r3, [r6, r5]
 5118f94:	e3530000 	cmp	r3, #0
 5118f98:	1a000033 	bne	511906c <I2c_LPI2C_MasterSyncSend+0x160>
                    REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), 
 5118f9c:	e19630b5 	ldrh	r3, [r6, r5]
 5118fa0:	e79a0108 	ldr	r0, [sl, r8, lsl #2]
 5118fa4:	e6ff3073 	uxth	r3, r3
 5118fa8:	e7d03003 	ldrb	r3, [r0, r3]
 5118fac:	e3833b01 	orr	r3, r3, #1024	; 0x400
 5118fb0:	e5873010 	str	r3, [r7, #16]
                if(REG_READ32(I2C_TXFLR_ADDR32(u8Channel)) == 0) {
 5118fb4:	e5973074 	ldr	r3, [r7, #116]	; 0x74
 5118fb8:	e3530000 	cmp	r3, #0
 5118fbc:	1a00000a 	bne	5118fec <I2c_LPI2C_MasterSyncSend+0xe0>
                    if( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x01) == 0x01) {
 5118fc0:	e5943000 	ldr	r3, [r4]
 5118fc4:	e3130001 	tst	r3, #1
 5118fc8:	1a000007 	bne	5118fec <I2c_LPI2C_MasterSyncSend+0xe0>
                        uint32 raw_intr_stat = REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5118fcc:	e5973034 	ldr	r3, [r7, #52]	; 0x34
                        if( (raw_intr_stat&0x400U) != 0x400U ) {
 5118fd0:	e3130b01 	tst	r3, #1024	; 0x400
                        uint32 raw_intr_stat = REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5118fd4:	e2873034 	add	r3, r7, #52	; 0x34
 5118fd8:	e58d3014 	str	r3, [sp, #20]
                        if( (raw_intr_stat&0x400U) != 0x400U ) {
 5118fdc:	1a000002 	bne	5118fec <I2c_LPI2C_MasterSyncSend+0xe0>
                            if(0 == wait_event_timeout( ( (REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x400U) == 0x400U ), 50)) {
 5118fe0:	e5973034 	ldr	r3, [r7, #52]	; 0x34
 5118fe4:	e3130b01 	tst	r3, #1024	; 0x400
 5118fe8:	0a00005b 	beq	511915c <I2c_LPI2C_MasterSyncSend+0x250>
                I2c_LPI2C_au16CurrentIndex[u8Channel]++;
 5118fec:	e19630b5 	ldrh	r3, [r6, r5]
 5118ff0:	e2833001 	add	r3, r3, #1
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5118ff4:	e19bc0b5 	ldrh	ip, [fp, r5]
                I2c_LPI2C_au16CurrentIndex[u8Channel]++;
 5118ff8:	e6ff3073 	uxth	r3, r3
 5118ffc:	e18630b5 	strh	r3, [r6, r5]
    while (I2c_LPI2C_au16CurrentIndex[u8Channel] < I2c_LPI2C_au16NumberOfBytes[u8Channel])
 5119000:	e19630b5 	ldrh	r3, [r6, r5]
 5119004:	e153000c 	cmp	r3, ip
 5119008:	3affffd8 	bcc	5118f70 <I2c_LPI2C_MasterSyncSend+0x64>
        u32IsrStatus =	REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 511900c:	e5972034 	ldr	r2, [r7, #52]	; 0x34
 5119010:	e2874034 	add	r4, r7, #52	; 0x34
 5119014:	e302370f 	movw	r3, #9999	; 0x270f
 5119018:	ea000002 	b	5119028 <I2c_LPI2C_MasterSyncSend+0x11c>
 511901c:	e5942000 	ldr	r2, [r4]
    } while ((u32Timeout > (uint32)0x0U) && (IC_INTR_STAT_R_TX_EMPTY_MASK != (u32IsrStatus & IC_INTR_STAT_R_TX_EMPTY_MASK)));
 5119020:	e2533001 	subs	r3, r3, #1
 5119024:	0a000032 	beq	51190f4 <I2c_LPI2C_MasterSyncSend+0x1e8>
 5119028:	e3120010 	tst	r2, #16
 511902c:	0afffffa 	beq	511901c <I2c_LPI2C_MasterSyncSend+0x110>
    delaySoft(I2C_TIMEOUT_LOOPS);//wait last byte has been send
 5119030:	e30832d8 	movw	r3, #33496	; 0x82d8
 5119034:	e3020710 	movw	r0, #10000	; 0x2710
 5119038:	e3403511 	movt	r3, #1297	; 0x511
 511903c:	e12fff33 	blx	r3
    u32IsrStatus = REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel));
 5119040:	e5943000 	ldr	r3, [r4]
    if(u32IsrStatus&IC_INTR_ERROR)
 5119044:	e213304a 	ands	r3, r3, #74	; 0x4a
 5119048:	1a000055 	bne	51191a4 <I2c_LPI2C_MasterSyncSend+0x298>
    I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_FINISHED;
 511904c:	e30826dc 	movw	r2, #34524	; 0x86dc
 5119050:	e3a01003 	mov	r1, #3
    return u8TmpReturn;
 5119054:	e1a00003 	mov	r0, r3
    I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_FINISHED;
 5119058:	e3402513 	movt	r2, #1299	; 0x513
 511905c:	e59d301c 	ldr	r3, [sp, #28]
 5119060:	e7c21003 	strb	r1, [r2, r3]
}
 5119064:	e28dd024 	add	sp, sp, #36	; 0x24
 5119068:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            else if (I2c_LPI2C_au16CurrentIndex[u8Channel] < (I2c_LPI2C_au16NumberOfBytes[u8Channel]-1))
 511906c:	e19630b5 	ldrh	r3, [r6, r5]
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]]);
 5119070:	e79a0108 	ldr	r0, [sl, r8, lsl #2]
            else if (I2c_LPI2C_au16CurrentIndex[u8Channel] < (I2c_LPI2C_au16NumberOfBytes[u8Channel]-1))
 5119074:	e24cc001 	sub	ip, ip, #1
 5119078:	e153000c 	cmp	r3, ip
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]]);
 511907c:	e19630b5 	ldrh	r3, [r6, r5]
 5119080:	e6ff3073 	uxth	r3, r3
 5119084:	e7d03003 	ldrb	r3, [r0, r3]
 5119088:	b6ef3073 	uxtblt	r3, r3
                REG_WRITE32(I2C_DATA_CMD_ADDR32(u8Channel), I2c_LPI2C_aup8DataBuffer[u8Channel][I2c_LPI2C_au16CurrentIndex[u8Channel]]|IC_DATA_CMD_STOP_MASK);
 511908c:	a3833c02 	orrge	r3, r3, #512	; 0x200
 5119090:	e5873010 	str	r3, [r7, #16]
 5119094:	eaffffd4 	b	5118fec <I2c_LPI2C_MasterSyncSend+0xe0>
            LOG(DBG_ERROR, "LPI2C", "ch%d:Tx fifo is full", u8Channel);
 5119098:	e30d2c80 	movw	r2, #56448	; 0xdc80
 511909c:	e30001f1 	movw	r0, #497	; 0x1f1
 51190a0:	e3402512 	movt	r2, #1298	; 0x512
 51190a4:	e30d3d1c 	movw	r3, #56604	; 0xdd1c
 51190a8:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 51190ac:	e30244b0 	movw	r4, #9392	; 0x24b0
 51190b0:	e3403512 	movt	r3, #1298	; 0x512
 51190b4:	e98d0104 	stmib	sp, {r2, r8}
 51190b8:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
 51190bc:	e58d0000 	str	r0, [sp]
 51190c0:	e3402512 	movt	r2, #1298	; 0x512
 51190c4:	e3401512 	movt	r1, #1298	; 0x512
 51190c8:	e3a00001 	mov	r0, #1
 51190cc:	e3404511 	movt	r4, #1297	; 0x511
 51190d0:	e12fff34 	blx	r4
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 51190d4:	e30836dc 	movw	r3, #34524	; 0x86dc
 51190d8:	e3a02004 	mov	r2, #4
 51190dc:	e59d101c 	ldr	r1, [sp, #28]
 51190e0:	e3403513 	movt	r3, #1299	; 0x513
            return u8TmpReturn;
 51190e4:	e3a00001 	mov	r0, #1
            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 51190e8:	e7c32001 	strb	r2, [r3, r1]
}
 51190ec:	e28dd024 	add	sp, sp, #36	; 0x24
 51190f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(0==(REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x200)) {//no STOP_DET
 51190f4:	e5943000 	ldr	r3, [r4]
 51190f8:	e3130c02 	tst	r3, #512	; 0x200
 51190fc:	0a000024 	beq	5119194 <I2c_LPI2C_MasterSyncSend+0x288>
            LOG(DBG_ERROR, "LPI2C", "ch%d:tx fifo can't send, i2c maybe float", u8Channel);
 5119100:	e30d2c20 	movw	r2, #56352	; 0xdc20
 5119104:	e3000207 	movw	r0, #519	; 0x207
 5119108:	e3402512 	movt	r2, #1298	; 0x512
 511910c:	e98d0104 	stmib	sp, {r2, r8}
 5119110:	e30d3d1c 	movw	r3, #56604	; 0xdd1c
 5119114:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
 5119118:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 511911c:	e30244b0 	movw	r4, #9392	; 0x24b0
 5119120:	e3403512 	movt	r3, #1298	; 0x512
 5119124:	e58d0000 	str	r0, [sp]
 5119128:	e3402512 	movt	r2, #1298	; 0x512
 511912c:	e3401512 	movt	r1, #1298	; 0x512
 5119130:	e3a00001 	mov	r0, #1
 5119134:	e3404511 	movt	r4, #1297	; 0x511
 5119138:	e12fff34 	blx	r4
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 511913c:	e30836dc 	movw	r3, #34524	; 0x86dc
 5119140:	e3a02004 	mov	r2, #4
 5119144:	e3403513 	movt	r3, #1299	; 0x513
 5119148:	e59d101c 	ldr	r1, [sp, #28]
        return u8TmpReturn;
 511914c:	e3a00001 	mov	r0, #1
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5119150:	e7c32001 	strb	r2, [r3, r1]
}
 5119154:	e28dd024 	add	sp, sp, #36	; 0x24
 5119158:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511915c:	e3a09032 	mov	r9, #50	; 0x32
                            if(0 == wait_event_timeout( ( (REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x400U) == 0x400U ), 50)) {
 5119160:	e59d3014 	ldr	r3, [sp, #20]
 5119164:	e3a00005 	mov	r0, #5
 5119168:	e593c000 	ldr	ip, [r3]
 511916c:	e31c0b01 	tst	ip, #1024	; 0x400
 5119170:	1affff9d 	bne	5118fec <I2c_LPI2C_MasterSyncSend+0xe0>
 5119174:	e59d3018 	ldr	r3, [sp, #24]
 5119178:	e12fff33 	blx	r3
 511917c:	e2599001 	subs	r9, r9, #1
 5119180:	1afffff6 	bne	5119160 <I2c_LPI2C_MasterSyncSend+0x254>
                                LOG(DBG_ERROR, "LPI2C", "ch%d:wait start timeout", u8Channel);
 5119184:	e30d2c68 	movw	r2, #56424	; 0xdc68
 5119188:	e3a00f75 	mov	r0, #468	; 0x1d4
 511918c:	e3402512 	movt	r2, #1298	; 0x512
 5119190:	eaffffc3 	b	51190a4 <I2c_LPI2C_MasterSyncSend+0x198>
            LOG(DBG_ERROR, "LPI2C", "ch%d:tx fifo can't send, no stop", u8Channel);
 5119194:	e30d2bfc 	movw	r2, #56316	; 0xdbfc
 5119198:	e3a00f81 	mov	r0, #516	; 0x204
 511919c:	e3402512 	movt	r2, #1298	; 0x512
 51191a0:	eaffffd9 	b	511910c <I2c_LPI2C_MasterSyncSend+0x200>
        I2c_LPI2C_au16CurrentIndex[u8Channel] = 0;
 51191a4:	e3a03000 	mov	r3, #0
        LOG(DBG_ERROR, "LPI2C", "ch%d:TX NACK, slave 0x%x", u8Channel, REG_READ32(I2C_TAR_ADDR32(u8Channel)));
 51191a8:	e30d1c4c 	movw	r1, #56396	; 0xdc4c
 51191ac:	e300021a 	movw	r0, #538	; 0x21a
 51191b0:	e3401512 	movt	r1, #1298	; 0x512
        I2c_LPI2C_au16CurrentIndex[u8Channel] = 0;
 51191b4:	e18630b5 	strh	r3, [r6, r5]
        LOG(DBG_ERROR, "LPI2C", "ch%d:TX NACK, slave 0x%x", u8Channel, REG_READ32(I2C_TAR_ADDR32(u8Channel)));
 51191b8:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
        REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 51191bc:	e5973040 	ldr	r3, [r7, #64]	; 0x40
        LOG(DBG_ERROR, "LPI2C", "ch%d:TX NACK, slave 0x%x", u8Channel, REG_READ32(I2C_TAR_ADDR32(u8Channel)));
 51191c0:	e30244b0 	movw	r4, #9392	; 0x24b0
 51191c4:	e5973004 	ldr	r3, [r7, #4]
 51191c8:	e3402512 	movt	r2, #1298	; 0x512
 51191cc:	e1cd00f0 	strd	r0, [sp]
 51191d0:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 51191d4:	e58d300c 	str	r3, [sp, #12]
 51191d8:	e30d3d1c 	movw	r3, #56604	; 0xdd1c
 51191dc:	e3a00001 	mov	r0, #1
 51191e0:	e3403512 	movt	r3, #1298	; 0x512
 51191e4:	e3401512 	movt	r1, #1298	; 0x512
 51191e8:	e58d8008 	str	r8, [sp, #8]
 51191ec:	e3404511 	movt	r4, #1297	; 0x511
 51191f0:	e12fff34 	blx	r4
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 51191f4:	eaffffb6 	b	51190d4 <I2c_LPI2C_MasterSyncSend+0x1c8>

051191f8 <I2c_LPI2C_InitChannel>:
*
*/
FUNC (void, I2C_CODE) I2c_LPI2C_InitChannel(
    CONST(uint8, AUTOMATIC) u8Channel, 
    P2CONST(I2c_HwUnitConfigType, AUTOMATIC, I2C_APPL_CONST) ConfigPtr)
{
 51191f8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)

#if (STD_ON == I2C_DEV_ERROR_DETECT)
    DevAssert(ConfigPtr != NULL_PTR);
    DevAssert(u8Channel < I2C_HW_MAX_MODULES);
#endif
    if (I2C_MASTER_MODE == ConfigPtr->eMasterSlaveConfig)
 51191fc:	e5d12001 	ldrb	r2, [r1, #1]
 5119200:	e3520000 	cmp	r2, #0
 5119204:	0a00002a 	beq	51192b4 <I2c_LPI2C_InitChannel+0xbc>
    {
		I2c_LPI2C_MasterInit(u8Channel, ConfigPtr->Master);
    } 
    else if (I2C_SLAVE_MODE == ConfigPtr->eMasterSlaveConfig)
 5119208:	e3520001 	cmp	r2, #1
 511920c:	0a000007 	beq	5119230 <I2c_LPI2C_InitChannel+0x38>
	{
	    I2c_LPI2C_SlaveInit(u8Channel, ConfigPtr->Slave);
	}
    else 
    {
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_IDLE;
 5119210:	e30836dc 	movw	r3, #34524	; 0x86dc
 5119214:	e3a01000 	mov	r1, #0
    VAR(uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5119218:	e30826e4 	movw	r2, #34532	; 0x86e4
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_IDLE;
 511921c:	e3403513 	movt	r3, #1299	; 0x513
    VAR(uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5119220:	e3402513 	movt	r2, #1299	; 0x513
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_IDLE;
 5119224:	e7d22000 	ldrb	r2, [r2, r0]
 5119228:	e7c31002 	strb	r1, [r3, r2]
        return;
    }
}
 511922c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 5119230:	e30d3cf8 	movw	r3, #56568	; 0xdcf8
 5119234:	e3a0e000 	mov	lr, #0
	    I2c_LPI2C_SlaveInit(u8Channel, ConfigPtr->Slave);
 5119238:	e5912008 	ldr	r2, [r1, #8]
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 511923c:	e3403512 	movt	r3, #1298	; 0x512
 5119240:	e5d21002 	ldrb	r1, [r2, #2]
        u32CON_Value |= IC_10BITADDR_SLAVE_ENABLE;
 5119244:	e3510000 	cmp	r1, #0
 5119248:	e5d21004 	ldrb	r1, [r2, #4]
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 511924c:	e1d2c0b0 	ldrh	ip, [r2]
 5119250:	e7933100 	ldr	r3, [r3, r0, lsl #2]
        u32CON_Value |= IC_10BITADDR_SLAVE_ENABLE;
 5119254:	03a00008 	moveq	r0, #8
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 5119258:	e583e06c 	str	lr, [r3, #108]	; 0x6c
        u32CON_Value |= IC_10BITADDR_SLAVE_ENABLE;
 511925c:	11a0000e 	movne	r0, lr
    if (I2C_STANDARD_SPEED_MODE == Slave->eSpeedMode) {
 5119260:	e151000e 	cmp	r1, lr
        u32CON_Value |= 1;
 5119264:	03800001 	orreq	r0, r0, #1
    if (I2C_STANDARD_SPEED_MODE == Slave->eSpeedMode) {
 5119268:	0a000004 	beq	5119280 <I2c_LPI2C_InitChannel+0x88>
    else if (I2C_FAST_SPEED_MODE == Slave->eSpeedMode) {
 511926c:	e3510001 	cmp	r1, #1
        u32CON_Value |= 2;
 5119270:	03800002 	orreq	r0, r0, #2
    else if (I2C_FAST_SPEED_MODE == Slave->eSpeedMode) {
 5119274:	0a000001 	beq	5119280 <I2c_LPI2C_InitChannel+0x88>
    else if (I2C_HIGH_SPEED_MODE == Slave->eSpeedMode) {
 5119278:	e3510002 	cmp	r1, #2
        u32CON_Value |= 3;
 511927c:	03800003 	orreq	r0, r0, #3
    REG_RMW32(I2C_CON_ADDR32(u8Channel), u32CON_Mask, u32CON_Value);
 5119280:	e5932000 	ldr	r2, [r3]
    REG_WRITE32(I2C_RX_TL_ADDR32(u8Channel),0);
 5119284:	e3a01000 	mov	r1, #0
    REG_RMW32(I2C_CON_ADDR32(u8Channel), u32CON_Mask, u32CON_Value);
 5119288:	e3c2207f 	bic	r2, r2, #127	; 0x7f
 511928c:	e1822000 	orr	r2, r2, r0
 5119290:	e5832000 	str	r2, [r3]
    REG_WRITE32(I2C_SAR_ADDR32(u8Channel), Slave->SlaveAddress);
 5119294:	e583c008 	str	ip, [r3, #8]
    REG_WRITE32(I2C_RX_TL_ADDR32(u8Channel),0);
 5119298:	e5831038 	str	r1, [r3, #56]	; 0x38
    REG_WRITE32(I2C_TX_TL_ADDR32(u8Channel),0);
 511929c:	e583103c 	str	r1, [r3, #60]	; 0x3c
    REG_RMW32(I2C_ENABLE_ADDR32(u8Channel),ENABLE_MASK,I2C_ENABL);
 51192a0:	e593206c 	ldr	r2, [r3, #108]	; 0x6c
 51192a4:	e3822001 	orr	r2, r2, #1
 51192a8:	e583206c 	str	r2, [r3, #108]	; 0x6c
    REG_WRITE32(I2C_INTR_MASK_ADDR32(u8Channel), 0x00);
 51192ac:	e5831030 	str	r1, [r3, #48]	; 0x30
}
 51192b0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
		I2c_LPI2C_MasterInit(u8Channel, ConfigPtr->Master);
 51192b4:	e5913004 	ldr	r3, [r1, #4]
 51192b8:	e5d31000 	ldrb	r1, [r3]
 51192bc:	e5d3c002 	ldrb	ip, [r3, #2]
        u32CON_Value |= IC_10BITADDR_MASTER_ENABLE;
 51192c0:	e3510000 	cmp	r1, #0
 51192c4:	e5d3e001 	ldrb	lr, [r3, #1]
 51192c8:	e5931004 	ldr	r1, [r3, #4]
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 51192cc:	e30d3cf8 	movw	r3, #56568	; 0xdcf8
 51192d0:	e3403512 	movt	r3, #1298	; 0x512
 51192d4:	e7933100 	ldr	r3, [r3, r0, lsl #2]
        u32CON_Value |= IC_10BITADDR_MASTER_ENABLE;
 51192d8:	13a00041 	movne	r0, #65	; 0x41
    REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel),0x00);
 51192dc:	e583206c 	str	r2, [r3, #108]	; 0x6c
        u32CON_Value |= IC_10BITADDR_MASTER_ENABLE;
 51192e0:	03a00051 	moveq	r0, #81	; 0x51
    if (I2C_STANDARD_SPEED_MODE == Master->eSpeedMode) {
 51192e4:	e35c0000 	cmp	ip, #0
 51192e8:	0a00000b 	beq	511931c <I2c_LPI2C_InitChannel+0x124>
    else if (I2C_FAST_SPEED_MODE == Master->eSpeedMode) {
 51192ec:	e35c0001 	cmp	ip, #1
 51192f0:	0a000026 	beq	5119390 <I2c_LPI2C_InitChannel+0x198>
    else if (I2C_HIGH_SPEED_MODE == Master->eSpeedMode) {
 51192f4:	e35c0002 	cmp	ip, #2
 51192f8:	1a00000c 	bne	5119330 <I2c_LPI2C_InitChannel+0x138>
        REG_WRITE32(I2C_HS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 51192fc:	e5912000 	ldr	r2, [r1]
        u32CON_Value |= 3;
 5119300:	e3800003 	orr	r0, r0, #3
        REG_WRITE32(I2C_HS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 5119304:	e5832024 	str	r2, [r3, #36]	; 0x24
        REG_WRITE32(I2C_HS_SCL_LCNT_ADDR32(u8Channel), Master->BaudrateParams->SclLO);
 5119308:	e5912004 	ldr	r2, [r1, #4]
 511930c:	e5832028 	str	r2, [r3, #40]	; 0x28
        REG_WRITE32(I2C_HS_SPKLEN_ADDR32(u8Channel), Master->BaudrateParams->spkLen);
 5119310:	e5912014 	ldr	r2, [r1, #20]
 5119314:	e58320a4 	str	r2, [r3, #164]	; 0xa4
 5119318:	ea000004 	b	5119330 <I2c_LPI2C_InitChannel+0x138>
        REG_WRITE32(I2C_SS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 511931c:	e5912000 	ldr	r2, [r1]
        u32CON_Value |= 1;
 5119320:	e3800001 	orr	r0, r0, #1
        REG_WRITE32(I2C_SS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 5119324:	e5832014 	str	r2, [r3, #20]
        REG_WRITE32(I2C_SS_SCL_LCNT_ADDR32(u8Channel), Master->BaudrateParams->SclLO);
 5119328:	e5912004 	ldr	r2, [r1, #4]
 511932c:	e5832018 	str	r2, [r3, #24]
    REG_RMW32(I2C_CON_ADDR32(u8Channel), u32CON_Mask, u32CON_Value);
 5119330:	e5932000 	ldr	r2, [r3]
    if (I2C_RESTART_MODE_ENABLE == Master->eRestartMode)
 5119334:	e35e0001 	cmp	lr, #1
    REG_WRITE32(I2C_RX_TL_ADDR32(u8Channel),0);
 5119338:	e3a0c000 	mov	ip, #0
        u32CON_Value |= MASTER_RESTART_ENABLE;
 511933c:	03800020 	orreq	r0, r0, #32
    REG_RMW32(I2C_CON_ADDR32(u8Channel), u32CON_Mask, u32CON_Value);
 5119340:	e3c2207f 	bic	r2, r2, #127	; 0x7f
 5119344:	e1822000 	orr	r2, r2, r0
 5119348:	e5832000 	str	r2, [r3]
    REG_WRITE32(I2C_SDA_HOLD_ADDR32(u8Channel), (Master->BaudrateParams->SdaRxHold<<16)|(Master->BaudrateParams->SdaTxHold));
 511934c:	e5910008 	ldr	r0, [r1, #8]
 5119350:	e591200c 	ldr	r2, [r1, #12]
 5119354:	e1822800 	orr	r2, r2, r0, lsl #16
 5119358:	e583207c 	str	r2, [r3, #124]	; 0x7c
    REG_WRITE32(I2C_SDA_SETUP_ADDR32(u8Channel), Master->BaudrateParams->SdaSetup);
 511935c:	e5912010 	ldr	r2, [r1, #16]
 5119360:	e5832094 	str	r2, [r3, #148]	; 0x94
    REG_WRITE32(I2C_SCL_STUCK_AT_LOW_TIMEOUT_ADDR32(u8Channel), Master->BaudrateParams->SclStuckLowTimeout);
 5119364:	e5912018 	ldr	r2, [r1, #24]
 5119368:	e58320ac 	str	r2, [r3, #172]	; 0xac
    REG_WRITE32(I2C_SDA_STUCK_AT_LOW_TIMEOUT_ADDR32(u8Channel), Master->BaudrateParams->SdaStuckLowTimeout);
 511936c:	e591201c 	ldr	r2, [r1, #28]
 5119370:	e58320b0 	str	r2, [r3, #176]	; 0xb0
    REG_WRITE32(I2C_RX_TL_ADDR32(u8Channel),0);
 5119374:	e583c038 	str	ip, [r3, #56]	; 0x38
    REG_WRITE32(I2C_TX_TL_ADDR32(u8Channel),0);
 5119378:	e583c03c 	str	ip, [r3, #60]	; 0x3c
    REG_RMW32(I2C_ENABLE_ADDR32(u8Channel),ENABLE_MASK,I2C_ENABL);
 511937c:	e593206c 	ldr	r2, [r3, #108]	; 0x6c
 5119380:	e3822001 	orr	r2, r2, #1
 5119384:	e583206c 	str	r2, [r3, #108]	; 0x6c
    REG_WRITE32(I2C_INTR_MASK_ADDR32(u8Channel), 0x00);
 5119388:	e583c030 	str	ip, [r3, #48]	; 0x30
}
 511938c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
        REG_WRITE32(I2C_FS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 5119390:	e5912000 	ldr	r2, [r1]
        u32CON_Value |= 2;
 5119394:	e3800002 	orr	r0, r0, #2
        REG_WRITE32(I2C_FS_SCL_HCNT_ADDR32(u8Channel), Master->BaudrateParams->SclHI);
 5119398:	e583201c 	str	r2, [r3, #28]
        REG_WRITE32(I2C_FS_SCL_LCNT_ADDR32(u8Channel), Master->BaudrateParams->SclLO);
 511939c:	e5912004 	ldr	r2, [r1, #4]
 51193a0:	e5832020 	str	r2, [r3, #32]
        REG_WRITE32(I2C_FS_SPKLEN_ADDR32(u8Channel), Master->BaudrateParams->spkLen);
 51193a4:	e5912014 	ldr	r2, [r1, #20]
 51193a8:	e58320a0 	str	r2, [r3, #160]	; 0xa0
 51193ac:	eaffffdf 	b	5119330 <I2c_LPI2C_InitChannel+0x138>

051193b0 <I2c_LPI2C_MasterSendAddress>:
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 51193b0:	e30d3cf8 	movw	r3, #56568	; 0xdcf8
 51193b4:	e3403512 	movt	r3, #1298	; 0x512
{
 51193b8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 51193bc:	e7937100 	ldr	r7, [r3, r0, lsl #2]
{
 51193c0:	e24dd018 	sub	sp, sp, #24
 51193c4:	e1a09000 	mov	r9, r0
 51193c8:	e1a08001 	mov	r8, r1
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 51193cc:	e5973070 	ldr	r3, [r7, #112]	; 0x70
 51193d0:	e3130004 	tst	r3, #4
 51193d4:	1a000015 	bne	5119430 <I2c_LPI2C_MasterSendAddress+0x80>
    const I2c_MasterConfigType * Master = (*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].Master;
 51193d8:	e30836ec 	movw	r3, #34540	; 0x86ec
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 51193dc:	e30852d8 	movw	r5, #33496	; 0x82d8
    const I2c_MasterConfigType * Master = (*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].Master;
 51193e0:	e3403513 	movt	r3, #1299	; 0x513
 51193e4:	e2876070 	add	r6, r7, #112	; 0x70
 51193e8:	e3a04e7d 	mov	r4, #2000	; 0x7d0
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 51193ec:	e3405511 	movt	r5, #1297	; 0x511
    const I2c_MasterConfigType * Master = (*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].Master;
 51193f0:	e5933000 	ldr	r3, [r3]
 51193f4:	e5932004 	ldr	r2, [r3, #4]
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51193f8:	e30836e4 	movw	r3, #34532	; 0x86e4
 51193fc:	e3403513 	movt	r3, #1299	; 0x513
    const I2c_MasterConfigType * Master = (*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].Master;
 5119400:	e7d33000 	ldrb	r3, [r3, r0]
 5119404:	e0833083 	add	r3, r3, r3, lsl #1
 5119408:	e0823103 	add	r3, r2, r3, lsl #2
 511940c:	e593a004 	ldr	sl, [r3, #4]
 5119410:	ea000002 	b	5119420 <I2c_LPI2C_MasterSendAddress+0x70>
    if(0 == wait_event_timeout( (REG_READ32(I2C_STATUS_ADDR32(u8Channel))&0x04) == 0x04, 2000)) {
 5119414:	e12fff35 	blx	r5
 5119418:	e2544001 	subs	r4, r4, #1
 511941c:	0a000021 	beq	51194a8 <I2c_LPI2C_MasterSendAddress+0xf8>
 5119420:	e5963000 	ldr	r3, [r6]
 5119424:	e3a00005 	mov	r0, #5
 5119428:	e3130004 	tst	r3, #4
 511942c:	0afffff8 	beq	5119414 <I2c_LPI2C_MasterSendAddress+0x64>
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5119430:	e308369c 	movw	r3, #34460	; 0x869c
	REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel), 0x00);
 5119434:	e3a01000 	mov	r1, #0
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5119438:	e1a02089 	lsl	r2, r9, #1
	REG_WRITE32(I2C_ENABLE_ADDR32(u8Channel), 0x00);
 511943c:	e587106c 	str	r1, [r7, #108]	; 0x6c
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5119440:	e3403513 	movt	r3, #1299	; 0x513
    REG_READ32(I2C_CLR_INTR_ADDR32(u8Channel));
 5119444:	e5970040 	ldr	r0, [r7, #64]	; 0x40
    I2c_LPI2C_au16CurrentIndex[u8Channel] = 0x00U;
 5119448:	e18310b2 	strh	r1, [r3, r2]
    I2c_LPI2C_au16NumberOfBytes[u8Channel] = pRequestPtr->u16BufferSize;
 511944c:	e30836ac 	movw	r3, #34476	; 0x86ac
 5119450:	e3403513 	movt	r3, #1299	; 0x513
 5119454:	e1d810b6 	ldrh	r1, [r8, #6]
 5119458:	e18310b2 	strh	r1, [r3, r2]
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 511945c:	e30836bc 	movw	r3, #34492	; 0x86bc
    if ((boolean)FALSE == (boolean)(pRequestPtr->b10BitsSlaveAddressSize))
 5119460:	e5d82002 	ldrb	r2, [r8, #2]
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 5119464:	e3403513 	movt	r3, #1299	; 0x513
    if ((boolean)FALSE == (boolean)(pRequestPtr->b10BitsSlaveAddressSize))
 5119468:	e3520000 	cmp	r2, #0
    I2c_LPI2C_aup8DataBuffer[u8Channel] = pRequestPtr->pDataBuffer;
 511946c:	e598200c 	ldr	r2, [r8, #12]
 5119470:	e7832109 	str	r2, [r3, r9, lsl #2]
    if ((boolean)FALSE == (boolean)(pRequestPtr->b10BitsSlaveAddressSize))
 5119474:	1a000005 	bne	5119490 <I2c_LPI2C_MasterSendAddress+0xe0>
		REG_RMW32(I2C_TAR_ADDR32(u8Channel), (MASTER_MODE_TAR_ADR_MASK | IC_TAR_IC_10BITADDR_MASTER_MASK), (pRequestPtr->SlaveAddress | MASTER_MODE_7BIT_ADR_VALUE));
 5119478:	e5973004 	ldr	r3, [r7, #4]
 511947c:	e1d820b0 	ldrh	r2, [r8]
 5119480:	e3c33d4f 	bic	r3, r3, #5056	; 0x13c0
 5119484:	e3c3303f 	bic	r3, r3, #63	; 0x3f
 5119488:	e1833002 	orr	r3, r3, r2
 511948c:	e5873004 	str	r3, [r7, #4]
	REG_RMW32(I2C_ENABLE_ADDR32(u8Channel), ENABLE_MASK, I2C_ENABL);
 5119490:	e597306c 	ldr	r3, [r7, #108]	; 0x6c
    return (Std_ReturnType)E_OK;
 5119494:	e3a00000 	mov	r0, #0
	REG_RMW32(I2C_ENABLE_ADDR32(u8Channel), ENABLE_MASK, I2C_ENABL);
 5119498:	e3833001 	orr	r3, r3, #1
 511949c:	e587306c 	str	r3, [r7, #108]	; 0x6c
}
 51194a0:	e28dd018 	add	sp, sp, #24
 51194a4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
        LOG(DBG_ERROR, "LPI2C", "ch%d wait idle timeout, status 0x%x, raw int 0x%x, slave 0x%x",
 51194a8:	e30d2cb8 	movw	r2, #56504	; 0xdcb8
 51194ac:	e300111f 	movw	r1, #287	; 0x11f
 51194b0:	e5970070 	ldr	r0, [r7, #112]	; 0x70
 51194b4:	e3402512 	movt	r2, #1298	; 0x512
 51194b8:	e597c034 	ldr	ip, [r7, #52]	; 0x34
 51194bc:	e30d3d38 	movw	r3, #56632	; 0xdd38
 51194c0:	e88d0206 	stm	sp, {r1, r2, r9}
 51194c4:	e30254b0 	movw	r5, #9392	; 0x24b0
 51194c8:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
 51194cc:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 51194d0:	e3403512 	movt	r3, #1298	; 0x512
 51194d4:	e58dc010 	str	ip, [sp, #16]
 51194d8:	e3402512 	movt	r2, #1298	; 0x512
 51194dc:	e58d000c 	str	r0, [sp, #12]
 51194e0:	e3401512 	movt	r1, #1298	; 0x512
 51194e4:	e1d800b0 	ldrh	r0, [r8]
 51194e8:	e58d0014 	str	r0, [sp, #20]
 51194ec:	e3a00001 	mov	r0, #1
 51194f0:	e3405511 	movt	r5, #1297	; 0x511
 51194f4:	e12fff35 	blx	r5
        if ( (Master->Callback != NULL_PTR)&&(0==(REG_READ32(I2C_RAW_INTR_STAT_ADDR32(u8Channel))&0x200)) )//no STOP_DET
 51194f8:	e59a300c 	ldr	r3, [sl, #12]
 51194fc:	e3530000 	cmp	r3, #0
 5119500:	0affffca 	beq	5119430 <I2c_LPI2C_MasterSendAddress+0x80>
 5119504:	e5973034 	ldr	r3, [r7, #52]	; 0x34
 5119508:	e3130c02 	tst	r3, #512	; 0x200
 511950c:	1affffc7 	bne	5119430 <I2c_LPI2C_MasterSendAddress+0x80>
            LOG(DBG_DEBUG,"LPI2C", "callback I2c_Event_ERROR_FIFO");
 5119510:	e30d3c98 	movw	r3, #56472	; 0xdc98
 5119514:	e30d2bbc 	movw	r2, #56252	; 0xdbbc
 5119518:	e30d1bdc 	movw	r1, #56284	; 0xdbdc
 511951c:	e3403512 	movt	r3, #1298	; 0x512
 5119520:	e3402512 	movt	r2, #1298	; 0x512
 5119524:	e58d3004 	str	r3, [sp, #4]
 5119528:	e3003123 	movw	r3, #291	; 0x123
 511952c:	e3a00004 	mov	r0, #4
 5119530:	e3401512 	movt	r1, #1298	; 0x512
 5119534:	e58d3000 	str	r3, [sp]
 5119538:	e30d3d38 	movw	r3, #56632	; 0xdd38
 511953c:	e3403512 	movt	r3, #1298	; 0x512
 5119540:	e12fff35 	blx	r5
            Master->Callback(I2c_Event_TX_FIFO_NOT_POP, Master->CallbackParam);
 5119544:	e59a300c 	ldr	r3, [sl, #12]
 5119548:	e3a0000f 	mov	r0, #15
 511954c:	e5da1010 	ldrb	r1, [sl, #16]
 5119550:	e12fff33 	blx	r3
            I2c_LPI2C_InitChannel(u8Channel, NULL_PTR);
 5119554:	e30931f8 	movw	r3, #37368	; 0x91f8
 5119558:	e1a00009 	mov	r0, r9
 511955c:	e1a01004 	mov	r1, r4
 5119560:	e3403511 	movt	r3, #1297	; 0x511
 5119564:	e12fff33 	blx	r3
            return E_NOT_OK;
 5119568:	e3a00001 	mov	r0, #1
 511956c:	eaffffcb 	b	51194a0 <I2c_LPI2C_MasterSendAddress+0xf0>

05119570 <I2c_LPI2C_SyncTransmit>:
{
 5119570:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
            u8TmpReturn = I2c_LPI2C_MasterReceive(u8Channel, pRequest, I2C_SYNC_MODE);
 5119574:	e3088d5c 	movw	r8, #36188	; 0x8d5c
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5119578:	e30876e4 	movw	r7, #34532	; 0x86e4
	u8TmpReturn = I2c_LPI2C_MasterSendAddress(u8Channel, pRequestPtr);
 511957c:	e30963b0 	movw	r6, #37808	; 0x93b0
{
 5119580:	e1a0a000 	mov	sl, r0
 5119584:	e1a05001 	mov	r5, r1
 5119588:	e3a04003 	mov	r4, #3
            u8TmpReturn = I2c_LPI2C_MasterReceive(u8Channel, pRequest, I2C_SYNC_MODE);
 511958c:	e3408511 	movt	r8, #1297	; 0x511
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5119590:	e3407513 	movt	r7, #1299	; 0x513
	u8TmpReturn = I2c_LPI2C_MasterSendAddress(u8Channel, pRequestPtr);
 5119594:	e3406511 	movt	r6, #1297	; 0x511
        if (I2C_SEND_DATA == pRequest->eDataDirection)
 5119598:	e5d53008 	ldrb	r3, [r5, #8]
	u8TmpReturn = I2c_LPI2C_MasterSendAddress(u8Channel, pRequestPtr);
 511959c:	e1a01005 	mov	r1, r5
 51195a0:	e1a0000a 	mov	r0, sl
        if (I2C_SEND_DATA == pRequest->eDataDirection)
 51195a4:	e3530000 	cmp	r3, #0
            u8TmpReturn = I2c_LPI2C_MasterReceive(u8Channel, pRequest, I2C_SYNC_MODE);
 51195a8:	e3a02001 	mov	r2, #1
        if (I2C_SEND_DATA == pRequest->eDataDirection)
 51195ac:	1a000011 	bne	51195f8 <I2c_LPI2C_SyncTransmit+0x88>
    VAR( uint8, AUTOMATIC) u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51195b0:	e7d7900a 	ldrb	r9, [r7, sl]
	u8TmpReturn = I2c_LPI2C_MasterSendAddress(u8Channel, pRequestPtr);
 51195b4:	e12fff36 	blx	r6
            u8TmpReturn = I2c_LPI2C_MasterSyncSend(u8Channel);
 51195b8:	e3081f0c 	movw	r1, #36620	; 0x8f0c
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 51195bc:	e30826dc 	movw	r2, #34524	; 0x86dc
            u8TmpReturn = I2c_LPI2C_MasterSyncSend(u8Channel);
 51195c0:	e3401511 	movt	r1, #1297	; 0x511
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 51195c4:	e3402513 	movt	r2, #1299	; 0x513
    if ((Std_ReturnType)E_OK == u8TmpReturn)
 51195c8:	e2503000 	subs	r3, r0, #0
            u8TmpReturn = I2c_LPI2C_MasterSyncSend(u8Channel);
 51195cc:	e1a0000a 	mov	r0, sl
    if ((Std_ReturnType)E_OK == u8TmpReturn)
 51195d0:	1a00000b 	bne	5119604 <I2c_LPI2C_SyncTransmit+0x94>
            u8TmpReturn = I2c_LPI2C_MasterSyncSend(u8Channel);
 51195d4:	e12fff31 	blx	r1
 51195d8:	e1a03000 	mov	r3, r0
        if(u8TmpReturn == E_OK) {
 51195dc:	e3530000 	cmp	r3, #0
 51195e0:	0a000002 	beq	51195f0 <I2c_LPI2C_SyncTransmit+0x80>
    for (retries = 3; retries > 0; retries--) {
 51195e4:	e2444001 	sub	r4, r4, #1
 51195e8:	e21440ff 	ands	r4, r4, #255	; 0xff
 51195ec:	1affffe9 	bne	5119598 <I2c_LPI2C_SyncTransmit+0x28>
}
 51195f0:	e1a00003 	mov	r0, r3
 51195f4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
            u8TmpReturn = I2c_LPI2C_MasterReceive(u8Channel, pRequest, I2C_SYNC_MODE);
 51195f8:	e12fff38 	blx	r8
 51195fc:	e1a03000 	mov	r3, r0
 5119600:	eafffff5 	b	51195dc <I2c_LPI2C_SyncTransmit+0x6c>
        I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_ERROR_PRESENT;
 5119604:	e3a01004 	mov	r1, #4
 5119608:	e7c21009 	strb	r1, [r2, r9]
        if(u8TmpReturn == E_OK) {
 511960c:	eafffff4 	b	51195e4 <I2c_LPI2C_SyncTransmit+0x74>

05119610 <I2c_LPI2C_DeInitChannel>:
*
*/
FUNC (void, I2C_CODE) I2c_LPI2C_DeInitChannel(CONST(uint8, AUTOMATIC) u8Channel)
{
  
}
 5119610:	e12fff1e 	bx	lr

05119614 <I2c_Init>:
* @note    Service ID: 0x00.
* @note    Synchronous, non re-entrant function.
*
*/
FUNC(void, I2C_CODE) I2c_Init(P2CONST(I2c_ConfigType, AUTOMATIC, I2C_APPL_CONST) pConfig)
{
 5119614:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
 5119618:	e30856e4 	movw	r5, #34532	; 0x86e4
            (void)Det_ReportError((uint16)I2C_MODULE_ID, (uint8)0, (uint8)I2C_INIT_ID, (uint8)I2C_E_INVALID_POINTER);
        }
        else
        {
    #endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */
                    I2c_pConfig = &I2c_PBCfgVariantPredefined;
 511961c:	e30866ec 	movw	r6, #34540	; 0x86ec
 5119620:	e30d7294 	movw	r7, #53908	; 0xd294
 5119624:	e3405513 	movt	r5, #1299	; 0x513
 5119628:	e30816dc 	movw	r1, #34524	; 0x86dc
 511962c:	e3406513 	movt	r6, #1299	; 0x513
 5119630:	e3407512 	movt	r7, #1298	; 0x512
 5119634:	e2453001 	sub	r3, r5, #1
 5119638:	e2854007 	add	r4, r5, #7
 511963c:	e3401513 	movt	r1, #1299	; 0x513
 5119640:	e265e001 	rsb	lr, r5, #1
#endif /* (I2C_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
            {
                I2c_au8ChannelHardwareMap[u8ChLoop] = 0xff;
                I2c_aeChannelStatus[u8ChLoop] = I2C_CH_IDLE;
 5119644:	e3a00000 	mov	r0, #0
                I2c_au8ChannelHardwareMap[u8ChLoop] = 0xff;
 5119648:	e3e0c000 	mvn	ip, #0
                    I2c_pConfig = &I2c_PBCfgVariantPredefined;
 511964c:	e5867000 	str	r7, [r6]
                I2c_au8ChannelHardwareMap[u8ChLoop] = 0xff;
 5119650:	e08e2003 	add	r2, lr, r3
 5119654:	e5e3c001 	strb	ip, [r3, #1]!
            for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
 5119658:	e1530004 	cmp	r3, r4
                I2c_aeChannelStatus[u8ChLoop] = I2C_CH_IDLE;
 511965c:	e7c10002 	strb	r0, [r1, r2]
            for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
 5119660:	1afffffa 	bne	5119650 <I2c_Init+0x3c>
            }
            for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 5119664:	e5d73000 	ldrb	r3, [r7]
 5119668:	e3530000 	cmp	r3, #0
 511966c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
 5119670:	e3a04000 	mov	r4, #0
 5119674:	e30d3294 	movw	r3, #53908	; 0xd294
 5119678:	e30971f8 	movw	r7, #37368	; 0x91f8
 511967c:	e3403512 	movt	r3, #1298	; 0x512
 5119680:	e1a01004 	mov	r1, r4
 5119684:	e3407511 	movt	r7, #1297	; 0x511
            {
                /* Map configured hardware channel to logical channel */
                I2c_au8ChannelHardwareMap[(*I2c_pConfig->I2c_pHwConfig)[u8ChLoop].I2c_HwUnit] = u8ChLoop;
 5119688:	e5932004 	ldr	r2, [r3, #4]
 511968c:	e0811081 	add	r1, r1, r1, lsl #1
 5119690:	e7d22101 	ldrb	r2, [r2, r1, lsl #2]
 5119694:	e7c54002 	strb	r4, [r5, r2]

                I2c_LPI2C_InitChannel((*I2c_pConfig->I2c_pHwConfig)[u8ChLoop].I2c_HwUnit, &(*I2c_pConfig->I2c_pHwConfig)[u8ChLoop]);
 5119698:	e5933004 	ldr	r3, [r3, #4]
            for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 511969c:	e2844001 	add	r4, r4, #1
                I2c_LPI2C_InitChannel((*I2c_pConfig->I2c_pHwConfig)[u8ChLoop].I2c_HwUnit, &(*I2c_pConfig->I2c_pHwConfig)[u8ChLoop]);
 51196a0:	e7d30101 	ldrb	r0, [r3, r1, lsl #2]
 51196a4:	e0831101 	add	r1, r3, r1, lsl #2
 51196a8:	e12fff37 	blx	r7
            for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 51196ac:	e5963000 	ldr	r3, [r6]
 51196b0:	e6ef1074 	uxtb	r1, r4
 51196b4:	e5d32000 	ldrb	r2, [r3]
 51196b8:	e1520001 	cmp	r2, r1
 51196bc:	8afffff1 	bhi	5119688 <I2c_Init+0x74>
 51196c0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

051196c4 <I2c_DeInit>:
    }
    else
    {
#endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */

        for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
 51196c4:	e30816e4 	movw	r1, #34532	; 0x86e4
 51196c8:	e30806dc 	movw	r0, #34524	; 0x86dc
 51196cc:	e3401513 	movt	r1, #1299	; 0x513
{
 51196d0:	e92d4070 	push	{r4, r5, r6, lr}
 51196d4:	e2413001 	sub	r3, r1, #1
 51196d8:	e2814007 	add	r4, r1, #7
 51196dc:	e3400513 	movt	r0, #1299	; 0x513
 51196e0:	e2611001 	rsb	r1, r1, #1
        {
            I2c_au8ChannelHardwareMap[u8ChLoop] = 0xff;
            I2c_aeChannelStatus[u8ChLoop] = I2C_CH_IDLE;
 51196e4:	e3a0c000 	mov	ip, #0
            I2c_au8ChannelHardwareMap[u8ChLoop] = 0xff;
 51196e8:	e3e0e000 	mvn	lr, #0
 51196ec:	e0812003 	add	r2, r1, r3
 51196f0:	e5e3e001 	strb	lr, [r3, #1]!
        for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
 51196f4:	e1530004 	cmp	r3, r4
            I2c_aeChannelStatus[u8ChLoop] = I2C_CH_IDLE;
 51196f8:	e7c0c002 	strb	ip, [r0, r2]
        for(u8ChLoop=(uint8)0U; u8ChLoop < I2C_HW_MAX_MODULES; u8ChLoop++)
 51196fc:	1afffffa 	bne	51196ec <I2c_DeInit+0x28>
        }
        for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 5119700:	e30856ec 	movw	r5, #34540	; 0x86ec
 5119704:	e3405513 	movt	r5, #1299	; 0x513
 5119708:	e5952000 	ldr	r2, [r5]
 511970c:	e5d23000 	ldrb	r3, [r2]
 5119710:	e3530000 	cmp	r3, #0
 5119714:	08bd8070 	popeq	{r4, r5, r6, pc}
 5119718:	e3a04000 	mov	r4, #0
 511971c:	e3096610 	movw	r6, #38416	; 0x9610
 5119720:	e1a03004 	mov	r3, r4
 5119724:	e3406511 	movt	r6, #1297	; 0x511
        {
           I2c_LPI2C_DeInitChannel((*I2c_pConfig->I2c_pHwConfig)[u8ChLoop].I2c_HwUnit);
 5119728:	e5922004 	ldr	r2, [r2, #4]
        for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 511972c:	e2844001 	add	r4, r4, #1
           I2c_LPI2C_DeInitChannel((*I2c_pConfig->I2c_pHwConfig)[u8ChLoop].I2c_HwUnit);
 5119730:	e0833083 	add	r3, r3, r3, lsl #1
 5119734:	e7d20103 	ldrb	r0, [r2, r3, lsl #2]
 5119738:	e12fff36 	blx	r6
        for(u8ChLoop=(uint8)0U; u8ChLoop < I2c_pConfig->I2c_MaxHwUnit; u8ChLoop++)
 511973c:	e5952000 	ldr	r2, [r5]
 5119740:	e6ef3074 	uxtb	r3, r4
 5119744:	e5d21000 	ldrb	r1, [r2]
 5119748:	e1510003 	cmp	r1, r3
 511974c:	8afffff5 	bhi	5119728 <I2c_DeInit+0x64>
 5119750:	e8bd8070 	pop	{r4, r5, r6, pc}

05119754 <I2c_SyncTransmit>:
{
    VAR(Std_ReturnType, AUTOMATIC) tempReturn = (uint8)E_NOT_OK;
    VAR(I2c_StatusType, AUTOMATIC) eTempChannelStatus;
    VAR(uint8, AUTOMATIC) u8LogicalChannel = 0xff;

    if(u8Channel >= I2C_HW_MAX_MODULES)
 5119754:	e3500007 	cmp	r0, #7
{
 5119758:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
        /* Invalid channel */
        /* Report error to development error tracer */
        (void)Det_ReportError((uint16)I2C_MODULE_ID,(uint8)0,(uint8)I2C_SYNCTRANSMIT_ID, (uint8)I2C_E_INVALID_CHANNEL);
    #endif
        tempReturn = (uint8)E_NOT_OK;
        return tempReturn;
 511975c:	83a05001 	movhi	r5, #1
    if(u8Channel >= I2C_HW_MAX_MODULES)
 5119760:	8a000009 	bhi	511978c <I2c_SyncTransmit+0x38>
            }
            else
            {
#endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */
                /* Check whether the I2C channel is a master or master/slave channel */
                if ( I2C_SLAVE_MODE != (*I2c_pConfig->I2c_pHwConfig)[u8Channel].eMasterSlaveConfig )
 5119764:	e30876ec 	movw	r7, #34540	; 0x86ec
 5119768:	e0802080 	add	r2, r0, r0, lsl #1
 511976c:	e1a04000 	mov	r4, r0
 5119770:	e3407513 	movt	r7, #1299	; 0x513
 5119774:	e5973000 	ldr	r3, [r7]
 5119778:	e5933004 	ldr	r3, [r3, #4]
 511977c:	e0833102 	add	r3, r3, r2, lsl #2
 5119780:	e5d35001 	ldrb	r5, [r3, #1]
 5119784:	e3550001 	cmp	r5, #1
 5119788:	1a000001 	bne	5119794 <I2c_SyncTransmit+0x40>
            }
        }
    }
#endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */
    return tempReturn;
}
 511978c:	e1a00005 	mov	r0, r5
 5119790:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119794:	e3015ecc 	movw	r5, #7884	; 0x1ecc
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 5119798:	e30836e4 	movw	r3, #34532	; 0x86e4
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 511979c:	e3405511 	movt	r5, #1297	; 0x511
 51197a0:	e1a06001 	mov	r6, r1
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51197a4:	e3403513 	movt	r3, #1299	; 0x513
 51197a8:	e7d38000 	ldrb	r8, [r3, r0]
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51197ac:	e12fff35 	blx	r5
                    eTempChannelStatus = I2c_aeChannelStatus[u8Channel];
 51197b0:	e30836dc 	movw	r3, #34524	; 0x86dc
 51197b4:	e3403513 	movt	r3, #1299	; 0x513
 51197b8:	e7d32004 	ldrb	r2, [r3, r4]
                    if ((I2C_CH_SEND != eTempChannelStatus) && (I2C_CH_RECEIVE != eTempChannelStatus))
 51197bc:	e2422001 	sub	r2, r2, #1
 51197c0:	e3520001 	cmp	r2, #1
 51197c4:	9a00001f 	bls	5119848 <I2c_SyncTransmit+0xf4>
                        if (I2C_SEND_DATA == pRequestPtr->eDataDirection)
 51197c8:	e5d62008 	ldrb	r2, [r6, #8]
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51197cc:	e3019ed0 	movw	r9, #7888	; 0x1ed0
                        if (I2C_SEND_DATA == pRequestPtr->eDataDirection)
 51197d0:	e3520000 	cmp	r2, #0
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_SEND;
 51197d4:	03a02001 	moveq	r2, #1
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_RECEIVE;
 51197d8:	13a02002 	movne	r2, #2
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51197dc:	e1a00004 	mov	r0, r4
 51197e0:	e3409511 	movt	r9, #1297	; 0x511
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_RECEIVE;
 51197e4:	e7c32008 	strb	r2, [r3, r8]
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pRequestPtr);
 51197e8:	e0888088 	add	r8, r8, r8, lsl #1
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51197ec:	e12fff39 	blx	r9
                        SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 51197f0:	e1a00004 	mov	r0, r4
 51197f4:	e12fff35 	blx	r5
 51197f8:	e3013ed4 	movw	r3, #7892	; 0x1ed4
 51197fc:	e1a00004 	mov	r0, r4
 5119800:	e3403511 	movt	r3, #1297	; 0x511
 5119804:	e12fff33 	blx	r3
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pRequestPtr);
 5119808:	e5973000 	ldr	r3, [r7]
 511980c:	e1a01006 	mov	r1, r6
 5119810:	e5933004 	ldr	r3, [r3, #4]
 5119814:	e7d30108 	ldrb	r0, [r3, r8, lsl #2]
 5119818:	e3093570 	movw	r3, #38256	; 0x9570
 511981c:	e3403511 	movt	r3, #1297	; 0x511
 5119820:	e12fff33 	blx	r3
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119824:	e3013f20 	movw	r3, #7968	; 0x1f20
 5119828:	e3403511 	movt	r3, #1297	; 0x511
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pRequestPtr);
 511982c:	e1a05000 	mov	r5, r0
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119830:	e1a00004 	mov	r0, r4
 5119834:	e12fff33 	blx	r3
 5119838:	e1a00004 	mov	r0, r4
 511983c:	e12fff39 	blx	r9
}
 5119840:	e1a00005 	mov	r0, r5
 5119844:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119848:	e3013ed0 	movw	r3, #7888	; 0x1ed0
 511984c:	e1a00004 	mov	r0, r4
    VAR(Std_ReturnType, AUTOMATIC) tempReturn = (uint8)E_NOT_OK;
 5119850:	e3a05001 	mov	r5, #1
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119854:	e3403511 	movt	r3, #1297	; 0x511
 5119858:	e12fff33 	blx	r3
 511985c:	eaffffca 	b	511978c <I2c_SyncTransmit+0x38>

05119860 <I2c_SyncTxRx>:
{
    VAR(Std_ReturnType, AUTOMATIC) tempReturn = (uint8)E_NOT_OK;
    VAR(I2c_StatusType, AUTOMATIC) eTempChannelStatus;
    VAR(uint8, AUTOMATIC) u8LogicalChannel = -1;

    if(u8Channel >= I2C_HW_MAX_MODULES)
 5119860:	e3500007 	cmp	r0, #7
 5119864:	8a00006b 	bhi	5119a18 <I2c_SyncTxRx+0x1b8>
{
 5119868:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
            }
            else
            {
#endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */
                /* Check whether the I2C channel is a master or master/slave channel */
                if ( I2C_MASTER_MODE == (*I2c_pConfig->I2c_pHwConfig)[u8Channel].eMasterSlaveConfig )
 511986c:	e30866ec 	movw	r6, #34540	; 0x86ec
 5119870:	e1a05002 	mov	r5, r2
 5119874:	e3406513 	movt	r6, #1299	; 0x513
 5119878:	e0803080 	add	r3, r0, r0, lsl #1
 511987c:	e1a04000 	mov	r4, r0
{
 5119880:	e24dd014 	sub	sp, sp, #20
                if ( I2C_MASTER_MODE == (*I2c_pConfig->I2c_pHwConfig)[u8Channel].eMasterSlaveConfig )
 5119884:	e5962000 	ldr	r2, [r6]
 5119888:	e5922004 	ldr	r2, [r2, #4]
 511988c:	e0823103 	add	r3, r2, r3, lsl #2
 5119890:	e5d33001 	ldrb	r3, [r3, #1]
 5119894:	e3530000 	cmp	r3, #0
        return tempReturn;
 5119898:	13a01001 	movne	r1, #1
                if ( I2C_MASTER_MODE == (*I2c_pConfig->I2c_pHwConfig)[u8Channel].eMasterSlaveConfig )
 511989c:	0a000002 	beq	51198ac <I2c_SyncTxRx+0x4c>
            }
        }
    }
#endif /* (I2C_DEV_ERROR_DETECT == STD_ON) */
    return tempReturn;
}
 51198a0:	e1a00001 	mov	r0, r1
 51198a4:	e28dd014 	add	sp, sp, #20
 51198a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51198ac:	e3017ecc 	movw	r7, #7884	; 0x1ecc
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51198b0:	e30836e4 	movw	r3, #34532	; 0x86e4
                    eTempChannelStatus = I2c_aeChannelStatus[u8Channel];
 51198b4:	e30886dc 	movw	r8, #34524	; 0x86dc
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51198b8:	e3407511 	movt	r7, #1297	; 0x511
 51198bc:	e1a0b001 	mov	fp, r1
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51198c0:	e3403513 	movt	r3, #1299	; 0x513
                    eTempChannelStatus = I2c_aeChannelStatus[u8Channel];
 51198c4:	e3408513 	movt	r8, #1299	; 0x513
    u8LogicalChannel = I2c_au8ChannelHardwareMap[u8Channel];
 51198c8:	e7d39000 	ldrb	r9, [r3, r0]
                    SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51198cc:	e12fff37 	blx	r7
                    eTempChannelStatus = I2c_aeChannelStatus[u8Channel];
 51198d0:	e7d83004 	ldrb	r3, [r8, r4]
                    if ((I2C_CH_SEND != eTempChannelStatus) && (I2C_CH_RECEIVE != eTempChannelStatus))
 51198d4:	e2433001 	sub	r3, r3, #1
 51198d8:	e3530001 	cmp	r3, #1
 51198dc:	9a000050 	bls	5119a24 <I2c_SyncTxRx+0x1c4>
                        if (I2C_SEND_DATA == pTxRequestPtr->eDataDirection)
 51198e0:	e5db3008 	ldrb	r3, [fp, #8]
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51198e4:	e301aed0 	movw	sl, #7888	; 0x1ed0
                        if (I2C_SEND_DATA == pTxRequestPtr->eDataDirection)
 51198e8:	e3530000 	cmp	r3, #0
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_SEND;
 51198ec:	03a03001 	moveq	r3, #1
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_RECEIVE;
 51198f0:	13a03002 	movne	r3, #2
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51198f4:	e1a00004 	mov	r0, r4
 51198f8:	e340a511 	movt	sl, #1297	; 0x511
                            I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_RECEIVE;
 51198fc:	e7c83009 	strb	r3, [r8, r9]
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119900:	e12fff3a 	blx	sl
                        SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119904:	e1a00004 	mov	r0, r4
 5119908:	e12fff37 	blx	r7
 511990c:	e3012ed4 	movw	r2, #7892	; 0x1ed4
 5119910:	e1a00004 	mov	r0, r4
 5119914:	e3402511 	movt	r2, #1297	; 0x511
 5119918:	e58d200c 	str	r2, [sp, #12]
 511991c:	e12fff32 	blx	r2
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pTxRequestPtr);
 5119920:	e5963000 	ldr	r3, [r6]
 5119924:	e1a0100b 	mov	r1, fp
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119928:	e301bf20 	movw	fp, #7968	; 0x1f20
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pTxRequestPtr);
 511992c:	e089c089 	add	ip, r9, r9, lsl #1
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119930:	e340b511 	movt	fp, #1297	; 0x511
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pTxRequestPtr);
 5119934:	e5930004 	ldr	r0, [r3, #4]
 5119938:	e3093570 	movw	r3, #38256	; 0x9570
 511993c:	e3403511 	movt	r3, #1297	; 0x511
 5119940:	e7d0010c 	ldrb	r0, [r0, ip, lsl #2]
 5119944:	e58d3008 	str	r3, [sp, #8]
 5119948:	e12fff33 	blx	r3
 511994c:	e58d0004 	str	r0, [sp, #4]
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119950:	e1a00004 	mov	r0, r4
 5119954:	e12fff3b 	blx	fp
 5119958:	e1a00004 	mov	r0, r4
 511995c:	e12fff3a 	blx	sl
                    if(tempReturn == E_OK)
 5119960:	e59d1004 	ldr	r1, [sp, #4]
 5119964:	e59d200c 	ldr	r2, [sp, #12]
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pTxRequestPtr);
 5119968:	e1a03089 	lsl	r3, r9, #1
                    if(tempReturn == E_OK)
 511996c:	e3510000 	cmp	r1, #0
                        tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pTxRequestPtr);
 5119970:	e58d3004 	str	r3, [sp, #4]
                    if(tempReturn == E_OK)
 5119974:	e59d3008 	ldr	r3, [sp, #8]
 5119978:	1affffc8 	bne	51198a0 <I2c_SyncTxRx+0x40>
                        SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 511997c:	e58d1004 	str	r1, [sp, #4]
 5119980:	e1a00004 	mov	r0, r4
 5119984:	e1cd20f8 	strd	r2, [sp, #8]
 5119988:	e12fff37 	blx	r7
                        eTempChannelStatus = I2c_aeChannelStatus[u8Channel];
 511998c:	e7d80004 	ldrb	r0, [r8, r4]
                        if ((I2C_CH_SEND != eTempChannelStatus) && (I2C_CH_RECEIVE != eTempChannelStatus))
 5119990:	e59d1004 	ldr	r1, [sp, #4]
 5119994:	e2400001 	sub	r0, r0, #1
 5119998:	e3500001 	cmp	r0, #1
 511999c:	9a000028 	bls	5119a44 <I2c_SyncTxRx+0x1e4>
                            if (I2C_SEND_DATA == pRxRequestPtr->eDataDirection)
 51199a0:	e5d51008 	ldrb	r1, [r5, #8]
 51199a4:	e1cd20d8 	ldrd	r2, [sp, #8]
                            SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51199a8:	e1a00004 	mov	r0, r4
                            if (I2C_SEND_DATA == pRxRequestPtr->eDataDirection)
 51199ac:	e3510000 	cmp	r1, #0
                                I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_SEND;
 51199b0:	03a01001 	moveq	r1, #1
                                I2c_aeChannelStatus[u8LogicalChannel] = I2C_CH_RECEIVE;
 51199b4:	13a01002 	movne	r1, #2
 51199b8:	e1cd20f4 	strd	r2, [sp, #4]
 51199bc:	e7c81009 	strb	r1, [r8, r9]
                            SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 51199c0:	e12fff3a 	blx	sl
                            SchM_Enter_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 51199c4:	e1a00004 	mov	r0, r4
 51199c8:	e12fff37 	blx	r7
 51199cc:	e59d2004 	ldr	r2, [sp, #4]
 51199d0:	e1a00004 	mov	r0, r4
 51199d4:	e12fff32 	blx	r2
                            tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pRxRequestPtr);
 51199d8:	e5962000 	ldr	r2, [r6]
 51199dc:	e1a01005 	mov	r1, r5
 51199e0:	e1a03089 	lsl	r3, r9, #1
 51199e4:	e0839009 	add	r9, r3, r9
 51199e8:	e5922004 	ldr	r2, [r2, #4]
 51199ec:	e7d20109 	ldrb	r0, [r2, r9, lsl #2]
 51199f0:	e59d3008 	ldr	r3, [sp, #8]
 51199f4:	e12fff33 	blx	r3
 51199f8:	e1a01000 	mov	r1, r0
                            SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 51199fc:	e1a00004 	mov	r0, r4
                            tempReturn = (uint8)I2c_LPI2C_SyncTransmit((*I2c_pConfig->I2c_pHwConfig)[u8LogicalChannel].I2c_HwUnit, pRxRequestPtr);
 5119a00:	e58d1004 	str	r1, [sp, #4]
                            SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_01(u8Channel);
 5119a04:	e12fff3b 	blx	fp
 5119a08:	e1a00004 	mov	r0, r4
 5119a0c:	e12fff3a 	blx	sl
 5119a10:	e59d1004 	ldr	r1, [sp, #4]
 5119a14:	eaffffa1 	b	51198a0 <I2c_SyncTxRx+0x40>
        return tempReturn;
 5119a18:	e3a01001 	mov	r1, #1
}
 5119a1c:	e1a00001 	mov	r0, r1
 5119a20:	e12fff1e 	bx	lr
    VAR(Std_ReturnType, AUTOMATIC) tempReturn = (uint8)E_NOT_OK;
 5119a24:	e3a01001 	mov	r1, #1
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119a28:	e3013ed0 	movw	r3, #7888	; 0x1ed0
 5119a2c:	e1a00004 	mov	r0, r4
 5119a30:	e3403511 	movt	r3, #1297	; 0x511
    VAR(Std_ReturnType, AUTOMATIC) tempReturn = (uint8)E_NOT_OK;
 5119a34:	e58d1004 	str	r1, [sp, #4]
                        SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119a38:	e12fff33 	blx	r3
                    if(tempReturn == E_OK)
 5119a3c:	e59d1004 	ldr	r1, [sp, #4]
 5119a40:	eaffff96 	b	51198a0 <I2c_SyncTxRx+0x40>
 5119a44:	e58d1004 	str	r1, [sp, #4]
                            SchM_Exit_I2c_I2C_EXCLUSIVE_AREA_00(u8Channel);
 5119a48:	e1a00004 	mov	r0, r4
 5119a4c:	e12fff3a 	blx	sl
 5119a50:	e59d1004 	ldr	r1, [sp, #4]
 5119a54:	eaffff91 	b	51198a0 <I2c_SyncTxRx+0x40>

05119a58 <Wdg_Internal_Init>:
LOCAL_INLINE FUNC(Std_ReturnType, WDG_CODE) Wdg_ChannelValidateGlobalCall(CONST(Wdg_ServiceIdType, AUTOMATIC)uServiceId , WdgIf_ModeType Mode)
{
    VAR(Std_ReturnType, AUTOMATIC) valid = (Std_ReturnType)E_OK;
    
    SchM_Enter_Wdg_WDG_EXCLUSIVE_AREA_01();
    if(((WDG_UNINIT == Wdg_Status) && (WDG_INIT_ID != uServiceId)) ||\
 5119a58:	e30836f0 	movw	r3, #34544	; 0x86f0
#if (WDG_PRECOMPILE_SUPPORT == STD_ON)
    /** @violates @ref Wdg_c_REF_4 Violates MISRA 2004 Rule 11.1, Cast from pointer to unsigned long.*/
    Wdg_pConfigPtr = Wdg_pPBCfgVariantPredefined[0];
    (void)pConfigPtr;
#else
    Wdg_pConfigPtr = ConfigPtr;
 5119a5c:	e30826f4 	movw	r2, #34548	; 0x86f4
    if(((WDG_UNINIT == Wdg_Status) && (WDG_INIT_ID != uServiceId)) ||\
 5119a60:	e3403513 	movt	r3, #1299	; 0x513
       (WDG_INITIALIZING == Wdg_Status) || (WDG_BUSY == Wdg_Status)
 5119a64:	e5d31000 	ldrb	r1, [r3]
 5119a68:	e2411002 	sub	r1, r1, #2
    Wdg_pConfigPtr = ConfigPtr;
 5119a6c:	e3402513 	movt	r2, #1299	; 0x513
       (WDG_INITIALIZING == Wdg_Status) || (WDG_BUSY == Wdg_Status)
 5119a70:	e3510001 	cmp	r1, #1
    Wdg_pConfigPtr = ConfigPtr;
 5119a74:	e5820000 	str	r0, [r2]
#endif /*(WDG_PRECOMPILE_SUPPORT == STD_ON)*/

#if (WDG_VALIDATE_GLOBAL_CALL == STD_ON)
    valid = Wdg_ChannelValidateGlobalCall(WDG_INIT_ID , Wdg_pConfigPtr->Wdg_DefaultMode);
 5119a78:	e5d02000 	ldrb	r2, [r0]
       (WDG_INITIALIZING == Wdg_Status) || (WDG_BUSY == Wdg_Status)
 5119a7c:	9a00000a 	bls	5119aac <Wdg_Internal_Init+0x54>
            Wdg_Status = WDG_INITIALIZING;
 5119a80:	e3a01003 	mov	r1, #3
    if (FALSE == ((WDGIF_OFF_MODE  == Mode)||(WDGIF_FAST_MODE == Mode)||(WDGIF_SLOW_MODE == Mode)))
 5119a84:	e31200fd 	tst	r2, #253	; 0xfd
            Wdg_Status = WDG_INITIALIZING;
 5119a88:	e5c31000 	strb	r1, [r3]
    if (FALSE == ((WDGIF_OFF_MODE  == Mode)||(WDGIF_FAST_MODE == Mode)||(WDGIF_SLOW_MODE == Mode)))
 5119a8c:	1a000009 	bne	5119ab8 <Wdg_Internal_Init+0x60>
#ifndef CPUTYPE_C1200_SEC
            // REG_BIT_CLEAR32(TOP_CRM_BASE_ADDR + WDT_RST_MASK_OFFSET, (0x1<<Wdg_InstanceNum));
#else
            // REG_BIT_CLEAR32(TOP_CRM_BASE_ADDR + WDT_RST_MASK_OFFSET, (0x1<<(Wdg_InstanceNum+3)));
#endif
            if(Wdg_DefaultMode != WDGIF_OFF_MODE)
 5119a90:	e3520000 	cmp	r2, #0
 5119a94:	1a000009 	bne	5119ac0 <Wdg_Internal_Init+0x68>
                /*CRR,watch dog reset(kick dog)*/
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
            }
            else
            {
                Wdg_TempReg = Wdg_HwModuleAddr[Wdg_InstanceNum]->CR;
 5119a98:	e3a02a0f 	mov	r2, #61440	; 0xf000
 5119a9c:	e3422000 	movt	r2, #8192	; 0x2000
 5119aa0:	e5921000 	ldr	r1, [r2]
                Wdg_TempReg &= (~0x01);
 5119aa4:	e3c11001 	bic	r1, r1, #1
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = Wdg_TempReg; /*Disable wdt*/
 5119aa8:	e5821000 	str	r1, [r2]
                Wdg_Status = WDG_IDLE;
 5119aac:	e3a02001 	mov	r2, #1
 5119ab0:	e5c32000 	strb	r2, [r3]
#endif
#if (WDG_VALIDATE_GLOBAL_CALL == STD_ON)
    }
    Wdg_ChannelEndValidateGlobalCall(valid);
#endif
}
 5119ab4:	e12fff1e 	bx	lr
    if (FALSE == ((WDGIF_OFF_MODE  == Mode)||(WDGIF_FAST_MODE == Mode)||(WDGIF_SLOW_MODE == Mode)))
 5119ab8:	e3520001 	cmp	r2, #1
 5119abc:	1afffffa 	bne	5119aac <Wdg_Internal_Init+0x54>
                Wdg_Timeout = Wdg_pConfigPtr->Wdg_ModeSettings[Wdg_DefaultMode]->Wdg_Timeout;
 5119ac0:	e0802102 	add	r2, r0, r2, lsl #2
 5119ac4:	e5921004 	ldr	r1, [r2, #4]
                Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = ((Wdg_InitTimeout << 4) | Wdg_Timeout);
 5119ac8:	e5d1c000 	ldrb	ip, [r1]
 5119acc:	e5d12001 	ldrb	r2, [r1, #1]
 5119ad0:	e3a01a0f 	mov	r1, #61440	; 0xf000
 5119ad4:	e3421000 	movt	r1, #8192	; 0x2000
 5119ad8:	e182220c 	orr	r2, r2, ip, lsl #4
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119adc:	e3a0c076 	mov	ip, #118	; 0x76
                Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = ((Wdg_InitTimeout << 4) | Wdg_Timeout);
 5119ae0:	e5812004 	str	r2, [r1, #4]
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119ae4:	e581c00c 	str	ip, [r1, #12]
                                                        (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119ae8:	e5d02003 	ldrb	r2, [r0, #3]
 5119aec:	e1a02082 	lsl	r2, r2, #1
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119af0:	e5d00002 	ldrb	r0, [r0, #2]
 5119af4:	e1822100 	orr	r2, r2, r0, lsl #2
                                                        (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119af8:	e3822001 	orr	r2, r2, #1
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119afc:	e5812000 	str	r2, [r1]
                Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119b00:	e581c00c 	str	ip, [r1, #12]
    if ((Std_ReturnType)E_OK == validation)
 5119b04:	eaffffe8 	b	5119aac <Wdg_Internal_Init+0x54>

05119b08 <Wdg_Internal_SetMode>:
    if(((WDG_UNINIT == Wdg_Status) && (WDG_INIT_ID != uServiceId)) ||\
 5119b08:	e30836f0 	movw	r3, #34544	; 0x86f0
 5119b0c:	e3403513 	movt	r3, #1299	; 0x513
 5119b10:	e5d32000 	ldrb	r2, [r3]
 5119b14:	e3520000 	cmp	r2, #0
 5119b18:	1a000008 	bne	5119b40 <Wdg_Internal_SetMode+0x38>
            if (NULL_PTR == Wdg_pConfigPtr)
 5119b1c:	e30826f4 	movw	r2, #34548	; 0x86f4
 5119b20:	e3402513 	movt	r2, #1299	; 0x513
 5119b24:	e5922000 	ldr	r2, [r2]
 5119b28:	e3520000 	cmp	r2, #0
 5119b2c:	0a000032 	beq	5119bfc <Wdg_Internal_SetMode+0xf4>
            Wdg_Status = WDG_IDLE;
 5119b30:	e3a02001 	mov	r2, #1
 5119b34:	e1a00002 	mov	r0, r2
 5119b38:	e5c32000 	strb	r2, [r3]
 5119b3c:	e12fff1e 	bx	lr
    if(((WDG_UNINIT == Wdg_Status) && (WDG_INIT_ID != uServiceId)) ||\
 5119b40:	e3520003 	cmp	r2, #3
 5119b44:	0afffff4 	beq	5119b1c <Wdg_Internal_SetMode+0x14>
       (WDG_INITIALIZING == Wdg_Status) || (WDG_BUSY == Wdg_Status)
 5119b48:	e3520002 	cmp	r2, #2
 5119b4c:	0afffff7 	beq	5119b30 <Wdg_Internal_SetMode+0x28>
            Wdg_Status = WDG_BUSY;
 5119b50:	e3a02002 	mov	r2, #2
    if (FALSE == ((WDGIF_OFF_MODE  == Mode)||(WDGIF_FAST_MODE == Mode)||(WDGIF_SLOW_MODE == Mode)))
 5119b54:	e31000fd 	tst	r0, #253	; 0xfd
            Wdg_Status = WDG_BUSY;
 5119b58:	e5c32000 	strb	r2, [r3]
    if (FALSE == ((WDGIF_OFF_MODE  == Mode)||(WDGIF_FAST_MODE == Mode)||(WDGIF_SLOW_MODE == Mode)))
 5119b5c:	1a00000a 	bne	5119b8c <Wdg_Internal_SetMode+0x84>
#if (WDG_VALIDATE_GLOBAL_CALL == STD_ON)
    valid = Wdg_ChannelValidateGlobalCall(WDG_SETMODE_ID , Mode);
    if ((Std_ReturnType)E_OK == valid)
    {
#endif /* (WDG_VALIDATE_GLOBAL_CALL == STD_ON */
        if(Mode != WDGIF_OFF_MODE)
 5119b60:	e3500000 	cmp	r0, #0
 5119b64:	1a00000a 	bne	5119b94 <Wdg_Internal_SetMode+0x8c>
            /*CRR,watch dog reset(kick dog)*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
        }
        else
        {
            Wdg_TempReg = Wdg_HwModuleAddr[Wdg_InstanceNum]->CR;
 5119b68:	e3a02a0f 	mov	r2, #61440	; 0xf000
 5119b6c:	e3a00000 	mov	r0, #0
 5119b70:	e3422000 	movt	r2, #8192	; 0x2000
 5119b74:	e5921000 	ldr	r1, [r2]
            Wdg_TempReg &= (~0x01);
 5119b78:	e3c11001 	bic	r1, r1, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = Wdg_TempReg; /*Disable wdt*/
 5119b7c:	e5821000 	str	r1, [r2]
        Wdg_Status = WDG_IDLE;
 5119b80:	e3a02001 	mov	r2, #1
 5119b84:	e5c32000 	strb	r2, [r3]
 5119b88:	e12fff1e 	bx	lr
    if ((Std_ReturnType)E_OK == valid)
 5119b8c:	e3500001 	cmp	r0, #1
 5119b90:	1affffe6 	bne	5119b30 <Wdg_Internal_SetMode+0x28>
            Wdg_Timeout = Wdg_pConfigPtr->Wdg_ModeSettings[Mode]->Wdg_Timeout;
 5119b94:	e30826f4 	movw	r2, #34548	; 0x86f4
 5119b98:	e3402513 	movt	r2, #1299	; 0x513
{
 5119b9c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
            Wdg_Timeout = Wdg_pConfigPtr->Wdg_ModeSettings[Mode]->Wdg_Timeout;
 5119ba0:	e592c000 	ldr	ip, [r2]
 5119ba4:	e08c0100 	add	r0, ip, r0, lsl #2
 5119ba8:	e5901004 	ldr	r1, [r0, #4]
 5119bac:	e5d12001 	ldrb	r2, [r1, #1]
            Wdg_InitTimeout = Wdg_pConfigPtr->Wdg_ModeSettings[Mode]->Wdog_InitTimeout;
 5119bb0:	e5d11000 	ldrb	r1, [r1]
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119bb4:	e3a00076 	mov	r0, #118	; 0x76
            Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = ((Wdg_InitTimeout << 4) | Wdg_Timeout);
 5119bb8:	e1822201 	orr	r2, r2, r1, lsl #4
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119bbc:	e3a01a0f 	mov	r1, #61440	; 0xf000
 5119bc0:	e3421000 	movt	r1, #8192	; 0x2000
 5119bc4:	e581000c 	str	r0, [r1, #12]
            Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = ((Wdg_InitTimeout << 4) | Wdg_Timeout);
 5119bc8:	e5812004 	str	r2, [r1, #4]
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119bcc:	e581000c 	str	r0, [r1, #12]
                                                    (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119bd0:	e5dc2003 	ldrb	r2, [ip, #3]
 5119bd4:	e1a02082 	lsl	r2, r2, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119bd8:	e5dce002 	ldrb	lr, [ip, #2]
 5119bdc:	e182210e 	orr	r2, r2, lr, lsl #2
                                                    (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119be0:	e3822001 	orr	r2, r2, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119be4:	e5812000 	str	r2, [r1]
        Wdg_Status = WDG_IDLE;
 5119be8:	e3a02001 	mov	r2, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119bec:	e581000c 	str	r0, [r1, #12]
        Wdg_Status = WDG_IDLE;
 5119bf0:	e3a00000 	mov	r0, #0
 5119bf4:	e5c32000 	strb	r2, [r3]
    Wdg_ChannelEndValidateGlobalCall(valid);

    return valid;
#endif
    return valid;
}
 5119bf8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
                Wdg_Status = WDG_UNINIT;
 5119bfc:	e5c32000 	strb	r2, [r3]
 5119c00:	e3a00001 	mov	r0, #1
}
 5119c04:	e12fff1e 	bx	lr

05119c08 <Wdg_Internal_SetTriggerCondition>:
    if ((WDG_UNINIT == Wdg_Status) ||(WDG_INITIALIZING == Wdg_Status))
 5119c08:	e30836f0 	movw	r3, #34544	; 0x86f0
 5119c0c:	e3403513 	movt	r3, #1299	; 0x513
 5119c10:	e5d33000 	ldrb	r3, [r3]
 5119c14:	e3530003 	cmp	r3, #3
 5119c18:	13530000 	cmpne	r3, #0
 5119c1c:	03a03001 	moveq	r3, #1
 5119c20:	13a03000 	movne	r3, #0
    if (u16Timeout > WDG_USER15_OR_2G)
 5119c24:	e350000f 	cmp	r0, #15
 5119c28:	83833001 	orrhi	r3, r3, #1
 5119c2c:	e3530000 	cmp	r3, #0
 5119c30:	112fff1e 	bxne	lr
#if (WDG_VALIDATE_PARAMS == STD_ON)
        valid = Wdg_ValidateTimeout(Timeout);
        if ((Std_ReturnType)E_OK == valid)
        {
#endif
            Wdg_InstanceNum = Wdg_pConfigPtr->Wdg_Instance;
 5119c34:	e30836f4 	movw	r3, #34548	; 0x86f4

            /*CRR,watch dog reset(kick dog)*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119c38:	e3a02a0f 	mov	r2, #61440	; 0xf000
            Wdg_InstanceNum = Wdg_pConfigPtr->Wdg_Instance;
 5119c3c:	e3403513 	movt	r3, #1299	; 0x513
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119c40:	e3a01076 	mov	r1, #118	; 0x76
 5119c44:	e3422000 	movt	r2, #8192	; 0x2000

            /*Config time out reg*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = (((Timeout << 4) & 0xF0) | (Timeout & 0x0F));
 5119c48:	e1800200 	orr	r0, r0, r0, lsl #4
            Wdg_InstanceNum = Wdg_pConfigPtr->Wdg_Instance;
 5119c4c:	e593c000 	ldr	ip, [r3]
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119c50:	e582100c 	str	r1, [r2, #12]
            Wdg_HwModuleAddr[Wdg_InstanceNum]->TORR = (((Timeout << 4) & 0xF0) | (Timeout & 0x0F));
 5119c54:	e5820004 	str	r0, [r2, #4]

            /*CRR,watch dog reset(kick dog)*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119c58:	e582100c 	str	r1, [r2, #12]

            /*Set reset pulse length, response mode, and enable WDT*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
                                                    (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119c5c:	e5dc3003 	ldrb	r3, [ip, #3]
 5119c60:	e1a03083 	lsl	r3, r3, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119c64:	e5dc0002 	ldrb	r0, [ip, #2]
 5119c68:	e1833100 	orr	r3, r3, r0, lsl #2
                                                    (Wdg_pConfigPtr->Wdg_RespMode << 1) | WDG_CR_ENABLED);
 5119c6c:	e3833001 	orr	r3, r3, #1
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CR = ((Wdg_pConfigPtr->Wdg_ResetPulse << 2) | \
 5119c70:	e5823000 	str	r3, [r2]

            /*CRR,watch dog reset(kick dog)*/
            Wdg_HwModuleAddr[Wdg_InstanceNum]->CRR = WDG_CRR_RESTART;
 5119c74:	e582100c 	str	r1, [r2, #12]
#endif
#if (WDG_VALIDATE_GLOBAL_CALL == STD_ON)
    }

#endif /* (WDG_VALIDATE_GLOBAL_CALL == STD_ON */
}
 5119c78:	e12fff1e 	bx	lr

05119c7c <atoi>:
 5119c7c:	220a      	movs	r2, #10
 5119c7e:	2100      	movs	r1, #0
 5119c80:	f000 be06 	b.w	511a890 <strtol>

05119c84 <memchr>:
 5119c84:	b2c9      	uxtb	r1, r1
 5119c86:	4402      	add	r2, r0
 5119c88:	b510      	push	{r4, lr}
 5119c8a:	4603      	mov	r3, r0
 5119c8c:	4290      	cmp	r0, r2
 5119c8e:	d101      	bne.n	5119c94 <memchr+0x10>
 5119c90:	2300      	movs	r3, #0
 5119c92:	e003      	b.n	5119c9c <memchr+0x18>
 5119c94:	781c      	ldrb	r4, [r3, #0]
 5119c96:	3001      	adds	r0, #1
 5119c98:	428c      	cmp	r4, r1
 5119c9a:	d1f6      	bne.n	5119c8a <memchr+0x6>
 5119c9c:	4618      	mov	r0, r3
 5119c9e:	bd10      	pop	{r4, pc}

05119ca0 <memcpy>:
 5119ca0:	440a      	add	r2, r1
 5119ca2:	1e43      	subs	r3, r0, #1
 5119ca4:	4291      	cmp	r1, r2
 5119ca6:	d100      	bne.n	5119caa <memcpy+0xa>
 5119ca8:	4770      	bx	lr
 5119caa:	b510      	push	{r4, lr}
 5119cac:	f811 4b01 	ldrb.w	r4, [r1], #1
 5119cb0:	f803 4f01 	strb.w	r4, [r3, #1]!
 5119cb4:	4291      	cmp	r1, r2
 5119cb6:	d1f9      	bne.n	5119cac <memcpy+0xc>
 5119cb8:	bd10      	pop	{r4, pc}

05119cba <memset>:
 5119cba:	4402      	add	r2, r0
 5119cbc:	4603      	mov	r3, r0
 5119cbe:	4293      	cmp	r3, r2
 5119cc0:	d100      	bne.n	5119cc4 <memset+0xa>
 5119cc2:	4770      	bx	lr
 5119cc4:	f803 1b01 	strb.w	r1, [r3], #1
 5119cc8:	e7f9      	b.n	5119cbe <memset+0x4>

05119cca <__cvt>:
 5119cca:	b5f0      	push	{r4, r5, r6, r7, lr}
 5119ccc:	4617      	mov	r7, r2
 5119cce:	460c      	mov	r4, r1
 5119cd0:	ed2d 8b02 	vpush	{d8}
 5119cd4:	eeb0 8b40 	vmov.f64	d8, d0
 5119cd8:	b085      	sub	sp, #20
 5119cda:	ee18 2a90 	vmov	r2, s17
 5119cde:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 5119ce0:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 5119ce2:	f025 0520 	bic.w	r5, r5, #32
 5119ce6:	2a00      	cmp	r2, #0
 5119ce8:	bfb4      	ite	lt
 5119cea:	222d      	movlt	r2, #45	; 0x2d
 5119cec:	2200      	movge	r2, #0
 5119cee:	701a      	strb	r2, [r3, #0]
 5119cf0:	bfb8      	it	lt
 5119cf2:	eeb1 8b40 	vneglt.f64	d8, d0
 5119cf6:	2d46      	cmp	r5, #70	; 0x46
 5119cf8:	d004      	beq.n	5119d04 <__cvt+0x3a>
 5119cfa:	2d45      	cmp	r5, #69	; 0x45
 5119cfc:	d100      	bne.n	5119d00 <__cvt+0x36>
 5119cfe:	3401      	adds	r4, #1
 5119d00:	2102      	movs	r1, #2
 5119d02:	e000      	b.n	5119d06 <__cvt+0x3c>
 5119d04:	2103      	movs	r1, #3
 5119d06:	ab03      	add	r3, sp, #12
 5119d08:	eeb0 0b48 	vmov.f64	d0, d8
 5119d0c:	9301      	str	r3, [sp, #4]
 5119d0e:	4622      	mov	r2, r4
 5119d10:	ab02      	add	r3, sp, #8
 5119d12:	9300      	str	r3, [sp, #0]
 5119d14:	4633      	mov	r3, r6
 5119d16:	f000 ff6b 	bl	511abf0 <_dtoa_r>
 5119d1a:	2d47      	cmp	r5, #71	; 0x47
 5119d1c:	d101      	bne.n	5119d22 <__cvt+0x58>
 5119d1e:	07fb      	lsls	r3, r7, #31
 5119d20:	d519      	bpl.n	5119d56 <__cvt+0x8c>
 5119d22:	1902      	adds	r2, r0, r4
 5119d24:	2d46      	cmp	r5, #70	; 0x46
 5119d26:	d10c      	bne.n	5119d42 <__cvt+0x78>
 5119d28:	7803      	ldrb	r3, [r0, #0]
 5119d2a:	2b30      	cmp	r3, #48	; 0x30
 5119d2c:	d107      	bne.n	5119d3e <__cvt+0x74>
 5119d2e:	eeb5 8b40 	vcmp.f64	d8, #0.0
 5119d32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119d36:	bf1c      	itt	ne
 5119d38:	f1c4 0401 	rsbne	r4, r4, #1
 5119d3c:	6034      	strne	r4, [r6, #0]
 5119d3e:	6833      	ldr	r3, [r6, #0]
 5119d40:	441a      	add	r2, r3
 5119d42:	eeb5 8b40 	vcmp.f64	d8, #0.0
 5119d46:	2130      	movs	r1, #48	; 0x30
 5119d48:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119d4c:	bf08      	it	eq
 5119d4e:	9203      	streq	r2, [sp, #12]
 5119d50:	9b03      	ldr	r3, [sp, #12]
 5119d52:	4293      	cmp	r3, r2
 5119d54:	d307      	bcc.n	5119d66 <__cvt+0x9c>
 5119d56:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 5119d58:	9b03      	ldr	r3, [sp, #12]
 5119d5a:	1a1b      	subs	r3, r3, r0
 5119d5c:	6013      	str	r3, [r2, #0]
 5119d5e:	b005      	add	sp, #20
 5119d60:	ecbd 8b02 	vpop	{d8}
 5119d64:	bdf0      	pop	{r4, r5, r6, r7, pc}
 5119d66:	1c5c      	adds	r4, r3, #1
 5119d68:	9403      	str	r4, [sp, #12]
 5119d6a:	7019      	strb	r1, [r3, #0]
 5119d6c:	e7f0      	b.n	5119d50 <__cvt+0x86>
	...

05119d70 <__exponent>:
 5119d70:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 5119d74:	4606      	mov	r6, r0
 5119d76:	1e0c      	subs	r4, r1, #0
 5119d78:	bfba      	itte	lt
 5119d7a:	4264      	neglt	r4, r4
 5119d7c:	232d      	movlt	r3, #45	; 0x2d
 5119d7e:	232b      	movge	r3, #43	; 0x2b
 5119d80:	f806 2b02 	strb.w	r2, [r6], #2
 5119d84:	4605      	mov	r5, r0
 5119d86:	2c09      	cmp	r4, #9
 5119d88:	7043      	strb	r3, [r0, #1]
 5119d8a:	dd2e      	ble.n	5119dea <__exponent+0x7a>
 5119d8c:	f10d 0807 	add.w	r8, sp, #7
 5119d90:	f8df a064 	ldr.w	sl, [pc, #100]	; 5119df8 <__exponent+0x88>
 5119d94:	46c1      	mov	r9, r8
 5119d96:	4647      	mov	r7, r8
 5119d98:	4620      	mov	r0, r4
 5119d9a:	210a      	movs	r1, #10
 5119d9c:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 5119da0:	f7f6 fd54 	bl	511084c <__aeabi_idivmod>
 5119da4:	3130      	adds	r1, #48	; 0x30
 5119da6:	f807 1c01 	strb.w	r1, [r7, #-1]
 5119daa:	fb84 210a 	smull	r2, r1, r4, sl
 5119dae:	4623      	mov	r3, r4
 5119db0:	17e4      	asrs	r4, r4, #31
 5119db2:	2b63      	cmp	r3, #99	; 0x63
 5119db4:	ebc4 04a1 	rsb	r4, r4, r1, asr #2
 5119db8:	dced      	bgt.n	5119d96 <__exponent+0x26>
 5119dba:	1eba      	subs	r2, r7, #2
 5119dbc:	1c69      	adds	r1, r5, #1
 5119dbe:	4613      	mov	r3, r2
 5119dc0:	3430      	adds	r4, #48	; 0x30
 5119dc2:	f808 4c01 	strb.w	r4, [r8, #-1]
 5119dc6:	454b      	cmp	r3, r9
 5119dc8:	d30a      	bcc.n	5119de0 <__exponent+0x70>
 5119dca:	f10d 0009 	add.w	r0, sp, #9
 5119dce:	1bc0      	subs	r0, r0, r7
 5119dd0:	454a      	cmp	r2, r9
 5119dd2:	bf88      	it	hi
 5119dd4:	2000      	movhi	r0, #0
 5119dd6:	4430      	add	r0, r6
 5119dd8:	1b40      	subs	r0, r0, r5
 5119dda:	b002      	add	sp, #8
 5119ddc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 5119de0:	f813 0b01 	ldrb.w	r0, [r3], #1
 5119de4:	f801 0f01 	strb.w	r0, [r1, #1]!
 5119de8:	e7ed      	b.n	5119dc6 <__exponent+0x56>
 5119dea:	2330      	movs	r3, #48	; 0x30
 5119dec:	3004      	adds	r0, #4
 5119dee:	f800 3c02 	strb.w	r3, [r0, #-2]
 5119df2:	441c      	add	r4, r3
 5119df4:	70ec      	strb	r4, [r5, #3]
 5119df6:	e7ef      	b.n	5119dd8 <__exponent+0x68>
 5119df8:	66666667 	.word	0x66666667
 5119dfc:	00000000 	.word	0x00000000

05119e00 <_printf_float>:
 5119e00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 5119e04:	460c      	mov	r4, r1
 5119e06:	4616      	mov	r6, r2
 5119e08:	b08b      	sub	sp, #44	; 0x2c
 5119e0a:	461f      	mov	r7, r3
 5119e0c:	4605      	mov	r5, r0
 5119e0e:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
 5119e12:	f001 fe19 	bl	511ba48 <_localeconv_r>
 5119e16:	f8d0 b000 	ldr.w	fp, [r0]
 5119e1a:	4658      	mov	r0, fp
 5119e1c:	f7f6 fa88 	bl	5110330 <strlen>
 5119e20:	2300      	movs	r3, #0
 5119e22:	9308      	str	r3, [sp, #32]
 5119e24:	4682      	mov	sl, r0
 5119e26:	f8d8 3000 	ldr.w	r3, [r8]
 5119e2a:	f894 9018 	ldrb.w	r9, [r4, #24]
 5119e2e:	3307      	adds	r3, #7
 5119e30:	6822      	ldr	r2, [r4, #0]
 5119e32:	f023 0307 	bic.w	r3, r3, #7
 5119e36:	ed9f 7b9c 	vldr	d7, [pc, #624]	; 511a0a8 <_printf_float+0x2a8>
 5119e3a:	f103 0108 	add.w	r1, r3, #8
 5119e3e:	f8c8 1000 	str.w	r1, [r8]
 5119e42:	e9d3 0100 	ldrd	r0, r1, [r3]
 5119e46:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
 5119e4a:	ed94 0b12 	vldr	d0, [r4, #72]	; 0x48
 5119e4e:	eeb0 6bc0 	vabs.f64	d6, d0
 5119e52:	eeb4 6b47 	vcmp.f64	d6, d7
 5119e56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119e5a:	dd24      	ble.n	5119ea6 <_printf_float+0xa6>
 5119e5c:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
 5119e60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119e64:	d502      	bpl.n	5119e6c <_printf_float+0x6c>
 5119e66:	232d      	movs	r3, #45	; 0x2d
 5119e68:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 5119e6c:	4b90      	ldr	r3, [pc, #576]	; (511a0b0 <_printf_float+0x2b0>)
 5119e6e:	4891      	ldr	r0, [pc, #580]	; (511a0b4 <_printf_float+0x2b4>)
 5119e70:	f1b9 0f47 	cmp.w	r9, #71	; 0x47
 5119e74:	bf94      	ite	ls
 5119e76:	4698      	movls	r8, r3
 5119e78:	4680      	movhi	r8, r0
 5119e7a:	f022 0204 	bic.w	r2, r2, #4
 5119e7e:	2303      	movs	r3, #3
 5119e80:	6022      	str	r2, [r4, #0]
 5119e82:	6123      	str	r3, [r4, #16]
 5119e84:	2300      	movs	r3, #0
 5119e86:	9304      	str	r3, [sp, #16]
 5119e88:	4633      	mov	r3, r6
 5119e8a:	aa09      	add	r2, sp, #36	; 0x24
 5119e8c:	4621      	mov	r1, r4
 5119e8e:	4628      	mov	r0, r5
 5119e90:	9700      	str	r7, [sp, #0]
 5119e92:	f000 f9d3 	bl	511a23c <_printf_common>
 5119e96:	3001      	adds	r0, #1
 5119e98:	f040 808a 	bne.w	5119fb0 <_printf_float+0x1b0>
 5119e9c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 5119ea0:	b00b      	add	sp, #44	; 0x2c
 5119ea2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 5119ea6:	eeb4 0b40 	vcmp.f64	d0, d0
 5119eaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119eae:	d709      	bvc.n	5119ec4 <_printf_float+0xc4>
 5119eb0:	ee10 3a90 	vmov	r3, s1
 5119eb4:	4880      	ldr	r0, [pc, #512]	; (511a0b8 <_printf_float+0x2b8>)
 5119eb6:	2b00      	cmp	r3, #0
 5119eb8:	bfbc      	itt	lt
 5119eba:	232d      	movlt	r3, #45	; 0x2d
 5119ebc:	f884 3043 	strblt.w	r3, [r4, #67]	; 0x43
 5119ec0:	4b7e      	ldr	r3, [pc, #504]	; (511a0bc <_printf_float+0x2bc>)
 5119ec2:	e7d5      	b.n	5119e70 <_printf_float+0x70>
 5119ec4:	6863      	ldr	r3, [r4, #4]
 5119ec6:	f009 01df 	and.w	r1, r9, #223	; 0xdf
 5119eca:	9104      	str	r1, [sp, #16]
 5119ecc:	1c59      	adds	r1, r3, #1
 5119ece:	d13c      	bne.n	5119f4a <_printf_float+0x14a>
 5119ed0:	2306      	movs	r3, #6
 5119ed2:	6063      	str	r3, [r4, #4]
 5119ed4:	6861      	ldr	r1, [r4, #4]
 5119ed6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 5119eda:	2300      	movs	r3, #0
 5119edc:	4628      	mov	r0, r5
 5119ede:	9303      	str	r3, [sp, #12]
 5119ee0:	ab08      	add	r3, sp, #32
 5119ee2:	6022      	str	r2, [r4, #0]
 5119ee4:	e9cd 9301 	strd	r9, r3, [sp, #4]
 5119ee8:	ab07      	add	r3, sp, #28
 5119eea:	9300      	str	r3, [sp, #0]
 5119eec:	f10d 031b 	add.w	r3, sp, #27
 5119ef0:	f7ff feeb 	bl	5119cca <__cvt>
 5119ef4:	9b04      	ldr	r3, [sp, #16]
 5119ef6:	9907      	ldr	r1, [sp, #28]
 5119ef8:	4680      	mov	r8, r0
 5119efa:	2b47      	cmp	r3, #71	; 0x47
 5119efc:	d108      	bne.n	5119f10 <_printf_float+0x110>
 5119efe:	1cc8      	adds	r0, r1, #3
 5119f00:	db02      	blt.n	5119f08 <_printf_float+0x108>
 5119f02:	6863      	ldr	r3, [r4, #4]
 5119f04:	4299      	cmp	r1, r3
 5119f06:	dd41      	ble.n	5119f8c <_printf_float+0x18c>
 5119f08:	f1a9 0902 	sub.w	r9, r9, #2
 5119f0c:	fa5f f989 	uxtb.w	r9, r9
 5119f10:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 5119f14:	d820      	bhi.n	5119f58 <_printf_float+0x158>
 5119f16:	3901      	subs	r1, #1
 5119f18:	464a      	mov	r2, r9
 5119f1a:	f104 0050 	add.w	r0, r4, #80	; 0x50
 5119f1e:	9107      	str	r1, [sp, #28]
 5119f20:	f7ff ff26 	bl	5119d70 <__exponent>
 5119f24:	9a08      	ldr	r2, [sp, #32]
 5119f26:	9004      	str	r0, [sp, #16]
 5119f28:	1813      	adds	r3, r2, r0
 5119f2a:	2a01      	cmp	r2, #1
 5119f2c:	6123      	str	r3, [r4, #16]
 5119f2e:	dc02      	bgt.n	5119f36 <_printf_float+0x136>
 5119f30:	6822      	ldr	r2, [r4, #0]
 5119f32:	07d2      	lsls	r2, r2, #31
 5119f34:	d501      	bpl.n	5119f3a <_printf_float+0x13a>
 5119f36:	3301      	adds	r3, #1
 5119f38:	6123      	str	r3, [r4, #16]
 5119f3a:	f89d 301b 	ldrb.w	r3, [sp, #27]
 5119f3e:	2b00      	cmp	r3, #0
 5119f40:	d0a2      	beq.n	5119e88 <_printf_float+0x88>
 5119f42:	232d      	movs	r3, #45	; 0x2d
 5119f44:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 5119f48:	e79e      	b.n	5119e88 <_printf_float+0x88>
 5119f4a:	9904      	ldr	r1, [sp, #16]
 5119f4c:	2947      	cmp	r1, #71	; 0x47
 5119f4e:	d1c1      	bne.n	5119ed4 <_printf_float+0xd4>
 5119f50:	2b00      	cmp	r3, #0
 5119f52:	d1bf      	bne.n	5119ed4 <_printf_float+0xd4>
 5119f54:	2301      	movs	r3, #1
 5119f56:	e7bc      	b.n	5119ed2 <_printf_float+0xd2>
 5119f58:	f1b9 0f66 	cmp.w	r9, #102	; 0x66
 5119f5c:	d118      	bne.n	5119f90 <_printf_float+0x190>
 5119f5e:	6863      	ldr	r3, [r4, #4]
 5119f60:	2900      	cmp	r1, #0
 5119f62:	dd0b      	ble.n	5119f7c <_printf_float+0x17c>
 5119f64:	6121      	str	r1, [r4, #16]
 5119f66:	b913      	cbnz	r3, 5119f6e <_printf_float+0x16e>
 5119f68:	6822      	ldr	r2, [r4, #0]
 5119f6a:	07d0      	lsls	r0, r2, #31
 5119f6c:	d502      	bpl.n	5119f74 <_printf_float+0x174>
 5119f6e:	3301      	adds	r3, #1
 5119f70:	440b      	add	r3, r1
 5119f72:	6123      	str	r3, [r4, #16]
 5119f74:	2300      	movs	r3, #0
 5119f76:	65a1      	str	r1, [r4, #88]	; 0x58
 5119f78:	9304      	str	r3, [sp, #16]
 5119f7a:	e7de      	b.n	5119f3a <_printf_float+0x13a>
 5119f7c:	b913      	cbnz	r3, 5119f84 <_printf_float+0x184>
 5119f7e:	6822      	ldr	r2, [r4, #0]
 5119f80:	07d2      	lsls	r2, r2, #31
 5119f82:	d501      	bpl.n	5119f88 <_printf_float+0x188>
 5119f84:	3302      	adds	r3, #2
 5119f86:	e7f4      	b.n	5119f72 <_printf_float+0x172>
 5119f88:	2301      	movs	r3, #1
 5119f8a:	e7f2      	b.n	5119f72 <_printf_float+0x172>
 5119f8c:	f04f 0967 	mov.w	r9, #103	; 0x67
 5119f90:	9b08      	ldr	r3, [sp, #32]
 5119f92:	4299      	cmp	r1, r3
 5119f94:	db05      	blt.n	5119fa2 <_printf_float+0x1a2>
 5119f96:	6823      	ldr	r3, [r4, #0]
 5119f98:	6121      	str	r1, [r4, #16]
 5119f9a:	07d8      	lsls	r0, r3, #31
 5119f9c:	d5ea      	bpl.n	5119f74 <_printf_float+0x174>
 5119f9e:	1c4b      	adds	r3, r1, #1
 5119fa0:	e7e7      	b.n	5119f72 <_printf_float+0x172>
 5119fa2:	2900      	cmp	r1, #0
 5119fa4:	bfd4      	ite	le
 5119fa6:	f1c1 0202 	rsble	r2, r1, #2
 5119faa:	2201      	movgt	r2, #1
 5119fac:	4413      	add	r3, r2
 5119fae:	e7e0      	b.n	5119f72 <_printf_float+0x172>
 5119fb0:	6823      	ldr	r3, [r4, #0]
 5119fb2:	055a      	lsls	r2, r3, #21
 5119fb4:	d407      	bmi.n	5119fc6 <_printf_float+0x1c6>
 5119fb6:	6923      	ldr	r3, [r4, #16]
 5119fb8:	4642      	mov	r2, r8
 5119fba:	4631      	mov	r1, r6
 5119fbc:	4628      	mov	r0, r5
 5119fbe:	47b8      	blx	r7
 5119fc0:	3001      	adds	r0, #1
 5119fc2:	d12a      	bne.n	511a01a <_printf_float+0x21a>
 5119fc4:	e76a      	b.n	5119e9c <_printf_float+0x9c>
 5119fc6:	f1b9 0f65 	cmp.w	r9, #101	; 0x65
 5119fca:	f240 80e2 	bls.w	511a192 <_printf_float+0x392>
 5119fce:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
 5119fd2:	eeb5 7b40 	vcmp.f64	d7, #0.0
 5119fd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 5119fda:	d133      	bne.n	511a044 <_printf_float+0x244>
 5119fdc:	4a38      	ldr	r2, [pc, #224]	; (511a0c0 <_printf_float+0x2c0>)
 5119fde:	2301      	movs	r3, #1
 5119fe0:	4631      	mov	r1, r6
 5119fe2:	4628      	mov	r0, r5
 5119fe4:	47b8      	blx	r7
 5119fe6:	3001      	adds	r0, #1
 5119fe8:	f43f af58 	beq.w	5119e9c <_printf_float+0x9c>
 5119fec:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
 5119ff0:	429a      	cmp	r2, r3
 5119ff2:	db02      	blt.n	5119ffa <_printf_float+0x1fa>
 5119ff4:	6823      	ldr	r3, [r4, #0]
 5119ff6:	07d8      	lsls	r0, r3, #31
 5119ff8:	d50f      	bpl.n	511a01a <_printf_float+0x21a>
 5119ffa:	4653      	mov	r3, sl
 5119ffc:	465a      	mov	r2, fp
 5119ffe:	4631      	mov	r1, r6
 511a000:	4628      	mov	r0, r5
 511a002:	47b8      	blx	r7
 511a004:	3001      	adds	r0, #1
 511a006:	f43f af49 	beq.w	5119e9c <_printf_float+0x9c>
 511a00a:	f04f 0800 	mov.w	r8, #0
 511a00e:	f104 091a 	add.w	r9, r4, #26
 511a012:	9b08      	ldr	r3, [sp, #32]
 511a014:	3b01      	subs	r3, #1
 511a016:	4543      	cmp	r3, r8
 511a018:	dc09      	bgt.n	511a02e <_printf_float+0x22e>
 511a01a:	6823      	ldr	r3, [r4, #0]
 511a01c:	079b      	lsls	r3, r3, #30
 511a01e:	f100 8108 	bmi.w	511a232 <_printf_float+0x432>
 511a022:	68e0      	ldr	r0, [r4, #12]
 511a024:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511a026:	4298      	cmp	r0, r3
 511a028:	bfb8      	it	lt
 511a02a:	4618      	movlt	r0, r3
 511a02c:	e738      	b.n	5119ea0 <_printf_float+0xa0>
 511a02e:	2301      	movs	r3, #1
 511a030:	464a      	mov	r2, r9
 511a032:	4631      	mov	r1, r6
 511a034:	4628      	mov	r0, r5
 511a036:	47b8      	blx	r7
 511a038:	3001      	adds	r0, #1
 511a03a:	f43f af2f 	beq.w	5119e9c <_printf_float+0x9c>
 511a03e:	f108 0801 	add.w	r8, r8, #1
 511a042:	e7e6      	b.n	511a012 <_printf_float+0x212>
 511a044:	9b07      	ldr	r3, [sp, #28]
 511a046:	2b00      	cmp	r3, #0
 511a048:	dc3c      	bgt.n	511a0c4 <_printf_float+0x2c4>
 511a04a:	4a1d      	ldr	r2, [pc, #116]	; (511a0c0 <_printf_float+0x2c0>)
 511a04c:	2301      	movs	r3, #1
 511a04e:	4631      	mov	r1, r6
 511a050:	4628      	mov	r0, r5
 511a052:	47b8      	blx	r7
 511a054:	3001      	adds	r0, #1
 511a056:	f43f af21 	beq.w	5119e9c <_printf_float+0x9c>
 511a05a:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
 511a05e:	4313      	orrs	r3, r2
 511a060:	d102      	bne.n	511a068 <_printf_float+0x268>
 511a062:	6823      	ldr	r3, [r4, #0]
 511a064:	07d9      	lsls	r1, r3, #31
 511a066:	d5d8      	bpl.n	511a01a <_printf_float+0x21a>
 511a068:	4653      	mov	r3, sl
 511a06a:	465a      	mov	r2, fp
 511a06c:	4631      	mov	r1, r6
 511a06e:	4628      	mov	r0, r5
 511a070:	47b8      	blx	r7
 511a072:	3001      	adds	r0, #1
 511a074:	f43f af12 	beq.w	5119e9c <_printf_float+0x9c>
 511a078:	f04f 0900 	mov.w	r9, #0
 511a07c:	f104 0a1a 	add.w	sl, r4, #26
 511a080:	9b07      	ldr	r3, [sp, #28]
 511a082:	425b      	negs	r3, r3
 511a084:	454b      	cmp	r3, r9
 511a086:	dc01      	bgt.n	511a08c <_printf_float+0x28c>
 511a088:	9b08      	ldr	r3, [sp, #32]
 511a08a:	e795      	b.n	5119fb8 <_printf_float+0x1b8>
 511a08c:	2301      	movs	r3, #1
 511a08e:	4652      	mov	r2, sl
 511a090:	4631      	mov	r1, r6
 511a092:	4628      	mov	r0, r5
 511a094:	47b8      	blx	r7
 511a096:	3001      	adds	r0, #1
 511a098:	f43f af00 	beq.w	5119e9c <_printf_float+0x9c>
 511a09c:	f109 0901 	add.w	r9, r9, #1
 511a0a0:	e7ee      	b.n	511a080 <_printf_float+0x280>
 511a0a2:	bf00      	nop
 511a0a4:	f3af 8000 	nop.w
 511a0a8:	ffffffff 	.word	0xffffffff
 511a0ac:	7fefffff 	.word	0x7fefffff
 511a0b0:	0512dd54 	.word	0x0512dd54
 511a0b4:	0512dd58 	.word	0x0512dd58
 511a0b8:	0512dd60 	.word	0x0512dd60
 511a0bc:	0512dd5c 	.word	0x0512dd5c
 511a0c0:	0512dd64 	.word	0x0512dd64
 511a0c4:	9a08      	ldr	r2, [sp, #32]
 511a0c6:	6da3      	ldr	r3, [r4, #88]	; 0x58
 511a0c8:	429a      	cmp	r2, r3
 511a0ca:	bfa8      	it	ge
 511a0cc:	461a      	movge	r2, r3
 511a0ce:	4691      	mov	r9, r2
 511a0d0:	2a00      	cmp	r2, #0
 511a0d2:	dc38      	bgt.n	511a146 <_printf_float+0x346>
 511a0d4:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 511a0d8:	f104 021a 	add.w	r2, r4, #26
 511a0dc:	2300      	movs	r3, #0
 511a0de:	9305      	str	r3, [sp, #20]
 511a0e0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 511a0e2:	9905      	ldr	r1, [sp, #20]
 511a0e4:	9304      	str	r3, [sp, #16]
 511a0e6:	eba3 0309 	sub.w	r3, r3, r9
 511a0ea:	428b      	cmp	r3, r1
 511a0ec:	dc33      	bgt.n	511a156 <_printf_float+0x356>
 511a0ee:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
 511a0f2:	429a      	cmp	r2, r3
 511a0f4:	db3c      	blt.n	511a170 <_printf_float+0x370>
 511a0f6:	6823      	ldr	r3, [r4, #0]
 511a0f8:	07da      	lsls	r2, r3, #31
 511a0fa:	d439      	bmi.n	511a170 <_printf_float+0x370>
 511a0fc:	9b08      	ldr	r3, [sp, #32]
 511a0fe:	9a04      	ldr	r2, [sp, #16]
 511a100:	9907      	ldr	r1, [sp, #28]
 511a102:	1a9a      	subs	r2, r3, r2
 511a104:	eba3 0901 	sub.w	r9, r3, r1
 511a108:	4591      	cmp	r9, r2
 511a10a:	bfa8      	it	ge
 511a10c:	4691      	movge	r9, r2
 511a10e:	f1b9 0f00 	cmp.w	r9, #0
 511a112:	dc35      	bgt.n	511a180 <_printf_float+0x380>
 511a114:	f04f 0800 	mov.w	r8, #0
 511a118:	ea29 79e9 	bic.w	r9, r9, r9, asr #31
 511a11c:	f104 0a1a 	add.w	sl, r4, #26
 511a120:	e9dd 2307 	ldrd	r2, r3, [sp, #28]
 511a124:	1a9b      	subs	r3, r3, r2
 511a126:	eba3 0309 	sub.w	r3, r3, r9
 511a12a:	4543      	cmp	r3, r8
 511a12c:	f77f af75 	ble.w	511a01a <_printf_float+0x21a>
 511a130:	2301      	movs	r3, #1
 511a132:	4652      	mov	r2, sl
 511a134:	4631      	mov	r1, r6
 511a136:	4628      	mov	r0, r5
 511a138:	47b8      	blx	r7
 511a13a:	3001      	adds	r0, #1
 511a13c:	f43f aeae 	beq.w	5119e9c <_printf_float+0x9c>
 511a140:	f108 0801 	add.w	r8, r8, #1
 511a144:	e7ec      	b.n	511a120 <_printf_float+0x320>
 511a146:	4613      	mov	r3, r2
 511a148:	4631      	mov	r1, r6
 511a14a:	4642      	mov	r2, r8
 511a14c:	4628      	mov	r0, r5
 511a14e:	47b8      	blx	r7
 511a150:	3001      	adds	r0, #1
 511a152:	d1bf      	bne.n	511a0d4 <_printf_float+0x2d4>
 511a154:	e6a2      	b.n	5119e9c <_printf_float+0x9c>
 511a156:	2301      	movs	r3, #1
 511a158:	4631      	mov	r1, r6
 511a15a:	4628      	mov	r0, r5
 511a15c:	9204      	str	r2, [sp, #16]
 511a15e:	47b8      	blx	r7
 511a160:	3001      	adds	r0, #1
 511a162:	f43f ae9b 	beq.w	5119e9c <_printf_float+0x9c>
 511a166:	9b05      	ldr	r3, [sp, #20]
 511a168:	9a04      	ldr	r2, [sp, #16]
 511a16a:	3301      	adds	r3, #1
 511a16c:	9305      	str	r3, [sp, #20]
 511a16e:	e7b7      	b.n	511a0e0 <_printf_float+0x2e0>
 511a170:	4653      	mov	r3, sl
 511a172:	465a      	mov	r2, fp
 511a174:	4631      	mov	r1, r6
 511a176:	4628      	mov	r0, r5
 511a178:	47b8      	blx	r7
 511a17a:	3001      	adds	r0, #1
 511a17c:	d1be      	bne.n	511a0fc <_printf_float+0x2fc>
 511a17e:	e68d      	b.n	5119e9c <_printf_float+0x9c>
 511a180:	9a04      	ldr	r2, [sp, #16]
 511a182:	464b      	mov	r3, r9
 511a184:	4631      	mov	r1, r6
 511a186:	4628      	mov	r0, r5
 511a188:	4442      	add	r2, r8
 511a18a:	47b8      	blx	r7
 511a18c:	3001      	adds	r0, #1
 511a18e:	d1c1      	bne.n	511a114 <_printf_float+0x314>
 511a190:	e684      	b.n	5119e9c <_printf_float+0x9c>
 511a192:	9a08      	ldr	r2, [sp, #32]
 511a194:	2a01      	cmp	r2, #1
 511a196:	dc01      	bgt.n	511a19c <_printf_float+0x39c>
 511a198:	07db      	lsls	r3, r3, #31
 511a19a:	d537      	bpl.n	511a20c <_printf_float+0x40c>
 511a19c:	2301      	movs	r3, #1
 511a19e:	4642      	mov	r2, r8
 511a1a0:	4631      	mov	r1, r6
 511a1a2:	4628      	mov	r0, r5
 511a1a4:	47b8      	blx	r7
 511a1a6:	3001      	adds	r0, #1
 511a1a8:	f43f ae78 	beq.w	5119e9c <_printf_float+0x9c>
 511a1ac:	4653      	mov	r3, sl
 511a1ae:	465a      	mov	r2, fp
 511a1b0:	4631      	mov	r1, r6
 511a1b2:	4628      	mov	r0, r5
 511a1b4:	47b8      	blx	r7
 511a1b6:	3001      	adds	r0, #1
 511a1b8:	f43f ae70 	beq.w	5119e9c <_printf_float+0x9c>
 511a1bc:	ed94 7b12 	vldr	d7, [r4, #72]	; 0x48
 511a1c0:	eeb5 7b40 	vcmp.f64	d7, #0.0
 511a1c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511a1c8:	d01b      	beq.n	511a202 <_printf_float+0x402>
 511a1ca:	9b08      	ldr	r3, [sp, #32]
 511a1cc:	f108 0201 	add.w	r2, r8, #1
 511a1d0:	3b01      	subs	r3, #1
 511a1d2:	4631      	mov	r1, r6
 511a1d4:	4628      	mov	r0, r5
 511a1d6:	47b8      	blx	r7
 511a1d8:	3001      	adds	r0, #1
 511a1da:	d10e      	bne.n	511a1fa <_printf_float+0x3fa>
 511a1dc:	e65e      	b.n	5119e9c <_printf_float+0x9c>
 511a1de:	2301      	movs	r3, #1
 511a1e0:	464a      	mov	r2, r9
 511a1e2:	4631      	mov	r1, r6
 511a1e4:	4628      	mov	r0, r5
 511a1e6:	47b8      	blx	r7
 511a1e8:	3001      	adds	r0, #1
 511a1ea:	f43f ae57 	beq.w	5119e9c <_printf_float+0x9c>
 511a1ee:	f108 0801 	add.w	r8, r8, #1
 511a1f2:	9b08      	ldr	r3, [sp, #32]
 511a1f4:	3b01      	subs	r3, #1
 511a1f6:	4543      	cmp	r3, r8
 511a1f8:	dcf1      	bgt.n	511a1de <_printf_float+0x3de>
 511a1fa:	9b04      	ldr	r3, [sp, #16]
 511a1fc:	f104 0250 	add.w	r2, r4, #80	; 0x50
 511a200:	e6db      	b.n	5119fba <_printf_float+0x1ba>
 511a202:	f04f 0800 	mov.w	r8, #0
 511a206:	f104 091a 	add.w	r9, r4, #26
 511a20a:	e7f2      	b.n	511a1f2 <_printf_float+0x3f2>
 511a20c:	2301      	movs	r3, #1
 511a20e:	4642      	mov	r2, r8
 511a210:	e7df      	b.n	511a1d2 <_printf_float+0x3d2>
 511a212:	2301      	movs	r3, #1
 511a214:	464a      	mov	r2, r9
 511a216:	4631      	mov	r1, r6
 511a218:	4628      	mov	r0, r5
 511a21a:	47b8      	blx	r7
 511a21c:	3001      	adds	r0, #1
 511a21e:	f43f ae3d 	beq.w	5119e9c <_printf_float+0x9c>
 511a222:	f108 0801 	add.w	r8, r8, #1
 511a226:	68e3      	ldr	r3, [r4, #12]
 511a228:	9909      	ldr	r1, [sp, #36]	; 0x24
 511a22a:	1a5b      	subs	r3, r3, r1
 511a22c:	4543      	cmp	r3, r8
 511a22e:	dcf0      	bgt.n	511a212 <_printf_float+0x412>
 511a230:	e6f7      	b.n	511a022 <_printf_float+0x222>
 511a232:	f04f 0800 	mov.w	r8, #0
 511a236:	f104 0919 	add.w	r9, r4, #25
 511a23a:	e7f4      	b.n	511a226 <_printf_float+0x426>

0511a23c <_printf_common>:
 511a23c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 511a240:	4616      	mov	r6, r2
 511a242:	4699      	mov	r9, r3
 511a244:	688a      	ldr	r2, [r1, #8]
 511a246:	4607      	mov	r7, r0
 511a248:	690b      	ldr	r3, [r1, #16]
 511a24a:	460c      	mov	r4, r1
 511a24c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 511a250:	4293      	cmp	r3, r2
 511a252:	bfb8      	it	lt
 511a254:	4613      	movlt	r3, r2
 511a256:	6033      	str	r3, [r6, #0]
 511a258:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 511a25c:	b10a      	cbz	r2, 511a262 <_printf_common+0x26>
 511a25e:	3301      	adds	r3, #1
 511a260:	6033      	str	r3, [r6, #0]
 511a262:	6823      	ldr	r3, [r4, #0]
 511a264:	0699      	lsls	r1, r3, #26
 511a266:	bf42      	ittt	mi
 511a268:	6833      	ldrmi	r3, [r6, #0]
 511a26a:	3302      	addmi	r3, #2
 511a26c:	6033      	strmi	r3, [r6, #0]
 511a26e:	6825      	ldr	r5, [r4, #0]
 511a270:	f015 0506 	ands.w	r5, r5, #6
 511a274:	d106      	bne.n	511a284 <_printf_common+0x48>
 511a276:	f104 0a19 	add.w	sl, r4, #25
 511a27a:	68e3      	ldr	r3, [r4, #12]
 511a27c:	6832      	ldr	r2, [r6, #0]
 511a27e:	1a9b      	subs	r3, r3, r2
 511a280:	42ab      	cmp	r3, r5
 511a282:	dc2b      	bgt.n	511a2dc <_printf_common+0xa0>
 511a284:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
 511a288:	1e13      	subs	r3, r2, #0
 511a28a:	6822      	ldr	r2, [r4, #0]
 511a28c:	bf18      	it	ne
 511a28e:	2301      	movne	r3, #1
 511a290:	0692      	lsls	r2, r2, #26
 511a292:	d430      	bmi.n	511a2f6 <_printf_common+0xba>
 511a294:	f104 0243 	add.w	r2, r4, #67	; 0x43
 511a298:	4649      	mov	r1, r9
 511a29a:	4638      	mov	r0, r7
 511a29c:	47c0      	blx	r8
 511a29e:	3001      	adds	r0, #1
 511a2a0:	d023      	beq.n	511a2ea <_printf_common+0xae>
 511a2a2:	6823      	ldr	r3, [r4, #0]
 511a2a4:	341a      	adds	r4, #26
 511a2a6:	f854 5c0e 	ldr.w	r5, [r4, #-14]
 511a2aa:	6832      	ldr	r2, [r6, #0]
 511a2ac:	f003 0306 	and.w	r3, r3, #6
 511a2b0:	2b04      	cmp	r3, #4
 511a2b2:	f854 3c12 	ldr.w	r3, [r4, #-18]
 511a2b6:	bf08      	it	eq
 511a2b8:	1aad      	subeq	r5, r5, r2
 511a2ba:	f854 2c0a 	ldr.w	r2, [r4, #-10]
 511a2be:	bf18      	it	ne
 511a2c0:	2500      	movne	r5, #0
 511a2c2:	f04f 0600 	mov.w	r6, #0
 511a2c6:	bf08      	it	eq
 511a2c8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 511a2cc:	4293      	cmp	r3, r2
 511a2ce:	bfc4      	itt	gt
 511a2d0:	1a9b      	subgt	r3, r3, r2
 511a2d2:	18ed      	addgt	r5, r5, r3
 511a2d4:	42b5      	cmp	r5, r6
 511a2d6:	d11a      	bne.n	511a30e <_printf_common+0xd2>
 511a2d8:	2000      	movs	r0, #0
 511a2da:	e008      	b.n	511a2ee <_printf_common+0xb2>
 511a2dc:	2301      	movs	r3, #1
 511a2de:	4652      	mov	r2, sl
 511a2e0:	4649      	mov	r1, r9
 511a2e2:	4638      	mov	r0, r7
 511a2e4:	47c0      	blx	r8
 511a2e6:	3001      	adds	r0, #1
 511a2e8:	d103      	bne.n	511a2f2 <_printf_common+0xb6>
 511a2ea:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511a2ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 511a2f2:	3501      	adds	r5, #1
 511a2f4:	e7c1      	b.n	511a27a <_printf_common+0x3e>
 511a2f6:	18e1      	adds	r1, r4, r3
 511a2f8:	1c5a      	adds	r2, r3, #1
 511a2fa:	2030      	movs	r0, #48	; 0x30
 511a2fc:	4422      	add	r2, r4
 511a2fe:	3302      	adds	r3, #2
 511a300:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 511a304:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 511a308:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 511a30c:	e7c2      	b.n	511a294 <_printf_common+0x58>
 511a30e:	2301      	movs	r3, #1
 511a310:	4622      	mov	r2, r4
 511a312:	4649      	mov	r1, r9
 511a314:	4638      	mov	r0, r7
 511a316:	47c0      	blx	r8
 511a318:	3001      	adds	r0, #1
 511a31a:	d0e6      	beq.n	511a2ea <_printf_common+0xae>
 511a31c:	3601      	adds	r6, #1
 511a31e:	e7d9      	b.n	511a2d4 <_printf_common+0x98>

0511a320 <_printf_i>:
 511a320:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511a324:	4680      	mov	r8, r0
 511a326:	460c      	mov	r4, r1
 511a328:	b087      	sub	sp, #28
 511a32a:	7e0f      	ldrb	r7, [r1, #24]
 511a32c:	4691      	mov	r9, r2
 511a32e:	469a      	mov	sl, r3
 511a330:	f101 0b43 	add.w	fp, r1, #67	; 0x43
 511a334:	2f78      	cmp	r7, #120	; 0x78
 511a336:	9d10      	ldr	r5, [sp, #64]	; 0x40
 511a338:	d807      	bhi.n	511a34a <_printf_i+0x2a>
 511a33a:	2f62      	cmp	r7, #98	; 0x62
 511a33c:	d80a      	bhi.n	511a354 <_printf_i+0x34>
 511a33e:	2f00      	cmp	r7, #0
 511a340:	f000 80da 	beq.w	511a4f8 <_printf_i+0x1d8>
 511a344:	2f58      	cmp	r7, #88	; 0x58
 511a346:	f000 80a7 	beq.w	511a498 <_printf_i+0x178>
 511a34a:	f104 0542 	add.w	r5, r4, #66	; 0x42
 511a34e:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
 511a352:	e03b      	b.n	511a3cc <_printf_i+0xac>
 511a354:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
 511a358:	2b15      	cmp	r3, #21
 511a35a:	d8f6      	bhi.n	511a34a <_printf_i+0x2a>
 511a35c:	a201      	add	r2, pc, #4	; (adr r2, 511a364 <_printf_i+0x44>)
 511a35e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 511a362:	bf00      	nop
 511a364:	0511a3bd 	.word	0x0511a3bd
 511a368:	0511a3d1 	.word	0x0511a3d1
 511a36c:	0511a34b 	.word	0x0511a34b
 511a370:	0511a34b 	.word	0x0511a34b
 511a374:	0511a34b 	.word	0x0511a34b
 511a378:	0511a34b 	.word	0x0511a34b
 511a37c:	0511a3d1 	.word	0x0511a3d1
 511a380:	0511a34b 	.word	0x0511a34b
 511a384:	0511a34b 	.word	0x0511a34b
 511a388:	0511a34b 	.word	0x0511a34b
 511a38c:	0511a34b 	.word	0x0511a34b
 511a390:	0511a4df 	.word	0x0511a4df
 511a394:	0511a401 	.word	0x0511a401
 511a398:	0511a4c5 	.word	0x0511a4c5
 511a39c:	0511a34b 	.word	0x0511a34b
 511a3a0:	0511a34b 	.word	0x0511a34b
 511a3a4:	0511a501 	.word	0x0511a501
 511a3a8:	0511a34b 	.word	0x0511a34b
 511a3ac:	0511a401 	.word	0x0511a401
 511a3b0:	0511a34b 	.word	0x0511a34b
 511a3b4:	0511a34b 	.word	0x0511a34b
 511a3b8:	0511a4cd 	.word	0x0511a4cd
 511a3bc:	682b      	ldr	r3, [r5, #0]
 511a3be:	1d1a      	adds	r2, r3, #4
 511a3c0:	602a      	str	r2, [r5, #0]
 511a3c2:	681b      	ldr	r3, [r3, #0]
 511a3c4:	f101 0542 	add.w	r5, r1, #66	; 0x42
 511a3c8:	f881 3042 	strb.w	r3, [r1, #66]	; 0x42
 511a3cc:	2301      	movs	r3, #1
 511a3ce:	e0a4      	b.n	511a51a <_printf_i+0x1fa>
 511a3d0:	6809      	ldr	r1, [r1, #0]
 511a3d2:	682a      	ldr	r2, [r5, #0]
 511a3d4:	060f      	lsls	r7, r1, #24
 511a3d6:	f102 0304 	add.w	r3, r2, #4
 511a3da:	d50a      	bpl.n	511a3f2 <_printf_i+0xd2>
 511a3dc:	6816      	ldr	r6, [r2, #0]
 511a3de:	602b      	str	r3, [r5, #0]
 511a3e0:	2e00      	cmp	r6, #0
 511a3e2:	da03      	bge.n	511a3ec <_printf_i+0xcc>
 511a3e4:	4276      	negs	r6, r6
 511a3e6:	232d      	movs	r3, #45	; 0x2d
 511a3e8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 511a3ec:	4b5e      	ldr	r3, [pc, #376]	; (511a568 <_printf_i+0x248>)
 511a3ee:	270a      	movs	r7, #10
 511a3f0:	e01a      	b.n	511a428 <_printf_i+0x108>
 511a3f2:	6816      	ldr	r6, [r2, #0]
 511a3f4:	f011 0f40 	tst.w	r1, #64	; 0x40
 511a3f8:	602b      	str	r3, [r5, #0]
 511a3fa:	bf18      	it	ne
 511a3fc:	b236      	sxthne	r6, r6
 511a3fe:	e7ef      	b.n	511a3e0 <_printf_i+0xc0>
 511a400:	6809      	ldr	r1, [r1, #0]
 511a402:	682b      	ldr	r3, [r5, #0]
 511a404:	060e      	lsls	r6, r1, #24
 511a406:	f103 0204 	add.w	r2, r3, #4
 511a40a:	602a      	str	r2, [r5, #0]
 511a40c:	d501      	bpl.n	511a412 <_printf_i+0xf2>
 511a40e:	681e      	ldr	r6, [r3, #0]
 511a410:	e002      	b.n	511a418 <_printf_i+0xf8>
 511a412:	064d      	lsls	r5, r1, #25
 511a414:	d5fb      	bpl.n	511a40e <_printf_i+0xee>
 511a416:	881e      	ldrh	r6, [r3, #0]
 511a418:	2f6f      	cmp	r7, #111	; 0x6f
 511a41a:	4b53      	ldr	r3, [pc, #332]	; (511a568 <_printf_i+0x248>)
 511a41c:	bf0c      	ite	eq
 511a41e:	2708      	moveq	r7, #8
 511a420:	270a      	movne	r7, #10
 511a422:	2200      	movs	r2, #0
 511a424:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 511a428:	6862      	ldr	r2, [r4, #4]
 511a42a:	465d      	mov	r5, fp
 511a42c:	60a2      	str	r2, [r4, #8]
 511a42e:	2a00      	cmp	r2, #0
 511a430:	bfa2      	ittt	ge
 511a432:	6821      	ldrge	r1, [r4, #0]
 511a434:	f021 0104 	bicge.w	r1, r1, #4
 511a438:	6021      	strge	r1, [r4, #0]
 511a43a:	b906      	cbnz	r6, 511a43e <_printf_i+0x11e>
 511a43c:	b162      	cbz	r2, 511a458 <_printf_i+0x138>
 511a43e:	4630      	mov	r0, r6
 511a440:	4639      	mov	r1, r7
 511a442:	9303      	str	r3, [sp, #12]
 511a444:	f7f6 f8aa 	bl	511059c <__aeabi_uidivmod>
 511a448:	9b03      	ldr	r3, [sp, #12]
 511a44a:	5c5a      	ldrb	r2, [r3, r1]
 511a44c:	f805 2d01 	strb.w	r2, [r5, #-1]!
 511a450:	4632      	mov	r2, r6
 511a452:	4297      	cmp	r7, r2
 511a454:	4606      	mov	r6, r0
 511a456:	d9f2      	bls.n	511a43e <_printf_i+0x11e>
 511a458:	2f08      	cmp	r7, #8
 511a45a:	d10b      	bne.n	511a474 <_printf_i+0x154>
 511a45c:	6823      	ldr	r3, [r4, #0]
 511a45e:	07de      	lsls	r6, r3, #31
 511a460:	d508      	bpl.n	511a474 <_printf_i+0x154>
 511a462:	6923      	ldr	r3, [r4, #16]
 511a464:	6862      	ldr	r2, [r4, #4]
 511a466:	429a      	cmp	r2, r3
 511a468:	bfde      	ittt	le
 511a46a:	2330      	movle	r3, #48	; 0x30
 511a46c:	f805 3c01 	strble.w	r3, [r5, #-1]
 511a470:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 511a474:	ebab 0305 	sub.w	r3, fp, r5
 511a478:	6123      	str	r3, [r4, #16]
 511a47a:	464b      	mov	r3, r9
 511a47c:	aa05      	add	r2, sp, #20
 511a47e:	4621      	mov	r1, r4
 511a480:	4640      	mov	r0, r8
 511a482:	f8cd a000 	str.w	sl, [sp]
 511a486:	f7ff fed9 	bl	511a23c <_printf_common>
 511a48a:	3001      	adds	r0, #1
 511a48c:	d14a      	bne.n	511a524 <_printf_i+0x204>
 511a48e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511a492:	b007      	add	sp, #28
 511a494:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511a498:	4b33      	ldr	r3, [pc, #204]	; (511a568 <_printf_i+0x248>)
 511a49a:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
 511a49e:	6829      	ldr	r1, [r5, #0]
 511a4a0:	6822      	ldr	r2, [r4, #0]
 511a4a2:	f851 6b04 	ldr.w	r6, [r1], #4
 511a4a6:	6029      	str	r1, [r5, #0]
 511a4a8:	0610      	lsls	r0, r2, #24
 511a4aa:	d514      	bpl.n	511a4d6 <_printf_i+0x1b6>
 511a4ac:	07d7      	lsls	r7, r2, #31
 511a4ae:	bf44      	itt	mi
 511a4b0:	f042 0220 	orrmi.w	r2, r2, #32
 511a4b4:	6022      	strmi	r2, [r4, #0]
 511a4b6:	b91e      	cbnz	r6, 511a4c0 <_printf_i+0x1a0>
 511a4b8:	6822      	ldr	r2, [r4, #0]
 511a4ba:	f022 0220 	bic.w	r2, r2, #32
 511a4be:	6022      	str	r2, [r4, #0]
 511a4c0:	2710      	movs	r7, #16
 511a4c2:	e7ae      	b.n	511a422 <_printf_i+0x102>
 511a4c4:	680b      	ldr	r3, [r1, #0]
 511a4c6:	f043 0320 	orr.w	r3, r3, #32
 511a4ca:	600b      	str	r3, [r1, #0]
 511a4cc:	2378      	movs	r3, #120	; 0x78
 511a4ce:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 511a4d2:	4b26      	ldr	r3, [pc, #152]	; (511a56c <_printf_i+0x24c>)
 511a4d4:	e7e3      	b.n	511a49e <_printf_i+0x17e>
 511a4d6:	0651      	lsls	r1, r2, #25
 511a4d8:	bf48      	it	mi
 511a4da:	b2b6      	uxthmi	r6, r6
 511a4dc:	e7e6      	b.n	511a4ac <_printf_i+0x18c>
 511a4de:	682b      	ldr	r3, [r5, #0]
 511a4e0:	6808      	ldr	r0, [r1, #0]
 511a4e2:	694a      	ldr	r2, [r1, #20]
 511a4e4:	1d19      	adds	r1, r3, #4
 511a4e6:	6029      	str	r1, [r5, #0]
 511a4e8:	0605      	lsls	r5, r0, #24
 511a4ea:	681b      	ldr	r3, [r3, #0]
 511a4ec:	d501      	bpl.n	511a4f2 <_printf_i+0x1d2>
 511a4ee:	601a      	str	r2, [r3, #0]
 511a4f0:	e002      	b.n	511a4f8 <_printf_i+0x1d8>
 511a4f2:	0641      	lsls	r1, r0, #25
 511a4f4:	d5fb      	bpl.n	511a4ee <_printf_i+0x1ce>
 511a4f6:	801a      	strh	r2, [r3, #0]
 511a4f8:	2300      	movs	r3, #0
 511a4fa:	465d      	mov	r5, fp
 511a4fc:	6123      	str	r3, [r4, #16]
 511a4fe:	e7bc      	b.n	511a47a <_printf_i+0x15a>
 511a500:	682b      	ldr	r3, [r5, #0]
 511a502:	1d1a      	adds	r2, r3, #4
 511a504:	602a      	str	r2, [r5, #0]
 511a506:	684a      	ldr	r2, [r1, #4]
 511a508:	2100      	movs	r1, #0
 511a50a:	681d      	ldr	r5, [r3, #0]
 511a50c:	4628      	mov	r0, r5
 511a50e:	f7ff fbb9 	bl	5119c84 <memchr>
 511a512:	b108      	cbz	r0, 511a518 <_printf_i+0x1f8>
 511a514:	1b40      	subs	r0, r0, r5
 511a516:	6060      	str	r0, [r4, #4]
 511a518:	6863      	ldr	r3, [r4, #4]
 511a51a:	6123      	str	r3, [r4, #16]
 511a51c:	2300      	movs	r3, #0
 511a51e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 511a522:	e7aa      	b.n	511a47a <_printf_i+0x15a>
 511a524:	6923      	ldr	r3, [r4, #16]
 511a526:	462a      	mov	r2, r5
 511a528:	4649      	mov	r1, r9
 511a52a:	4640      	mov	r0, r8
 511a52c:	47d0      	blx	sl
 511a52e:	3001      	adds	r0, #1
 511a530:	d0ad      	beq.n	511a48e <_printf_i+0x16e>
 511a532:	6823      	ldr	r3, [r4, #0]
 511a534:	079b      	lsls	r3, r3, #30
 511a536:	d413      	bmi.n	511a560 <_printf_i+0x240>
 511a538:	68e0      	ldr	r0, [r4, #12]
 511a53a:	9b05      	ldr	r3, [sp, #20]
 511a53c:	4298      	cmp	r0, r3
 511a53e:	bfb8      	it	lt
 511a540:	4618      	movlt	r0, r3
 511a542:	e7a6      	b.n	511a492 <_printf_i+0x172>
 511a544:	2301      	movs	r3, #1
 511a546:	4632      	mov	r2, r6
 511a548:	4649      	mov	r1, r9
 511a54a:	4640      	mov	r0, r8
 511a54c:	47d0      	blx	sl
 511a54e:	3001      	adds	r0, #1
 511a550:	d09d      	beq.n	511a48e <_printf_i+0x16e>
 511a552:	3501      	adds	r5, #1
 511a554:	68e3      	ldr	r3, [r4, #12]
 511a556:	9905      	ldr	r1, [sp, #20]
 511a558:	1a5b      	subs	r3, r3, r1
 511a55a:	42ab      	cmp	r3, r5
 511a55c:	dcf2      	bgt.n	511a544 <_printf_i+0x224>
 511a55e:	e7eb      	b.n	511a538 <_printf_i+0x218>
 511a560:	2500      	movs	r5, #0
 511a562:	f104 0619 	add.w	r6, r4, #25
 511a566:	e7f5      	b.n	511a554 <_printf_i+0x234>
 511a568:	0512dd66 	.word	0x0512dd66
 511a56c:	0512dd77 	.word	0x0512dd77

0511a570 <iprintf>:
 511a570:	b40f      	push	{r0, r1, r2, r3}
 511a572:	4b0a      	ldr	r3, [pc, #40]	; (511a59c <iprintf+0x2c>)
 511a574:	b513      	push	{r0, r1, r4, lr}
 511a576:	681c      	ldr	r4, [r3, #0]
 511a578:	b124      	cbz	r4, 511a584 <iprintf+0x14>
 511a57a:	69a3      	ldr	r3, [r4, #24]
 511a57c:	b913      	cbnz	r3, 511a584 <iprintf+0x14>
 511a57e:	4620      	mov	r0, r4
 511a580:	f001 f9c4 	bl	511b90c <__sinit>
 511a584:	ab05      	add	r3, sp, #20
 511a586:	9a04      	ldr	r2, [sp, #16]
 511a588:	68a1      	ldr	r1, [r4, #8]
 511a58a:	4620      	mov	r0, r4
 511a58c:	9301      	str	r3, [sp, #4]
 511a58e:	f002 f893 	bl	511c6b8 <_vfiprintf_r>
 511a592:	b002      	add	sp, #8
 511a594:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 511a598:	b004      	add	sp, #16
 511a59a:	4770      	bx	lr
 511a59c:	0512fab4 	.word	0x0512fab4

0511a5a0 <_puts_r>:
 511a5a0:	b570      	push	{r4, r5, r6, lr}
 511a5a2:	460e      	mov	r6, r1
 511a5a4:	4605      	mov	r5, r0
 511a5a6:	b118      	cbz	r0, 511a5b0 <_puts_r+0x10>
 511a5a8:	6983      	ldr	r3, [r0, #24]
 511a5aa:	b90b      	cbnz	r3, 511a5b0 <_puts_r+0x10>
 511a5ac:	f001 f9ae 	bl	511b90c <__sinit>
 511a5b0:	69ab      	ldr	r3, [r5, #24]
 511a5b2:	68ac      	ldr	r4, [r5, #8]
 511a5b4:	b913      	cbnz	r3, 511a5bc <_puts_r+0x1c>
 511a5b6:	4628      	mov	r0, r5
 511a5b8:	f001 f9a8 	bl	511b90c <__sinit>
 511a5bc:	4b2c      	ldr	r3, [pc, #176]	; (511a670 <_puts_r+0xd0>)
 511a5be:	429c      	cmp	r4, r3
 511a5c0:	d120      	bne.n	511a604 <_puts_r+0x64>
 511a5c2:	686c      	ldr	r4, [r5, #4]
 511a5c4:	6e63      	ldr	r3, [r4, #100]	; 0x64
 511a5c6:	07db      	lsls	r3, r3, #31
 511a5c8:	d405      	bmi.n	511a5d6 <_puts_r+0x36>
 511a5ca:	89a3      	ldrh	r3, [r4, #12]
 511a5cc:	0598      	lsls	r0, r3, #22
 511a5ce:	d402      	bmi.n	511a5d6 <_puts_r+0x36>
 511a5d0:	6da0      	ldr	r0, [r4, #88]	; 0x58
 511a5d2:	f001 fa3e 	bl	511ba52 <__retarget_lock_acquire_recursive>
 511a5d6:	89a3      	ldrh	r3, [r4, #12]
 511a5d8:	0719      	lsls	r1, r3, #28
 511a5da:	d51d      	bpl.n	511a618 <_puts_r+0x78>
 511a5dc:	6923      	ldr	r3, [r4, #16]
 511a5de:	b1db      	cbz	r3, 511a618 <_puts_r+0x78>
 511a5e0:	3e01      	subs	r6, #1
 511a5e2:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 511a5e6:	68a3      	ldr	r3, [r4, #8]
 511a5e8:	3b01      	subs	r3, #1
 511a5ea:	60a3      	str	r3, [r4, #8]
 511a5ec:	bb39      	cbnz	r1, 511a63e <_puts_r+0x9e>
 511a5ee:	2b00      	cmp	r3, #0
 511a5f0:	da38      	bge.n	511a664 <_puts_r+0xc4>
 511a5f2:	4622      	mov	r2, r4
 511a5f4:	210a      	movs	r1, #10
 511a5f6:	4628      	mov	r0, r5
 511a5f8:	f000 f98e 	bl	511a918 <__swbuf_r>
 511a5fc:	3001      	adds	r0, #1
 511a5fe:	d011      	beq.n	511a624 <_puts_r+0x84>
 511a600:	250a      	movs	r5, #10
 511a602:	e011      	b.n	511a628 <_puts_r+0x88>
 511a604:	4b1b      	ldr	r3, [pc, #108]	; (511a674 <_puts_r+0xd4>)
 511a606:	429c      	cmp	r4, r3
 511a608:	d101      	bne.n	511a60e <_puts_r+0x6e>
 511a60a:	68ac      	ldr	r4, [r5, #8]
 511a60c:	e7da      	b.n	511a5c4 <_puts_r+0x24>
 511a60e:	4b1a      	ldr	r3, [pc, #104]	; (511a678 <_puts_r+0xd8>)
 511a610:	429c      	cmp	r4, r3
 511a612:	bf08      	it	eq
 511a614:	68ec      	ldreq	r4, [r5, #12]
 511a616:	e7d5      	b.n	511a5c4 <_puts_r+0x24>
 511a618:	4621      	mov	r1, r4
 511a61a:	4628      	mov	r0, r5
 511a61c:	f000 f9e0 	bl	511a9e0 <__swsetup_r>
 511a620:	2800      	cmp	r0, #0
 511a622:	d0dd      	beq.n	511a5e0 <_puts_r+0x40>
 511a624:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 511a628:	6e63      	ldr	r3, [r4, #100]	; 0x64
 511a62a:	07da      	lsls	r2, r3, #31
 511a62c:	d405      	bmi.n	511a63a <_puts_r+0x9a>
 511a62e:	89a3      	ldrh	r3, [r4, #12]
 511a630:	059b      	lsls	r3, r3, #22
 511a632:	d402      	bmi.n	511a63a <_puts_r+0x9a>
 511a634:	6da0      	ldr	r0, [r4, #88]	; 0x58
 511a636:	f001 fa0d 	bl	511ba54 <__retarget_lock_release_recursive>
 511a63a:	4628      	mov	r0, r5
 511a63c:	bd70      	pop	{r4, r5, r6, pc}
 511a63e:	2b00      	cmp	r3, #0
 511a640:	da04      	bge.n	511a64c <_puts_r+0xac>
 511a642:	69a2      	ldr	r2, [r4, #24]
 511a644:	429a      	cmp	r2, r3
 511a646:	dc06      	bgt.n	511a656 <_puts_r+0xb6>
 511a648:	290a      	cmp	r1, #10
 511a64a:	d004      	beq.n	511a656 <_puts_r+0xb6>
 511a64c:	6823      	ldr	r3, [r4, #0]
 511a64e:	1c5a      	adds	r2, r3, #1
 511a650:	6022      	str	r2, [r4, #0]
 511a652:	7019      	strb	r1, [r3, #0]
 511a654:	e7c5      	b.n	511a5e2 <_puts_r+0x42>
 511a656:	4622      	mov	r2, r4
 511a658:	4628      	mov	r0, r5
 511a65a:	f000 f95d 	bl	511a918 <__swbuf_r>
 511a65e:	3001      	adds	r0, #1
 511a660:	d1bf      	bne.n	511a5e2 <_puts_r+0x42>
 511a662:	e7df      	b.n	511a624 <_puts_r+0x84>
 511a664:	6823      	ldr	r3, [r4, #0]
 511a666:	250a      	movs	r5, #10
 511a668:	1c5a      	adds	r2, r3, #1
 511a66a:	6022      	str	r2, [r4, #0]
 511a66c:	701d      	strb	r5, [r3, #0]
 511a66e:	e7db      	b.n	511a628 <_puts_r+0x88>
 511a670:	0512df5c 	.word	0x0512df5c
 511a674:	0512df7c 	.word	0x0512df7c
 511a678:	0512df3c 	.word	0x0512df3c

0511a67c <puts>:
 511a67c:	4b02      	ldr	r3, [pc, #8]	; (511a688 <puts+0xc>)
 511a67e:	4601      	mov	r1, r0
 511a680:	6818      	ldr	r0, [r3, #0]
 511a682:	f7ff bf8d 	b.w	511a5a0 <_puts_r>
 511a686:	bf00      	nop
 511a688:	0512fab4 	.word	0x0512fab4

0511a68c <sniprintf>:
 511a68c:	b40c      	push	{r2, r3}
 511a68e:	4b18      	ldr	r3, [pc, #96]	; (511a6f0 <sniprintf+0x64>)
 511a690:	b530      	push	{r4, r5, lr}
 511a692:	1e0c      	subs	r4, r1, #0
 511a694:	b09d      	sub	sp, #116	; 0x74
 511a696:	681d      	ldr	r5, [r3, #0]
 511a698:	da08      	bge.n	511a6ac <sniprintf+0x20>
 511a69a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511a69e:	238b      	movs	r3, #139	; 0x8b
 511a6a0:	602b      	str	r3, [r5, #0]
 511a6a2:	b01d      	add	sp, #116	; 0x74
 511a6a4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 511a6a8:	b002      	add	sp, #8
 511a6aa:	4770      	bx	lr
 511a6ac:	f44f 7302 	mov.w	r3, #520	; 0x208
 511a6b0:	9002      	str	r0, [sp, #8]
 511a6b2:	f8ad 3014 	strh.w	r3, [sp, #20]
 511a6b6:	a902      	add	r1, sp, #8
 511a6b8:	bf14      	ite	ne
 511a6ba:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
 511a6be:	4623      	moveq	r3, r4
 511a6c0:	9006      	str	r0, [sp, #24]
 511a6c2:	4628      	mov	r0, r5
 511a6c4:	9304      	str	r3, [sp, #16]
 511a6c6:	9307      	str	r3, [sp, #28]
 511a6c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 511a6cc:	9a20      	ldr	r2, [sp, #128]	; 0x80
 511a6ce:	f8ad 3016 	strh.w	r3, [sp, #22]
 511a6d2:	ab21      	add	r3, sp, #132	; 0x84
 511a6d4:	9301      	str	r3, [sp, #4]
 511a6d6:	f001 fec5 	bl	511c464 <_svfiprintf_r>
 511a6da:	1c43      	adds	r3, r0, #1
 511a6dc:	bfbc      	itt	lt
 511a6de:	238b      	movlt	r3, #139	; 0x8b
 511a6e0:	602b      	strlt	r3, [r5, #0]
 511a6e2:	2c00      	cmp	r4, #0
 511a6e4:	d0dd      	beq.n	511a6a2 <sniprintf+0x16>
 511a6e6:	9b02      	ldr	r3, [sp, #8]
 511a6e8:	2200      	movs	r2, #0
 511a6ea:	701a      	strb	r2, [r3, #0]
 511a6ec:	e7d9      	b.n	511a6a2 <sniprintf+0x16>
 511a6ee:	bf00      	nop
 511a6f0:	0512fab4 	.word	0x0512fab4

0511a6f4 <__stack_chk_init>:
 511a6f4:	4b03      	ldr	r3, [pc, #12]	; (511a704 <__stack_chk_init+0x10>)
 511a6f6:	681a      	ldr	r2, [r3, #0]
 511a6f8:	b912      	cbnz	r2, 511a700 <__stack_chk_init+0xc>
 511a6fa:	f5a2 0276 	sub.w	r2, r2, #16121856	; 0xf60000
 511a6fe:	601a      	str	r2, [r3, #0]
 511a700:	4770      	bx	lr
 511a702:	bf00      	nop
 511a704:	051386f8 	.word	0x051386f8

0511a708 <strncmp>:
 511a708:	b510      	push	{r4, lr}
 511a70a:	b17a      	cbz	r2, 511a72c <strncmp+0x24>
 511a70c:	4603      	mov	r3, r0
 511a70e:	3901      	subs	r1, #1
 511a710:	1884      	adds	r4, r0, r2
 511a712:	f813 0b01 	ldrb.w	r0, [r3], #1
 511a716:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 511a71a:	4290      	cmp	r0, r2
 511a71c:	d101      	bne.n	511a722 <strncmp+0x1a>
 511a71e:	42a3      	cmp	r3, r4
 511a720:	d101      	bne.n	511a726 <strncmp+0x1e>
 511a722:	1a80      	subs	r0, r0, r2
 511a724:	bd10      	pop	{r4, pc}
 511a726:	2800      	cmp	r0, #0
 511a728:	d1f3      	bne.n	511a712 <strncmp+0xa>
 511a72a:	e7fa      	b.n	511a722 <strncmp+0x1a>
 511a72c:	4610      	mov	r0, r2
 511a72e:	e7f9      	b.n	511a724 <strncmp+0x1c>

0511a730 <strncpy>:
 511a730:	3901      	subs	r1, #1
 511a732:	4603      	mov	r3, r0
 511a734:	b510      	push	{r4, lr}
 511a736:	b132      	cbz	r2, 511a746 <strncpy+0x16>
 511a738:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 511a73c:	3a01      	subs	r2, #1
 511a73e:	f803 4b01 	strb.w	r4, [r3], #1
 511a742:	2c00      	cmp	r4, #0
 511a744:	d1f7      	bne.n	511a736 <strncpy+0x6>
 511a746:	441a      	add	r2, r3
 511a748:	2100      	movs	r1, #0
 511a74a:	4293      	cmp	r3, r2
 511a74c:	d100      	bne.n	511a750 <strncpy+0x20>
 511a74e:	bd10      	pop	{r4, pc}
 511a750:	f803 1b01 	strb.w	r1, [r3], #1
 511a754:	e7f9      	b.n	511a74a <strncpy+0x1a>

0511a756 <strstr>:
 511a756:	780a      	ldrb	r2, [r1, #0]
 511a758:	b570      	push	{r4, r5, r6, lr}
 511a75a:	b96a      	cbnz	r2, 511a778 <strstr+0x22>
 511a75c:	bd70      	pop	{r4, r5, r6, pc}
 511a75e:	429a      	cmp	r2, r3
 511a760:	d109      	bne.n	511a776 <strstr+0x20>
 511a762:	460c      	mov	r4, r1
 511a764:	4605      	mov	r5, r0
 511a766:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 511a76a:	2b00      	cmp	r3, #0
 511a76c:	d0f6      	beq.n	511a75c <strstr+0x6>
 511a76e:	f815 6f01 	ldrb.w	r6, [r5, #1]!
 511a772:	429e      	cmp	r6, r3
 511a774:	d0f7      	beq.n	511a766 <strstr+0x10>
 511a776:	3001      	adds	r0, #1
 511a778:	7803      	ldrb	r3, [r0, #0]
 511a77a:	2b00      	cmp	r3, #0
 511a77c:	d1ef      	bne.n	511a75e <strstr+0x8>
 511a77e:	4618      	mov	r0, r3
 511a780:	e7ec      	b.n	511a75c <strstr+0x6>
	...

0511a784 <_strtol_l.constprop.0>:
 511a784:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511a788:	2b01      	cmp	r3, #1
 511a78a:	4681      	mov	r9, r0
 511a78c:	4688      	mov	r8, r1
 511a78e:	4692      	mov	sl, r2
 511a790:	461e      	mov	r6, r3
 511a792:	d001      	beq.n	511a798 <_strtol_l.constprop.0+0x14>
 511a794:	2b24      	cmp	r3, #36	; 0x24
 511a796:	d906      	bls.n	511a7a6 <_strtol_l.constprop.0+0x22>
 511a798:	f000 ff98 	bl	511b6cc <__errno>
 511a79c:	2316      	movs	r3, #22
 511a79e:	6003      	str	r3, [r0, #0]
 511a7a0:	2000      	movs	r0, #0
 511a7a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511a7a6:	4a39      	ldr	r2, [pc, #228]	; (511a88c <_strtol_l.constprop.0+0x108>)
 511a7a8:	460d      	mov	r5, r1
 511a7aa:	462b      	mov	r3, r5
 511a7ac:	f815 4b01 	ldrb.w	r4, [r5], #1
 511a7b0:	5ca7      	ldrb	r7, [r4, r2]
 511a7b2:	f017 0708 	ands.w	r7, r7, #8
 511a7b6:	d1f8      	bne.n	511a7aa <_strtol_l.constprop.0+0x26>
 511a7b8:	2c2d      	cmp	r4, #45	; 0x2d
 511a7ba:	d131      	bne.n	511a820 <_strtol_l.constprop.0+0x9c>
 511a7bc:	782c      	ldrb	r4, [r5, #0]
 511a7be:	2701      	movs	r7, #1
 511a7c0:	1c9d      	adds	r5, r3, #2
 511a7c2:	2e00      	cmp	r6, #0
 511a7c4:	d05e      	beq.n	511a884 <_strtol_l.constprop.0+0x100>
 511a7c6:	2e10      	cmp	r6, #16
 511a7c8:	d109      	bne.n	511a7de <_strtol_l.constprop.0+0x5a>
 511a7ca:	2c30      	cmp	r4, #48	; 0x30
 511a7cc:	d107      	bne.n	511a7de <_strtol_l.constprop.0+0x5a>
 511a7ce:	782b      	ldrb	r3, [r5, #0]
 511a7d0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 511a7d4:	2b58      	cmp	r3, #88	; 0x58
 511a7d6:	d150      	bne.n	511a87a <_strtol_l.constprop.0+0xf6>
 511a7d8:	786c      	ldrb	r4, [r5, #1]
 511a7da:	2610      	movs	r6, #16
 511a7dc:	3502      	adds	r5, #2
 511a7de:	f107 4b00 	add.w	fp, r7, #2147483648	; 0x80000000
 511a7e2:	4631      	mov	r1, r6
 511a7e4:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 511a7e8:	4658      	mov	r0, fp
 511a7ea:	f7f5 fed7 	bl	511059c <__aeabi_uidivmod>
 511a7ee:	f04f 0c00 	mov.w	ip, #0
 511a7f2:	4663      	mov	r3, ip
 511a7f4:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
 511a7f8:	2a09      	cmp	r2, #9
 511a7fa:	d816      	bhi.n	511a82a <_strtol_l.constprop.0+0xa6>
 511a7fc:	4614      	mov	r4, r2
 511a7fe:	42a6      	cmp	r6, r4
 511a800:	dd22      	ble.n	511a848 <_strtol_l.constprop.0+0xc4>
 511a802:	f1bc 0f00 	cmp.w	ip, #0
 511a806:	db1c      	blt.n	511a842 <_strtol_l.constprop.0+0xbe>
 511a808:	4298      	cmp	r0, r3
 511a80a:	d31a      	bcc.n	511a842 <_strtol_l.constprop.0+0xbe>
 511a80c:	d101      	bne.n	511a812 <_strtol_l.constprop.0+0x8e>
 511a80e:	42a1      	cmp	r1, r4
 511a810:	db17      	blt.n	511a842 <_strtol_l.constprop.0+0xbe>
 511a812:	fb03 4306 	mla	r3, r3, r6, r4
 511a816:	f04f 0c01 	mov.w	ip, #1
 511a81a:	f815 4b01 	ldrb.w	r4, [r5], #1
 511a81e:	e7e9      	b.n	511a7f4 <_strtol_l.constprop.0+0x70>
 511a820:	2c2b      	cmp	r4, #43	; 0x2b
 511a822:	bf04      	itt	eq
 511a824:	782c      	ldrbeq	r4, [r5, #0]
 511a826:	1c9d      	addeq	r5, r3, #2
 511a828:	e7cb      	b.n	511a7c2 <_strtol_l.constprop.0+0x3e>
 511a82a:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
 511a82e:	2a19      	cmp	r2, #25
 511a830:	d801      	bhi.n	511a836 <_strtol_l.constprop.0+0xb2>
 511a832:	3c37      	subs	r4, #55	; 0x37
 511a834:	e7e3      	b.n	511a7fe <_strtol_l.constprop.0+0x7a>
 511a836:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
 511a83a:	2a19      	cmp	r2, #25
 511a83c:	d804      	bhi.n	511a848 <_strtol_l.constprop.0+0xc4>
 511a83e:	3c57      	subs	r4, #87	; 0x57
 511a840:	e7dd      	b.n	511a7fe <_strtol_l.constprop.0+0x7a>
 511a842:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 511a846:	e7e8      	b.n	511a81a <_strtol_l.constprop.0+0x96>
 511a848:	f1bc 0f00 	cmp.w	ip, #0
 511a84c:	da08      	bge.n	511a860 <_strtol_l.constprop.0+0xdc>
 511a84e:	2322      	movs	r3, #34	; 0x22
 511a850:	f8c9 3000 	str.w	r3, [r9]
 511a854:	465b      	mov	r3, fp
 511a856:	f1ba 0f00 	cmp.w	sl, #0
 511a85a:	d109      	bne.n	511a870 <_strtol_l.constprop.0+0xec>
 511a85c:	4618      	mov	r0, r3
 511a85e:	e7a0      	b.n	511a7a2 <_strtol_l.constprop.0+0x1e>
 511a860:	b107      	cbz	r7, 511a864 <_strtol_l.constprop.0+0xe0>
 511a862:	425b      	negs	r3, r3
 511a864:	f1ba 0f00 	cmp.w	sl, #0
 511a868:	d0f8      	beq.n	511a85c <_strtol_l.constprop.0+0xd8>
 511a86a:	f1bc 0f00 	cmp.w	ip, #0
 511a86e:	d001      	beq.n	511a874 <_strtol_l.constprop.0+0xf0>
 511a870:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
 511a874:	f8ca 8000 	str.w	r8, [sl]
 511a878:	e7f0      	b.n	511a85c <_strtol_l.constprop.0+0xd8>
 511a87a:	2430      	movs	r4, #48	; 0x30
 511a87c:	2e00      	cmp	r6, #0
 511a87e:	d1ae      	bne.n	511a7de <_strtol_l.constprop.0+0x5a>
 511a880:	2608      	movs	r6, #8
 511a882:	e7ac      	b.n	511a7de <_strtol_l.constprop.0+0x5a>
 511a884:	2c30      	cmp	r4, #48	; 0x30
 511a886:	d0a2      	beq.n	511a7ce <_strtol_l.constprop.0+0x4a>
 511a888:	260a      	movs	r6, #10
 511a88a:	e7a8      	b.n	511a7de <_strtol_l.constprop.0+0x5a>
 511a88c:	0512dd89 	.word	0x0512dd89

0511a890 <strtol>:
 511a890:	4613      	mov	r3, r2
 511a892:	460a      	mov	r2, r1
 511a894:	4601      	mov	r1, r0
 511a896:	4802      	ldr	r0, [pc, #8]	; (511a8a0 <strtol+0x10>)
 511a898:	6800      	ldr	r0, [r0, #0]
 511a89a:	f7ff bf73 	b.w	511a784 <_strtol_l.constprop.0>
 511a89e:	bf00      	nop
 511a8a0:	0512fab4 	.word	0x0512fab4

0511a8a4 <_vsniprintf_r>:
 511a8a4:	b530      	push	{r4, r5, lr}
 511a8a6:	4614      	mov	r4, r2
 511a8a8:	4605      	mov	r5, r0
 511a8aa:	b09b      	sub	sp, #108	; 0x6c
 511a8ac:	461a      	mov	r2, r3
 511a8ae:	2c00      	cmp	r4, #0
 511a8b0:	da05      	bge.n	511a8be <_vsniprintf_r+0x1a>
 511a8b2:	238b      	movs	r3, #139	; 0x8b
 511a8b4:	6003      	str	r3, [r0, #0]
 511a8b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511a8ba:	b01b      	add	sp, #108	; 0x6c
 511a8bc:	bd30      	pop	{r4, r5, pc}
 511a8be:	f44f 7302 	mov.w	r3, #520	; 0x208
 511a8c2:	9100      	str	r1, [sp, #0]
 511a8c4:	f8ad 300c 	strh.w	r3, [sp, #12]
 511a8c8:	bf14      	ite	ne
 511a8ca:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
 511a8ce:	4623      	moveq	r3, r4
 511a8d0:	9104      	str	r1, [sp, #16]
 511a8d2:	9302      	str	r3, [sp, #8]
 511a8d4:	4669      	mov	r1, sp
 511a8d6:	9305      	str	r3, [sp, #20]
 511a8d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
 511a8dc:	f8ad 300e 	strh.w	r3, [sp, #14]
 511a8e0:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 511a8e2:	f001 fdbf 	bl	511c464 <_svfiprintf_r>
 511a8e6:	1c43      	adds	r3, r0, #1
 511a8e8:	bfbc      	itt	lt
 511a8ea:	238b      	movlt	r3, #139	; 0x8b
 511a8ec:	602b      	strlt	r3, [r5, #0]
 511a8ee:	2c00      	cmp	r4, #0
 511a8f0:	d0e3      	beq.n	511a8ba <_vsniprintf_r+0x16>
 511a8f2:	9b00      	ldr	r3, [sp, #0]
 511a8f4:	2200      	movs	r2, #0
 511a8f6:	701a      	strb	r2, [r3, #0]
 511a8f8:	e7df      	b.n	511a8ba <_vsniprintf_r+0x16>
	...

0511a8fc <vsniprintf>:
 511a8fc:	b507      	push	{r0, r1, r2, lr}
 511a8fe:	9300      	str	r3, [sp, #0]
 511a900:	4613      	mov	r3, r2
 511a902:	460a      	mov	r2, r1
 511a904:	4601      	mov	r1, r0
 511a906:	4803      	ldr	r0, [pc, #12]	; (511a914 <vsniprintf+0x18>)
 511a908:	6800      	ldr	r0, [r0, #0]
 511a90a:	f7ff ffcb 	bl	511a8a4 <_vsniprintf_r>
 511a90e:	b003      	add	sp, #12
 511a910:	f85d fb04 	ldr.w	pc, [sp], #4
 511a914:	0512fab4 	.word	0x0512fab4

0511a918 <__swbuf_r>:
 511a918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 511a91a:	460e      	mov	r6, r1
 511a91c:	4614      	mov	r4, r2
 511a91e:	4605      	mov	r5, r0
 511a920:	b118      	cbz	r0, 511a92a <__swbuf_r+0x12>
 511a922:	6983      	ldr	r3, [r0, #24]
 511a924:	b90b      	cbnz	r3, 511a92a <__swbuf_r+0x12>
 511a926:	f000 fff1 	bl	511b90c <__sinit>
 511a92a:	4b21      	ldr	r3, [pc, #132]	; (511a9b0 <__swbuf_r+0x98>)
 511a92c:	429c      	cmp	r4, r3
 511a92e:	d12b      	bne.n	511a988 <__swbuf_r+0x70>
 511a930:	686c      	ldr	r4, [r5, #4]
 511a932:	69a3      	ldr	r3, [r4, #24]
 511a934:	60a3      	str	r3, [r4, #8]
 511a936:	89a3      	ldrh	r3, [r4, #12]
 511a938:	071a      	lsls	r2, r3, #28
 511a93a:	d52f      	bpl.n	511a99c <__swbuf_r+0x84>
 511a93c:	6923      	ldr	r3, [r4, #16]
 511a93e:	b36b      	cbz	r3, 511a99c <__swbuf_r+0x84>
 511a940:	6923      	ldr	r3, [r4, #16]
 511a942:	b2f6      	uxtb	r6, r6
 511a944:	6820      	ldr	r0, [r4, #0]
 511a946:	4637      	mov	r7, r6
 511a948:	1ac0      	subs	r0, r0, r3
 511a94a:	6963      	ldr	r3, [r4, #20]
 511a94c:	4283      	cmp	r3, r0
 511a94e:	dc04      	bgt.n	511a95a <__swbuf_r+0x42>
 511a950:	4621      	mov	r1, r4
 511a952:	4628      	mov	r0, r5
 511a954:	f000 ff46 	bl	511b7e4 <_fflush_r>
 511a958:	bb30      	cbnz	r0, 511a9a8 <__swbuf_r+0x90>
 511a95a:	68a3      	ldr	r3, [r4, #8]
 511a95c:	3001      	adds	r0, #1
 511a95e:	3b01      	subs	r3, #1
 511a960:	60a3      	str	r3, [r4, #8]
 511a962:	6823      	ldr	r3, [r4, #0]
 511a964:	1c5a      	adds	r2, r3, #1
 511a966:	6022      	str	r2, [r4, #0]
 511a968:	701e      	strb	r6, [r3, #0]
 511a96a:	6963      	ldr	r3, [r4, #20]
 511a96c:	4283      	cmp	r3, r0
 511a96e:	d004      	beq.n	511a97a <__swbuf_r+0x62>
 511a970:	89a3      	ldrh	r3, [r4, #12]
 511a972:	07db      	lsls	r3, r3, #31
 511a974:	d506      	bpl.n	511a984 <__swbuf_r+0x6c>
 511a976:	2e0a      	cmp	r6, #10
 511a978:	d104      	bne.n	511a984 <__swbuf_r+0x6c>
 511a97a:	4621      	mov	r1, r4
 511a97c:	4628      	mov	r0, r5
 511a97e:	f000 ff31 	bl	511b7e4 <_fflush_r>
 511a982:	b988      	cbnz	r0, 511a9a8 <__swbuf_r+0x90>
 511a984:	4638      	mov	r0, r7
 511a986:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 511a988:	4b0a      	ldr	r3, [pc, #40]	; (511a9b4 <__swbuf_r+0x9c>)
 511a98a:	429c      	cmp	r4, r3
 511a98c:	d101      	bne.n	511a992 <__swbuf_r+0x7a>
 511a98e:	68ac      	ldr	r4, [r5, #8]
 511a990:	e7cf      	b.n	511a932 <__swbuf_r+0x1a>
 511a992:	4b09      	ldr	r3, [pc, #36]	; (511a9b8 <__swbuf_r+0xa0>)
 511a994:	429c      	cmp	r4, r3
 511a996:	bf08      	it	eq
 511a998:	68ec      	ldreq	r4, [r5, #12]
 511a99a:	e7ca      	b.n	511a932 <__swbuf_r+0x1a>
 511a99c:	4621      	mov	r1, r4
 511a99e:	4628      	mov	r0, r5
 511a9a0:	f000 f81e 	bl	511a9e0 <__swsetup_r>
 511a9a4:	2800      	cmp	r0, #0
 511a9a6:	d0cb      	beq.n	511a940 <__swbuf_r+0x28>
 511a9a8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 511a9ac:	e7ea      	b.n	511a984 <__swbuf_r+0x6c>
 511a9ae:	bf00      	nop
 511a9b0:	0512df5c 	.word	0x0512df5c
 511a9b4:	0512df7c 	.word	0x0512df7c
 511a9b8:	0512df3c 	.word	0x0512df3c

0511a9bc <_write_r>:
 511a9bc:	b538      	push	{r3, r4, r5, lr}
 511a9be:	4604      	mov	r4, r0
 511a9c0:	4d06      	ldr	r5, [pc, #24]	; (511a9dc <_write_r+0x20>)
 511a9c2:	4608      	mov	r0, r1
 511a9c4:	4611      	mov	r1, r2
 511a9c6:	2200      	movs	r2, #0
 511a9c8:	602a      	str	r2, [r5, #0]
 511a9ca:	461a      	mov	r2, r3
 511a9cc:	f7f6 efea 	blx	51119a4 <_write>
 511a9d0:	1c43      	adds	r3, r0, #1
 511a9d2:	d102      	bne.n	511a9da <_write_r+0x1e>
 511a9d4:	682b      	ldr	r3, [r5, #0]
 511a9d6:	b103      	cbz	r3, 511a9da <_write_r+0x1e>
 511a9d8:	6023      	str	r3, [r4, #0]
 511a9da:	bd38      	pop	{r3, r4, r5, pc}
 511a9dc:	05138708 	.word	0x05138708

0511a9e0 <__swsetup_r>:
 511a9e0:	4b32      	ldr	r3, [pc, #200]	; (511aaac <__swsetup_r+0xcc>)
 511a9e2:	b570      	push	{r4, r5, r6, lr}
 511a9e4:	4606      	mov	r6, r0
 511a9e6:	460c      	mov	r4, r1
 511a9e8:	681d      	ldr	r5, [r3, #0]
 511a9ea:	b125      	cbz	r5, 511a9f6 <__swsetup_r+0x16>
 511a9ec:	69ab      	ldr	r3, [r5, #24]
 511a9ee:	b913      	cbnz	r3, 511a9f6 <__swsetup_r+0x16>
 511a9f0:	4628      	mov	r0, r5
 511a9f2:	f000 ff8b 	bl	511b90c <__sinit>
 511a9f6:	4b2e      	ldr	r3, [pc, #184]	; (511aab0 <__swsetup_r+0xd0>)
 511a9f8:	429c      	cmp	r4, r3
 511a9fa:	d10f      	bne.n	511aa1c <__swsetup_r+0x3c>
 511a9fc:	686c      	ldr	r4, [r5, #4]
 511a9fe:	89a3      	ldrh	r3, [r4, #12]
 511aa00:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 511aa04:	0719      	lsls	r1, r3, #28
 511aa06:	d42c      	bmi.n	511aa62 <__swsetup_r+0x82>
 511aa08:	06dd      	lsls	r5, r3, #27
 511aa0a:	d411      	bmi.n	511aa30 <__swsetup_r+0x50>
 511aa0c:	2309      	movs	r3, #9
 511aa0e:	6033      	str	r3, [r6, #0]
 511aa10:	f042 0340 	orr.w	r3, r2, #64	; 0x40
 511aa14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511aa18:	81a3      	strh	r3, [r4, #12]
 511aa1a:	e03e      	b.n	511aa9a <__swsetup_r+0xba>
 511aa1c:	4b25      	ldr	r3, [pc, #148]	; (511aab4 <__swsetup_r+0xd4>)
 511aa1e:	429c      	cmp	r4, r3
 511aa20:	d101      	bne.n	511aa26 <__swsetup_r+0x46>
 511aa22:	68ac      	ldr	r4, [r5, #8]
 511aa24:	e7eb      	b.n	511a9fe <__swsetup_r+0x1e>
 511aa26:	4b24      	ldr	r3, [pc, #144]	; (511aab8 <__swsetup_r+0xd8>)
 511aa28:	429c      	cmp	r4, r3
 511aa2a:	bf08      	it	eq
 511aa2c:	68ec      	ldreq	r4, [r5, #12]
 511aa2e:	e7e6      	b.n	511a9fe <__swsetup_r+0x1e>
 511aa30:	0758      	lsls	r0, r3, #29
 511aa32:	d512      	bpl.n	511aa5a <__swsetup_r+0x7a>
 511aa34:	6b61      	ldr	r1, [r4, #52]	; 0x34
 511aa36:	b141      	cbz	r1, 511aa4a <__swsetup_r+0x6a>
 511aa38:	f104 0344 	add.w	r3, r4, #68	; 0x44
 511aa3c:	4299      	cmp	r1, r3
 511aa3e:	d002      	beq.n	511aa46 <__swsetup_r+0x66>
 511aa40:	4630      	mov	r0, r6
 511aa42:	f001 fc0d 	bl	511c260 <_free_r>
 511aa46:	2300      	movs	r3, #0
 511aa48:	6363      	str	r3, [r4, #52]	; 0x34
 511aa4a:	89a3      	ldrh	r3, [r4, #12]
 511aa4c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 511aa50:	81a3      	strh	r3, [r4, #12]
 511aa52:	2300      	movs	r3, #0
 511aa54:	6063      	str	r3, [r4, #4]
 511aa56:	6923      	ldr	r3, [r4, #16]
 511aa58:	6023      	str	r3, [r4, #0]
 511aa5a:	89a3      	ldrh	r3, [r4, #12]
 511aa5c:	f043 0308 	orr.w	r3, r3, #8
 511aa60:	81a3      	strh	r3, [r4, #12]
 511aa62:	6923      	ldr	r3, [r4, #16]
 511aa64:	b94b      	cbnz	r3, 511aa7a <__swsetup_r+0x9a>
 511aa66:	89a3      	ldrh	r3, [r4, #12]
 511aa68:	f403 7320 	and.w	r3, r3, #640	; 0x280
 511aa6c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 511aa70:	d003      	beq.n	511aa7a <__swsetup_r+0x9a>
 511aa72:	4621      	mov	r1, r4
 511aa74:	4630      	mov	r0, r6
 511aa76:	f001 f813 	bl	511baa0 <__smakebuf_r>
 511aa7a:	89a0      	ldrh	r0, [r4, #12]
 511aa7c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 511aa80:	f010 0301 	ands.w	r3, r0, #1
 511aa84:	d00a      	beq.n	511aa9c <__swsetup_r+0xbc>
 511aa86:	2300      	movs	r3, #0
 511aa88:	60a3      	str	r3, [r4, #8]
 511aa8a:	6963      	ldr	r3, [r4, #20]
 511aa8c:	425b      	negs	r3, r3
 511aa8e:	61a3      	str	r3, [r4, #24]
 511aa90:	6923      	ldr	r3, [r4, #16]
 511aa92:	b943      	cbnz	r3, 511aaa6 <__swsetup_r+0xc6>
 511aa94:	f010 0080 	ands.w	r0, r0, #128	; 0x80
 511aa98:	d1ba      	bne.n	511aa10 <__swsetup_r+0x30>
 511aa9a:	bd70      	pop	{r4, r5, r6, pc}
 511aa9c:	0781      	lsls	r1, r0, #30
 511aa9e:	bf58      	it	pl
 511aaa0:	6963      	ldrpl	r3, [r4, #20]
 511aaa2:	60a3      	str	r3, [r4, #8]
 511aaa4:	e7f4      	b.n	511aa90 <__swsetup_r+0xb0>
 511aaa6:	2000      	movs	r0, #0
 511aaa8:	e7f7      	b.n	511aa9a <__swsetup_r+0xba>
 511aaaa:	bf00      	nop
 511aaac:	0512fab4 	.word	0x0512fab4
 511aab0:	0512df5c 	.word	0x0512df5c
 511aab4:	0512df7c 	.word	0x0512df7c
 511aab8:	0512df3c 	.word	0x0512df3c

0511aabc <quorem>:
 511aabc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511aac0:	4607      	mov	r7, r0
 511aac2:	690c      	ldr	r4, [r1, #16]
 511aac4:	6903      	ldr	r3, [r0, #16]
 511aac6:	b085      	sub	sp, #20
 511aac8:	468a      	mov	sl, r1
 511aaca:	42a3      	cmp	r3, r4
 511aacc:	f2c0 808b 	blt.w	511abe6 <quorem+0x12a>
 511aad0:	3c01      	subs	r4, #1
 511aad2:	f100 0614 	add.w	r6, r0, #20
 511aad6:	f101 0814 	add.w	r8, r1, #20
 511aada:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 511aade:	9301      	str	r3, [sp, #4]
 511aae0:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 511aae4:	ea4f 0b84 	mov.w	fp, r4, lsl #2
 511aae8:	f858 1024 	ldr.w	r1, [r8, r4, lsl #2]
 511aaec:	eb08 0984 	add.w	r9, r8, r4, lsl #2
 511aaf0:	4618      	mov	r0, r3
 511aaf2:	9302      	str	r3, [sp, #8]
 511aaf4:	3101      	adds	r1, #1
 511aaf6:	9103      	str	r1, [sp, #12]
 511aaf8:	f7f5 fc22 	bl	5110340 <__udivsi3>
 511aafc:	4605      	mov	r5, r0
 511aafe:	e9dd 3102 	ldrd	r3, r1, [sp, #8]
 511ab02:	428b      	cmp	r3, r1
 511ab04:	d332      	bcc.n	511ab6c <quorem+0xb0>
 511ab06:	f04f 0c00 	mov.w	ip, #0
 511ab0a:	4641      	mov	r1, r8
 511ab0c:	4630      	mov	r0, r6
 511ab0e:	46e6      	mov	lr, ip
 511ab10:	f851 2b04 	ldr.w	r2, [r1], #4
 511ab14:	4589      	cmp	r9, r1
 511ab16:	b293      	uxth	r3, r2
 511ab18:	ea4f 4212 	mov.w	r2, r2, lsr #16
 511ab1c:	fb05 c303 	mla	r3, r5, r3, ip
 511ab20:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 511ab24:	b29b      	uxth	r3, r3
 511ab26:	ebae 0303 	sub.w	r3, lr, r3
 511ab2a:	f8d0 e000 	ldr.w	lr, [r0]
 511ab2e:	fb05 c202 	mla	r2, r5, r2, ip
 511ab32:	fa1f fe8e 	uxth.w	lr, lr
 511ab36:	4473      	add	r3, lr
 511ab38:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 511ab3c:	fa1f fe82 	uxth.w	lr, r2
 511ab40:	6802      	ldr	r2, [r0, #0]
 511ab42:	ebce 4212 	rsb	r2, lr, r2, lsr #16
 511ab46:	eb02 4223 	add.w	r2, r2, r3, asr #16
 511ab4a:	b29b      	uxth	r3, r3
 511ab4c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 511ab50:	ea4f 4e22 	mov.w	lr, r2, asr #16
 511ab54:	f840 3b04 	str.w	r3, [r0], #4
 511ab58:	d2da      	bcs.n	511ab10 <quorem+0x54>
 511ab5a:	f856 300b 	ldr.w	r3, [r6, fp]
 511ab5e:	b92b      	cbnz	r3, 511ab6c <quorem+0xb0>
 511ab60:	9b01      	ldr	r3, [sp, #4]
 511ab62:	3b04      	subs	r3, #4
 511ab64:	461a      	mov	r2, r3
 511ab66:	429e      	cmp	r6, r3
 511ab68:	d331      	bcc.n	511abce <quorem+0x112>
 511ab6a:	613c      	str	r4, [r7, #16]
 511ab6c:	4651      	mov	r1, sl
 511ab6e:	4638      	mov	r0, r7
 511ab70:	f001 fa60 	bl	511c034 <__mcmp>
 511ab74:	2800      	cmp	r0, #0
 511ab76:	db26      	blt.n	511abc6 <quorem+0x10a>
 511ab78:	3501      	adds	r5, #1
 511ab7a:	4630      	mov	r0, r6
 511ab7c:	f04f 0c00 	mov.w	ip, #0
 511ab80:	f858 1b04 	ldr.w	r1, [r8], #4
 511ab84:	f8d0 e000 	ldr.w	lr, [r0]
 511ab88:	45c1      	cmp	r9, r8
 511ab8a:	b28b      	uxth	r3, r1
 511ab8c:	ebac 0303 	sub.w	r3, ip, r3
 511ab90:	fa1f f28e 	uxth.w	r2, lr
 511ab94:	4413      	add	r3, r2
 511ab96:	ea4f 4211 	mov.w	r2, r1, lsr #16
 511ab9a:	ebc2 421e 	rsb	r2, r2, lr, lsr #16
 511ab9e:	eb02 4223 	add.w	r2, r2, r3, asr #16
 511aba2:	b29b      	uxth	r3, r3
 511aba4:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 511aba8:	ea4f 4c22 	mov.w	ip, r2, asr #16
 511abac:	f840 3b04 	str.w	r3, [r0], #4
 511abb0:	d2e6      	bcs.n	511ab80 <quorem+0xc4>
 511abb2:	f856 2024 	ldr.w	r2, [r6, r4, lsl #2]
 511abb6:	eb06 0384 	add.w	r3, r6, r4, lsl #2
 511abba:	b922      	cbnz	r2, 511abc6 <quorem+0x10a>
 511abbc:	3b04      	subs	r3, #4
 511abbe:	461a      	mov	r2, r3
 511abc0:	429e      	cmp	r6, r3
 511abc2:	d30a      	bcc.n	511abda <quorem+0x11e>
 511abc4:	613c      	str	r4, [r7, #16]
 511abc6:	4628      	mov	r0, r5
 511abc8:	b005      	add	sp, #20
 511abca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511abce:	6812      	ldr	r2, [r2, #0]
 511abd0:	3b04      	subs	r3, #4
 511abd2:	2a00      	cmp	r2, #0
 511abd4:	d1c9      	bne.n	511ab6a <quorem+0xae>
 511abd6:	3c01      	subs	r4, #1
 511abd8:	e7c4      	b.n	511ab64 <quorem+0xa8>
 511abda:	6812      	ldr	r2, [r2, #0]
 511abdc:	3b04      	subs	r3, #4
 511abde:	2a00      	cmp	r2, #0
 511abe0:	d1f0      	bne.n	511abc4 <quorem+0x108>
 511abe2:	3c01      	subs	r4, #1
 511abe4:	e7eb      	b.n	511abbe <quorem+0x102>
 511abe6:	2000      	movs	r0, #0
 511abe8:	e7ee      	b.n	511abc8 <quorem+0x10c>
 511abea:	0000      	movs	r0, r0
 511abec:	0000      	movs	r0, r0
	...

0511abf0 <_dtoa_r>:
 511abf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511abf4:	ec59 8b10 	vmov	r8, r9, d0
 511abf8:	6a45      	ldr	r5, [r0, #36]	; 0x24
 511abfa:	ed2d 8b02 	vpush	{d8}
 511abfe:	b091      	sub	sp, #68	; 0x44
 511ac00:	4606      	mov	r6, r0
 511ac02:	9c1c      	ldr	r4, [sp, #112]	; 0x70
 511ac04:	9106      	str	r1, [sp, #24]
 511ac06:	9208      	str	r2, [sp, #32]
 511ac08:	930c      	str	r3, [sp, #48]	; 0x30
 511ac0a:	ed8d 0b02 	vstr	d0, [sp, #8]
 511ac0e:	b975      	cbnz	r5, 511ac2e <_dtoa_r+0x3e>
 511ac10:	2010      	movs	r0, #16
 511ac12:	f000 ff85 	bl	511bb20 <malloc>
 511ac16:	4602      	mov	r2, r0
 511ac18:	6270      	str	r0, [r6, #36]	; 0x24
 511ac1a:	b920      	cbnz	r0, 511ac26 <_dtoa_r+0x36>
 511ac1c:	4baa      	ldr	r3, [pc, #680]	; (511aec8 <_dtoa_r+0x2d8>)
 511ac1e:	21ea      	movs	r1, #234	; 0xea
 511ac20:	48aa      	ldr	r0, [pc, #680]	; (511aecc <_dtoa_r+0x2dc>)
 511ac22:	f001 ff11 	bl	511ca48 <__assert_func>
 511ac26:	e9c0 5501 	strd	r5, r5, [r0, #4]
 511ac2a:	6005      	str	r5, [r0, #0]
 511ac2c:	60c5      	str	r5, [r0, #12]
 511ac2e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 511ac30:	6819      	ldr	r1, [r3, #0]
 511ac32:	b151      	cbz	r1, 511ac4a <_dtoa_r+0x5a>
 511ac34:	685a      	ldr	r2, [r3, #4]
 511ac36:	2301      	movs	r3, #1
 511ac38:	604a      	str	r2, [r1, #4]
 511ac3a:	4630      	mov	r0, r6
 511ac3c:	4093      	lsls	r3, r2
 511ac3e:	608b      	str	r3, [r1, #8]
 511ac40:	f000 ffb6 	bl	511bbb0 <_Bfree>
 511ac44:	6a73      	ldr	r3, [r6, #36]	; 0x24
 511ac46:	2200      	movs	r2, #0
 511ac48:	601a      	str	r2, [r3, #0]
 511ac4a:	f1b9 0300 	subs.w	r3, r9, #0
 511ac4e:	bfbb      	ittet	lt
 511ac50:	f023 4300 	biclt.w	r3, r3, #2147483648	; 0x80000000
 511ac54:	9303      	strlt	r3, [sp, #12]
 511ac56:	2300      	movge	r3, #0
 511ac58:	2201      	movlt	r2, #1
 511ac5a:	bfac      	ite	ge
 511ac5c:	6023      	strge	r3, [r4, #0]
 511ac5e:	6022      	strlt	r2, [r4, #0]
 511ac60:	4b9b      	ldr	r3, [pc, #620]	; (511aed0 <_dtoa_r+0x2e0>)
 511ac62:	9c03      	ldr	r4, [sp, #12]
 511ac64:	43a3      	bics	r3, r4
 511ac66:	d11c      	bne.n	511aca2 <_dtoa_r+0xb2>
 511ac68:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 511ac6a:	f242 730f 	movw	r3, #9999	; 0x270f
 511ac6e:	6013      	str	r3, [r2, #0]
 511ac70:	f3c4 0313 	ubfx	r3, r4, #0, #20
 511ac74:	ea53 0308 	orrs.w	r3, r3, r8
 511ac78:	f000 84fc 	beq.w	511b674 <_dtoa_r+0xa84>
 511ac7c:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 511ac7e:	b963      	cbnz	r3, 511ac9a <_dtoa_r+0xaa>
 511ac80:	4b94      	ldr	r3, [pc, #592]	; (511aed4 <_dtoa_r+0x2e4>)
 511ac82:	e01f      	b.n	511acc4 <_dtoa_r+0xd4>
 511ac84:	4b94      	ldr	r3, [pc, #592]	; (511aed8 <_dtoa_r+0x2e8>)
 511ac86:	9301      	str	r3, [sp, #4]
 511ac88:	3308      	adds	r3, #8
 511ac8a:	9a1d      	ldr	r2, [sp, #116]	; 0x74
 511ac8c:	6013      	str	r3, [r2, #0]
 511ac8e:	9801      	ldr	r0, [sp, #4]
 511ac90:	b011      	add	sp, #68	; 0x44
 511ac92:	ecbd 8b02 	vpop	{d8}
 511ac96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511ac9a:	4b8e      	ldr	r3, [pc, #568]	; (511aed4 <_dtoa_r+0x2e4>)
 511ac9c:	9301      	str	r3, [sp, #4]
 511ac9e:	3303      	adds	r3, #3
 511aca0:	e7f3      	b.n	511ac8a <_dtoa_r+0x9a>
 511aca2:	ed9d 8b02 	vldr	d8, [sp, #8]
 511aca6:	eeb5 8b40 	vcmp.f64	d8, #0.0
 511acaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511acae:	d10b      	bne.n	511acc8 <_dtoa_r+0xd8>
 511acb0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 511acb2:	2301      	movs	r3, #1
 511acb4:	6013      	str	r3, [r2, #0]
 511acb6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 511acb8:	2b00      	cmp	r3, #0
 511acba:	f000 84d8 	beq.w	511b66e <_dtoa_r+0xa7e>
 511acbe:	4887      	ldr	r0, [pc, #540]	; (511aedc <_dtoa_r+0x2ec>)
 511acc0:	6018      	str	r0, [r3, #0]
 511acc2:	1e43      	subs	r3, r0, #1
 511acc4:	9301      	str	r3, [sp, #4]
 511acc6:	e7e2      	b.n	511ac8e <_dtoa_r+0x9e>
 511acc8:	a90f      	add	r1, sp, #60	; 0x3c
 511acca:	eeb0 0b48 	vmov.f64	d0, d8
 511acce:	aa0e      	add	r2, sp, #56	; 0x38
 511acd0:	4630      	mov	r0, r6
 511acd2:	f001 fa59 	bl	511c188 <__d2b>
 511acd6:	f3c4 510a 	ubfx	r1, r4, #20, #11
 511acda:	4605      	mov	r5, r0
 511acdc:	980e      	ldr	r0, [sp, #56]	; 0x38
 511acde:	2900      	cmp	r1, #0
 511ace0:	d046      	beq.n	511ad70 <_dtoa_r+0x180>
 511ace2:	ee18 4a90 	vmov	r4, s17
 511ace6:	ec53 2b18 	vmov	r2, r3, d8
 511acea:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
 511acee:	f3c4 0413 	ubfx	r4, r4, #0, #20
 511acf2:	f044 537f 	orr.w	r3, r4, #1069547520	; 0x3fc00000
 511acf6:	2400      	movs	r4, #0
 511acf8:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 511acfc:	ec43 2b16 	vmov	d6, r2, r3
 511ad00:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
 511ad04:	ed9f 5b6a 	vldr	d5, [pc, #424]	; 511aeb0 <_dtoa_r+0x2c0>
 511ad08:	ee36 7b47 	vsub.f64	d7, d6, d7
 511ad0c:	ed9f 6b6a 	vldr	d6, [pc, #424]	; 511aeb8 <_dtoa_r+0x2c8>
 511ad10:	ed9f 4b6b 	vldr	d4, [pc, #428]	; 511aec0 <_dtoa_r+0x2d0>
 511ad14:	940a      	str	r4, [sp, #40]	; 0x28
 511ad16:	ee07 6b05 	vmla.f64	d6, d7, d5
 511ad1a:	ee07 1a90 	vmov	s15, r1
 511ad1e:	eeb8 5be7 	vcvt.f64.s32	d5, s15
 511ad22:	eeb0 7b46 	vmov.f64	d7, d6
 511ad26:	ee05 7b04 	vmla.f64	d7, d5, d4
 511ad2a:	eeb5 7bc0 	vcmpe.f64	d7, #0.0
 511ad2e:	eefd 6bc7 	vcvt.s32.f64	s13, d7
 511ad32:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511ad36:	ee16 ba90 	vmov	fp, s13
 511ad3a:	d508      	bpl.n	511ad4e <_dtoa_r+0x15e>
 511ad3c:	eeb8 6be6 	vcvt.f64.s32	d6, s13
 511ad40:	eeb4 6b47 	vcmp.f64	d6, d7
 511ad44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511ad48:	bf18      	it	ne
 511ad4a:	f10b 3bff 	addne.w	fp, fp, #4294967295	; 0xffffffff
 511ad4e:	f1bb 0f16 	cmp.w	fp, #22
 511ad52:	d831      	bhi.n	511adb8 <_dtoa_r+0x1c8>
 511ad54:	4b62      	ldr	r3, [pc, #392]	; (511aee0 <_dtoa_r+0x2f0>)
 511ad56:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 511ad5a:	ed93 7b00 	vldr	d7, [r3]
 511ad5e:	eeb4 8bc7 	vcmpe.f64	d8, d7
 511ad62:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511ad66:	d501      	bpl.n	511ad6c <_dtoa_r+0x17c>
 511ad68:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 511ad6c:	2300      	movs	r3, #0
 511ad6e:	e024      	b.n	511adba <_dtoa_r+0x1ca>
 511ad70:	990f      	ldr	r1, [sp, #60]	; 0x3c
 511ad72:	4401      	add	r1, r0
 511ad74:	f201 4332 	addw	r3, r1, #1074	; 0x432
 511ad78:	2b20      	cmp	r3, #32
 511ad7a:	bfc9      	itett	gt
 511ad7c:	f1c3 0340 	rsbgt	r3, r3, #64	; 0x40
 511ad80:	f1c3 0320 	rsble	r3, r3, #32
 511ad84:	fa04 f303 	lslgt.w	r3, r4, r3
 511ad88:	f201 4412 	addwgt	r4, r1, #1042	; 0x412
 511ad8c:	bfd8      	it	le
 511ad8e:	fa08 f803 	lslle.w	r8, r8, r3
 511ad92:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
 511ad96:	bfc4      	itt	gt
 511ad98:	fa28 f804 	lsrgt.w	r8, r8, r4
 511ad9c:	ea43 0808 	orrgt.w	r8, r3, r8
 511ada0:	ee07 8a90 	vmov	s15, r8
 511ada4:	eeb8 7b67 	vcvt.f64.u32	d7, s15
 511ada8:	ee17 4a90 	vmov	r4, s15
 511adac:	ec53 2b17 	vmov	r2, r3, d7
 511adb0:	f1a4 73f8 	sub.w	r3, r4, #32505856	; 0x1f00000
 511adb4:	2401      	movs	r4, #1
 511adb6:	e7a1      	b.n	511acfc <_dtoa_r+0x10c>
 511adb8:	2301      	movs	r3, #1
 511adba:	930b      	str	r3, [sp, #44]	; 0x2c
 511adbc:	1a43      	subs	r3, r0, r1
 511adbe:	1e5a      	subs	r2, r3, #1
 511adc0:	9205      	str	r2, [sp, #20]
 511adc2:	bf49      	itett	mi
 511adc4:	f1c3 0301 	rsbmi	r3, r3, #1
 511adc8:	2300      	movpl	r3, #0
 511adca:	9304      	strmi	r3, [sp, #16]
 511adcc:	2300      	movmi	r3, #0
 511adce:	bf54      	ite	pl
 511add0:	9304      	strpl	r3, [sp, #16]
 511add2:	9305      	strmi	r3, [sp, #20]
 511add4:	f1bb 0f00 	cmp.w	fp, #0
 511add8:	db16      	blt.n	511ae08 <_dtoa_r+0x218>
 511adda:	9b05      	ldr	r3, [sp, #20]
 511addc:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
 511ade0:	445b      	add	r3, fp
 511ade2:	9305      	str	r3, [sp, #20]
 511ade4:	2300      	movs	r3, #0
 511ade6:	9a06      	ldr	r2, [sp, #24]
 511ade8:	2a09      	cmp	r2, #9
 511adea:	d847      	bhi.n	511ae7c <_dtoa_r+0x28c>
 511adec:	2a05      	cmp	r2, #5
 511adee:	bfc3      	ittte	gt
 511adf0:	3a04      	subgt	r2, #4
 511adf2:	9206      	strgt	r2, [sp, #24]
 511adf4:	2400      	movgt	r4, #0
 511adf6:	2401      	movle	r4, #1
 511adf8:	9a06      	ldr	r2, [sp, #24]
 511adfa:	3a02      	subs	r2, #2
 511adfc:	2a03      	cmp	r2, #3
 511adfe:	d848      	bhi.n	511ae92 <_dtoa_r+0x2a2>
 511ae00:	e8df f002 	tbb	[pc, r2]
 511ae04:	3a2c2e0b 	.word	0x3a2c2e0b
 511ae08:	9b04      	ldr	r3, [sp, #16]
 511ae0a:	2200      	movs	r2, #0
 511ae0c:	9209      	str	r2, [sp, #36]	; 0x24
 511ae0e:	eba3 030b 	sub.w	r3, r3, fp
 511ae12:	9304      	str	r3, [sp, #16]
 511ae14:	f1cb 0300 	rsb	r3, fp, #0
 511ae18:	e7e5      	b.n	511ade6 <_dtoa_r+0x1f6>
 511ae1a:	2200      	movs	r2, #0
 511ae1c:	9207      	str	r2, [sp, #28]
 511ae1e:	9a08      	ldr	r2, [sp, #32]
 511ae20:	2a00      	cmp	r2, #0
 511ae22:	dc39      	bgt.n	511ae98 <_dtoa_r+0x2a8>
 511ae24:	f04f 0a01 	mov.w	sl, #1
 511ae28:	f8cd a020 	str.w	sl, [sp, #32]
 511ae2c:	46d1      	mov	r9, sl
 511ae2e:	4652      	mov	r2, sl
 511ae30:	6a77      	ldr	r7, [r6, #36]	; 0x24
 511ae32:	2004      	movs	r0, #4
 511ae34:	2100      	movs	r1, #0
 511ae36:	6079      	str	r1, [r7, #4]
 511ae38:	f100 0c14 	add.w	ip, r0, #20
 511ae3c:	6879      	ldr	r1, [r7, #4]
 511ae3e:	4594      	cmp	ip, r2
 511ae40:	d92f      	bls.n	511aea2 <_dtoa_r+0x2b2>
 511ae42:	4630      	mov	r0, r6
 511ae44:	930d      	str	r3, [sp, #52]	; 0x34
 511ae46:	f000 fe73 	bl	511bb30 <_Balloc>
 511ae4a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 511ae4c:	4602      	mov	r2, r0
 511ae4e:	9001      	str	r0, [sp, #4]
 511ae50:	2800      	cmp	r0, #0
 511ae52:	d149      	bne.n	511aee8 <_dtoa_r+0x2f8>
 511ae54:	4b23      	ldr	r3, [pc, #140]	; (511aee4 <_dtoa_r+0x2f4>)
 511ae56:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 511ae5a:	e6e1      	b.n	511ac20 <_dtoa_r+0x30>
 511ae5c:	2201      	movs	r2, #1
 511ae5e:	e7dd      	b.n	511ae1c <_dtoa_r+0x22c>
 511ae60:	2200      	movs	r2, #0
 511ae62:	9207      	str	r2, [sp, #28]
 511ae64:	9a08      	ldr	r2, [sp, #32]
 511ae66:	eb0b 0a02 	add.w	sl, fp, r2
 511ae6a:	f10a 0901 	add.w	r9, sl, #1
 511ae6e:	464a      	mov	r2, r9
 511ae70:	2a01      	cmp	r2, #1
 511ae72:	bfb8      	it	lt
 511ae74:	2201      	movlt	r2, #1
 511ae76:	e7db      	b.n	511ae30 <_dtoa_r+0x240>
 511ae78:	2201      	movs	r2, #1
 511ae7a:	e7f2      	b.n	511ae62 <_dtoa_r+0x272>
 511ae7c:	2401      	movs	r4, #1
 511ae7e:	2200      	movs	r2, #0
 511ae80:	e9cd 2406 	strd	r2, r4, [sp, #24]
 511ae84:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
 511ae88:	2100      	movs	r1, #0
 511ae8a:	46d1      	mov	r9, sl
 511ae8c:	2212      	movs	r2, #18
 511ae8e:	9108      	str	r1, [sp, #32]
 511ae90:	e7ce      	b.n	511ae30 <_dtoa_r+0x240>
 511ae92:	2201      	movs	r2, #1
 511ae94:	9207      	str	r2, [sp, #28]
 511ae96:	e7f5      	b.n	511ae84 <_dtoa_r+0x294>
 511ae98:	f8dd a020 	ldr.w	sl, [sp, #32]
 511ae9c:	46d1      	mov	r9, sl
 511ae9e:	4652      	mov	r2, sl
 511aea0:	e7c6      	b.n	511ae30 <_dtoa_r+0x240>
 511aea2:	3101      	adds	r1, #1
 511aea4:	0040      	lsls	r0, r0, #1
 511aea6:	6079      	str	r1, [r7, #4]
 511aea8:	e7c6      	b.n	511ae38 <_dtoa_r+0x248>
 511aeaa:	bf00      	nop
 511aeac:	f3af 8000 	nop.w
 511aeb0:	636f4361 	.word	0x636f4361
 511aeb4:	3fd287a7 	.word	0x3fd287a7
 511aeb8:	8b60c8b3 	.word	0x8b60c8b3
 511aebc:	3fc68a28 	.word	0x3fc68a28
 511aec0:	509f79fb 	.word	0x509f79fb
 511aec4:	3fd34413 	.word	0x3fd34413
 511aec8:	0512de96 	.word	0x0512de96
 511aecc:	0512dead 	.word	0x0512dead
 511aed0:	7ff00000 	.word	0x7ff00000
 511aed4:	0512de92 	.word	0x0512de92
 511aed8:	0512de89 	.word	0x0512de89
 511aedc:	0512dd65 	.word	0x0512dd65
 511aee0:	0512e048 	.word	0x0512e048
 511aee4:	0512df2a 	.word	0x0512df2a
 511aee8:	6a72      	ldr	r2, [r6, #36]	; 0x24
 511aeea:	f1b9 0f0e 	cmp.w	r9, #14
 511aeee:	9901      	ldr	r1, [sp, #4]
 511aef0:	6011      	str	r1, [r2, #0]
 511aef2:	d86c      	bhi.n	511afce <_dtoa_r+0x3de>
 511aef4:	2c00      	cmp	r4, #0
 511aef6:	d06a      	beq.n	511afce <_dtoa_r+0x3de>
 511aef8:	f1bb 0f00 	cmp.w	fp, #0
 511aefc:	f340 80a0 	ble.w	511b040 <_dtoa_r+0x450>
 511af00:	49c1      	ldr	r1, [pc, #772]	; (511b208 <_dtoa_r+0x618>)
 511af02:	f00b 020f 	and.w	r2, fp, #15
 511af06:	f41b 7f80 	tst.w	fp, #256	; 0x100
 511af0a:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 511af0e:	ea4f 112b 	mov.w	r1, fp, asr #4
 511af12:	ed92 7b00 	vldr	d7, [r2]
 511af16:	f000 8087 	beq.w	511b028 <_dtoa_r+0x438>
 511af1a:	4abc      	ldr	r2, [pc, #752]	; (511b20c <_dtoa_r+0x61c>)
 511af1c:	f001 010f 	and.w	r1, r1, #15
 511af20:	ed92 6b08 	vldr	d6, [r2, #32]
 511af24:	2203      	movs	r2, #3
 511af26:	ee88 6b06 	vdiv.f64	d6, d8, d6
 511af2a:	ed8d 6b02 	vstr	d6, [sp, #8]
 511af2e:	48b7      	ldr	r0, [pc, #732]	; (511b20c <_dtoa_r+0x61c>)
 511af30:	2900      	cmp	r1, #0
 511af32:	d17b      	bne.n	511b02c <_dtoa_r+0x43c>
 511af34:	ed9d 6b02 	vldr	d6, [sp, #8]
 511af38:	ee86 7b07 	vdiv.f64	d7, d6, d7
 511af3c:	ed8d 7b02 	vstr	d7, [sp, #8]
 511af40:	990b      	ldr	r1, [sp, #44]	; 0x2c
 511af42:	2900      	cmp	r1, #0
 511af44:	f000 80a2 	beq.w	511b08c <_dtoa_r+0x49c>
 511af48:	ed9d 7b02 	vldr	d7, [sp, #8]
 511af4c:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
 511af50:	eeb4 7bc6 	vcmpe.f64	d7, d6
 511af54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511af58:	f140 8098 	bpl.w	511b08c <_dtoa_r+0x49c>
 511af5c:	f1b9 0f00 	cmp.w	r9, #0
 511af60:	f000 8094 	beq.w	511b08c <_dtoa_r+0x49c>
 511af64:	f1ba 0f00 	cmp.w	sl, #0
 511af68:	dd2f      	ble.n	511afca <_dtoa_r+0x3da>
 511af6a:	eeb2 6b04 	vmov.f64	d6, #36	; 0x41200000  10.0
 511af6e:	f10b 37ff 	add.w	r7, fp, #4294967295	; 0xffffffff
 511af72:	3201      	adds	r2, #1
 511af74:	4650      	mov	r0, sl
 511af76:	ee27 7b06 	vmul.f64	d7, d7, d6
 511af7a:	ed8d 7b02 	vstr	d7, [sp, #8]
 511af7e:	ee07 2a90 	vmov	s15, r2
 511af82:	ed9d 6b02 	vldr	d6, [sp, #8]
 511af86:	eeb1 5b0c 	vmov.f64	d5, #28	; 0x40e00000  7.0
 511af8a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 511af8e:	ee07 5b06 	vmla.f64	d5, d7, d6
 511af92:	ee15 4a90 	vmov	r4, s11
 511af96:	ec52 1b15 	vmov	r1, r2, d5
 511af9a:	f1a4 7250 	sub.w	r2, r4, #54525952	; 0x3400000
 511af9e:	2800      	cmp	r0, #0
 511afa0:	d177      	bne.n	511b092 <_dtoa_r+0x4a2>
 511afa2:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
 511afa6:	ee36 6b47 	vsub.f64	d6, d6, d7
 511afaa:	ec42 1b17 	vmov	d7, r1, r2
 511afae:	eeb4 6bc7 	vcmpe.f64	d6, d7
 511afb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511afb6:	f300 8264 	bgt.w	511b482 <_dtoa_r+0x892>
 511afba:	eeb1 7b47 	vneg.f64	d7, d7
 511afbe:	eeb4 6bc7 	vcmpe.f64	d6, d7
 511afc2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511afc6:	f100 8259 	bmi.w	511b47c <_dtoa_r+0x88c>
 511afca:	ed8d 8b02 	vstr	d8, [sp, #8]
 511afce:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 511afd0:	2a00      	cmp	r2, #0
 511afd2:	f2c0 811d 	blt.w	511b210 <_dtoa_r+0x620>
 511afd6:	f1bb 0f0e 	cmp.w	fp, #14
 511afda:	f300 8119 	bgt.w	511b210 <_dtoa_r+0x620>
 511afde:	4b8a      	ldr	r3, [pc, #552]	; (511b208 <_dtoa_r+0x618>)
 511afe0:	eb03 03cb 	add.w	r3, r3, fp, lsl #3
 511afe4:	ed93 6b00 	vldr	d6, [r3]
 511afe8:	9b08      	ldr	r3, [sp, #32]
 511afea:	2b00      	cmp	r3, #0
 511afec:	f280 80b7 	bge.w	511b15e <_dtoa_r+0x56e>
 511aff0:	f1b9 0f00 	cmp.w	r9, #0
 511aff4:	f300 80b3 	bgt.w	511b15e <_dtoa_r+0x56e>
 511aff8:	f040 8240 	bne.w	511b47c <_dtoa_r+0x88c>
 511affc:	eeb1 7b04 	vmov.f64	d7, #20	; 0x40a00000  5.0
 511b000:	464c      	mov	r4, r9
 511b002:	464f      	mov	r7, r9
 511b004:	ee26 6b07 	vmul.f64	d6, d6, d7
 511b008:	ed9d 7b02 	vldr	d7, [sp, #8]
 511b00c:	eeb4 6bc7 	vcmpe.f64	d6, d7
 511b010:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b014:	f280 8216 	bge.w	511b444 <_dtoa_r+0x854>
 511b018:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b01c:	2331      	movs	r3, #49	; 0x31
 511b01e:	f10b 0b01 	add.w	fp, fp, #1
 511b022:	f808 3b01 	strb.w	r3, [r8], #1
 511b026:	e212      	b.n	511b44e <_dtoa_r+0x85e>
 511b028:	2202      	movs	r2, #2
 511b02a:	e780      	b.n	511af2e <_dtoa_r+0x33e>
 511b02c:	07cc      	lsls	r4, r1, #31
 511b02e:	d504      	bpl.n	511b03a <_dtoa_r+0x44a>
 511b030:	ed90 6b00 	vldr	d6, [r0]
 511b034:	3201      	adds	r2, #1
 511b036:	ee27 7b06 	vmul.f64	d7, d7, d6
 511b03a:	1049      	asrs	r1, r1, #1
 511b03c:	3008      	adds	r0, #8
 511b03e:	e777      	b.n	511af30 <_dtoa_r+0x340>
 511b040:	d022      	beq.n	511b088 <_dtoa_r+0x498>
 511b042:	f1cb 0100 	rsb	r1, fp, #0
 511b046:	4a70      	ldr	r2, [pc, #448]	; (511b208 <_dtoa_r+0x618>)
 511b048:	f001 000f 	and.w	r0, r1, #15
 511b04c:	2400      	movs	r4, #0
 511b04e:	1109      	asrs	r1, r1, #4
 511b050:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 511b054:	486d      	ldr	r0, [pc, #436]	; (511b20c <_dtoa_r+0x61c>)
 511b056:	ed92 7b00 	vldr	d7, [r2]
 511b05a:	2202      	movs	r2, #2
 511b05c:	ee28 7b07 	vmul.f64	d7, d8, d7
 511b060:	ed8d 7b02 	vstr	d7, [sp, #8]
 511b064:	b929      	cbnz	r1, 511b072 <_dtoa_r+0x482>
 511b066:	2c00      	cmp	r4, #0
 511b068:	f43f af6a 	beq.w	511af40 <_dtoa_r+0x350>
 511b06c:	ed8d 7b02 	vstr	d7, [sp, #8]
 511b070:	e766      	b.n	511af40 <_dtoa_r+0x350>
 511b072:	07cf      	lsls	r7, r1, #31
 511b074:	d505      	bpl.n	511b082 <_dtoa_r+0x492>
 511b076:	ed90 6b00 	vldr	d6, [r0]
 511b07a:	3201      	adds	r2, #1
 511b07c:	2401      	movs	r4, #1
 511b07e:	ee27 7b06 	vmul.f64	d7, d7, d6
 511b082:	1049      	asrs	r1, r1, #1
 511b084:	3008      	adds	r0, #8
 511b086:	e7ed      	b.n	511b064 <_dtoa_r+0x474>
 511b088:	2202      	movs	r2, #2
 511b08a:	e759      	b.n	511af40 <_dtoa_r+0x350>
 511b08c:	465f      	mov	r7, fp
 511b08e:	4648      	mov	r0, r9
 511b090:	e775      	b.n	511af7e <_dtoa_r+0x38e>
 511b092:	ec42 1b17 	vmov	d7, r1, r2
 511b096:	4a5c      	ldr	r2, [pc, #368]	; (511b208 <_dtoa_r+0x618>)
 511b098:	eb02 02c0 	add.w	r2, r2, r0, lsl #3
 511b09c:	ed12 4b02 	vldr	d4, [r2, #-8]
 511b0a0:	9a01      	ldr	r2, [sp, #4]
 511b0a2:	1814      	adds	r4, r2, r0
 511b0a4:	9a07      	ldr	r2, [sp, #28]
 511b0a6:	b352      	cbz	r2, 511b0fe <_dtoa_r+0x50e>
 511b0a8:	eeb6 3b00 	vmov.f64	d3, #96	; 0x3f000000  0.5
 511b0ac:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b0b0:	eeb7 2b00 	vmov.f64	d2, #112	; 0x3f800000  1.0
 511b0b4:	ee83 5b04 	vdiv.f64	d5, d3, d4
 511b0b8:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
 511b0bc:	ee35 7b47 	vsub.f64	d7, d5, d7
 511b0c0:	eefd 4bc6 	vcvt.s32.f64	s9, d6
 511b0c4:	eeb8 5be4 	vcvt.f64.s32	d5, s9
 511b0c8:	ee14 2a90 	vmov	r2, s9
 511b0cc:	ee36 6b45 	vsub.f64	d6, d6, d5
 511b0d0:	3230      	adds	r2, #48	; 0x30
 511b0d2:	f808 2b01 	strb.w	r2, [r8], #1
 511b0d6:	eeb4 6bc7 	vcmpe.f64	d6, d7
 511b0da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b0de:	d439      	bmi.n	511b154 <_dtoa_r+0x564>
 511b0e0:	ee32 5b46 	vsub.f64	d5, d2, d6
 511b0e4:	eeb4 5bc7 	vcmpe.f64	d5, d7
 511b0e8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b0ec:	d472      	bmi.n	511b1d4 <_dtoa_r+0x5e4>
 511b0ee:	45a0      	cmp	r8, r4
 511b0f0:	f43f af6b 	beq.w	511afca <_dtoa_r+0x3da>
 511b0f4:	ee27 7b03 	vmul.f64	d7, d7, d3
 511b0f8:	ee26 6b03 	vmul.f64	d6, d6, d3
 511b0fc:	e7e0      	b.n	511b0c0 <_dtoa_r+0x4d0>
 511b0fe:	ee27 7b04 	vmul.f64	d7, d7, d4
 511b102:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b106:	4621      	mov	r1, r4
 511b108:	eeb2 3b04 	vmov.f64	d3, #36	; 0x41200000  10.0
 511b10c:	eefd 4bc6 	vcvt.s32.f64	s9, d6
 511b110:	ee14 2a90 	vmov	r2, s9
 511b114:	eeb8 5be4 	vcvt.f64.s32	d5, s9
 511b118:	3230      	adds	r2, #48	; 0x30
 511b11a:	f808 2b01 	strb.w	r2, [r8], #1
 511b11e:	ee36 6b45 	vsub.f64	d6, d6, d5
 511b122:	45a0      	cmp	r8, r4
 511b124:	d118      	bne.n	511b158 <_dtoa_r+0x568>
 511b126:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
 511b12a:	ee37 4b05 	vadd.f64	d4, d7, d5
 511b12e:	eeb4 6bc4 	vcmpe.f64	d6, d4
 511b132:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b136:	dc4d      	bgt.n	511b1d4 <_dtoa_r+0x5e4>
 511b138:	ee35 7b47 	vsub.f64	d7, d5, d7
 511b13c:	eeb4 6bc7 	vcmpe.f64	d6, d7
 511b140:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b144:	f57f af41 	bpl.w	511afca <_dtoa_r+0x3da>
 511b148:	4688      	mov	r8, r1
 511b14a:	3901      	subs	r1, #1
 511b14c:	f818 3c01 	ldrb.w	r3, [r8, #-1]
 511b150:	2b30      	cmp	r3, #48	; 0x30
 511b152:	d0f9      	beq.n	511b148 <_dtoa_r+0x558>
 511b154:	46bb      	mov	fp, r7
 511b156:	e02a      	b.n	511b1ae <_dtoa_r+0x5be>
 511b158:	ee26 6b03 	vmul.f64	d6, d6, d3
 511b15c:	e7d6      	b.n	511b10c <_dtoa_r+0x51c>
 511b15e:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b162:	eeb2 4b04 	vmov.f64	d4, #36	; 0x41200000  10.0
 511b166:	ed9d 7b02 	vldr	d7, [sp, #8]
 511b16a:	ee87 5b06 	vdiv.f64	d5, d7, d6
 511b16e:	eebd 5bc5 	vcvt.s32.f64	s10, d5
 511b172:	ee15 3a10 	vmov	r3, s10
 511b176:	eeb8 3bc5 	vcvt.f64.s32	d3, s10
 511b17a:	3330      	adds	r3, #48	; 0x30
 511b17c:	f808 3b01 	strb.w	r3, [r8], #1
 511b180:	9b01      	ldr	r3, [sp, #4]
 511b182:	ee03 7b46 	vmls.f64	d7, d3, d6
 511b186:	eba8 0303 	sub.w	r3, r8, r3
 511b18a:	4599      	cmp	r9, r3
 511b18c:	d133      	bne.n	511b1f6 <_dtoa_r+0x606>
 511b18e:	ee37 7b07 	vadd.f64	d7, d7, d7
 511b192:	eeb4 7bc6 	vcmpe.f64	d7, d6
 511b196:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b19a:	dc1a      	bgt.n	511b1d2 <_dtoa_r+0x5e2>
 511b19c:	eeb4 7b46 	vcmp.f64	d7, d6
 511b1a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b1a4:	d103      	bne.n	511b1ae <_dtoa_r+0x5be>
 511b1a6:	ee15 3a10 	vmov	r3, s10
 511b1aa:	07d9      	lsls	r1, r3, #31
 511b1ac:	d411      	bmi.n	511b1d2 <_dtoa_r+0x5e2>
 511b1ae:	4629      	mov	r1, r5
 511b1b0:	4630      	mov	r0, r6
 511b1b2:	f000 fcfd 	bl	511bbb0 <_Bfree>
 511b1b6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 511b1b8:	2300      	movs	r3, #0
 511b1ba:	f888 3000 	strb.w	r3, [r8]
 511b1be:	f10b 0301 	add.w	r3, fp, #1
 511b1c2:	6013      	str	r3, [r2, #0]
 511b1c4:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 511b1c6:	2b00      	cmp	r3, #0
 511b1c8:	f43f ad61 	beq.w	511ac8e <_dtoa_r+0x9e>
 511b1cc:	f8c3 8000 	str.w	r8, [r3]
 511b1d0:	e55d      	b.n	511ac8e <_dtoa_r+0x9e>
 511b1d2:	465f      	mov	r7, fp
 511b1d4:	4643      	mov	r3, r8
 511b1d6:	4698      	mov	r8, r3
 511b1d8:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 511b1dc:	2a39      	cmp	r2, #57	; 0x39
 511b1de:	d106      	bne.n	511b1ee <_dtoa_r+0x5fe>
 511b1e0:	9a01      	ldr	r2, [sp, #4]
 511b1e2:	429a      	cmp	r2, r3
 511b1e4:	d1f7      	bne.n	511b1d6 <_dtoa_r+0x5e6>
 511b1e6:	9901      	ldr	r1, [sp, #4]
 511b1e8:	3701      	adds	r7, #1
 511b1ea:	2230      	movs	r2, #48	; 0x30
 511b1ec:	700a      	strb	r2, [r1, #0]
 511b1ee:	781a      	ldrb	r2, [r3, #0]
 511b1f0:	3201      	adds	r2, #1
 511b1f2:	701a      	strb	r2, [r3, #0]
 511b1f4:	e7ae      	b.n	511b154 <_dtoa_r+0x564>
 511b1f6:	ee27 7b04 	vmul.f64	d7, d7, d4
 511b1fa:	eeb5 7b40 	vcmp.f64	d7, #0.0
 511b1fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 511b202:	d1b2      	bne.n	511b16a <_dtoa_r+0x57a>
 511b204:	e7d3      	b.n	511b1ae <_dtoa_r+0x5be>
 511b206:	bf00      	nop
 511b208:	0512e048 	.word	0x0512e048
 511b20c:	0512e020 	.word	0x0512e020
 511b210:	9907      	ldr	r1, [sp, #28]
 511b212:	2900      	cmp	r1, #0
 511b214:	f000 80d1 	beq.w	511b3ba <_dtoa_r+0x7ca>
 511b218:	9906      	ldr	r1, [sp, #24]
 511b21a:	2901      	cmp	r1, #1
 511b21c:	f300 80b4 	bgt.w	511b388 <_dtoa_r+0x798>
 511b220:	990a      	ldr	r1, [sp, #40]	; 0x28
 511b222:	2900      	cmp	r1, #0
 511b224:	f000 80ac 	beq.w	511b380 <_dtoa_r+0x790>
 511b228:	f202 4233 	addw	r2, r2, #1075	; 0x433
 511b22c:	f8dd 8010 	ldr.w	r8, [sp, #16]
 511b230:	461c      	mov	r4, r3
 511b232:	930a      	str	r3, [sp, #40]	; 0x28
 511b234:	2101      	movs	r1, #1
 511b236:	9b04      	ldr	r3, [sp, #16]
 511b238:	4630      	mov	r0, r6
 511b23a:	4413      	add	r3, r2
 511b23c:	9304      	str	r3, [sp, #16]
 511b23e:	9b05      	ldr	r3, [sp, #20]
 511b240:	4413      	add	r3, r2
 511b242:	9305      	str	r3, [sp, #20]
 511b244:	f000 fd6c 	bl	511bd20 <__i2b>
 511b248:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 511b24a:	4607      	mov	r7, r0
 511b24c:	f1b8 0f00 	cmp.w	r8, #0
 511b250:	dd0d      	ble.n	511b26e <_dtoa_r+0x67e>
 511b252:	9a05      	ldr	r2, [sp, #20]
 511b254:	2a00      	cmp	r2, #0
 511b256:	dd0a      	ble.n	511b26e <_dtoa_r+0x67e>
 511b258:	4542      	cmp	r2, r8
 511b25a:	9904      	ldr	r1, [sp, #16]
 511b25c:	bfa8      	it	ge
 511b25e:	4642      	movge	r2, r8
 511b260:	1a89      	subs	r1, r1, r2
 511b262:	9104      	str	r1, [sp, #16]
 511b264:	9905      	ldr	r1, [sp, #20]
 511b266:	eba8 0802 	sub.w	r8, r8, r2
 511b26a:	1a8a      	subs	r2, r1, r2
 511b26c:	9205      	str	r2, [sp, #20]
 511b26e:	b303      	cbz	r3, 511b2b2 <_dtoa_r+0x6c2>
 511b270:	9a07      	ldr	r2, [sp, #28]
 511b272:	2a00      	cmp	r2, #0
 511b274:	f000 80a6 	beq.w	511b3c4 <_dtoa_r+0x7d4>
 511b278:	2c00      	cmp	r4, #0
 511b27a:	dd13      	ble.n	511b2a4 <_dtoa_r+0x6b4>
 511b27c:	4639      	mov	r1, r7
 511b27e:	4622      	mov	r2, r4
 511b280:	4630      	mov	r0, r6
 511b282:	930d      	str	r3, [sp, #52]	; 0x34
 511b284:	f000 fe0c 	bl	511bea0 <__pow5mult>
 511b288:	462a      	mov	r2, r5
 511b28a:	4601      	mov	r1, r0
 511b28c:	4607      	mov	r7, r0
 511b28e:	4630      	mov	r0, r6
 511b290:	f000 fd5c 	bl	511bd4c <__multiply>
 511b294:	4629      	mov	r1, r5
 511b296:	900a      	str	r0, [sp, #40]	; 0x28
 511b298:	4630      	mov	r0, r6
 511b29a:	f000 fc89 	bl	511bbb0 <_Bfree>
 511b29e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 511b2a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 511b2a2:	4615      	mov	r5, r2
 511b2a4:	1b1a      	subs	r2, r3, r4
 511b2a6:	d004      	beq.n	511b2b2 <_dtoa_r+0x6c2>
 511b2a8:	4629      	mov	r1, r5
 511b2aa:	4630      	mov	r0, r6
 511b2ac:	f000 fdf8 	bl	511bea0 <__pow5mult>
 511b2b0:	4605      	mov	r5, r0
 511b2b2:	2101      	movs	r1, #1
 511b2b4:	4630      	mov	r0, r6
 511b2b6:	f000 fd33 	bl	511bd20 <__i2b>
 511b2ba:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511b2bc:	4604      	mov	r4, r0
 511b2be:	2b00      	cmp	r3, #0
 511b2c0:	f340 8082 	ble.w	511b3c8 <_dtoa_r+0x7d8>
 511b2c4:	461a      	mov	r2, r3
 511b2c6:	4601      	mov	r1, r0
 511b2c8:	4630      	mov	r0, r6
 511b2ca:	f000 fde9 	bl	511bea0 <__pow5mult>
 511b2ce:	9b06      	ldr	r3, [sp, #24]
 511b2d0:	4604      	mov	r4, r0
 511b2d2:	2b01      	cmp	r3, #1
 511b2d4:	dd7b      	ble.n	511b3ce <_dtoa_r+0x7de>
 511b2d6:	2300      	movs	r3, #0
 511b2d8:	930a      	str	r3, [sp, #40]	; 0x28
 511b2da:	6922      	ldr	r2, [r4, #16]
 511b2dc:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 511b2e0:	6910      	ldr	r0, [r2, #16]
 511b2e2:	f000 fccf 	bl	511bc84 <__hi0bits>
 511b2e6:	f1c0 0020 	rsb	r0, r0, #32
 511b2ea:	9b05      	ldr	r3, [sp, #20]
 511b2ec:	4418      	add	r0, r3
 511b2ee:	f010 001f 	ands.w	r0, r0, #31
 511b2f2:	f000 808d 	beq.w	511b410 <_dtoa_r+0x820>
 511b2f6:	f1c0 0220 	rsb	r2, r0, #32
 511b2fa:	2a04      	cmp	r2, #4
 511b2fc:	f340 8086 	ble.w	511b40c <_dtoa_r+0x81c>
 511b300:	f1c0 001c 	rsb	r0, r0, #28
 511b304:	9b04      	ldr	r3, [sp, #16]
 511b306:	4480      	add	r8, r0
 511b308:	4403      	add	r3, r0
 511b30a:	9304      	str	r3, [sp, #16]
 511b30c:	9b05      	ldr	r3, [sp, #20]
 511b30e:	4403      	add	r3, r0
 511b310:	9305      	str	r3, [sp, #20]
 511b312:	9b04      	ldr	r3, [sp, #16]
 511b314:	2b00      	cmp	r3, #0
 511b316:	dd05      	ble.n	511b324 <_dtoa_r+0x734>
 511b318:	4629      	mov	r1, r5
 511b31a:	461a      	mov	r2, r3
 511b31c:	4630      	mov	r0, r6
 511b31e:	f000 fe19 	bl	511bf54 <__lshift>
 511b322:	4605      	mov	r5, r0
 511b324:	9b05      	ldr	r3, [sp, #20]
 511b326:	2b00      	cmp	r3, #0
 511b328:	dd05      	ble.n	511b336 <_dtoa_r+0x746>
 511b32a:	4621      	mov	r1, r4
 511b32c:	461a      	mov	r2, r3
 511b32e:	4630      	mov	r0, r6
 511b330:	f000 fe10 	bl	511bf54 <__lshift>
 511b334:	4604      	mov	r4, r0
 511b336:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 511b338:	2b00      	cmp	r3, #0
 511b33a:	d06b      	beq.n	511b414 <_dtoa_r+0x824>
 511b33c:	4621      	mov	r1, r4
 511b33e:	4628      	mov	r0, r5
 511b340:	f000 fe78 	bl	511c034 <__mcmp>
 511b344:	2800      	cmp	r0, #0
 511b346:	da65      	bge.n	511b414 <_dtoa_r+0x824>
 511b348:	2300      	movs	r3, #0
 511b34a:	4629      	mov	r1, r5
 511b34c:	220a      	movs	r2, #10
 511b34e:	4630      	mov	r0, r6
 511b350:	f000 fc50 	bl	511bbf4 <__multadd>
 511b354:	9b07      	ldr	r3, [sp, #28]
 511b356:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 511b35a:	4605      	mov	r5, r0
 511b35c:	2b00      	cmp	r3, #0
 511b35e:	f000 8190 	beq.w	511b682 <_dtoa_r+0xa92>
 511b362:	4639      	mov	r1, r7
 511b364:	2300      	movs	r3, #0
 511b366:	220a      	movs	r2, #10
 511b368:	4630      	mov	r0, r6
 511b36a:	f000 fc43 	bl	511bbf4 <__multadd>
 511b36e:	f1ba 0f00 	cmp.w	sl, #0
 511b372:	4607      	mov	r7, r0
 511b374:	f300 808e 	bgt.w	511b494 <_dtoa_r+0x8a4>
 511b378:	9b06      	ldr	r3, [sp, #24]
 511b37a:	2b02      	cmp	r3, #2
 511b37c:	dc51      	bgt.n	511b422 <_dtoa_r+0x832>
 511b37e:	e089      	b.n	511b494 <_dtoa_r+0x8a4>
 511b380:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 511b382:	f1c2 0236 	rsb	r2, r2, #54	; 0x36
 511b386:	e751      	b.n	511b22c <_dtoa_r+0x63c>
 511b388:	f109 34ff 	add.w	r4, r9, #4294967295	; 0xffffffff
 511b38c:	42a3      	cmp	r3, r4
 511b38e:	bfb7      	itett	lt
 511b390:	1ae3      	sublt	r3, r4, r3
 511b392:	1b1c      	subge	r4, r3, r4
 511b394:	9a09      	ldrlt	r2, [sp, #36]	; 0x24
 511b396:	18d2      	addlt	r2, r2, r3
 511b398:	bfbf      	itttt	lt
 511b39a:	4613      	movlt	r3, r2
 511b39c:	9309      	strlt	r3, [sp, #36]	; 0x24
 511b39e:	4623      	movlt	r3, r4
 511b3a0:	2400      	movlt	r4, #0
 511b3a2:	f1b9 0f00 	cmp.w	r9, #0
 511b3a6:	bfab      	itete	ge
 511b3a8:	464a      	movge	r2, r9
 511b3aa:	9a04      	ldrlt	r2, [sp, #16]
 511b3ac:	f8dd 8010 	ldrge.w	r8, [sp, #16]
 511b3b0:	eba2 0809 	sublt.w	r8, r2, r9
 511b3b4:	bfb8      	it	lt
 511b3b6:	2200      	movlt	r2, #0
 511b3b8:	e73b      	b.n	511b232 <_dtoa_r+0x642>
 511b3ba:	f8dd 8010 	ldr.w	r8, [sp, #16]
 511b3be:	461c      	mov	r4, r3
 511b3c0:	9f07      	ldr	r7, [sp, #28]
 511b3c2:	e743      	b.n	511b24c <_dtoa_r+0x65c>
 511b3c4:	461a      	mov	r2, r3
 511b3c6:	e76f      	b.n	511b2a8 <_dtoa_r+0x6b8>
 511b3c8:	9b06      	ldr	r3, [sp, #24]
 511b3ca:	2b01      	cmp	r3, #1
 511b3cc:	dc18      	bgt.n	511b400 <_dtoa_r+0x810>
 511b3ce:	9b02      	ldr	r3, [sp, #8]
 511b3d0:	b9b3      	cbnz	r3, 511b400 <_dtoa_r+0x810>
 511b3d2:	9b03      	ldr	r3, [sp, #12]
 511b3d4:	f3c3 0213 	ubfx	r2, r3, #0, #20
 511b3d8:	b9a2      	cbnz	r2, 511b404 <_dtoa_r+0x814>
 511b3da:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 511b3de:	0d12      	lsrs	r2, r2, #20
 511b3e0:	0512      	lsls	r2, r2, #20
 511b3e2:	b18a      	cbz	r2, 511b408 <_dtoa_r+0x818>
 511b3e4:	9b04      	ldr	r3, [sp, #16]
 511b3e6:	3301      	adds	r3, #1
 511b3e8:	9304      	str	r3, [sp, #16]
 511b3ea:	9b05      	ldr	r3, [sp, #20]
 511b3ec:	3301      	adds	r3, #1
 511b3ee:	9305      	str	r3, [sp, #20]
 511b3f0:	2301      	movs	r3, #1
 511b3f2:	930a      	str	r3, [sp, #40]	; 0x28
 511b3f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511b3f6:	2b00      	cmp	r3, #0
 511b3f8:	f47f af6f 	bne.w	511b2da <_dtoa_r+0x6ea>
 511b3fc:	2001      	movs	r0, #1
 511b3fe:	e774      	b.n	511b2ea <_dtoa_r+0x6fa>
 511b400:	2300      	movs	r3, #0
 511b402:	e7f6      	b.n	511b3f2 <_dtoa_r+0x802>
 511b404:	9b02      	ldr	r3, [sp, #8]
 511b406:	e7f4      	b.n	511b3f2 <_dtoa_r+0x802>
 511b408:	920a      	str	r2, [sp, #40]	; 0x28
 511b40a:	e7f3      	b.n	511b3f4 <_dtoa_r+0x804>
 511b40c:	d081      	beq.n	511b312 <_dtoa_r+0x722>
 511b40e:	4610      	mov	r0, r2
 511b410:	301c      	adds	r0, #28
 511b412:	e777      	b.n	511b304 <_dtoa_r+0x714>
 511b414:	f1b9 0f00 	cmp.w	r9, #0
 511b418:	dc37      	bgt.n	511b48a <_dtoa_r+0x89a>
 511b41a:	9b06      	ldr	r3, [sp, #24]
 511b41c:	2b02      	cmp	r3, #2
 511b41e:	dd34      	ble.n	511b48a <_dtoa_r+0x89a>
 511b420:	46ca      	mov	sl, r9
 511b422:	f1ba 0f00 	cmp.w	sl, #0
 511b426:	d10d      	bne.n	511b444 <_dtoa_r+0x854>
 511b428:	4621      	mov	r1, r4
 511b42a:	4653      	mov	r3, sl
 511b42c:	2205      	movs	r2, #5
 511b42e:	4630      	mov	r0, r6
 511b430:	f000 fbe0 	bl	511bbf4 <__multadd>
 511b434:	4601      	mov	r1, r0
 511b436:	4604      	mov	r4, r0
 511b438:	4628      	mov	r0, r5
 511b43a:	f000 fdfb 	bl	511c034 <__mcmp>
 511b43e:	2800      	cmp	r0, #0
 511b440:	f73f adea 	bgt.w	511b018 <_dtoa_r+0x428>
 511b444:	9b08      	ldr	r3, [sp, #32]
 511b446:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b44a:	ea6f 0b03 	mvn.w	fp, r3
 511b44e:	f04f 0900 	mov.w	r9, #0
 511b452:	4621      	mov	r1, r4
 511b454:	4630      	mov	r0, r6
 511b456:	f000 fbab 	bl	511bbb0 <_Bfree>
 511b45a:	2f00      	cmp	r7, #0
 511b45c:	f43f aea7 	beq.w	511b1ae <_dtoa_r+0x5be>
 511b460:	f1b9 0f00 	cmp.w	r9, #0
 511b464:	d005      	beq.n	511b472 <_dtoa_r+0x882>
 511b466:	45b9      	cmp	r9, r7
 511b468:	d003      	beq.n	511b472 <_dtoa_r+0x882>
 511b46a:	4649      	mov	r1, r9
 511b46c:	4630      	mov	r0, r6
 511b46e:	f000 fb9f 	bl	511bbb0 <_Bfree>
 511b472:	4639      	mov	r1, r7
 511b474:	4630      	mov	r0, r6
 511b476:	f000 fb9b 	bl	511bbb0 <_Bfree>
 511b47a:	e698      	b.n	511b1ae <_dtoa_r+0x5be>
 511b47c:	2400      	movs	r4, #0
 511b47e:	4627      	mov	r7, r4
 511b480:	e7e0      	b.n	511b444 <_dtoa_r+0x854>
 511b482:	46bb      	mov	fp, r7
 511b484:	4604      	mov	r4, r0
 511b486:	4607      	mov	r7, r0
 511b488:	e5c6      	b.n	511b018 <_dtoa_r+0x428>
 511b48a:	9b07      	ldr	r3, [sp, #28]
 511b48c:	46ca      	mov	sl, r9
 511b48e:	2b00      	cmp	r3, #0
 511b490:	f000 80fe 	beq.w	511b690 <_dtoa_r+0xaa0>
 511b494:	f1b8 0f00 	cmp.w	r8, #0
 511b498:	dd05      	ble.n	511b4a6 <_dtoa_r+0x8b6>
 511b49a:	4639      	mov	r1, r7
 511b49c:	4642      	mov	r2, r8
 511b49e:	4630      	mov	r0, r6
 511b4a0:	f000 fd58 	bl	511bf54 <__lshift>
 511b4a4:	4607      	mov	r7, r0
 511b4a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 511b4a8:	2b00      	cmp	r3, #0
 511b4aa:	d05d      	beq.n	511b568 <_dtoa_r+0x978>
 511b4ac:	6879      	ldr	r1, [r7, #4]
 511b4ae:	4630      	mov	r0, r6
 511b4b0:	f000 fb3e 	bl	511bb30 <_Balloc>
 511b4b4:	4680      	mov	r8, r0
 511b4b6:	b928      	cbnz	r0, 511b4c4 <_dtoa_r+0x8d4>
 511b4b8:	4b81      	ldr	r3, [pc, #516]	; (511b6c0 <_dtoa_r+0xad0>)
 511b4ba:	4602      	mov	r2, r0
 511b4bc:	f240 21ea 	movw	r1, #746	; 0x2ea
 511b4c0:	f7ff bbae 	b.w	511ac20 <_dtoa_r+0x30>
 511b4c4:	693a      	ldr	r2, [r7, #16]
 511b4c6:	f107 010c 	add.w	r1, r7, #12
 511b4ca:	300c      	adds	r0, #12
 511b4cc:	3202      	adds	r2, #2
 511b4ce:	0092      	lsls	r2, r2, #2
 511b4d0:	f7fe fbe6 	bl	5119ca0 <memcpy>
 511b4d4:	2201      	movs	r2, #1
 511b4d6:	4641      	mov	r1, r8
 511b4d8:	4630      	mov	r0, r6
 511b4da:	f000 fd3b 	bl	511bf54 <__lshift>
 511b4de:	9b01      	ldr	r3, [sp, #4]
 511b4e0:	46b9      	mov	r9, r7
 511b4e2:	4607      	mov	r7, r0
 511b4e4:	3301      	adds	r3, #1
 511b4e6:	9304      	str	r3, [sp, #16]
 511b4e8:	9b01      	ldr	r3, [sp, #4]
 511b4ea:	4453      	add	r3, sl
 511b4ec:	9308      	str	r3, [sp, #32]
 511b4ee:	9b02      	ldr	r3, [sp, #8]
 511b4f0:	f003 0301 	and.w	r3, r3, #1
 511b4f4:	9307      	str	r3, [sp, #28]
 511b4f6:	9b04      	ldr	r3, [sp, #16]
 511b4f8:	4621      	mov	r1, r4
 511b4fa:	4628      	mov	r0, r5
 511b4fc:	3b01      	subs	r3, #1
 511b4fe:	9302      	str	r3, [sp, #8]
 511b500:	f7ff fadc 	bl	511aabc <quorem>
 511b504:	4649      	mov	r1, r9
 511b506:	4603      	mov	r3, r0
 511b508:	9005      	str	r0, [sp, #20]
 511b50a:	4628      	mov	r0, r5
 511b50c:	3330      	adds	r3, #48	; 0x30
 511b50e:	9309      	str	r3, [sp, #36]	; 0x24
 511b510:	f000 fd90 	bl	511c034 <__mcmp>
 511b514:	463a      	mov	r2, r7
 511b516:	4682      	mov	sl, r0
 511b518:	4621      	mov	r1, r4
 511b51a:	4630      	mov	r0, r6
 511b51c:	f000 fda6 	bl	511c06c <__mdiff>
 511b520:	68c2      	ldr	r2, [r0, #12]
 511b522:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511b524:	4680      	mov	r8, r0
 511b526:	bb0a      	cbnz	r2, 511b56c <_dtoa_r+0x97c>
 511b528:	4601      	mov	r1, r0
 511b52a:	4628      	mov	r0, r5
 511b52c:	f000 fd82 	bl	511c034 <__mcmp>
 511b530:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511b532:	4602      	mov	r2, r0
 511b534:	4641      	mov	r1, r8
 511b536:	4630      	mov	r0, r6
 511b538:	e9cd 3209 	strd	r3, r2, [sp, #36]	; 0x24
 511b53c:	f000 fb38 	bl	511bbb0 <_Bfree>
 511b540:	9b06      	ldr	r3, [sp, #24]
 511b542:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 511b544:	f8dd 8010 	ldr.w	r8, [sp, #16]
 511b548:	ea43 0102 	orr.w	r1, r3, r2
 511b54c:	9b07      	ldr	r3, [sp, #28]
 511b54e:	430b      	orrs	r3, r1
 511b550:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511b552:	d10d      	bne.n	511b570 <_dtoa_r+0x980>
 511b554:	2b39      	cmp	r3, #57	; 0x39
 511b556:	d029      	beq.n	511b5ac <_dtoa_r+0x9bc>
 511b558:	f1ba 0f00 	cmp.w	sl, #0
 511b55c:	dd01      	ble.n	511b562 <_dtoa_r+0x972>
 511b55e:	9b05      	ldr	r3, [sp, #20]
 511b560:	3331      	adds	r3, #49	; 0x31
 511b562:	9a02      	ldr	r2, [sp, #8]
 511b564:	7013      	strb	r3, [r2, #0]
 511b566:	e774      	b.n	511b452 <_dtoa_r+0x862>
 511b568:	4638      	mov	r0, r7
 511b56a:	e7b8      	b.n	511b4de <_dtoa_r+0x8ee>
 511b56c:	2201      	movs	r2, #1
 511b56e:	e7e1      	b.n	511b534 <_dtoa_r+0x944>
 511b570:	f1ba 0f00 	cmp.w	sl, #0
 511b574:	db06      	blt.n	511b584 <_dtoa_r+0x994>
 511b576:	9906      	ldr	r1, [sp, #24]
 511b578:	ea41 0a0a 	orr.w	sl, r1, sl
 511b57c:	9907      	ldr	r1, [sp, #28]
 511b57e:	ea5a 0101 	orrs.w	r1, sl, r1
 511b582:	d120      	bne.n	511b5c6 <_dtoa_r+0x9d6>
 511b584:	2a00      	cmp	r2, #0
 511b586:	ddec      	ble.n	511b562 <_dtoa_r+0x972>
 511b588:	4629      	mov	r1, r5
 511b58a:	2201      	movs	r2, #1
 511b58c:	4630      	mov	r0, r6
 511b58e:	9304      	str	r3, [sp, #16]
 511b590:	f000 fce0 	bl	511bf54 <__lshift>
 511b594:	4621      	mov	r1, r4
 511b596:	4605      	mov	r5, r0
 511b598:	f000 fd4c 	bl	511c034 <__mcmp>
 511b59c:	9b04      	ldr	r3, [sp, #16]
 511b59e:	2800      	cmp	r0, #0
 511b5a0:	dc02      	bgt.n	511b5a8 <_dtoa_r+0x9b8>
 511b5a2:	d1de      	bne.n	511b562 <_dtoa_r+0x972>
 511b5a4:	07da      	lsls	r2, r3, #31
 511b5a6:	d5dc      	bpl.n	511b562 <_dtoa_r+0x972>
 511b5a8:	2b39      	cmp	r3, #57	; 0x39
 511b5aa:	d1d8      	bne.n	511b55e <_dtoa_r+0x96e>
 511b5ac:	9a02      	ldr	r2, [sp, #8]
 511b5ae:	2339      	movs	r3, #57	; 0x39
 511b5b0:	7013      	strb	r3, [r2, #0]
 511b5b2:	4643      	mov	r3, r8
 511b5b4:	4698      	mov	r8, r3
 511b5b6:	3b01      	subs	r3, #1
 511b5b8:	f818 2c01 	ldrb.w	r2, [r8, #-1]
 511b5bc:	2a39      	cmp	r2, #57	; 0x39
 511b5be:	d04f      	beq.n	511b660 <_dtoa_r+0xa70>
 511b5c0:	3201      	adds	r2, #1
 511b5c2:	701a      	strb	r2, [r3, #0]
 511b5c4:	e745      	b.n	511b452 <_dtoa_r+0x862>
 511b5c6:	2a00      	cmp	r2, #0
 511b5c8:	dd03      	ble.n	511b5d2 <_dtoa_r+0x9e2>
 511b5ca:	2b39      	cmp	r3, #57	; 0x39
 511b5cc:	d0ee      	beq.n	511b5ac <_dtoa_r+0x9bc>
 511b5ce:	3301      	adds	r3, #1
 511b5d0:	e7c7      	b.n	511b562 <_dtoa_r+0x972>
 511b5d2:	9a04      	ldr	r2, [sp, #16]
 511b5d4:	9908      	ldr	r1, [sp, #32]
 511b5d6:	f802 3c01 	strb.w	r3, [r2, #-1]
 511b5da:	428a      	cmp	r2, r1
 511b5dc:	d029      	beq.n	511b632 <_dtoa_r+0xa42>
 511b5de:	4629      	mov	r1, r5
 511b5e0:	2300      	movs	r3, #0
 511b5e2:	220a      	movs	r2, #10
 511b5e4:	4630      	mov	r0, r6
 511b5e6:	f000 fb05 	bl	511bbf4 <__multadd>
 511b5ea:	2300      	movs	r3, #0
 511b5ec:	4605      	mov	r5, r0
 511b5ee:	220a      	movs	r2, #10
 511b5f0:	4649      	mov	r1, r9
 511b5f2:	4630      	mov	r0, r6
 511b5f4:	45b9      	cmp	r9, r7
 511b5f6:	d107      	bne.n	511b608 <_dtoa_r+0xa18>
 511b5f8:	f000 fafc 	bl	511bbf4 <__multadd>
 511b5fc:	4681      	mov	r9, r0
 511b5fe:	4607      	mov	r7, r0
 511b600:	9b04      	ldr	r3, [sp, #16]
 511b602:	3301      	adds	r3, #1
 511b604:	9304      	str	r3, [sp, #16]
 511b606:	e776      	b.n	511b4f6 <_dtoa_r+0x906>
 511b608:	f000 faf4 	bl	511bbf4 <__multadd>
 511b60c:	4639      	mov	r1, r7
 511b60e:	4681      	mov	r9, r0
 511b610:	2300      	movs	r3, #0
 511b612:	220a      	movs	r2, #10
 511b614:	4630      	mov	r0, r6
 511b616:	f000 faed 	bl	511bbf4 <__multadd>
 511b61a:	4607      	mov	r7, r0
 511b61c:	e7f0      	b.n	511b600 <_dtoa_r+0xa10>
 511b61e:	f1ba 0f00 	cmp.w	sl, #0
 511b622:	9a01      	ldr	r2, [sp, #4]
 511b624:	bfcc      	ite	gt
 511b626:	46d0      	movgt	r8, sl
 511b628:	f04f 0801 	movle.w	r8, #1
 511b62c:	4490      	add	r8, r2
 511b62e:	f04f 0900 	mov.w	r9, #0
 511b632:	4629      	mov	r1, r5
 511b634:	2201      	movs	r2, #1
 511b636:	4630      	mov	r0, r6
 511b638:	9302      	str	r3, [sp, #8]
 511b63a:	f000 fc8b 	bl	511bf54 <__lshift>
 511b63e:	4621      	mov	r1, r4
 511b640:	4605      	mov	r5, r0
 511b642:	f000 fcf7 	bl	511c034 <__mcmp>
 511b646:	2800      	cmp	r0, #0
 511b648:	dcb3      	bgt.n	511b5b2 <_dtoa_r+0x9c2>
 511b64a:	d102      	bne.n	511b652 <_dtoa_r+0xa62>
 511b64c:	9b02      	ldr	r3, [sp, #8]
 511b64e:	07db      	lsls	r3, r3, #31
 511b650:	d4af      	bmi.n	511b5b2 <_dtoa_r+0x9c2>
 511b652:	4643      	mov	r3, r8
 511b654:	4698      	mov	r8, r3
 511b656:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
 511b65a:	2a30      	cmp	r2, #48	; 0x30
 511b65c:	d0fa      	beq.n	511b654 <_dtoa_r+0xa64>
 511b65e:	e6f8      	b.n	511b452 <_dtoa_r+0x862>
 511b660:	9a01      	ldr	r2, [sp, #4]
 511b662:	429a      	cmp	r2, r3
 511b664:	d1a6      	bne.n	511b5b4 <_dtoa_r+0x9c4>
 511b666:	f10b 0b01 	add.w	fp, fp, #1
 511b66a:	2331      	movs	r3, #49	; 0x31
 511b66c:	e77a      	b.n	511b564 <_dtoa_r+0x974>
 511b66e:	4b15      	ldr	r3, [pc, #84]	; (511b6c4 <_dtoa_r+0xad4>)
 511b670:	f7ff bb28 	b.w	511acc4 <_dtoa_r+0xd4>
 511b674:	9b1d      	ldr	r3, [sp, #116]	; 0x74
 511b676:	2b00      	cmp	r3, #0
 511b678:	f47f ab04 	bne.w	511ac84 <_dtoa_r+0x94>
 511b67c:	4b12      	ldr	r3, [pc, #72]	; (511b6c8 <_dtoa_r+0xad8>)
 511b67e:	f7ff bb21 	b.w	511acc4 <_dtoa_r+0xd4>
 511b682:	f1ba 0f00 	cmp.w	sl, #0
 511b686:	dc03      	bgt.n	511b690 <_dtoa_r+0xaa0>
 511b688:	9b06      	ldr	r3, [sp, #24]
 511b68a:	2b02      	cmp	r3, #2
 511b68c:	f73f aec9 	bgt.w	511b422 <_dtoa_r+0x832>
 511b690:	f8dd 8004 	ldr.w	r8, [sp, #4]
 511b694:	4621      	mov	r1, r4
 511b696:	4628      	mov	r0, r5
 511b698:	f7ff fa10 	bl	511aabc <quorem>
 511b69c:	9a01      	ldr	r2, [sp, #4]
 511b69e:	f100 0330 	add.w	r3, r0, #48	; 0x30
 511b6a2:	f808 3b01 	strb.w	r3, [r8], #1
 511b6a6:	eba8 0202 	sub.w	r2, r8, r2
 511b6aa:	4592      	cmp	sl, r2
 511b6ac:	ddb7      	ble.n	511b61e <_dtoa_r+0xa2e>
 511b6ae:	4629      	mov	r1, r5
 511b6b0:	2300      	movs	r3, #0
 511b6b2:	220a      	movs	r2, #10
 511b6b4:	4630      	mov	r0, r6
 511b6b6:	f000 fa9d 	bl	511bbf4 <__multadd>
 511b6ba:	4605      	mov	r5, r0
 511b6bc:	e7ea      	b.n	511b694 <_dtoa_r+0xaa4>
 511b6be:	bf00      	nop
 511b6c0:	0512df2a 	.word	0x0512df2a
 511b6c4:	0512dd64 	.word	0x0512dd64
 511b6c8:	0512de89 	.word	0x0512de89

0511b6cc <__errno>:
 511b6cc:	4b01      	ldr	r3, [pc, #4]	; (511b6d4 <__errno+0x8>)
 511b6ce:	6818      	ldr	r0, [r3, #0]
 511b6d0:	4770      	bx	lr
 511b6d2:	bf00      	nop
 511b6d4:	0512fab4 	.word	0x0512fab4

0511b6d8 <__sflush_r>:
 511b6d8:	898a      	ldrh	r2, [r1, #12]
 511b6da:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 511b6de:	4605      	mov	r5, r0
 511b6e0:	460c      	mov	r4, r1
 511b6e2:	0710      	lsls	r0, r2, #28
 511b6e4:	d458      	bmi.n	511b798 <__sflush_r+0xc0>
 511b6e6:	684b      	ldr	r3, [r1, #4]
 511b6e8:	2b00      	cmp	r3, #0
 511b6ea:	dc05      	bgt.n	511b6f8 <__sflush_r+0x20>
 511b6ec:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 511b6ee:	2b00      	cmp	r3, #0
 511b6f0:	dc02      	bgt.n	511b6f8 <__sflush_r+0x20>
 511b6f2:	2000      	movs	r0, #0
 511b6f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 511b6f8:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 511b6fa:	2e00      	cmp	r6, #0
 511b6fc:	d0f9      	beq.n	511b6f2 <__sflush_r+0x1a>
 511b6fe:	682f      	ldr	r7, [r5, #0]
 511b700:	2300      	movs	r3, #0
 511b702:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 511b706:	602b      	str	r3, [r5, #0]
 511b708:	d032      	beq.n	511b770 <__sflush_r+0x98>
 511b70a:	6d60      	ldr	r0, [r4, #84]	; 0x54
 511b70c:	89a3      	ldrh	r3, [r4, #12]
 511b70e:	075a      	lsls	r2, r3, #29
 511b710:	d505      	bpl.n	511b71e <__sflush_r+0x46>
 511b712:	6863      	ldr	r3, [r4, #4]
 511b714:	1ac0      	subs	r0, r0, r3
 511b716:	6b63      	ldr	r3, [r4, #52]	; 0x34
 511b718:	b10b      	cbz	r3, 511b71e <__sflush_r+0x46>
 511b71a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 511b71c:	1ac0      	subs	r0, r0, r3
 511b71e:	2300      	movs	r3, #0
 511b720:	4602      	mov	r2, r0
 511b722:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 511b724:	4628      	mov	r0, r5
 511b726:	6a21      	ldr	r1, [r4, #32]
 511b728:	47b0      	blx	r6
 511b72a:	1c43      	adds	r3, r0, #1
 511b72c:	89a3      	ldrh	r3, [r4, #12]
 511b72e:	d106      	bne.n	511b73e <__sflush_r+0x66>
 511b730:	6829      	ldr	r1, [r5, #0]
 511b732:	291d      	cmp	r1, #29
 511b734:	d82c      	bhi.n	511b790 <__sflush_r+0xb8>
 511b736:	4a2a      	ldr	r2, [pc, #168]	; (511b7e0 <__sflush_r+0x108>)
 511b738:	40ca      	lsrs	r2, r1
 511b73a:	07d6      	lsls	r6, r2, #31
 511b73c:	d528      	bpl.n	511b790 <__sflush_r+0xb8>
 511b73e:	2200      	movs	r2, #0
 511b740:	6062      	str	r2, [r4, #4]
 511b742:	6922      	ldr	r2, [r4, #16]
 511b744:	04d9      	lsls	r1, r3, #19
 511b746:	6022      	str	r2, [r4, #0]
 511b748:	d504      	bpl.n	511b754 <__sflush_r+0x7c>
 511b74a:	1c42      	adds	r2, r0, #1
 511b74c:	d101      	bne.n	511b752 <__sflush_r+0x7a>
 511b74e:	682b      	ldr	r3, [r5, #0]
 511b750:	b903      	cbnz	r3, 511b754 <__sflush_r+0x7c>
 511b752:	6560      	str	r0, [r4, #84]	; 0x54
 511b754:	6b61      	ldr	r1, [r4, #52]	; 0x34
 511b756:	602f      	str	r7, [r5, #0]
 511b758:	2900      	cmp	r1, #0
 511b75a:	d0ca      	beq.n	511b6f2 <__sflush_r+0x1a>
 511b75c:	f104 0344 	add.w	r3, r4, #68	; 0x44
 511b760:	4299      	cmp	r1, r3
 511b762:	d002      	beq.n	511b76a <__sflush_r+0x92>
 511b764:	4628      	mov	r0, r5
 511b766:	f000 fd7b 	bl	511c260 <_free_r>
 511b76a:	2000      	movs	r0, #0
 511b76c:	6360      	str	r0, [r4, #52]	; 0x34
 511b76e:	e7c1      	b.n	511b6f4 <__sflush_r+0x1c>
 511b770:	6a21      	ldr	r1, [r4, #32]
 511b772:	2301      	movs	r3, #1
 511b774:	4628      	mov	r0, r5
 511b776:	47b0      	blx	r6
 511b778:	1c41      	adds	r1, r0, #1
 511b77a:	d1c7      	bne.n	511b70c <__sflush_r+0x34>
 511b77c:	682b      	ldr	r3, [r5, #0]
 511b77e:	2b00      	cmp	r3, #0
 511b780:	d0c4      	beq.n	511b70c <__sflush_r+0x34>
 511b782:	2b1d      	cmp	r3, #29
 511b784:	d001      	beq.n	511b78a <__sflush_r+0xb2>
 511b786:	2b16      	cmp	r3, #22
 511b788:	d101      	bne.n	511b78e <__sflush_r+0xb6>
 511b78a:	602f      	str	r7, [r5, #0]
 511b78c:	e7b1      	b.n	511b6f2 <__sflush_r+0x1a>
 511b78e:	89a3      	ldrh	r3, [r4, #12]
 511b790:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 511b794:	81a3      	strh	r3, [r4, #12]
 511b796:	e7ad      	b.n	511b6f4 <__sflush_r+0x1c>
 511b798:	690f      	ldr	r7, [r1, #16]
 511b79a:	2f00      	cmp	r7, #0
 511b79c:	d0a9      	beq.n	511b6f2 <__sflush_r+0x1a>
 511b79e:	0793      	lsls	r3, r2, #30
 511b7a0:	680e      	ldr	r6, [r1, #0]
 511b7a2:	bf18      	it	ne
 511b7a4:	2300      	movne	r3, #0
 511b7a6:	600f      	str	r7, [r1, #0]
 511b7a8:	bf08      	it	eq
 511b7aa:	694b      	ldreq	r3, [r1, #20]
 511b7ac:	eba6 0807 	sub.w	r8, r6, r7
 511b7b0:	608b      	str	r3, [r1, #8]
 511b7b2:	f1b8 0f00 	cmp.w	r8, #0
 511b7b6:	dd9c      	ble.n	511b6f2 <__sflush_r+0x1a>
 511b7b8:	6a21      	ldr	r1, [r4, #32]
 511b7ba:	4643      	mov	r3, r8
 511b7bc:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 511b7be:	463a      	mov	r2, r7
 511b7c0:	4628      	mov	r0, r5
 511b7c2:	47b0      	blx	r6
 511b7c4:	2800      	cmp	r0, #0
 511b7c6:	dc06      	bgt.n	511b7d6 <__sflush_r+0xfe>
 511b7c8:	89a3      	ldrh	r3, [r4, #12]
 511b7ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511b7ce:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 511b7d2:	81a3      	strh	r3, [r4, #12]
 511b7d4:	e78e      	b.n	511b6f4 <__sflush_r+0x1c>
 511b7d6:	4407      	add	r7, r0
 511b7d8:	eba8 0800 	sub.w	r8, r8, r0
 511b7dc:	e7e9      	b.n	511b7b2 <__sflush_r+0xda>
 511b7de:	bf00      	nop
 511b7e0:	20400001 	.word	0x20400001

0511b7e4 <_fflush_r>:
 511b7e4:	b538      	push	{r3, r4, r5, lr}
 511b7e6:	4605      	mov	r5, r0
 511b7e8:	690b      	ldr	r3, [r1, #16]
 511b7ea:	460c      	mov	r4, r1
 511b7ec:	b913      	cbnz	r3, 511b7f4 <_fflush_r+0x10>
 511b7ee:	2500      	movs	r5, #0
 511b7f0:	4628      	mov	r0, r5
 511b7f2:	bd38      	pop	{r3, r4, r5, pc}
 511b7f4:	b118      	cbz	r0, 511b7fe <_fflush_r+0x1a>
 511b7f6:	6983      	ldr	r3, [r0, #24]
 511b7f8:	b90b      	cbnz	r3, 511b7fe <_fflush_r+0x1a>
 511b7fa:	f000 f887 	bl	511b90c <__sinit>
 511b7fe:	4b14      	ldr	r3, [pc, #80]	; (511b850 <_fflush_r+0x6c>)
 511b800:	429c      	cmp	r4, r3
 511b802:	d11b      	bne.n	511b83c <_fflush_r+0x58>
 511b804:	686c      	ldr	r4, [r5, #4]
 511b806:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 511b80a:	2b00      	cmp	r3, #0
 511b80c:	d0ef      	beq.n	511b7ee <_fflush_r+0xa>
 511b80e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 511b810:	07d0      	lsls	r0, r2, #31
 511b812:	d404      	bmi.n	511b81e <_fflush_r+0x3a>
 511b814:	0599      	lsls	r1, r3, #22
 511b816:	d402      	bmi.n	511b81e <_fflush_r+0x3a>
 511b818:	6da0      	ldr	r0, [r4, #88]	; 0x58
 511b81a:	f000 f91a 	bl	511ba52 <__retarget_lock_acquire_recursive>
 511b81e:	4628      	mov	r0, r5
 511b820:	4621      	mov	r1, r4
 511b822:	f7ff ff59 	bl	511b6d8 <__sflush_r>
 511b826:	6e63      	ldr	r3, [r4, #100]	; 0x64
 511b828:	4605      	mov	r5, r0
 511b82a:	07da      	lsls	r2, r3, #31
 511b82c:	d4e0      	bmi.n	511b7f0 <_fflush_r+0xc>
 511b82e:	89a3      	ldrh	r3, [r4, #12]
 511b830:	059b      	lsls	r3, r3, #22
 511b832:	d4dd      	bmi.n	511b7f0 <_fflush_r+0xc>
 511b834:	6da0      	ldr	r0, [r4, #88]	; 0x58
 511b836:	f000 f90d 	bl	511ba54 <__retarget_lock_release_recursive>
 511b83a:	e7d9      	b.n	511b7f0 <_fflush_r+0xc>
 511b83c:	4b05      	ldr	r3, [pc, #20]	; (511b854 <_fflush_r+0x70>)
 511b83e:	429c      	cmp	r4, r3
 511b840:	d101      	bne.n	511b846 <_fflush_r+0x62>
 511b842:	68ac      	ldr	r4, [r5, #8]
 511b844:	e7df      	b.n	511b806 <_fflush_r+0x22>
 511b846:	4b04      	ldr	r3, [pc, #16]	; (511b858 <_fflush_r+0x74>)
 511b848:	429c      	cmp	r4, r3
 511b84a:	bf08      	it	eq
 511b84c:	68ec      	ldreq	r4, [r5, #12]
 511b84e:	e7da      	b.n	511b806 <_fflush_r+0x22>
 511b850:	0512df5c 	.word	0x0512df5c
 511b854:	0512df7c 	.word	0x0512df7c
 511b858:	0512df3c 	.word	0x0512df3c

0511b85c <std>:
 511b85c:	b510      	push	{r4, lr}
 511b85e:	2300      	movs	r3, #0
 511b860:	4604      	mov	r4, r0
 511b862:	e9c0 3300 	strd	r3, r3, [r0]
 511b866:	6083      	str	r3, [r0, #8]
 511b868:	8181      	strh	r1, [r0, #12]
 511b86a:	4619      	mov	r1, r3
 511b86c:	6643      	str	r3, [r0, #100]	; 0x64
 511b86e:	81c2      	strh	r2, [r0, #14]
 511b870:	2208      	movs	r2, #8
 511b872:	e9c0 3304 	strd	r3, r3, [r0, #16]
 511b876:	305c      	adds	r0, #92	; 0x5c
 511b878:	f840 3c44 	str.w	r3, [r0, #-68]
 511b87c:	f7fe fa1d 	bl	5119cba <memset>
 511b880:	4b04      	ldr	r3, [pc, #16]	; (511b894 <std+0x38>)
 511b882:	6263      	str	r3, [r4, #36]	; 0x24
 511b884:	4b04      	ldr	r3, [pc, #16]	; (511b898 <std+0x3c>)
 511b886:	62a3      	str	r3, [r4, #40]	; 0x28
 511b888:	4b04      	ldr	r3, [pc, #16]	; (511b89c <std+0x40>)
 511b88a:	62e3      	str	r3, [r4, #44]	; 0x2c
 511b88c:	4b04      	ldr	r3, [pc, #16]	; (511b8a0 <std+0x44>)
 511b88e:	6224      	str	r4, [r4, #32]
 511b890:	6323      	str	r3, [r4, #48]	; 0x30
 511b892:	bd10      	pop	{r4, pc}
 511b894:	0511c9c1 	.word	0x0511c9c1
 511b898:	0511c9e3 	.word	0x0511c9e3
 511b89c:	0511ca1b 	.word	0x0511ca1b
 511b8a0:	0511ca3f 	.word	0x0511ca3f

0511b8a4 <_cleanup_r>:
 511b8a4:	4901      	ldr	r1, [pc, #4]	; (511b8ac <_cleanup_r+0x8>)
 511b8a6:	f000 b8af 	b.w	511ba08 <_fwalk_reent>
 511b8aa:	bf00      	nop
 511b8ac:	0511b7e5 	.word	0x0511b7e5

0511b8b0 <__sfmoreglue>:
 511b8b0:	b570      	push	{r4, r5, r6, lr}
 511b8b2:	2268      	movs	r2, #104	; 0x68
 511b8b4:	1e4d      	subs	r5, r1, #1
 511b8b6:	460e      	mov	r6, r1
 511b8b8:	4355      	muls	r5, r2
 511b8ba:	f105 0174 	add.w	r1, r5, #116	; 0x74
 511b8be:	f000 fd1b 	bl	511c2f8 <_malloc_r>
 511b8c2:	4604      	mov	r4, r0
 511b8c4:	b140      	cbz	r0, 511b8d8 <__sfmoreglue+0x28>
 511b8c6:	2100      	movs	r1, #0
 511b8c8:	f105 0268 	add.w	r2, r5, #104	; 0x68
 511b8cc:	e9c0 1600 	strd	r1, r6, [r0]
 511b8d0:	300c      	adds	r0, #12
 511b8d2:	60a0      	str	r0, [r4, #8]
 511b8d4:	f7fe f9f1 	bl	5119cba <memset>
 511b8d8:	4620      	mov	r0, r4
 511b8da:	bd70      	pop	{r4, r5, r6, pc}

0511b8dc <__sfp_lock_acquire>:
 511b8dc:	4801      	ldr	r0, [pc, #4]	; (511b8e4 <__sfp_lock_acquire+0x8>)
 511b8de:	f000 b8b8 	b.w	511ba52 <__retarget_lock_acquire_recursive>
 511b8e2:	bf00      	nop
 511b8e4:	051386fd 	.word	0x051386fd

0511b8e8 <__sfp_lock_release>:
 511b8e8:	4801      	ldr	r0, [pc, #4]	; (511b8f0 <__sfp_lock_release+0x8>)
 511b8ea:	f000 b8b3 	b.w	511ba54 <__retarget_lock_release_recursive>
 511b8ee:	bf00      	nop
 511b8f0:	051386fd 	.word	0x051386fd

0511b8f4 <__sinit_lock_acquire>:
 511b8f4:	4801      	ldr	r0, [pc, #4]	; (511b8fc <__sinit_lock_acquire+0x8>)
 511b8f6:	f000 b8ac 	b.w	511ba52 <__retarget_lock_acquire_recursive>
 511b8fa:	bf00      	nop
 511b8fc:	051386fe 	.word	0x051386fe

0511b900 <__sinit_lock_release>:
 511b900:	4801      	ldr	r0, [pc, #4]	; (511b908 <__sinit_lock_release+0x8>)
 511b902:	f000 b8a7 	b.w	511ba54 <__retarget_lock_release_recursive>
 511b906:	bf00      	nop
 511b908:	051386fe 	.word	0x051386fe

0511b90c <__sinit>:
 511b90c:	b510      	push	{r4, lr}
 511b90e:	4604      	mov	r4, r0
 511b910:	f7ff fff0 	bl	511b8f4 <__sinit_lock_acquire>
 511b914:	69a3      	ldr	r3, [r4, #24]
 511b916:	b11b      	cbz	r3, 511b920 <__sinit+0x14>
 511b918:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 511b91c:	f7ff bff0 	b.w	511b900 <__sinit_lock_release>
 511b920:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
 511b924:	4620      	mov	r0, r4
 511b926:	6523      	str	r3, [r4, #80]	; 0x50
 511b928:	4b12      	ldr	r3, [pc, #72]	; (511b974 <__sinit+0x68>)
 511b92a:	4a13      	ldr	r2, [pc, #76]	; (511b978 <__sinit+0x6c>)
 511b92c:	62a2      	str	r2, [r4, #40]	; 0x28
 511b92e:	681b      	ldr	r3, [r3, #0]
 511b930:	42a3      	cmp	r3, r4
 511b932:	bf04      	itt	eq
 511b934:	2301      	moveq	r3, #1
 511b936:	61a3      	streq	r3, [r4, #24]
 511b938:	f000 f820 	bl	511b97c <__sfp>
 511b93c:	6060      	str	r0, [r4, #4]
 511b93e:	4620      	mov	r0, r4
 511b940:	f000 f81c 	bl	511b97c <__sfp>
 511b944:	60a0      	str	r0, [r4, #8]
 511b946:	4620      	mov	r0, r4
 511b948:	f000 f818 	bl	511b97c <__sfp>
 511b94c:	2200      	movs	r2, #0
 511b94e:	2104      	movs	r1, #4
 511b950:	60e0      	str	r0, [r4, #12]
 511b952:	6860      	ldr	r0, [r4, #4]
 511b954:	f7ff ff82 	bl	511b85c <std>
 511b958:	68a0      	ldr	r0, [r4, #8]
 511b95a:	2201      	movs	r2, #1
 511b95c:	2109      	movs	r1, #9
 511b95e:	f7ff ff7d 	bl	511b85c <std>
 511b962:	68e0      	ldr	r0, [r4, #12]
 511b964:	2202      	movs	r2, #2
 511b966:	2112      	movs	r1, #18
 511b968:	f7ff ff78 	bl	511b85c <std>
 511b96c:	2301      	movs	r3, #1
 511b96e:	61a3      	str	r3, [r4, #24]
 511b970:	e7d2      	b.n	511b918 <__sinit+0xc>
 511b972:	bf00      	nop
 511b974:	0512df9c 	.word	0x0512df9c
 511b978:	0511b8a5 	.word	0x0511b8a5

0511b97c <__sfp>:
 511b97c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 511b97e:	4607      	mov	r7, r0
 511b980:	f7ff ffac 	bl	511b8dc <__sfp_lock_acquire>
 511b984:	4b1e      	ldr	r3, [pc, #120]	; (511ba00 <__sfp+0x84>)
 511b986:	681e      	ldr	r6, [r3, #0]
 511b988:	69b3      	ldr	r3, [r6, #24]
 511b98a:	b913      	cbnz	r3, 511b992 <__sfp+0x16>
 511b98c:	4630      	mov	r0, r6
 511b98e:	f7ff ffbd 	bl	511b90c <__sinit>
 511b992:	3648      	adds	r6, #72	; 0x48
 511b994:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 511b998:	3b01      	subs	r3, #1
 511b99a:	d503      	bpl.n	511b9a4 <__sfp+0x28>
 511b99c:	6833      	ldr	r3, [r6, #0]
 511b99e:	b30b      	cbz	r3, 511b9e4 <__sfp+0x68>
 511b9a0:	6836      	ldr	r6, [r6, #0]
 511b9a2:	e7f7      	b.n	511b994 <__sfp+0x18>
 511b9a4:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 511b9a8:	b9d5      	cbnz	r5, 511b9e0 <__sfp+0x64>
 511b9aa:	4b16      	ldr	r3, [pc, #88]	; (511ba04 <__sfp+0x88>)
 511b9ac:	f104 0058 	add.w	r0, r4, #88	; 0x58
 511b9b0:	60e3      	str	r3, [r4, #12]
 511b9b2:	6665      	str	r5, [r4, #100]	; 0x64
 511b9b4:	f000 f84c 	bl	511ba50 <__retarget_lock_init_recursive>
 511b9b8:	f7ff ff96 	bl	511b8e8 <__sfp_lock_release>
 511b9bc:	2208      	movs	r2, #8
 511b9be:	4629      	mov	r1, r5
 511b9c0:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 511b9c4:	6025      	str	r5, [r4, #0]
 511b9c6:	e9c4 5501 	strd	r5, r5, [r4, #4]
 511b9ca:	e9c4 5504 	strd	r5, r5, [r4, #16]
 511b9ce:	61a5      	str	r5, [r4, #24]
 511b9d0:	f7fe f973 	bl	5119cba <memset>
 511b9d4:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 511b9d8:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 511b9dc:	4620      	mov	r0, r4
 511b9de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 511b9e0:	3468      	adds	r4, #104	; 0x68
 511b9e2:	e7d9      	b.n	511b998 <__sfp+0x1c>
 511b9e4:	2104      	movs	r1, #4
 511b9e6:	4638      	mov	r0, r7
 511b9e8:	f7ff ff62 	bl	511b8b0 <__sfmoreglue>
 511b9ec:	4604      	mov	r4, r0
 511b9ee:	6030      	str	r0, [r6, #0]
 511b9f0:	2800      	cmp	r0, #0
 511b9f2:	d1d5      	bne.n	511b9a0 <__sfp+0x24>
 511b9f4:	f7ff ff78 	bl	511b8e8 <__sfp_lock_release>
 511b9f8:	230c      	movs	r3, #12
 511b9fa:	603b      	str	r3, [r7, #0]
 511b9fc:	e7ee      	b.n	511b9dc <__sfp+0x60>
 511b9fe:	bf00      	nop
 511ba00:	0512df9c 	.word	0x0512df9c
 511ba04:	ffff0001 	.word	0xffff0001

0511ba08 <_fwalk_reent>:
 511ba08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 511ba0c:	4606      	mov	r6, r0
 511ba0e:	4688      	mov	r8, r1
 511ba10:	f100 0448 	add.w	r4, r0, #72	; 0x48
 511ba14:	2700      	movs	r7, #0
 511ba16:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 511ba1a:	f1b9 0901 	subs.w	r9, r9, #1
 511ba1e:	d505      	bpl.n	511ba2c <_fwalk_reent+0x24>
 511ba20:	6824      	ldr	r4, [r4, #0]
 511ba22:	2c00      	cmp	r4, #0
 511ba24:	d1f7      	bne.n	511ba16 <_fwalk_reent+0xe>
 511ba26:	4638      	mov	r0, r7
 511ba28:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 511ba2c:	89ab      	ldrh	r3, [r5, #12]
 511ba2e:	2b01      	cmp	r3, #1
 511ba30:	d907      	bls.n	511ba42 <_fwalk_reent+0x3a>
 511ba32:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 511ba36:	3301      	adds	r3, #1
 511ba38:	d003      	beq.n	511ba42 <_fwalk_reent+0x3a>
 511ba3a:	4629      	mov	r1, r5
 511ba3c:	4630      	mov	r0, r6
 511ba3e:	47c0      	blx	r8
 511ba40:	4307      	orrs	r7, r0
 511ba42:	3568      	adds	r5, #104	; 0x68
 511ba44:	e7e9      	b.n	511ba1a <_fwalk_reent+0x12>
	...

0511ba48 <_localeconv_r>:
 511ba48:	4800      	ldr	r0, [pc, #0]	; (511ba4c <_localeconv_r+0x4>)
 511ba4a:	4770      	bx	lr
 511ba4c:	0512fc08 	.word	0x0512fc08

0511ba50 <__retarget_lock_init_recursive>:
 511ba50:	4770      	bx	lr

0511ba52 <__retarget_lock_acquire_recursive>:
 511ba52:	4770      	bx	lr

0511ba54 <__retarget_lock_release_recursive>:
 511ba54:	4770      	bx	lr

0511ba56 <__swhatbuf_r>:
 511ba56:	b570      	push	{r4, r5, r6, lr}
 511ba58:	460e      	mov	r6, r1
 511ba5a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 511ba5e:	b096      	sub	sp, #88	; 0x58
 511ba60:	4614      	mov	r4, r2
 511ba62:	461d      	mov	r5, r3
 511ba64:	2900      	cmp	r1, #0
 511ba66:	da08      	bge.n	511ba7a <__swhatbuf_r+0x24>
 511ba68:	f9b6 300c 	ldrsh.w	r3, [r6, #12]
 511ba6c:	2200      	movs	r2, #0
 511ba6e:	602a      	str	r2, [r5, #0]
 511ba70:	061a      	lsls	r2, r3, #24
 511ba72:	d410      	bmi.n	511ba96 <__swhatbuf_r+0x40>
 511ba74:	f44f 6380 	mov.w	r3, #1024	; 0x400
 511ba78:	e00e      	b.n	511ba98 <__swhatbuf_r+0x42>
 511ba7a:	466a      	mov	r2, sp
 511ba7c:	f001 f824 	bl	511cac8 <_fstat_r>
 511ba80:	2800      	cmp	r0, #0
 511ba82:	dbf1      	blt.n	511ba68 <__swhatbuf_r+0x12>
 511ba84:	9a01      	ldr	r2, [sp, #4]
 511ba86:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 511ba8a:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 511ba8e:	425a      	negs	r2, r3
 511ba90:	415a      	adcs	r2, r3
 511ba92:	602a      	str	r2, [r5, #0]
 511ba94:	e7ee      	b.n	511ba74 <__swhatbuf_r+0x1e>
 511ba96:	2340      	movs	r3, #64	; 0x40
 511ba98:	2000      	movs	r0, #0
 511ba9a:	6023      	str	r3, [r4, #0]
 511ba9c:	b016      	add	sp, #88	; 0x58
 511ba9e:	bd70      	pop	{r4, r5, r6, pc}

0511baa0 <__smakebuf_r>:
 511baa0:	898b      	ldrh	r3, [r1, #12]
 511baa2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 511baa4:	4606      	mov	r6, r0
 511baa6:	460c      	mov	r4, r1
 511baa8:	079d      	lsls	r5, r3, #30
 511baaa:	d507      	bpl.n	511babc <__smakebuf_r+0x1c>
 511baac:	f104 0347 	add.w	r3, r4, #71	; 0x47
 511bab0:	6023      	str	r3, [r4, #0]
 511bab2:	6123      	str	r3, [r4, #16]
 511bab4:	2301      	movs	r3, #1
 511bab6:	6163      	str	r3, [r4, #20]
 511bab8:	b002      	add	sp, #8
 511baba:	bd70      	pop	{r4, r5, r6, pc}
 511babc:	ab01      	add	r3, sp, #4
 511babe:	466a      	mov	r2, sp
 511bac0:	f7ff ffc9 	bl	511ba56 <__swhatbuf_r>
 511bac4:	9900      	ldr	r1, [sp, #0]
 511bac6:	4605      	mov	r5, r0
 511bac8:	4630      	mov	r0, r6
 511baca:	f000 fc15 	bl	511c2f8 <_malloc_r>
 511bace:	b948      	cbnz	r0, 511bae4 <__smakebuf_r+0x44>
 511bad0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 511bad4:	059a      	lsls	r2, r3, #22
 511bad6:	d4ef      	bmi.n	511bab8 <__smakebuf_r+0x18>
 511bad8:	f023 0303 	bic.w	r3, r3, #3
 511badc:	f043 0302 	orr.w	r3, r3, #2
 511bae0:	81a3      	strh	r3, [r4, #12]
 511bae2:	e7e3      	b.n	511baac <__smakebuf_r+0xc>
 511bae4:	4b0d      	ldr	r3, [pc, #52]	; (511bb1c <__smakebuf_r+0x7c>)
 511bae6:	62b3      	str	r3, [r6, #40]	; 0x28
 511bae8:	89a3      	ldrh	r3, [r4, #12]
 511baea:	6020      	str	r0, [r4, #0]
 511baec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 511baf0:	81a3      	strh	r3, [r4, #12]
 511baf2:	9b00      	ldr	r3, [sp, #0]
 511baf4:	6163      	str	r3, [r4, #20]
 511baf6:	9b01      	ldr	r3, [sp, #4]
 511baf8:	6120      	str	r0, [r4, #16]
 511bafa:	b15b      	cbz	r3, 511bb14 <__smakebuf_r+0x74>
 511bafc:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 511bb00:	4630      	mov	r0, r6
 511bb02:	f000 fff3 	bl	511caec <_isatty_r>
 511bb06:	b128      	cbz	r0, 511bb14 <__smakebuf_r+0x74>
 511bb08:	89a3      	ldrh	r3, [r4, #12]
 511bb0a:	f023 0303 	bic.w	r3, r3, #3
 511bb0e:	f043 0301 	orr.w	r3, r3, #1
 511bb12:	81a3      	strh	r3, [r4, #12]
 511bb14:	89a0      	ldrh	r0, [r4, #12]
 511bb16:	4305      	orrs	r5, r0
 511bb18:	81a5      	strh	r5, [r4, #12]
 511bb1a:	e7cd      	b.n	511bab8 <__smakebuf_r+0x18>
 511bb1c:	0511b8a5 	.word	0x0511b8a5

0511bb20 <malloc>:
 511bb20:	4b02      	ldr	r3, [pc, #8]	; (511bb2c <malloc+0xc>)
 511bb22:	4601      	mov	r1, r0
 511bb24:	6818      	ldr	r0, [r3, #0]
 511bb26:	f000 bbe7 	b.w	511c2f8 <_malloc_r>
 511bb2a:	bf00      	nop
 511bb2c:	0512fab4 	.word	0x0512fab4

0511bb30 <_Balloc>:
 511bb30:	b570      	push	{r4, r5, r6, lr}
 511bb32:	4604      	mov	r4, r0
 511bb34:	6a46      	ldr	r6, [r0, #36]	; 0x24
 511bb36:	460d      	mov	r5, r1
 511bb38:	b976      	cbnz	r6, 511bb58 <_Balloc+0x28>
 511bb3a:	2010      	movs	r0, #16
 511bb3c:	f7ff fff0 	bl	511bb20 <malloc>
 511bb40:	4602      	mov	r2, r0
 511bb42:	6260      	str	r0, [r4, #36]	; 0x24
 511bb44:	b920      	cbnz	r0, 511bb50 <_Balloc+0x20>
 511bb46:	4b18      	ldr	r3, [pc, #96]	; (511bba8 <_Balloc+0x78>)
 511bb48:	2166      	movs	r1, #102	; 0x66
 511bb4a:	4818      	ldr	r0, [pc, #96]	; (511bbac <_Balloc+0x7c>)
 511bb4c:	f000 ff7c 	bl	511ca48 <__assert_func>
 511bb50:	e9c0 6601 	strd	r6, r6, [r0, #4]
 511bb54:	6006      	str	r6, [r0, #0]
 511bb56:	60c6      	str	r6, [r0, #12]
 511bb58:	6a66      	ldr	r6, [r4, #36]	; 0x24
 511bb5a:	68f3      	ldr	r3, [r6, #12]
 511bb5c:	b183      	cbz	r3, 511bb80 <_Balloc+0x50>
 511bb5e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 511bb60:	68db      	ldr	r3, [r3, #12]
 511bb62:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
 511bb66:	b9b8      	cbnz	r0, 511bb98 <_Balloc+0x68>
 511bb68:	2101      	movs	r1, #1
 511bb6a:	4620      	mov	r0, r4
 511bb6c:	fa01 f605 	lsl.w	r6, r1, r5
 511bb70:	1d72      	adds	r2, r6, #5
 511bb72:	0092      	lsls	r2, r2, #2
 511bb74:	f000 fb64 	bl	511c240 <_calloc_r>
 511bb78:	b160      	cbz	r0, 511bb94 <_Balloc+0x64>
 511bb7a:	e9c0 5601 	strd	r5, r6, [r0, #4]
 511bb7e:	e00e      	b.n	511bb9e <_Balloc+0x6e>
 511bb80:	2221      	movs	r2, #33	; 0x21
 511bb82:	2104      	movs	r1, #4
 511bb84:	4620      	mov	r0, r4
 511bb86:	f000 fb5b 	bl	511c240 <_calloc_r>
 511bb8a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 511bb8c:	60f0      	str	r0, [r6, #12]
 511bb8e:	68db      	ldr	r3, [r3, #12]
 511bb90:	2b00      	cmp	r3, #0
 511bb92:	d1e4      	bne.n	511bb5e <_Balloc+0x2e>
 511bb94:	2000      	movs	r0, #0
 511bb96:	bd70      	pop	{r4, r5, r6, pc}
 511bb98:	6802      	ldr	r2, [r0, #0]
 511bb9a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
 511bb9e:	2300      	movs	r3, #0
 511bba0:	e9c0 3303 	strd	r3, r3, [r0, #12]
 511bba4:	e7f7      	b.n	511bb96 <_Balloc+0x66>
 511bba6:	bf00      	nop
 511bba8:	0512de96 	.word	0x0512de96
 511bbac:	0512dfa0 	.word	0x0512dfa0

0511bbb0 <_Bfree>:
 511bbb0:	b570      	push	{r4, r5, r6, lr}
 511bbb2:	4605      	mov	r5, r0
 511bbb4:	6a46      	ldr	r6, [r0, #36]	; 0x24
 511bbb6:	460c      	mov	r4, r1
 511bbb8:	b976      	cbnz	r6, 511bbd8 <_Bfree+0x28>
 511bbba:	2010      	movs	r0, #16
 511bbbc:	f7ff ffb0 	bl	511bb20 <malloc>
 511bbc0:	4602      	mov	r2, r0
 511bbc2:	6268      	str	r0, [r5, #36]	; 0x24
 511bbc4:	b920      	cbnz	r0, 511bbd0 <_Bfree+0x20>
 511bbc6:	4b09      	ldr	r3, [pc, #36]	; (511bbec <_Bfree+0x3c>)
 511bbc8:	218a      	movs	r1, #138	; 0x8a
 511bbca:	4809      	ldr	r0, [pc, #36]	; (511bbf0 <_Bfree+0x40>)
 511bbcc:	f000 ff3c 	bl	511ca48 <__assert_func>
 511bbd0:	e9c0 6601 	strd	r6, r6, [r0, #4]
 511bbd4:	6006      	str	r6, [r0, #0]
 511bbd6:	60c6      	str	r6, [r0, #12]
 511bbd8:	b13c      	cbz	r4, 511bbea <_Bfree+0x3a>
 511bbda:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 511bbdc:	6862      	ldr	r2, [r4, #4]
 511bbde:	68db      	ldr	r3, [r3, #12]
 511bbe0:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 511bbe4:	6021      	str	r1, [r4, #0]
 511bbe6:	f843 4022 	str.w	r4, [r3, r2, lsl #2]
 511bbea:	bd70      	pop	{r4, r5, r6, pc}
 511bbec:	0512de96 	.word	0x0512de96
 511bbf0:	0512dfa0 	.word	0x0512dfa0

0511bbf4 <__multadd>:
 511bbf4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 511bbf8:	f101 0c14 	add.w	ip, r1, #20
 511bbfc:	690d      	ldr	r5, [r1, #16]
 511bbfe:	4607      	mov	r7, r0
 511bc00:	460c      	mov	r4, r1
 511bc02:	461e      	mov	r6, r3
 511bc04:	2000      	movs	r0, #0
 511bc06:	f8dc 3000 	ldr.w	r3, [ip]
 511bc0a:	3001      	adds	r0, #1
 511bc0c:	4285      	cmp	r5, r0
 511bc0e:	b299      	uxth	r1, r3
 511bc10:	fb02 6101 	mla	r1, r2, r1, r6
 511bc14:	ea4f 4613 	mov.w	r6, r3, lsr #16
 511bc18:	ea4f 4311 	mov.w	r3, r1, lsr #16
 511bc1c:	b289      	uxth	r1, r1
 511bc1e:	fb02 3306 	mla	r3, r2, r6, r3
 511bc22:	eb01 4103 	add.w	r1, r1, r3, lsl #16
 511bc26:	ea4f 4613 	mov.w	r6, r3, lsr #16
 511bc2a:	f84c 1b04 	str.w	r1, [ip], #4
 511bc2e:	dcea      	bgt.n	511bc06 <__multadd+0x12>
 511bc30:	b30e      	cbz	r6, 511bc76 <__multadd+0x82>
 511bc32:	68a3      	ldr	r3, [r4, #8]
 511bc34:	42ab      	cmp	r3, r5
 511bc36:	dc19      	bgt.n	511bc6c <__multadd+0x78>
 511bc38:	6861      	ldr	r1, [r4, #4]
 511bc3a:	4638      	mov	r0, r7
 511bc3c:	3101      	adds	r1, #1
 511bc3e:	f7ff ff77 	bl	511bb30 <_Balloc>
 511bc42:	4680      	mov	r8, r0
 511bc44:	b928      	cbnz	r0, 511bc52 <__multadd+0x5e>
 511bc46:	4602      	mov	r2, r0
 511bc48:	4b0c      	ldr	r3, [pc, #48]	; (511bc7c <__multadd+0x88>)
 511bc4a:	480d      	ldr	r0, [pc, #52]	; (511bc80 <__multadd+0x8c>)
 511bc4c:	21b5      	movs	r1, #181	; 0xb5
 511bc4e:	f000 fefb 	bl	511ca48 <__assert_func>
 511bc52:	6922      	ldr	r2, [r4, #16]
 511bc54:	f104 010c 	add.w	r1, r4, #12
 511bc58:	300c      	adds	r0, #12
 511bc5a:	3202      	adds	r2, #2
 511bc5c:	0092      	lsls	r2, r2, #2
 511bc5e:	f7fe f81f 	bl	5119ca0 <memcpy>
 511bc62:	4621      	mov	r1, r4
 511bc64:	4644      	mov	r4, r8
 511bc66:	4638      	mov	r0, r7
 511bc68:	f7ff ffa2 	bl	511bbb0 <_Bfree>
 511bc6c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
 511bc70:	3501      	adds	r5, #1
 511bc72:	615e      	str	r6, [r3, #20]
 511bc74:	6125      	str	r5, [r4, #16]
 511bc76:	4620      	mov	r0, r4
 511bc78:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 511bc7c:	0512df2a 	.word	0x0512df2a
 511bc80:	0512dfa0 	.word	0x0512dfa0

0511bc84 <__hi0bits>:
 511bc84:	0c03      	lsrs	r3, r0, #16
 511bc86:	041b      	lsls	r3, r3, #16
 511bc88:	b9d3      	cbnz	r3, 511bcc0 <__hi0bits+0x3c>
 511bc8a:	0400      	lsls	r0, r0, #16
 511bc8c:	2310      	movs	r3, #16
 511bc8e:	f010 4f7f 	tst.w	r0, #4278190080	; 0xff000000
 511bc92:	bf04      	itt	eq
 511bc94:	0200      	lsleq	r0, r0, #8
 511bc96:	3308      	addeq	r3, #8
 511bc98:	f010 4f70 	tst.w	r0, #4026531840	; 0xf0000000
 511bc9c:	bf04      	itt	eq
 511bc9e:	0100      	lsleq	r0, r0, #4
 511bca0:	3304      	addeq	r3, #4
 511bca2:	f010 4f40 	tst.w	r0, #3221225472	; 0xc0000000
 511bca6:	bf04      	itt	eq
 511bca8:	0080      	lsleq	r0, r0, #2
 511bcaa:	3302      	addeq	r3, #2
 511bcac:	2800      	cmp	r0, #0
 511bcae:	db05      	blt.n	511bcbc <__hi0bits+0x38>
 511bcb0:	f010 4f80 	tst.w	r0, #1073741824	; 0x40000000
 511bcb4:	f103 0301 	add.w	r3, r3, #1
 511bcb8:	bf08      	it	eq
 511bcba:	2320      	moveq	r3, #32
 511bcbc:	4618      	mov	r0, r3
 511bcbe:	4770      	bx	lr
 511bcc0:	2300      	movs	r3, #0
 511bcc2:	e7e4      	b.n	511bc8e <__hi0bits+0xa>

0511bcc4 <__lo0bits>:
 511bcc4:	6803      	ldr	r3, [r0, #0]
 511bcc6:	4601      	mov	r1, r0
 511bcc8:	f013 0207 	ands.w	r2, r3, #7
 511bccc:	d00b      	beq.n	511bce6 <__lo0bits+0x22>
 511bcce:	07da      	lsls	r2, r3, #31
 511bcd0:	d422      	bmi.n	511bd18 <__lo0bits+0x54>
 511bcd2:	0798      	lsls	r0, r3, #30
 511bcd4:	bf45      	ittet	mi
 511bcd6:	2001      	movmi	r0, #1
 511bcd8:	085b      	lsrmi	r3, r3, #1
 511bcda:	089b      	lsrpl	r3, r3, #2
 511bcdc:	600b      	strmi	r3, [r1, #0]
 511bcde:	bf5c      	itt	pl
 511bce0:	2002      	movpl	r0, #2
 511bce2:	600b      	strpl	r3, [r1, #0]
 511bce4:	4770      	bx	lr
 511bce6:	b298      	uxth	r0, r3
 511bce8:	b9a0      	cbnz	r0, 511bd14 <__lo0bits+0x50>
 511bcea:	0c1b      	lsrs	r3, r3, #16
 511bcec:	2010      	movs	r0, #16
 511bcee:	b2da      	uxtb	r2, r3
 511bcf0:	b90a      	cbnz	r2, 511bcf6 <__lo0bits+0x32>
 511bcf2:	3008      	adds	r0, #8
 511bcf4:	0a1b      	lsrs	r3, r3, #8
 511bcf6:	071a      	lsls	r2, r3, #28
 511bcf8:	bf04      	itt	eq
 511bcfa:	3004      	addeq	r0, #4
 511bcfc:	091b      	lsreq	r3, r3, #4
 511bcfe:	079a      	lsls	r2, r3, #30
 511bd00:	bf04      	itt	eq
 511bd02:	3002      	addeq	r0, #2
 511bd04:	089b      	lsreq	r3, r3, #2
 511bd06:	07da      	lsls	r2, r3, #31
 511bd08:	d402      	bmi.n	511bd10 <__lo0bits+0x4c>
 511bd0a:	3001      	adds	r0, #1
 511bd0c:	085b      	lsrs	r3, r3, #1
 511bd0e:	d005      	beq.n	511bd1c <__lo0bits+0x58>
 511bd10:	600b      	str	r3, [r1, #0]
 511bd12:	4770      	bx	lr
 511bd14:	4610      	mov	r0, r2
 511bd16:	e7ea      	b.n	511bcee <__lo0bits+0x2a>
 511bd18:	2000      	movs	r0, #0
 511bd1a:	4770      	bx	lr
 511bd1c:	2020      	movs	r0, #32
 511bd1e:	4770      	bx	lr

0511bd20 <__i2b>:
 511bd20:	b510      	push	{r4, lr}
 511bd22:	460c      	mov	r4, r1
 511bd24:	2101      	movs	r1, #1
 511bd26:	f7ff ff03 	bl	511bb30 <_Balloc>
 511bd2a:	4602      	mov	r2, r0
 511bd2c:	b928      	cbnz	r0, 511bd3a <__i2b+0x1a>
 511bd2e:	4b05      	ldr	r3, [pc, #20]	; (511bd44 <__i2b+0x24>)
 511bd30:	f44f 71a0 	mov.w	r1, #320	; 0x140
 511bd34:	4804      	ldr	r0, [pc, #16]	; (511bd48 <__i2b+0x28>)
 511bd36:	f000 fe87 	bl	511ca48 <__assert_func>
 511bd3a:	2301      	movs	r3, #1
 511bd3c:	6144      	str	r4, [r0, #20]
 511bd3e:	6103      	str	r3, [r0, #16]
 511bd40:	bd10      	pop	{r4, pc}
 511bd42:	bf00      	nop
 511bd44:	0512df2a 	.word	0x0512df2a
 511bd48:	0512dfa0 	.word	0x0512dfa0

0511bd4c <__multiply>:
 511bd4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511bd50:	4691      	mov	r9, r2
 511bd52:	690a      	ldr	r2, [r1, #16]
 511bd54:	460c      	mov	r4, r1
 511bd56:	b085      	sub	sp, #20
 511bd58:	f8d9 3010 	ldr.w	r3, [r9, #16]
 511bd5c:	429a      	cmp	r2, r3
 511bd5e:	bfbe      	ittt	lt
 511bd60:	460b      	movlt	r3, r1
 511bd62:	464c      	movlt	r4, r9
 511bd64:	4699      	movlt	r9, r3
 511bd66:	6927      	ldr	r7, [r4, #16]
 511bd68:	f8d9 a010 	ldr.w	sl, [r9, #16]
 511bd6c:	68a3      	ldr	r3, [r4, #8]
 511bd6e:	6861      	ldr	r1, [r4, #4]
 511bd70:	eb07 060a 	add.w	r6, r7, sl
 511bd74:	42b3      	cmp	r3, r6
 511bd76:	bfb8      	it	lt
 511bd78:	3101      	addlt	r1, #1
 511bd7a:	f7ff fed9 	bl	511bb30 <_Balloc>
 511bd7e:	b930      	cbnz	r0, 511bd8e <__multiply+0x42>
 511bd80:	4602      	mov	r2, r0
 511bd82:	4b45      	ldr	r3, [pc, #276]	; (511be98 <__multiply+0x14c>)
 511bd84:	4845      	ldr	r0, [pc, #276]	; (511be9c <__multiply+0x150>)
 511bd86:	f240 115d 	movw	r1, #349	; 0x15d
 511bd8a:	f000 fe5d 	bl	511ca48 <__assert_func>
 511bd8e:	f100 0514 	add.w	r5, r0, #20
 511bd92:	2200      	movs	r2, #0
 511bd94:	eb05 0886 	add.w	r8, r5, r6, lsl #2
 511bd98:	462b      	mov	r3, r5
 511bd9a:	4543      	cmp	r3, r8
 511bd9c:	d321      	bcc.n	511bde2 <__multiply+0x96>
 511bd9e:	f104 0314 	add.w	r3, r4, #20
 511bda2:	f104 0115 	add.w	r1, r4, #21
 511bda6:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 511bdaa:	f109 0314 	add.w	r3, r9, #20
 511bdae:	eb03 028a 	add.w	r2, r3, sl, lsl #2
 511bdb2:	9202      	str	r2, [sp, #8]
 511bdb4:	1b3a      	subs	r2, r7, r4
 511bdb6:	3a15      	subs	r2, #21
 511bdb8:	f022 0203 	bic.w	r2, r2, #3
 511bdbc:	3204      	adds	r2, #4
 511bdbe:	428f      	cmp	r7, r1
 511bdc0:	bf38      	it	cc
 511bdc2:	2204      	movcc	r2, #4
 511bdc4:	9201      	str	r2, [sp, #4]
 511bdc6:	9a02      	ldr	r2, [sp, #8]
 511bdc8:	9303      	str	r3, [sp, #12]
 511bdca:	429a      	cmp	r2, r3
 511bdcc:	d80c      	bhi.n	511bde8 <__multiply+0x9c>
 511bdce:	2e00      	cmp	r6, #0
 511bdd0:	dd03      	ble.n	511bdda <__multiply+0x8e>
 511bdd2:	f858 3d04 	ldr.w	r3, [r8, #-4]!
 511bdd6:	2b00      	cmp	r3, #0
 511bdd8:	d05b      	beq.n	511be92 <__multiply+0x146>
 511bdda:	6106      	str	r6, [r0, #16]
 511bddc:	b005      	add	sp, #20
 511bdde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511bde2:	f843 2b04 	str.w	r2, [r3], #4
 511bde6:	e7d8      	b.n	511bd9a <__multiply+0x4e>
 511bde8:	f8b3 a000 	ldrh.w	sl, [r3]
 511bdec:	f1ba 0f00 	cmp.w	sl, #0
 511bdf0:	d024      	beq.n	511be3c <__multiply+0xf0>
 511bdf2:	f104 0e14 	add.w	lr, r4, #20
 511bdf6:	46a9      	mov	r9, r5
 511bdf8:	f04f 0c00 	mov.w	ip, #0
 511bdfc:	f85e 2b04 	ldr.w	r2, [lr], #4
 511be00:	f8d9 1000 	ldr.w	r1, [r9]
 511be04:	4577      	cmp	r7, lr
 511be06:	fa1f fb82 	uxth.w	fp, r2
 511be0a:	b289      	uxth	r1, r1
 511be0c:	fb0a 110b 	mla	r1, sl, fp, r1
 511be10:	ea4f 4b12 	mov.w	fp, r2, lsr #16
 511be14:	f8d9 2000 	ldr.w	r2, [r9]
 511be18:	4461      	add	r1, ip
 511be1a:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 511be1e:	fb0a c20b 	mla	r2, sl, fp, ip
 511be22:	eb02 4211 	add.w	r2, r2, r1, lsr #16
 511be26:	b289      	uxth	r1, r1
 511be28:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 511be2c:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 511be30:	f849 1b04 	str.w	r1, [r9], #4
 511be34:	d8e2      	bhi.n	511bdfc <__multiply+0xb0>
 511be36:	9a01      	ldr	r2, [sp, #4]
 511be38:	f845 c002 	str.w	ip, [r5, r2]
 511be3c:	9a03      	ldr	r2, [sp, #12]
 511be3e:	3304      	adds	r3, #4
 511be40:	f8b2 9002 	ldrh.w	r9, [r2, #2]
 511be44:	f1b9 0f00 	cmp.w	r9, #0
 511be48:	d021      	beq.n	511be8e <__multiply+0x142>
 511be4a:	6829      	ldr	r1, [r5, #0]
 511be4c:	f104 0c14 	add.w	ip, r4, #20
 511be50:	46ae      	mov	lr, r5
 511be52:	f04f 0a00 	mov.w	sl, #0
 511be56:	f8bc b000 	ldrh.w	fp, [ip]
 511be5a:	b289      	uxth	r1, r1
 511be5c:	f8be 2002 	ldrh.w	r2, [lr, #2]
 511be60:	fb09 220b 	mla	r2, r9, fp, r2
 511be64:	4492      	add	sl, r2
 511be66:	ea41 410a 	orr.w	r1, r1, sl, lsl #16
 511be6a:	f84e 1b04 	str.w	r1, [lr], #4
 511be6e:	f85c 2b04 	ldr.w	r2, [ip], #4
 511be72:	f8be 1000 	ldrh.w	r1, [lr]
 511be76:	4567      	cmp	r7, ip
 511be78:	ea4f 4212 	mov.w	r2, r2, lsr #16
 511be7c:	fb09 1102 	mla	r1, r9, r2, r1
 511be80:	eb01 411a 	add.w	r1, r1, sl, lsr #16
 511be84:	ea4f 4a11 	mov.w	sl, r1, lsr #16
 511be88:	d8e5      	bhi.n	511be56 <__multiply+0x10a>
 511be8a:	9a01      	ldr	r2, [sp, #4]
 511be8c:	50a9      	str	r1, [r5, r2]
 511be8e:	3504      	adds	r5, #4
 511be90:	e799      	b.n	511bdc6 <__multiply+0x7a>
 511be92:	3e01      	subs	r6, #1
 511be94:	e79b      	b.n	511bdce <__multiply+0x82>
 511be96:	bf00      	nop
 511be98:	0512df2a 	.word	0x0512df2a
 511be9c:	0512dfa0 	.word	0x0512dfa0

0511bea0 <__pow5mult>:
 511bea0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 511bea4:	4615      	mov	r5, r2
 511bea6:	4606      	mov	r6, r0
 511bea8:	460f      	mov	r7, r1
 511beaa:	f012 0203 	ands.w	r2, r2, #3
 511beae:	d007      	beq.n	511bec0 <__pow5mult+0x20>
 511beb0:	4c25      	ldr	r4, [pc, #148]	; (511bf48 <__pow5mult+0xa8>)
 511beb2:	3a01      	subs	r2, #1
 511beb4:	2300      	movs	r3, #0
 511beb6:	f854 2022 	ldr.w	r2, [r4, r2, lsl #2]
 511beba:	f7ff fe9b 	bl	511bbf4 <__multadd>
 511bebe:	4607      	mov	r7, r0
 511bec0:	10ad      	asrs	r5, r5, #2
 511bec2:	d03d      	beq.n	511bf40 <__pow5mult+0xa0>
 511bec4:	6a74      	ldr	r4, [r6, #36]	; 0x24
 511bec6:	b97c      	cbnz	r4, 511bee8 <__pow5mult+0x48>
 511bec8:	2010      	movs	r0, #16
 511beca:	f7ff fe29 	bl	511bb20 <malloc>
 511bece:	4602      	mov	r2, r0
 511bed0:	6270      	str	r0, [r6, #36]	; 0x24
 511bed2:	b928      	cbnz	r0, 511bee0 <__pow5mult+0x40>
 511bed4:	4b1d      	ldr	r3, [pc, #116]	; (511bf4c <__pow5mult+0xac>)
 511bed6:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 511beda:	481d      	ldr	r0, [pc, #116]	; (511bf50 <__pow5mult+0xb0>)
 511bedc:	f000 fdb4 	bl	511ca48 <__assert_func>
 511bee0:	e9c0 4401 	strd	r4, r4, [r0, #4]
 511bee4:	6004      	str	r4, [r0, #0]
 511bee6:	60c4      	str	r4, [r0, #12]
 511bee8:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
 511beec:	f8d8 4008 	ldr.w	r4, [r8, #8]
 511bef0:	b94c      	cbnz	r4, 511bf06 <__pow5mult+0x66>
 511bef2:	4630      	mov	r0, r6
 511bef4:	f240 2171 	movw	r1, #625	; 0x271
 511bef8:	f7ff ff12 	bl	511bd20 <__i2b>
 511befc:	4604      	mov	r4, r0
 511befe:	2300      	movs	r3, #0
 511bf00:	f8c8 0008 	str.w	r0, [r8, #8]
 511bf04:	6003      	str	r3, [r0, #0]
 511bf06:	f04f 0900 	mov.w	r9, #0
 511bf0a:	07eb      	lsls	r3, r5, #31
 511bf0c:	d50a      	bpl.n	511bf24 <__pow5mult+0x84>
 511bf0e:	4639      	mov	r1, r7
 511bf10:	4622      	mov	r2, r4
 511bf12:	4630      	mov	r0, r6
 511bf14:	f7ff ff1a 	bl	511bd4c <__multiply>
 511bf18:	4680      	mov	r8, r0
 511bf1a:	4639      	mov	r1, r7
 511bf1c:	4647      	mov	r7, r8
 511bf1e:	4630      	mov	r0, r6
 511bf20:	f7ff fe46 	bl	511bbb0 <_Bfree>
 511bf24:	106d      	asrs	r5, r5, #1
 511bf26:	d00b      	beq.n	511bf40 <__pow5mult+0xa0>
 511bf28:	6820      	ldr	r0, [r4, #0]
 511bf2a:	b938      	cbnz	r0, 511bf3c <__pow5mult+0x9c>
 511bf2c:	4622      	mov	r2, r4
 511bf2e:	4621      	mov	r1, r4
 511bf30:	4630      	mov	r0, r6
 511bf32:	f7ff ff0b 	bl	511bd4c <__multiply>
 511bf36:	6020      	str	r0, [r4, #0]
 511bf38:	f8c0 9000 	str.w	r9, [r0]
 511bf3c:	4604      	mov	r4, r0
 511bf3e:	e7e4      	b.n	511bf0a <__pow5mult+0x6a>
 511bf40:	4638      	mov	r0, r7
 511bf42:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 511bf46:	bf00      	nop
 511bf48:	0512e110 	.word	0x0512e110
 511bf4c:	0512de96 	.word	0x0512de96
 511bf50:	0512dfa0 	.word	0x0512dfa0

0511bf54 <__lshift>:
 511bf54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 511bf58:	460c      	mov	r4, r1
 511bf5a:	6849      	ldr	r1, [r1, #4]
 511bf5c:	4607      	mov	r7, r0
 511bf5e:	4691      	mov	r9, r2
 511bf60:	6923      	ldr	r3, [r4, #16]
 511bf62:	ea4f 1a62 	mov.w	sl, r2, asr #5
 511bf66:	eb03 1862 	add.w	r8, r3, r2, asr #5
 511bf6a:	68a3      	ldr	r3, [r4, #8]
 511bf6c:	f108 0601 	add.w	r6, r8, #1
 511bf70:	42b3      	cmp	r3, r6
 511bf72:	db0b      	blt.n	511bf8c <__lshift+0x38>
 511bf74:	4638      	mov	r0, r7
 511bf76:	f7ff fddb 	bl	511bb30 <_Balloc>
 511bf7a:	4605      	mov	r5, r0
 511bf7c:	b948      	cbnz	r0, 511bf92 <__lshift+0x3e>
 511bf7e:	4602      	mov	r2, r0
 511bf80:	4b2a      	ldr	r3, [pc, #168]	; (511c02c <__lshift+0xd8>)
 511bf82:	482b      	ldr	r0, [pc, #172]	; (511c030 <__lshift+0xdc>)
 511bf84:	f240 11d9 	movw	r1, #473	; 0x1d9
 511bf88:	f000 fd5e 	bl	511ca48 <__assert_func>
 511bf8c:	3101      	adds	r1, #1
 511bf8e:	005b      	lsls	r3, r3, #1
 511bf90:	e7ee      	b.n	511bf70 <__lshift+0x1c>
 511bf92:	2300      	movs	r3, #0
 511bf94:	f100 0114 	add.w	r1, r0, #20
 511bf98:	f100 0210 	add.w	r2, r0, #16
 511bf9c:	4618      	mov	r0, r3
 511bf9e:	4553      	cmp	r3, sl
 511bfa0:	db37      	blt.n	511c012 <__lshift+0xbe>
 511bfa2:	6920      	ldr	r0, [r4, #16]
 511bfa4:	ea2a 7aea 	bic.w	sl, sl, sl, asr #31
 511bfa8:	f104 0314 	add.w	r3, r4, #20
 511bfac:	f019 091f 	ands.w	r9, r9, #31
 511bfb0:	eb01 018a 	add.w	r1, r1, sl, lsl #2
 511bfb4:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 511bfb8:	d02f      	beq.n	511c01a <__lshift+0xc6>
 511bfba:	f1c9 0e20 	rsb	lr, r9, #32
 511bfbe:	468a      	mov	sl, r1
 511bfc0:	f04f 0c00 	mov.w	ip, #0
 511bfc4:	681a      	ldr	r2, [r3, #0]
 511bfc6:	fa02 f209 	lsl.w	r2, r2, r9
 511bfca:	ea42 020c 	orr.w	r2, r2, ip
 511bfce:	f84a 2b04 	str.w	r2, [sl], #4
 511bfd2:	f853 2b04 	ldr.w	r2, [r3], #4
 511bfd6:	4298      	cmp	r0, r3
 511bfd8:	fa22 fc0e 	lsr.w	ip, r2, lr
 511bfdc:	d8f2      	bhi.n	511bfc4 <__lshift+0x70>
 511bfde:	1b03      	subs	r3, r0, r4
 511bfe0:	f104 0215 	add.w	r2, r4, #21
 511bfe4:	3b15      	subs	r3, #21
 511bfe6:	f023 0303 	bic.w	r3, r3, #3
 511bfea:	3304      	adds	r3, #4
 511bfec:	4290      	cmp	r0, r2
 511bfee:	bf38      	it	cc
 511bff0:	2304      	movcc	r3, #4
 511bff2:	f841 c003 	str.w	ip, [r1, r3]
 511bff6:	f1bc 0f00 	cmp.w	ip, #0
 511bffa:	d001      	beq.n	511c000 <__lshift+0xac>
 511bffc:	f108 0602 	add.w	r6, r8, #2
 511c000:	4638      	mov	r0, r7
 511c002:	3e01      	subs	r6, #1
 511c004:	4621      	mov	r1, r4
 511c006:	612e      	str	r6, [r5, #16]
 511c008:	f7ff fdd2 	bl	511bbb0 <_Bfree>
 511c00c:	4628      	mov	r0, r5
 511c00e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 511c012:	3301      	adds	r3, #1
 511c014:	f842 0f04 	str.w	r0, [r2, #4]!
 511c018:	e7c1      	b.n	511bf9e <__lshift+0x4a>
 511c01a:	3904      	subs	r1, #4
 511c01c:	f853 2b04 	ldr.w	r2, [r3], #4
 511c020:	f841 2f04 	str.w	r2, [r1, #4]!
 511c024:	4298      	cmp	r0, r3
 511c026:	d8f9      	bhi.n	511c01c <__lshift+0xc8>
 511c028:	e7ea      	b.n	511c000 <__lshift+0xac>
 511c02a:	bf00      	nop
 511c02c:	0512df2a 	.word	0x0512df2a
 511c030:	0512dfa0 	.word	0x0512dfa0

0511c034 <__mcmp>:
 511c034:	6902      	ldr	r2, [r0, #16]
 511c036:	b530      	push	{r4, r5, lr}
 511c038:	690c      	ldr	r4, [r1, #16]
 511c03a:	1b12      	subs	r2, r2, r4
 511c03c:	d10e      	bne.n	511c05c <__mcmp+0x28>
 511c03e:	f100 0314 	add.w	r3, r0, #20
 511c042:	3114      	adds	r1, #20
 511c044:	eb03 0084 	add.w	r0, r3, r4, lsl #2
 511c048:	eb01 0184 	add.w	r1, r1, r4, lsl #2
 511c04c:	f850 5d04 	ldr.w	r5, [r0, #-4]!
 511c050:	f851 4d04 	ldr.w	r4, [r1, #-4]!
 511c054:	42a5      	cmp	r5, r4
 511c056:	d003      	beq.n	511c060 <__mcmp+0x2c>
 511c058:	d305      	bcc.n	511c066 <__mcmp+0x32>
 511c05a:	2201      	movs	r2, #1
 511c05c:	4610      	mov	r0, r2
 511c05e:	bd30      	pop	{r4, r5, pc}
 511c060:	4283      	cmp	r3, r0
 511c062:	d3f3      	bcc.n	511c04c <__mcmp+0x18>
 511c064:	e7fa      	b.n	511c05c <__mcmp+0x28>
 511c066:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 511c06a:	e7f7      	b.n	511c05c <__mcmp+0x28>

0511c06c <__mdiff>:
 511c06c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511c070:	460c      	mov	r4, r1
 511c072:	4606      	mov	r6, r0
 511c074:	4611      	mov	r1, r2
 511c076:	4620      	mov	r0, r4
 511c078:	4692      	mov	sl, r2
 511c07a:	f7ff ffdb 	bl	511c034 <__mcmp>
 511c07e:	1e05      	subs	r5, r0, #0
 511c080:	d110      	bne.n	511c0a4 <__mdiff+0x38>
 511c082:	4629      	mov	r1, r5
 511c084:	4630      	mov	r0, r6
 511c086:	f7ff fd53 	bl	511bb30 <_Balloc>
 511c08a:	b930      	cbnz	r0, 511c09a <__mdiff+0x2e>
 511c08c:	4b3c      	ldr	r3, [pc, #240]	; (511c180 <__mdiff+0x114>)
 511c08e:	4602      	mov	r2, r0
 511c090:	f240 2132 	movw	r1, #562	; 0x232
 511c094:	483b      	ldr	r0, [pc, #236]	; (511c184 <__mdiff+0x118>)
 511c096:	f000 fcd7 	bl	511ca48 <__assert_func>
 511c09a:	2301      	movs	r3, #1
 511c09c:	e9c0 3504 	strd	r3, r5, [r0, #16]
 511c0a0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511c0a4:	bfa4      	itt	ge
 511c0a6:	4653      	movge	r3, sl
 511c0a8:	46a2      	movge	sl, r4
 511c0aa:	4630      	mov	r0, r6
 511c0ac:	bfa6      	itte	ge
 511c0ae:	461c      	movge	r4, r3
 511c0b0:	2500      	movge	r5, #0
 511c0b2:	2501      	movlt	r5, #1
 511c0b4:	f8da 1004 	ldr.w	r1, [sl, #4]
 511c0b8:	f7ff fd3a 	bl	511bb30 <_Balloc>
 511c0bc:	b920      	cbnz	r0, 511c0c8 <__mdiff+0x5c>
 511c0be:	4b30      	ldr	r3, [pc, #192]	; (511c180 <__mdiff+0x114>)
 511c0c0:	4602      	mov	r2, r0
 511c0c2:	f44f 7110 	mov.w	r1, #576	; 0x240
 511c0c6:	e7e5      	b.n	511c094 <__mdiff+0x28>
 511c0c8:	f8da 7010 	ldr.w	r7, [sl, #16]
 511c0cc:	f104 0914 	add.w	r9, r4, #20
 511c0d0:	6926      	ldr	r6, [r4, #16]
 511c0d2:	f100 0814 	add.w	r8, r0, #20
 511c0d6:	60c5      	str	r5, [r0, #12]
 511c0d8:	f10a 0514 	add.w	r5, sl, #20
 511c0dc:	f10a 0210 	add.w	r2, sl, #16
 511c0e0:	eb05 0e87 	add.w	lr, r5, r7, lsl #2
 511c0e4:	eb09 0686 	add.w	r6, r9, r6, lsl #2
 511c0e8:	46c2      	mov	sl, r8
 511c0ea:	f04f 0c00 	mov.w	ip, #0
 511c0ee:	f852 bf04 	ldr.w	fp, [r2, #4]!
 511c0f2:	f859 3b04 	ldr.w	r3, [r9], #4
 511c0f6:	fa1f f18b 	uxth.w	r1, fp
 511c0fa:	454e      	cmp	r6, r9
 511c0fc:	448c      	add	ip, r1
 511c0fe:	b299      	uxth	r1, r3
 511c100:	ebac 0101 	sub.w	r1, ip, r1
 511c104:	ea4f 4313 	mov.w	r3, r3, lsr #16
 511c108:	ebc3 431b 	rsb	r3, r3, fp, lsr #16
 511c10c:	eb03 4321 	add.w	r3, r3, r1, asr #16
 511c110:	b289      	uxth	r1, r1
 511c112:	ea4f 4c23 	mov.w	ip, r3, asr #16
 511c116:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
 511c11a:	f84a 3b04 	str.w	r3, [sl], #4
 511c11e:	d8e6      	bhi.n	511c0ee <__mdiff+0x82>
 511c120:	1b33      	subs	r3, r6, r4
 511c122:	3415      	adds	r4, #21
 511c124:	3b15      	subs	r3, #21
 511c126:	f023 0303 	bic.w	r3, r3, #3
 511c12a:	3304      	adds	r3, #4
 511c12c:	42a6      	cmp	r6, r4
 511c12e:	bf38      	it	cc
 511c130:	2304      	movcc	r3, #4
 511c132:	441d      	add	r5, r3
 511c134:	4443      	add	r3, r8
 511c136:	461e      	mov	r6, r3
 511c138:	462c      	mov	r4, r5
 511c13a:	4574      	cmp	r4, lr
 511c13c:	d30e      	bcc.n	511c15c <__mdiff+0xf0>
 511c13e:	f10e 0203 	add.w	r2, lr, #3
 511c142:	1b52      	subs	r2, r2, r5
 511c144:	3d03      	subs	r5, #3
 511c146:	f022 0203 	bic.w	r2, r2, #3
 511c14a:	45ae      	cmp	lr, r5
 511c14c:	bf38      	it	cc
 511c14e:	2200      	movcc	r2, #0
 511c150:	441a      	add	r2, r3
 511c152:	f852 3d04 	ldr.w	r3, [r2, #-4]!
 511c156:	b18b      	cbz	r3, 511c17c <__mdiff+0x110>
 511c158:	6107      	str	r7, [r0, #16]
 511c15a:	e7a1      	b.n	511c0a0 <__mdiff+0x34>
 511c15c:	f854 8b04 	ldr.w	r8, [r4], #4
 511c160:	fa1f f288 	uxth.w	r2, r8
 511c164:	4462      	add	r2, ip
 511c166:	1411      	asrs	r1, r2, #16
 511c168:	b292      	uxth	r2, r2
 511c16a:	eb01 4118 	add.w	r1, r1, r8, lsr #16
 511c16e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 511c172:	ea4f 4c21 	mov.w	ip, r1, asr #16
 511c176:	f846 2b04 	str.w	r2, [r6], #4
 511c17a:	e7de      	b.n	511c13a <__mdiff+0xce>
 511c17c:	3f01      	subs	r7, #1
 511c17e:	e7e8      	b.n	511c152 <__mdiff+0xe6>
 511c180:	0512df2a 	.word	0x0512df2a
 511c184:	0512dfa0 	.word	0x0512dfa0

0511c188 <__d2b>:
 511c188:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 511c18c:	4689      	mov	r9, r1
 511c18e:	2101      	movs	r1, #1
 511c190:	ec57 6b10 	vmov	r6, r7, d0
 511c194:	4690      	mov	r8, r2
 511c196:	f7ff fccb 	bl	511bb30 <_Balloc>
 511c19a:	4604      	mov	r4, r0
 511c19c:	b930      	cbnz	r0, 511c1ac <__d2b+0x24>
 511c19e:	4602      	mov	r2, r0
 511c1a0:	4b25      	ldr	r3, [pc, #148]	; (511c238 <__d2b+0xb0>)
 511c1a2:	4826      	ldr	r0, [pc, #152]	; (511c23c <__d2b+0xb4>)
 511c1a4:	f240 310a 	movw	r1, #778	; 0x30a
 511c1a8:	f000 fc4e 	bl	511ca48 <__assert_func>
 511c1ac:	f3c7 0313 	ubfx	r3, r7, #0, #20
 511c1b0:	f3c7 550a 	ubfx	r5, r7, #20, #11
 511c1b4:	bb35      	cbnz	r5, 511c204 <__d2b+0x7c>
 511c1b6:	2e00      	cmp	r6, #0
 511c1b8:	9301      	str	r3, [sp, #4]
 511c1ba:	d028      	beq.n	511c20e <__d2b+0x86>
 511c1bc:	4668      	mov	r0, sp
 511c1be:	9600      	str	r6, [sp, #0]
 511c1c0:	f7ff fd80 	bl	511bcc4 <__lo0bits>
 511c1c4:	9900      	ldr	r1, [sp, #0]
 511c1c6:	b300      	cbz	r0, 511c20a <__d2b+0x82>
 511c1c8:	9a01      	ldr	r2, [sp, #4]
 511c1ca:	f1c0 0320 	rsb	r3, r0, #32
 511c1ce:	fa02 f303 	lsl.w	r3, r2, r3
 511c1d2:	430b      	orrs	r3, r1
 511c1d4:	40c2      	lsrs	r2, r0
 511c1d6:	6163      	str	r3, [r4, #20]
 511c1d8:	9201      	str	r2, [sp, #4]
 511c1da:	9b01      	ldr	r3, [sp, #4]
 511c1dc:	61a3      	str	r3, [r4, #24]
 511c1de:	2b00      	cmp	r3, #0
 511c1e0:	bf14      	ite	ne
 511c1e2:	2202      	movne	r2, #2
 511c1e4:	2201      	moveq	r2, #1
 511c1e6:	6122      	str	r2, [r4, #16]
 511c1e8:	b1d5      	cbz	r5, 511c220 <__d2b+0x98>
 511c1ea:	f2a5 4533 	subw	r5, r5, #1075	; 0x433
 511c1ee:	4405      	add	r5, r0
 511c1f0:	f1c0 0035 	rsb	r0, r0, #53	; 0x35
 511c1f4:	f8c9 5000 	str.w	r5, [r9]
 511c1f8:	f8c8 0000 	str.w	r0, [r8]
 511c1fc:	4620      	mov	r0, r4
 511c1fe:	b003      	add	sp, #12
 511c200:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 511c204:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 511c208:	e7d5      	b.n	511c1b6 <__d2b+0x2e>
 511c20a:	6161      	str	r1, [r4, #20]
 511c20c:	e7e5      	b.n	511c1da <__d2b+0x52>
 511c20e:	a801      	add	r0, sp, #4
 511c210:	f7ff fd58 	bl	511bcc4 <__lo0bits>
 511c214:	9b01      	ldr	r3, [sp, #4]
 511c216:	2201      	movs	r2, #1
 511c218:	3020      	adds	r0, #32
 511c21a:	6163      	str	r3, [r4, #20]
 511c21c:	6122      	str	r2, [r4, #16]
 511c21e:	e7e3      	b.n	511c1e8 <__d2b+0x60>
 511c220:	eb04 0382 	add.w	r3, r4, r2, lsl #2
 511c224:	f2a0 4032 	subw	r0, r0, #1074	; 0x432
 511c228:	f8c9 0000 	str.w	r0, [r9]
 511c22c:	6918      	ldr	r0, [r3, #16]
 511c22e:	f7ff fd29 	bl	511bc84 <__hi0bits>
 511c232:	ebc0 1042 	rsb	r0, r0, r2, lsl #5
 511c236:	e7df      	b.n	511c1f8 <__d2b+0x70>
 511c238:	0512df2a 	.word	0x0512df2a
 511c23c:	0512dfa0 	.word	0x0512dfa0

0511c240 <_calloc_r>:
 511c240:	434a      	muls	r2, r1
 511c242:	b513      	push	{r0, r1, r4, lr}
 511c244:	4611      	mov	r1, r2
 511c246:	9201      	str	r2, [sp, #4]
 511c248:	f000 f856 	bl	511c2f8 <_malloc_r>
 511c24c:	4604      	mov	r4, r0
 511c24e:	b118      	cbz	r0, 511c258 <_calloc_r+0x18>
 511c250:	9a01      	ldr	r2, [sp, #4]
 511c252:	2100      	movs	r1, #0
 511c254:	f7fd fd31 	bl	5119cba <memset>
 511c258:	4620      	mov	r0, r4
 511c25a:	b002      	add	sp, #8
 511c25c:	bd10      	pop	{r4, pc}
	...

0511c260 <_free_r>:
 511c260:	b537      	push	{r0, r1, r2, r4, r5, lr}
 511c262:	2900      	cmp	r1, #0
 511c264:	d043      	beq.n	511c2ee <_free_r+0x8e>
 511c266:	f851 3c04 	ldr.w	r3, [r1, #-4]
 511c26a:	1f0c      	subs	r4, r1, #4
 511c26c:	9001      	str	r0, [sp, #4]
 511c26e:	2b00      	cmp	r3, #0
 511c270:	bfb8      	it	lt
 511c272:	18e4      	addlt	r4, r4, r3
 511c274:	f000 fc88 	bl	511cb88 <__malloc_lock>
 511c278:	4a1e      	ldr	r2, [pc, #120]	; (511c2f4 <_free_r+0x94>)
 511c27a:	9801      	ldr	r0, [sp, #4]
 511c27c:	6813      	ldr	r3, [r2, #0]
 511c27e:	b933      	cbnz	r3, 511c28e <_free_r+0x2e>
 511c280:	6063      	str	r3, [r4, #4]
 511c282:	6014      	str	r4, [r2, #0]
 511c284:	b003      	add	sp, #12
 511c286:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 511c28a:	f000 bc83 	b.w	511cb94 <__malloc_unlock>
 511c28e:	42a3      	cmp	r3, r4
 511c290:	d908      	bls.n	511c2a4 <_free_r+0x44>
 511c292:	6825      	ldr	r5, [r4, #0]
 511c294:	1961      	adds	r1, r4, r5
 511c296:	428b      	cmp	r3, r1
 511c298:	bf01      	itttt	eq
 511c29a:	6819      	ldreq	r1, [r3, #0]
 511c29c:	685b      	ldreq	r3, [r3, #4]
 511c29e:	1949      	addeq	r1, r1, r5
 511c2a0:	6021      	streq	r1, [r4, #0]
 511c2a2:	e7ed      	b.n	511c280 <_free_r+0x20>
 511c2a4:	461a      	mov	r2, r3
 511c2a6:	685b      	ldr	r3, [r3, #4]
 511c2a8:	b10b      	cbz	r3, 511c2ae <_free_r+0x4e>
 511c2aa:	42a3      	cmp	r3, r4
 511c2ac:	d9fa      	bls.n	511c2a4 <_free_r+0x44>
 511c2ae:	6811      	ldr	r1, [r2, #0]
 511c2b0:	1855      	adds	r5, r2, r1
 511c2b2:	42a5      	cmp	r5, r4
 511c2b4:	d10b      	bne.n	511c2ce <_free_r+0x6e>
 511c2b6:	6824      	ldr	r4, [r4, #0]
 511c2b8:	4421      	add	r1, r4
 511c2ba:	6011      	str	r1, [r2, #0]
 511c2bc:	1854      	adds	r4, r2, r1
 511c2be:	42a3      	cmp	r3, r4
 511c2c0:	d1e0      	bne.n	511c284 <_free_r+0x24>
 511c2c2:	681c      	ldr	r4, [r3, #0]
 511c2c4:	685b      	ldr	r3, [r3, #4]
 511c2c6:	4421      	add	r1, r4
 511c2c8:	6053      	str	r3, [r2, #4]
 511c2ca:	6011      	str	r1, [r2, #0]
 511c2cc:	e7da      	b.n	511c284 <_free_r+0x24>
 511c2ce:	d902      	bls.n	511c2d6 <_free_r+0x76>
 511c2d0:	230c      	movs	r3, #12
 511c2d2:	6003      	str	r3, [r0, #0]
 511c2d4:	e7d6      	b.n	511c284 <_free_r+0x24>
 511c2d6:	6825      	ldr	r5, [r4, #0]
 511c2d8:	1961      	adds	r1, r4, r5
 511c2da:	428b      	cmp	r3, r1
 511c2dc:	bf02      	ittt	eq
 511c2de:	6819      	ldreq	r1, [r3, #0]
 511c2e0:	685b      	ldreq	r3, [r3, #4]
 511c2e2:	1949      	addeq	r1, r1, r5
 511c2e4:	6063      	str	r3, [r4, #4]
 511c2e6:	bf08      	it	eq
 511c2e8:	6021      	streq	r1, [r4, #0]
 511c2ea:	6054      	str	r4, [r2, #4]
 511c2ec:	e7ca      	b.n	511c284 <_free_r+0x24>
 511c2ee:	b003      	add	sp, #12
 511c2f0:	bd30      	pop	{r4, r5, pc}
 511c2f2:	bf00      	nop
 511c2f4:	05138700 	.word	0x05138700

0511c2f8 <_malloc_r>:
 511c2f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 511c2fa:	1ccd      	adds	r5, r1, #3
 511c2fc:	f025 0503 	bic.w	r5, r5, #3
 511c300:	3508      	adds	r5, #8
 511c302:	4606      	mov	r6, r0
 511c304:	2d0c      	cmp	r5, #12
 511c306:	bf38      	it	cc
 511c308:	250c      	movcc	r5, #12
 511c30a:	2d00      	cmp	r5, #0
 511c30c:	db01      	blt.n	511c312 <_malloc_r+0x1a>
 511c30e:	42a9      	cmp	r1, r5
 511c310:	d903      	bls.n	511c31a <_malloc_r+0x22>
 511c312:	230c      	movs	r3, #12
 511c314:	6033      	str	r3, [r6, #0]
 511c316:	2000      	movs	r0, #0
 511c318:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 511c31a:	f000 fc35 	bl	511cb88 <__malloc_lock>
 511c31e:	4921      	ldr	r1, [pc, #132]	; (511c3a4 <_malloc_r+0xac>)
 511c320:	680a      	ldr	r2, [r1, #0]
 511c322:	4614      	mov	r4, r2
 511c324:	b99c      	cbnz	r4, 511c34e <_malloc_r+0x56>
 511c326:	4f20      	ldr	r7, [pc, #128]	; (511c3a8 <_malloc_r+0xb0>)
 511c328:	683b      	ldr	r3, [r7, #0]
 511c32a:	b923      	cbnz	r3, 511c336 <_malloc_r+0x3e>
 511c32c:	4621      	mov	r1, r4
 511c32e:	4630      	mov	r0, r6
 511c330:	f000 faf2 	bl	511c918 <_sbrk_r>
 511c334:	6038      	str	r0, [r7, #0]
 511c336:	4629      	mov	r1, r5
 511c338:	4630      	mov	r0, r6
 511c33a:	f000 faed 	bl	511c918 <_sbrk_r>
 511c33e:	1c43      	adds	r3, r0, #1
 511c340:	d123      	bne.n	511c38a <_malloc_r+0x92>
 511c342:	230c      	movs	r3, #12
 511c344:	4630      	mov	r0, r6
 511c346:	6033      	str	r3, [r6, #0]
 511c348:	f000 fc24 	bl	511cb94 <__malloc_unlock>
 511c34c:	e7e3      	b.n	511c316 <_malloc_r+0x1e>
 511c34e:	6823      	ldr	r3, [r4, #0]
 511c350:	1b5b      	subs	r3, r3, r5
 511c352:	d417      	bmi.n	511c384 <_malloc_r+0x8c>
 511c354:	2b0b      	cmp	r3, #11
 511c356:	d903      	bls.n	511c360 <_malloc_r+0x68>
 511c358:	6023      	str	r3, [r4, #0]
 511c35a:	441c      	add	r4, r3
 511c35c:	6025      	str	r5, [r4, #0]
 511c35e:	e004      	b.n	511c36a <_malloc_r+0x72>
 511c360:	6863      	ldr	r3, [r4, #4]
 511c362:	42a2      	cmp	r2, r4
 511c364:	bf0c      	ite	eq
 511c366:	600b      	streq	r3, [r1, #0]
 511c368:	6053      	strne	r3, [r2, #4]
 511c36a:	4630      	mov	r0, r6
 511c36c:	f000 fc12 	bl	511cb94 <__malloc_unlock>
 511c370:	f104 000b 	add.w	r0, r4, #11
 511c374:	1d23      	adds	r3, r4, #4
 511c376:	f020 0007 	bic.w	r0, r0, #7
 511c37a:	1ac2      	subs	r2, r0, r3
 511c37c:	d0cc      	beq.n	511c318 <_malloc_r+0x20>
 511c37e:	1a1b      	subs	r3, r3, r0
 511c380:	50a3      	str	r3, [r4, r2]
 511c382:	e7c9      	b.n	511c318 <_malloc_r+0x20>
 511c384:	4622      	mov	r2, r4
 511c386:	6864      	ldr	r4, [r4, #4]
 511c388:	e7cc      	b.n	511c324 <_malloc_r+0x2c>
 511c38a:	1cc4      	adds	r4, r0, #3
 511c38c:	f024 0403 	bic.w	r4, r4, #3
 511c390:	42a0      	cmp	r0, r4
 511c392:	d0e3      	beq.n	511c35c <_malloc_r+0x64>
 511c394:	1a21      	subs	r1, r4, r0
 511c396:	4630      	mov	r0, r6
 511c398:	f000 fabe 	bl	511c918 <_sbrk_r>
 511c39c:	3001      	adds	r0, #1
 511c39e:	d1dd      	bne.n	511c35c <_malloc_r+0x64>
 511c3a0:	e7cf      	b.n	511c342 <_malloc_r+0x4a>
 511c3a2:	bf00      	nop
 511c3a4:	05138700 	.word	0x05138700
 511c3a8:	05138704 	.word	0x05138704

0511c3ac <__ssputs_r>:
 511c3ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 511c3b0:	4682      	mov	sl, r0
 511c3b2:	688e      	ldr	r6, [r1, #8]
 511c3b4:	460c      	mov	r4, r1
 511c3b6:	4690      	mov	r8, r2
 511c3b8:	461f      	mov	r7, r3
 511c3ba:	429e      	cmp	r6, r3
 511c3bc:	d838      	bhi.n	511c430 <__ssputs_r+0x84>
 511c3be:	898a      	ldrh	r2, [r1, #12]
 511c3c0:	f412 6f90 	tst.w	r2, #1152	; 0x480
 511c3c4:	d032      	beq.n	511c42c <__ssputs_r+0x80>
 511c3c6:	6825      	ldr	r5, [r4, #0]
 511c3c8:	3301      	adds	r3, #1
 511c3ca:	6909      	ldr	r1, [r1, #16]
 511c3cc:	eba5 0901 	sub.w	r9, r5, r1
 511c3d0:	6965      	ldr	r5, [r4, #20]
 511c3d2:	444b      	add	r3, r9
 511c3d4:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 511c3d8:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
 511c3dc:	106d      	asrs	r5, r5, #1
 511c3de:	429d      	cmp	r5, r3
 511c3e0:	bf38      	it	cc
 511c3e2:	461d      	movcc	r5, r3
 511c3e4:	0553      	lsls	r3, r2, #21
 511c3e6:	d531      	bpl.n	511c44c <__ssputs_r+0xa0>
 511c3e8:	4629      	mov	r1, r5
 511c3ea:	f7ff ff85 	bl	511c2f8 <_malloc_r>
 511c3ee:	4606      	mov	r6, r0
 511c3f0:	b950      	cbnz	r0, 511c408 <__ssputs_r+0x5c>
 511c3f2:	230c      	movs	r3, #12
 511c3f4:	f8ca 3000 	str.w	r3, [sl]
 511c3f8:	89a3      	ldrh	r3, [r4, #12]
 511c3fa:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511c3fe:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 511c402:	81a3      	strh	r3, [r4, #12]
 511c404:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 511c408:	6921      	ldr	r1, [r4, #16]
 511c40a:	464a      	mov	r2, r9
 511c40c:	f7fd fc48 	bl	5119ca0 <memcpy>
 511c410:	89a3      	ldrh	r3, [r4, #12]
 511c412:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 511c416:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 511c41a:	81a3      	strh	r3, [r4, #12]
 511c41c:	6126      	str	r6, [r4, #16]
 511c41e:	444e      	add	r6, r9
 511c420:	6026      	str	r6, [r4, #0]
 511c422:	463e      	mov	r6, r7
 511c424:	6165      	str	r5, [r4, #20]
 511c426:	eba5 0509 	sub.w	r5, r5, r9
 511c42a:	60a5      	str	r5, [r4, #8]
 511c42c:	42be      	cmp	r6, r7
 511c42e:	d900      	bls.n	511c432 <__ssputs_r+0x86>
 511c430:	463e      	mov	r6, r7
 511c432:	6820      	ldr	r0, [r4, #0]
 511c434:	4632      	mov	r2, r6
 511c436:	4641      	mov	r1, r8
 511c438:	f000 fb8c 	bl	511cb54 <memmove>
 511c43c:	68a3      	ldr	r3, [r4, #8]
 511c43e:	2000      	movs	r0, #0
 511c440:	1b9b      	subs	r3, r3, r6
 511c442:	60a3      	str	r3, [r4, #8]
 511c444:	6823      	ldr	r3, [r4, #0]
 511c446:	4433      	add	r3, r6
 511c448:	6023      	str	r3, [r4, #0]
 511c44a:	e7db      	b.n	511c404 <__ssputs_r+0x58>
 511c44c:	462a      	mov	r2, r5
 511c44e:	f000 fba7 	bl	511cba0 <_realloc_r>
 511c452:	4606      	mov	r6, r0
 511c454:	2800      	cmp	r0, #0
 511c456:	d1e1      	bne.n	511c41c <__ssputs_r+0x70>
 511c458:	6921      	ldr	r1, [r4, #16]
 511c45a:	4650      	mov	r0, sl
 511c45c:	f7ff ff00 	bl	511c260 <_free_r>
 511c460:	e7c7      	b.n	511c3f2 <__ssputs_r+0x46>
	...

0511c464 <_svfiprintf_r>:
 511c464:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511c468:	4698      	mov	r8, r3
 511c46a:	898b      	ldrh	r3, [r1, #12]
 511c46c:	b09d      	sub	sp, #116	; 0x74
 511c46e:	4607      	mov	r7, r0
 511c470:	460d      	mov	r5, r1
 511c472:	4614      	mov	r4, r2
 511c474:	061b      	lsls	r3, r3, #24
 511c476:	d50e      	bpl.n	511c496 <_svfiprintf_r+0x32>
 511c478:	690b      	ldr	r3, [r1, #16]
 511c47a:	b963      	cbnz	r3, 511c496 <_svfiprintf_r+0x32>
 511c47c:	2140      	movs	r1, #64	; 0x40
 511c47e:	f7ff ff3b 	bl	511c2f8 <_malloc_r>
 511c482:	6028      	str	r0, [r5, #0]
 511c484:	6128      	str	r0, [r5, #16]
 511c486:	b920      	cbnz	r0, 511c492 <_svfiprintf_r+0x2e>
 511c488:	230c      	movs	r3, #12
 511c48a:	603b      	str	r3, [r7, #0]
 511c48c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511c490:	e0d1      	b.n	511c636 <_svfiprintf_r+0x1d2>
 511c492:	2340      	movs	r3, #64	; 0x40
 511c494:	616b      	str	r3, [r5, #20]
 511c496:	f8cd 800c 	str.w	r8, [sp, #12]
 511c49a:	f04f 0901 	mov.w	r9, #1
 511c49e:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 511c650 <_svfiprintf_r+0x1ec>
 511c4a2:	2300      	movs	r3, #0
 511c4a4:	9309      	str	r3, [sp, #36]	; 0x24
 511c4a6:	2320      	movs	r3, #32
 511c4a8:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 511c4ac:	2330      	movs	r3, #48	; 0x30
 511c4ae:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 511c4b2:	4623      	mov	r3, r4
 511c4b4:	469a      	mov	sl, r3
 511c4b6:	f813 2b01 	ldrb.w	r2, [r3], #1
 511c4ba:	b10a      	cbz	r2, 511c4c0 <_svfiprintf_r+0x5c>
 511c4bc:	2a25      	cmp	r2, #37	; 0x25
 511c4be:	d1f9      	bne.n	511c4b4 <_svfiprintf_r+0x50>
 511c4c0:	ebba 0b04 	subs.w	fp, sl, r4
 511c4c4:	d00b      	beq.n	511c4de <_svfiprintf_r+0x7a>
 511c4c6:	465b      	mov	r3, fp
 511c4c8:	4622      	mov	r2, r4
 511c4ca:	4629      	mov	r1, r5
 511c4cc:	4638      	mov	r0, r7
 511c4ce:	f7ff ff6d 	bl	511c3ac <__ssputs_r>
 511c4d2:	3001      	adds	r0, #1
 511c4d4:	f000 80aa 	beq.w	511c62c <_svfiprintf_r+0x1c8>
 511c4d8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 511c4da:	445a      	add	r2, fp
 511c4dc:	9209      	str	r2, [sp, #36]	; 0x24
 511c4de:	f89a 3000 	ldrb.w	r3, [sl]
 511c4e2:	2b00      	cmp	r3, #0
 511c4e4:	f000 80a2 	beq.w	511c62c <_svfiprintf_r+0x1c8>
 511c4e8:	f10a 0a01 	add.w	sl, sl, #1
 511c4ec:	2300      	movs	r3, #0
 511c4ee:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 511c4f2:	9304      	str	r3, [sp, #16]
 511c4f4:	9307      	str	r3, [sp, #28]
 511c4f6:	e9cd 2305 	strd	r2, r3, [sp, #20]
 511c4fa:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 511c4fe:	931a      	str	r3, [sp, #104]	; 0x68
 511c500:	4654      	mov	r4, sl
 511c502:	2205      	movs	r2, #5
 511c504:	4852      	ldr	r0, [pc, #328]	; (511c650 <_svfiprintf_r+0x1ec>)
 511c506:	f814 1b01 	ldrb.w	r1, [r4], #1
 511c50a:	f7fd fbbb 	bl	5119c84 <memchr>
 511c50e:	9a04      	ldr	r2, [sp, #16]
 511c510:	b9d8      	cbnz	r0, 511c54a <_svfiprintf_r+0xe6>
 511c512:	06d0      	lsls	r0, r2, #27
 511c514:	bf44      	itt	mi
 511c516:	2320      	movmi	r3, #32
 511c518:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 511c51c:	0711      	lsls	r1, r2, #28
 511c51e:	bf44      	itt	mi
 511c520:	232b      	movmi	r3, #43	; 0x2b
 511c522:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 511c526:	f89a 3000 	ldrb.w	r3, [sl]
 511c52a:	2b2a      	cmp	r3, #42	; 0x2a
 511c52c:	d015      	beq.n	511c55a <_svfiprintf_r+0xf6>
 511c52e:	9a07      	ldr	r2, [sp, #28]
 511c530:	4654      	mov	r4, sl
 511c532:	2000      	movs	r0, #0
 511c534:	f04f 0c0a 	mov.w	ip, #10
 511c538:	4621      	mov	r1, r4
 511c53a:	f811 3b01 	ldrb.w	r3, [r1], #1
 511c53e:	3b30      	subs	r3, #48	; 0x30
 511c540:	2b09      	cmp	r3, #9
 511c542:	d94e      	bls.n	511c5e2 <_svfiprintf_r+0x17e>
 511c544:	b1b0      	cbz	r0, 511c574 <_svfiprintf_r+0x110>
 511c546:	9207      	str	r2, [sp, #28]
 511c548:	e014      	b.n	511c574 <_svfiprintf_r+0x110>
 511c54a:	eba0 0308 	sub.w	r3, r0, r8
 511c54e:	46a2      	mov	sl, r4
 511c550:	fa09 f303 	lsl.w	r3, r9, r3
 511c554:	4313      	orrs	r3, r2
 511c556:	9304      	str	r3, [sp, #16]
 511c558:	e7d2      	b.n	511c500 <_svfiprintf_r+0x9c>
 511c55a:	9b03      	ldr	r3, [sp, #12]
 511c55c:	1d19      	adds	r1, r3, #4
 511c55e:	9103      	str	r1, [sp, #12]
 511c560:	681b      	ldr	r3, [r3, #0]
 511c562:	2b00      	cmp	r3, #0
 511c564:	bfaf      	iteee	ge
 511c566:	9307      	strge	r3, [sp, #28]
 511c568:	425b      	neglt	r3, r3
 511c56a:	f042 0202 	orrlt.w	r2, r2, #2
 511c56e:	9307      	strlt	r3, [sp, #28]
 511c570:	bfb8      	it	lt
 511c572:	9204      	strlt	r2, [sp, #16]
 511c574:	7823      	ldrb	r3, [r4, #0]
 511c576:	2b2e      	cmp	r3, #46	; 0x2e
 511c578:	d10c      	bne.n	511c594 <_svfiprintf_r+0x130>
 511c57a:	7863      	ldrb	r3, [r4, #1]
 511c57c:	2b2a      	cmp	r3, #42	; 0x2a
 511c57e:	d135      	bne.n	511c5ec <_svfiprintf_r+0x188>
 511c580:	9b03      	ldr	r3, [sp, #12]
 511c582:	3402      	adds	r4, #2
 511c584:	1d1a      	adds	r2, r3, #4
 511c586:	9203      	str	r2, [sp, #12]
 511c588:	681b      	ldr	r3, [r3, #0]
 511c58a:	2b00      	cmp	r3, #0
 511c58c:	bfb8      	it	lt
 511c58e:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 511c592:	9305      	str	r3, [sp, #20]
 511c594:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 511c660 <_svfiprintf_r+0x1fc>
 511c598:	2203      	movs	r2, #3
 511c59a:	7821      	ldrb	r1, [r4, #0]
 511c59c:	4650      	mov	r0, sl
 511c59e:	f7fd fb71 	bl	5119c84 <memchr>
 511c5a2:	b140      	cbz	r0, 511c5b6 <_svfiprintf_r+0x152>
 511c5a4:	2340      	movs	r3, #64	; 0x40
 511c5a6:	eba0 000a 	sub.w	r0, r0, sl
 511c5aa:	3401      	adds	r4, #1
 511c5ac:	fa03 f000 	lsl.w	r0, r3, r0
 511c5b0:	9b04      	ldr	r3, [sp, #16]
 511c5b2:	4303      	orrs	r3, r0
 511c5b4:	9304      	str	r3, [sp, #16]
 511c5b6:	f814 1b01 	ldrb.w	r1, [r4], #1
 511c5ba:	2206      	movs	r2, #6
 511c5bc:	4825      	ldr	r0, [pc, #148]	; (511c654 <_svfiprintf_r+0x1f0>)
 511c5be:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 511c5c2:	f7fd fb5f 	bl	5119c84 <memchr>
 511c5c6:	2800      	cmp	r0, #0
 511c5c8:	d038      	beq.n	511c63c <_svfiprintf_r+0x1d8>
 511c5ca:	4b23      	ldr	r3, [pc, #140]	; (511c658 <_svfiprintf_r+0x1f4>)
 511c5cc:	bb1b      	cbnz	r3, 511c616 <_svfiprintf_r+0x1b2>
 511c5ce:	9b03      	ldr	r3, [sp, #12]
 511c5d0:	3307      	adds	r3, #7
 511c5d2:	f023 0307 	bic.w	r3, r3, #7
 511c5d6:	3308      	adds	r3, #8
 511c5d8:	9303      	str	r3, [sp, #12]
 511c5da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511c5dc:	4433      	add	r3, r6
 511c5de:	9309      	str	r3, [sp, #36]	; 0x24
 511c5e0:	e767      	b.n	511c4b2 <_svfiprintf_r+0x4e>
 511c5e2:	fb0c 3202 	mla	r2, ip, r2, r3
 511c5e6:	460c      	mov	r4, r1
 511c5e8:	2001      	movs	r0, #1
 511c5ea:	e7a5      	b.n	511c538 <_svfiprintf_r+0xd4>
 511c5ec:	2300      	movs	r3, #0
 511c5ee:	3401      	adds	r4, #1
 511c5f0:	4619      	mov	r1, r3
 511c5f2:	f04f 0c0a 	mov.w	ip, #10
 511c5f6:	9305      	str	r3, [sp, #20]
 511c5f8:	4620      	mov	r0, r4
 511c5fa:	f810 2b01 	ldrb.w	r2, [r0], #1
 511c5fe:	3a30      	subs	r2, #48	; 0x30
 511c600:	2a09      	cmp	r2, #9
 511c602:	d903      	bls.n	511c60c <_svfiprintf_r+0x1a8>
 511c604:	2b00      	cmp	r3, #0
 511c606:	d0c5      	beq.n	511c594 <_svfiprintf_r+0x130>
 511c608:	9105      	str	r1, [sp, #20]
 511c60a:	e7c3      	b.n	511c594 <_svfiprintf_r+0x130>
 511c60c:	fb0c 2101 	mla	r1, ip, r1, r2
 511c610:	4604      	mov	r4, r0
 511c612:	2301      	movs	r3, #1
 511c614:	e7f0      	b.n	511c5f8 <_svfiprintf_r+0x194>
 511c616:	ab03      	add	r3, sp, #12
 511c618:	462a      	mov	r2, r5
 511c61a:	9300      	str	r3, [sp, #0]
 511c61c:	a904      	add	r1, sp, #16
 511c61e:	4b0f      	ldr	r3, [pc, #60]	; (511c65c <_svfiprintf_r+0x1f8>)
 511c620:	4638      	mov	r0, r7
 511c622:	f7fd fbed 	bl	5119e00 <_printf_float>
 511c626:	4606      	mov	r6, r0
 511c628:	1c42      	adds	r2, r0, #1
 511c62a:	d1d6      	bne.n	511c5da <_svfiprintf_r+0x176>
 511c62c:	89ab      	ldrh	r3, [r5, #12]
 511c62e:	065b      	lsls	r3, r3, #25
 511c630:	f53f af2c 	bmi.w	511c48c <_svfiprintf_r+0x28>
 511c634:	9809      	ldr	r0, [sp, #36]	; 0x24
 511c636:	b01d      	add	sp, #116	; 0x74
 511c638:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511c63c:	ab03      	add	r3, sp, #12
 511c63e:	462a      	mov	r2, r5
 511c640:	9300      	str	r3, [sp, #0]
 511c642:	a904      	add	r1, sp, #16
 511c644:	4b05      	ldr	r3, [pc, #20]	; (511c65c <_svfiprintf_r+0x1f8>)
 511c646:	4638      	mov	r0, r7
 511c648:	f7fd fe6a 	bl	511a320 <_printf_i>
 511c64c:	e7eb      	b.n	511c626 <_svfiprintf_r+0x1c2>
 511c64e:	bf00      	nop
 511c650:	0512e11c 	.word	0x0512e11c
 511c654:	0512e126 	.word	0x0512e126
 511c658:	05119e01 	.word	0x05119e01
 511c65c:	0511c3ad 	.word	0x0511c3ad
 511c660:	0512e122 	.word	0x0512e122

0511c664 <__sfputc_r>:
 511c664:	6893      	ldr	r3, [r2, #8]
 511c666:	b410      	push	{r4}
 511c668:	3b01      	subs	r3, #1
 511c66a:	2b00      	cmp	r3, #0
 511c66c:	6093      	str	r3, [r2, #8]
 511c66e:	da08      	bge.n	511c682 <__sfputc_r+0x1e>
 511c670:	6994      	ldr	r4, [r2, #24]
 511c672:	42a3      	cmp	r3, r4
 511c674:	db01      	blt.n	511c67a <__sfputc_r+0x16>
 511c676:	290a      	cmp	r1, #10
 511c678:	d103      	bne.n	511c682 <__sfputc_r+0x1e>
 511c67a:	f85d 4b04 	ldr.w	r4, [sp], #4
 511c67e:	f7fe b94b 	b.w	511a918 <__swbuf_r>
 511c682:	6813      	ldr	r3, [r2, #0]
 511c684:	1c58      	adds	r0, r3, #1
 511c686:	6010      	str	r0, [r2, #0]
 511c688:	7019      	strb	r1, [r3, #0]
 511c68a:	4608      	mov	r0, r1
 511c68c:	f85d 4b04 	ldr.w	r4, [sp], #4
 511c690:	4770      	bx	lr

0511c692 <__sfputs_r>:
 511c692:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 511c694:	4606      	mov	r6, r0
 511c696:	460f      	mov	r7, r1
 511c698:	4614      	mov	r4, r2
 511c69a:	18d5      	adds	r5, r2, r3
 511c69c:	42ac      	cmp	r4, r5
 511c69e:	d101      	bne.n	511c6a4 <__sfputs_r+0x12>
 511c6a0:	2000      	movs	r0, #0
 511c6a2:	e007      	b.n	511c6b4 <__sfputs_r+0x22>
 511c6a4:	f814 1b01 	ldrb.w	r1, [r4], #1
 511c6a8:	463a      	mov	r2, r7
 511c6aa:	4630      	mov	r0, r6
 511c6ac:	f7ff ffda 	bl	511c664 <__sfputc_r>
 511c6b0:	1c43      	adds	r3, r0, #1
 511c6b2:	d1f3      	bne.n	511c69c <__sfputs_r+0xa>
 511c6b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0511c6b8 <_vfiprintf_r>:
 511c6b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 511c6bc:	460d      	mov	r5, r1
 511c6be:	4614      	mov	r4, r2
 511c6c0:	b09d      	sub	sp, #116	; 0x74
 511c6c2:	4698      	mov	r8, r3
 511c6c4:	4606      	mov	r6, r0
 511c6c6:	b118      	cbz	r0, 511c6d0 <_vfiprintf_r+0x18>
 511c6c8:	6983      	ldr	r3, [r0, #24]
 511c6ca:	b90b      	cbnz	r3, 511c6d0 <_vfiprintf_r+0x18>
 511c6cc:	f7ff f91e 	bl	511b90c <__sinit>
 511c6d0:	4b89      	ldr	r3, [pc, #548]	; (511c8f8 <_vfiprintf_r+0x240>)
 511c6d2:	429d      	cmp	r5, r3
 511c6d4:	d11b      	bne.n	511c70e <_vfiprintf_r+0x56>
 511c6d6:	6875      	ldr	r5, [r6, #4]
 511c6d8:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 511c6da:	07d9      	lsls	r1, r3, #31
 511c6dc:	d405      	bmi.n	511c6ea <_vfiprintf_r+0x32>
 511c6de:	89ab      	ldrh	r3, [r5, #12]
 511c6e0:	059a      	lsls	r2, r3, #22
 511c6e2:	d402      	bmi.n	511c6ea <_vfiprintf_r+0x32>
 511c6e4:	6da8      	ldr	r0, [r5, #88]	; 0x58
 511c6e6:	f7ff f9b4 	bl	511ba52 <__retarget_lock_acquire_recursive>
 511c6ea:	89ab      	ldrh	r3, [r5, #12]
 511c6ec:	071b      	lsls	r3, r3, #28
 511c6ee:	d501      	bpl.n	511c6f4 <_vfiprintf_r+0x3c>
 511c6f0:	692b      	ldr	r3, [r5, #16]
 511c6f2:	b9eb      	cbnz	r3, 511c730 <_vfiprintf_r+0x78>
 511c6f4:	4629      	mov	r1, r5
 511c6f6:	4630      	mov	r0, r6
 511c6f8:	f7fe f972 	bl	511a9e0 <__swsetup_r>
 511c6fc:	b1c0      	cbz	r0, 511c730 <_vfiprintf_r+0x78>
 511c6fe:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 511c700:	07dc      	lsls	r4, r3, #31
 511c702:	d50e      	bpl.n	511c722 <_vfiprintf_r+0x6a>
 511c704:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511c708:	b01d      	add	sp, #116	; 0x74
 511c70a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 511c70e:	4b7b      	ldr	r3, [pc, #492]	; (511c8fc <_vfiprintf_r+0x244>)
 511c710:	429d      	cmp	r5, r3
 511c712:	d101      	bne.n	511c718 <_vfiprintf_r+0x60>
 511c714:	68b5      	ldr	r5, [r6, #8]
 511c716:	e7df      	b.n	511c6d8 <_vfiprintf_r+0x20>
 511c718:	4b79      	ldr	r3, [pc, #484]	; (511c900 <_vfiprintf_r+0x248>)
 511c71a:	429d      	cmp	r5, r3
 511c71c:	bf08      	it	eq
 511c71e:	68f5      	ldreq	r5, [r6, #12]
 511c720:	e7da      	b.n	511c6d8 <_vfiprintf_r+0x20>
 511c722:	89ab      	ldrh	r3, [r5, #12]
 511c724:	0598      	lsls	r0, r3, #22
 511c726:	d4ed      	bmi.n	511c704 <_vfiprintf_r+0x4c>
 511c728:	6da8      	ldr	r0, [r5, #88]	; 0x58
 511c72a:	f7ff f993 	bl	511ba54 <__retarget_lock_release_recursive>
 511c72e:	e7e9      	b.n	511c704 <_vfiprintf_r+0x4c>
 511c730:	f8cd 800c 	str.w	r8, [sp, #12]
 511c734:	f04f 0901 	mov.w	r9, #1
 511c738:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 511c904 <_vfiprintf_r+0x24c>
 511c73c:	2300      	movs	r3, #0
 511c73e:	9309      	str	r3, [sp, #36]	; 0x24
 511c740:	2320      	movs	r3, #32
 511c742:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 511c746:	2330      	movs	r3, #48	; 0x30
 511c748:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 511c74c:	4623      	mov	r3, r4
 511c74e:	469a      	mov	sl, r3
 511c750:	f813 2b01 	ldrb.w	r2, [r3], #1
 511c754:	b10a      	cbz	r2, 511c75a <_vfiprintf_r+0xa2>
 511c756:	2a25      	cmp	r2, #37	; 0x25
 511c758:	d1f9      	bne.n	511c74e <_vfiprintf_r+0x96>
 511c75a:	ebba 0b04 	subs.w	fp, sl, r4
 511c75e:	d00b      	beq.n	511c778 <_vfiprintf_r+0xc0>
 511c760:	465b      	mov	r3, fp
 511c762:	4622      	mov	r2, r4
 511c764:	4629      	mov	r1, r5
 511c766:	4630      	mov	r0, r6
 511c768:	f7ff ff93 	bl	511c692 <__sfputs_r>
 511c76c:	3001      	adds	r0, #1
 511c76e:	f000 80aa 	beq.w	511c8c6 <_vfiprintf_r+0x20e>
 511c772:	9a09      	ldr	r2, [sp, #36]	; 0x24
 511c774:	445a      	add	r2, fp
 511c776:	9209      	str	r2, [sp, #36]	; 0x24
 511c778:	f89a 3000 	ldrb.w	r3, [sl]
 511c77c:	2b00      	cmp	r3, #0
 511c77e:	f000 80a2 	beq.w	511c8c6 <_vfiprintf_r+0x20e>
 511c782:	f10a 0a01 	add.w	sl, sl, #1
 511c786:	2300      	movs	r3, #0
 511c788:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 511c78c:	9304      	str	r3, [sp, #16]
 511c78e:	9307      	str	r3, [sp, #28]
 511c790:	e9cd 2305 	strd	r2, r3, [sp, #20]
 511c794:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 511c798:	931a      	str	r3, [sp, #104]	; 0x68
 511c79a:	4654      	mov	r4, sl
 511c79c:	2205      	movs	r2, #5
 511c79e:	4859      	ldr	r0, [pc, #356]	; (511c904 <_vfiprintf_r+0x24c>)
 511c7a0:	f814 1b01 	ldrb.w	r1, [r4], #1
 511c7a4:	f7fd fa6e 	bl	5119c84 <memchr>
 511c7a8:	9a04      	ldr	r2, [sp, #16]
 511c7aa:	b9d8      	cbnz	r0, 511c7e4 <_vfiprintf_r+0x12c>
 511c7ac:	06d1      	lsls	r1, r2, #27
 511c7ae:	bf44      	itt	mi
 511c7b0:	2320      	movmi	r3, #32
 511c7b2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 511c7b6:	0713      	lsls	r3, r2, #28
 511c7b8:	bf44      	itt	mi
 511c7ba:	232b      	movmi	r3, #43	; 0x2b
 511c7bc:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
 511c7c0:	f89a 3000 	ldrb.w	r3, [sl]
 511c7c4:	2b2a      	cmp	r3, #42	; 0x2a
 511c7c6:	d015      	beq.n	511c7f4 <_vfiprintf_r+0x13c>
 511c7c8:	9a07      	ldr	r2, [sp, #28]
 511c7ca:	4654      	mov	r4, sl
 511c7cc:	2000      	movs	r0, #0
 511c7ce:	f04f 0c0a 	mov.w	ip, #10
 511c7d2:	4621      	mov	r1, r4
 511c7d4:	f811 3b01 	ldrb.w	r3, [r1], #1
 511c7d8:	3b30      	subs	r3, #48	; 0x30
 511c7da:	2b09      	cmp	r3, #9
 511c7dc:	d94e      	bls.n	511c87c <_vfiprintf_r+0x1c4>
 511c7de:	b1b0      	cbz	r0, 511c80e <_vfiprintf_r+0x156>
 511c7e0:	9207      	str	r2, [sp, #28]
 511c7e2:	e014      	b.n	511c80e <_vfiprintf_r+0x156>
 511c7e4:	eba0 0308 	sub.w	r3, r0, r8
 511c7e8:	46a2      	mov	sl, r4
 511c7ea:	fa09 f303 	lsl.w	r3, r9, r3
 511c7ee:	4313      	orrs	r3, r2
 511c7f0:	9304      	str	r3, [sp, #16]
 511c7f2:	e7d2      	b.n	511c79a <_vfiprintf_r+0xe2>
 511c7f4:	9b03      	ldr	r3, [sp, #12]
 511c7f6:	1d19      	adds	r1, r3, #4
 511c7f8:	9103      	str	r1, [sp, #12]
 511c7fa:	681b      	ldr	r3, [r3, #0]
 511c7fc:	2b00      	cmp	r3, #0
 511c7fe:	bfaf      	iteee	ge
 511c800:	9307      	strge	r3, [sp, #28]
 511c802:	425b      	neglt	r3, r3
 511c804:	f042 0202 	orrlt.w	r2, r2, #2
 511c808:	9307      	strlt	r3, [sp, #28]
 511c80a:	bfb8      	it	lt
 511c80c:	9204      	strlt	r2, [sp, #16]
 511c80e:	7823      	ldrb	r3, [r4, #0]
 511c810:	2b2e      	cmp	r3, #46	; 0x2e
 511c812:	d10c      	bne.n	511c82e <_vfiprintf_r+0x176>
 511c814:	7863      	ldrb	r3, [r4, #1]
 511c816:	2b2a      	cmp	r3, #42	; 0x2a
 511c818:	d135      	bne.n	511c886 <_vfiprintf_r+0x1ce>
 511c81a:	9b03      	ldr	r3, [sp, #12]
 511c81c:	3402      	adds	r4, #2
 511c81e:	1d1a      	adds	r2, r3, #4
 511c820:	9203      	str	r2, [sp, #12]
 511c822:	681b      	ldr	r3, [r3, #0]
 511c824:	2b00      	cmp	r3, #0
 511c826:	bfb8      	it	lt
 511c828:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 511c82c:	9305      	str	r3, [sp, #20]
 511c82e:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 511c914 <_vfiprintf_r+0x25c>
 511c832:	2203      	movs	r2, #3
 511c834:	7821      	ldrb	r1, [r4, #0]
 511c836:	4650      	mov	r0, sl
 511c838:	f7fd fa24 	bl	5119c84 <memchr>
 511c83c:	b140      	cbz	r0, 511c850 <_vfiprintf_r+0x198>
 511c83e:	2340      	movs	r3, #64	; 0x40
 511c840:	eba0 000a 	sub.w	r0, r0, sl
 511c844:	3401      	adds	r4, #1
 511c846:	fa03 f000 	lsl.w	r0, r3, r0
 511c84a:	9b04      	ldr	r3, [sp, #16]
 511c84c:	4303      	orrs	r3, r0
 511c84e:	9304      	str	r3, [sp, #16]
 511c850:	f814 1b01 	ldrb.w	r1, [r4], #1
 511c854:	2206      	movs	r2, #6
 511c856:	482c      	ldr	r0, [pc, #176]	; (511c908 <_vfiprintf_r+0x250>)
 511c858:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 511c85c:	f7fd fa12 	bl	5119c84 <memchr>
 511c860:	2800      	cmp	r0, #0
 511c862:	d03f      	beq.n	511c8e4 <_vfiprintf_r+0x22c>
 511c864:	4b29      	ldr	r3, [pc, #164]	; (511c90c <_vfiprintf_r+0x254>)
 511c866:	bb1b      	cbnz	r3, 511c8b0 <_vfiprintf_r+0x1f8>
 511c868:	9b03      	ldr	r3, [sp, #12]
 511c86a:	3307      	adds	r3, #7
 511c86c:	f023 0307 	bic.w	r3, r3, #7
 511c870:	3308      	adds	r3, #8
 511c872:	9303      	str	r3, [sp, #12]
 511c874:	9b09      	ldr	r3, [sp, #36]	; 0x24
 511c876:	443b      	add	r3, r7
 511c878:	9309      	str	r3, [sp, #36]	; 0x24
 511c87a:	e767      	b.n	511c74c <_vfiprintf_r+0x94>
 511c87c:	fb0c 3202 	mla	r2, ip, r2, r3
 511c880:	460c      	mov	r4, r1
 511c882:	2001      	movs	r0, #1
 511c884:	e7a5      	b.n	511c7d2 <_vfiprintf_r+0x11a>
 511c886:	2300      	movs	r3, #0
 511c888:	3401      	adds	r4, #1
 511c88a:	4619      	mov	r1, r3
 511c88c:	f04f 0c0a 	mov.w	ip, #10
 511c890:	9305      	str	r3, [sp, #20]
 511c892:	4620      	mov	r0, r4
 511c894:	f810 2b01 	ldrb.w	r2, [r0], #1
 511c898:	3a30      	subs	r2, #48	; 0x30
 511c89a:	2a09      	cmp	r2, #9
 511c89c:	d903      	bls.n	511c8a6 <_vfiprintf_r+0x1ee>
 511c89e:	2b00      	cmp	r3, #0
 511c8a0:	d0c5      	beq.n	511c82e <_vfiprintf_r+0x176>
 511c8a2:	9105      	str	r1, [sp, #20]
 511c8a4:	e7c3      	b.n	511c82e <_vfiprintf_r+0x176>
 511c8a6:	fb0c 2101 	mla	r1, ip, r1, r2
 511c8aa:	4604      	mov	r4, r0
 511c8ac:	2301      	movs	r3, #1
 511c8ae:	e7f0      	b.n	511c892 <_vfiprintf_r+0x1da>
 511c8b0:	ab03      	add	r3, sp, #12
 511c8b2:	462a      	mov	r2, r5
 511c8b4:	9300      	str	r3, [sp, #0]
 511c8b6:	a904      	add	r1, sp, #16
 511c8b8:	4b15      	ldr	r3, [pc, #84]	; (511c910 <_vfiprintf_r+0x258>)
 511c8ba:	4630      	mov	r0, r6
 511c8bc:	f7fd faa0 	bl	5119e00 <_printf_float>
 511c8c0:	4607      	mov	r7, r0
 511c8c2:	1c78      	adds	r0, r7, #1
 511c8c4:	d1d6      	bne.n	511c874 <_vfiprintf_r+0x1bc>
 511c8c6:	6e6b      	ldr	r3, [r5, #100]	; 0x64
 511c8c8:	07d9      	lsls	r1, r3, #31
 511c8ca:	d405      	bmi.n	511c8d8 <_vfiprintf_r+0x220>
 511c8cc:	89ab      	ldrh	r3, [r5, #12]
 511c8ce:	059a      	lsls	r2, r3, #22
 511c8d0:	d402      	bmi.n	511c8d8 <_vfiprintf_r+0x220>
 511c8d2:	6da8      	ldr	r0, [r5, #88]	; 0x58
 511c8d4:	f7ff f8be 	bl	511ba54 <__retarget_lock_release_recursive>
 511c8d8:	89ab      	ldrh	r3, [r5, #12]
 511c8da:	065b      	lsls	r3, r3, #25
 511c8dc:	f53f af12 	bmi.w	511c704 <_vfiprintf_r+0x4c>
 511c8e0:	9809      	ldr	r0, [sp, #36]	; 0x24
 511c8e2:	e711      	b.n	511c708 <_vfiprintf_r+0x50>
 511c8e4:	ab03      	add	r3, sp, #12
 511c8e6:	462a      	mov	r2, r5
 511c8e8:	9300      	str	r3, [sp, #0]
 511c8ea:	a904      	add	r1, sp, #16
 511c8ec:	4b08      	ldr	r3, [pc, #32]	; (511c910 <_vfiprintf_r+0x258>)
 511c8ee:	4630      	mov	r0, r6
 511c8f0:	f7fd fd16 	bl	511a320 <_printf_i>
 511c8f4:	e7e4      	b.n	511c8c0 <_vfiprintf_r+0x208>
 511c8f6:	bf00      	nop
 511c8f8:	0512df5c 	.word	0x0512df5c
 511c8fc:	0512df7c 	.word	0x0512df7c
 511c900:	0512df3c 	.word	0x0512df3c
 511c904:	0512e11c 	.word	0x0512e11c
 511c908:	0512e126 	.word	0x0512e126
 511c90c:	05119e01 	.word	0x05119e01
 511c910:	0511c693 	.word	0x0511c693
 511c914:	0512e122 	.word	0x0512e122

0511c918 <_sbrk_r>:
 511c918:	b538      	push	{r3, r4, r5, lr}
 511c91a:	4604      	mov	r4, r0
 511c91c:	4d05      	ldr	r5, [pc, #20]	; (511c934 <_sbrk_r+0x1c>)
 511c91e:	4608      	mov	r0, r1
 511c920:	2300      	movs	r3, #0
 511c922:	602b      	str	r3, [r5, #0]
 511c924:	f000 f9d4 	bl	511ccd0 <_sbrk>
 511c928:	1c43      	adds	r3, r0, #1
 511c92a:	d102      	bne.n	511c932 <_sbrk_r+0x1a>
 511c92c:	682b      	ldr	r3, [r5, #0]
 511c92e:	b103      	cbz	r3, 511c932 <_sbrk_r+0x1a>
 511c930:	6023      	str	r3, [r4, #0]
 511c932:	bd38      	pop	{r3, r4, r5, pc}
 511c934:	05138708 	.word	0x05138708

0511c938 <_raise_r>:
 511c938:	b538      	push	{r3, r4, r5, lr}
 511c93a:	291f      	cmp	r1, #31
 511c93c:	4604      	mov	r4, r0
 511c93e:	460d      	mov	r5, r1
 511c940:	d904      	bls.n	511c94c <_raise_r+0x14>
 511c942:	2316      	movs	r3, #22
 511c944:	6003      	str	r3, [r0, #0]
 511c946:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511c94a:	bd38      	pop	{r3, r4, r5, pc}
 511c94c:	6c42      	ldr	r2, [r0, #68]	; 0x44
 511c94e:	b112      	cbz	r2, 511c956 <_raise_r+0x1e>
 511c950:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 511c954:	b94b      	cbnz	r3, 511c96a <_raise_r+0x32>
 511c956:	4620      	mov	r0, r4
 511c958:	f000 f830 	bl	511c9bc <_getpid_r>
 511c95c:	462a      	mov	r2, r5
 511c95e:	4601      	mov	r1, r0
 511c960:	4620      	mov	r0, r4
 511c962:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 511c966:	f000 b817 	b.w	511c998 <_kill_r>
 511c96a:	2b01      	cmp	r3, #1
 511c96c:	d00a      	beq.n	511c984 <_raise_r+0x4c>
 511c96e:	1c59      	adds	r1, r3, #1
 511c970:	d103      	bne.n	511c97a <_raise_r+0x42>
 511c972:	2316      	movs	r3, #22
 511c974:	6003      	str	r3, [r0, #0]
 511c976:	2001      	movs	r0, #1
 511c978:	e7e7      	b.n	511c94a <_raise_r+0x12>
 511c97a:	2400      	movs	r4, #0
 511c97c:	4628      	mov	r0, r5
 511c97e:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 511c982:	4798      	blx	r3
 511c984:	2000      	movs	r0, #0
 511c986:	e7e0      	b.n	511c94a <_raise_r+0x12>

0511c988 <raise>:
 511c988:	4b02      	ldr	r3, [pc, #8]	; (511c994 <raise+0xc>)
 511c98a:	4601      	mov	r1, r0
 511c98c:	6818      	ldr	r0, [r3, #0]
 511c98e:	f7ff bfd3 	b.w	511c938 <_raise_r>
 511c992:	bf00      	nop
 511c994:	0512fab4 	.word	0x0512fab4

0511c998 <_kill_r>:
 511c998:	b538      	push	{r3, r4, r5, lr}
 511c99a:	4604      	mov	r4, r0
 511c99c:	4d06      	ldr	r5, [pc, #24]	; (511c9b8 <_kill_r+0x20>)
 511c99e:	4608      	mov	r0, r1
 511c9a0:	4611      	mov	r1, r2
 511c9a2:	2300      	movs	r3, #0
 511c9a4:	602b      	str	r3, [r5, #0]
 511c9a6:	f000 f975 	bl	511cc94 <_kill>
 511c9aa:	1c43      	adds	r3, r0, #1
 511c9ac:	d102      	bne.n	511c9b4 <_kill_r+0x1c>
 511c9ae:	682b      	ldr	r3, [r5, #0]
 511c9b0:	b103      	cbz	r3, 511c9b4 <_kill_r+0x1c>
 511c9b2:	6023      	str	r3, [r4, #0]
 511c9b4:	bd38      	pop	{r3, r4, r5, pc}
 511c9b6:	bf00      	nop
 511c9b8:	05138708 	.word	0x05138708

0511c9bc <_getpid_r>:
 511c9bc:	f000 b958 	b.w	511cc70 <_getpid>

0511c9c0 <__sread>:
 511c9c0:	b510      	push	{r4, lr}
 511c9c2:	460c      	mov	r4, r1
 511c9c4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 511c9c8:	f000 f910 	bl	511cbec <_read_r>
 511c9cc:	2800      	cmp	r0, #0
 511c9ce:	bfa9      	itett	ge
 511c9d0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 511c9d2:	89a3      	ldrhlt	r3, [r4, #12]
 511c9d4:	181b      	addge	r3, r3, r0
 511c9d6:	6563      	strge	r3, [r4, #84]	; 0x54
 511c9d8:	bfbc      	itt	lt
 511c9da:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 511c9de:	81a3      	strhlt	r3, [r4, #12]
 511c9e0:	bd10      	pop	{r4, pc}

0511c9e2 <__swrite>:
 511c9e2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 511c9e6:	461f      	mov	r7, r3
 511c9e8:	898b      	ldrh	r3, [r1, #12]
 511c9ea:	4605      	mov	r5, r0
 511c9ec:	460c      	mov	r4, r1
 511c9ee:	4616      	mov	r6, r2
 511c9f0:	05db      	lsls	r3, r3, #23
 511c9f2:	d505      	bpl.n	511ca00 <__swrite+0x1e>
 511c9f4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 511c9f8:	2302      	movs	r3, #2
 511c9fa:	2200      	movs	r2, #0
 511c9fc:	f000 f886 	bl	511cb0c <_lseek_r>
 511ca00:	89a3      	ldrh	r3, [r4, #12]
 511ca02:	4632      	mov	r2, r6
 511ca04:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 511ca08:	4628      	mov	r0, r5
 511ca0a:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 511ca0e:	81a3      	strh	r3, [r4, #12]
 511ca10:	463b      	mov	r3, r7
 511ca12:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 511ca16:	f7fd bfd1 	b.w	511a9bc <_write_r>

0511ca1a <__sseek>:
 511ca1a:	b510      	push	{r4, lr}
 511ca1c:	460c      	mov	r4, r1
 511ca1e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 511ca22:	f000 f873 	bl	511cb0c <_lseek_r>
 511ca26:	1c43      	adds	r3, r0, #1
 511ca28:	89a3      	ldrh	r3, [r4, #12]
 511ca2a:	bf15      	itete	ne
 511ca2c:	6560      	strne	r0, [r4, #84]	; 0x54
 511ca2e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 511ca32:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 511ca36:	81a3      	strheq	r3, [r4, #12]
 511ca38:	bf18      	it	ne
 511ca3a:	81a3      	strhne	r3, [r4, #12]
 511ca3c:	bd10      	pop	{r4, pc}

0511ca3e <__sclose>:
 511ca3e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 511ca42:	f000 b81f 	b.w	511ca84 <_close_r>
	...

0511ca48 <__assert_func>:
 511ca48:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 511ca4a:	4614      	mov	r4, r2
 511ca4c:	461a      	mov	r2, r3
 511ca4e:	4b09      	ldr	r3, [pc, #36]	; (511ca74 <__assert_func+0x2c>)
 511ca50:	4605      	mov	r5, r0
 511ca52:	681b      	ldr	r3, [r3, #0]
 511ca54:	68d8      	ldr	r0, [r3, #12]
 511ca56:	b14c      	cbz	r4, 511ca6c <__assert_func+0x24>
 511ca58:	4b07      	ldr	r3, [pc, #28]	; (511ca78 <__assert_func+0x30>)
 511ca5a:	e9cd 3401 	strd	r3, r4, [sp, #4]
 511ca5e:	462b      	mov	r3, r5
 511ca60:	9100      	str	r1, [sp, #0]
 511ca62:	4906      	ldr	r1, [pc, #24]	; (511ca7c <__assert_func+0x34>)
 511ca64:	f000 f81e 	bl	511caa4 <fiprintf>
 511ca68:	f000 f8df 	bl	511cc2a <abort>
 511ca6c:	4b04      	ldr	r3, [pc, #16]	; (511ca80 <__assert_func+0x38>)
 511ca6e:	461c      	mov	r4, r3
 511ca70:	e7f3      	b.n	511ca5a <__assert_func+0x12>
 511ca72:	bf00      	nop
 511ca74:	0512fab4 	.word	0x0512fab4
 511ca78:	0512e12d 	.word	0x0512e12d
 511ca7c:	0512e13a 	.word	0x0512e13a
 511ca80:	0512e168 	.word	0x0512e168

0511ca84 <_close_r>:
 511ca84:	b538      	push	{r3, r4, r5, lr}
 511ca86:	4604      	mov	r4, r0
 511ca88:	4d05      	ldr	r5, [pc, #20]	; (511caa0 <_close_r+0x1c>)
 511ca8a:	4608      	mov	r0, r1
 511ca8c:	2300      	movs	r3, #0
 511ca8e:	602b      	str	r3, [r5, #0]
 511ca90:	f000 f8da 	bl	511cc48 <_close>
 511ca94:	1c43      	adds	r3, r0, #1
 511ca96:	d102      	bne.n	511ca9e <_close_r+0x1a>
 511ca98:	682b      	ldr	r3, [r5, #0]
 511ca9a:	b103      	cbz	r3, 511ca9e <_close_r+0x1a>
 511ca9c:	6023      	str	r3, [r4, #0]
 511ca9e:	bd38      	pop	{r3, r4, r5, pc}
 511caa0:	05138708 	.word	0x05138708

0511caa4 <fiprintf>:
 511caa4:	b40e      	push	{r1, r2, r3}
 511caa6:	b503      	push	{r0, r1, lr}
 511caa8:	4601      	mov	r1, r0
 511caaa:	4806      	ldr	r0, [pc, #24]	; (511cac4 <fiprintf+0x20>)
 511caac:	ab03      	add	r3, sp, #12
 511caae:	6800      	ldr	r0, [r0, #0]
 511cab0:	f853 2b04 	ldr.w	r2, [r3], #4
 511cab4:	9301      	str	r3, [sp, #4]
 511cab6:	f7ff fdff 	bl	511c6b8 <_vfiprintf_r>
 511caba:	b002      	add	sp, #8
 511cabc:	f85d eb04 	ldr.w	lr, [sp], #4
 511cac0:	b003      	add	sp, #12
 511cac2:	4770      	bx	lr
 511cac4:	0512fab4 	.word	0x0512fab4

0511cac8 <_fstat_r>:
 511cac8:	b538      	push	{r3, r4, r5, lr}
 511caca:	4604      	mov	r4, r0
 511cacc:	4d06      	ldr	r5, [pc, #24]	; (511cae8 <_fstat_r+0x20>)
 511cace:	4608      	mov	r0, r1
 511cad0:	4611      	mov	r1, r2
 511cad2:	2300      	movs	r3, #0
 511cad4:	602b      	str	r3, [r5, #0]
 511cad6:	f000 f8c1 	bl	511cc5c <_fstat>
 511cada:	1c43      	adds	r3, r0, #1
 511cadc:	d102      	bne.n	511cae4 <_fstat_r+0x1c>
 511cade:	682b      	ldr	r3, [r5, #0]
 511cae0:	b103      	cbz	r3, 511cae4 <_fstat_r+0x1c>
 511cae2:	6023      	str	r3, [r4, #0]
 511cae4:	bd38      	pop	{r3, r4, r5, pc}
 511cae6:	bf00      	nop
 511cae8:	05138708 	.word	0x05138708

0511caec <_isatty_r>:
 511caec:	b538      	push	{r3, r4, r5, lr}
 511caee:	4604      	mov	r4, r0
 511caf0:	4d05      	ldr	r5, [pc, #20]	; (511cb08 <_isatty_r+0x1c>)
 511caf2:	4608      	mov	r0, r1
 511caf4:	2300      	movs	r3, #0
 511caf6:	602b      	str	r3, [r5, #0]
 511caf8:	f000 f8c4 	bl	511cc84 <_isatty>
 511cafc:	1c43      	adds	r3, r0, #1
 511cafe:	d102      	bne.n	511cb06 <_isatty_r+0x1a>
 511cb00:	682b      	ldr	r3, [r5, #0]
 511cb02:	b103      	cbz	r3, 511cb06 <_isatty_r+0x1a>
 511cb04:	6023      	str	r3, [r4, #0]
 511cb06:	bd38      	pop	{r3, r4, r5, pc}
 511cb08:	05138708 	.word	0x05138708

0511cb0c <_lseek_r>:
 511cb0c:	b538      	push	{r3, r4, r5, lr}
 511cb0e:	4604      	mov	r4, r0
 511cb10:	4d06      	ldr	r5, [pc, #24]	; (511cb2c <_lseek_r+0x20>)
 511cb12:	4608      	mov	r0, r1
 511cb14:	4611      	mov	r1, r2
 511cb16:	2200      	movs	r2, #0
 511cb18:	602a      	str	r2, [r5, #0]
 511cb1a:	461a      	mov	r2, r3
 511cb1c:	f000 f8c4 	bl	511cca8 <_lseek>
 511cb20:	1c43      	adds	r3, r0, #1
 511cb22:	d102      	bne.n	511cb2a <_lseek_r+0x1e>
 511cb24:	682b      	ldr	r3, [r5, #0]
 511cb26:	b103      	cbz	r3, 511cb2a <_lseek_r+0x1e>
 511cb28:	6023      	str	r3, [r4, #0]
 511cb2a:	bd38      	pop	{r3, r4, r5, pc}
 511cb2c:	05138708 	.word	0x05138708

0511cb30 <__ascii_mbtowc>:
 511cb30:	b082      	sub	sp, #8
 511cb32:	b901      	cbnz	r1, 511cb36 <__ascii_mbtowc+0x6>
 511cb34:	a901      	add	r1, sp, #4
 511cb36:	b142      	cbz	r2, 511cb4a <__ascii_mbtowc+0x1a>
 511cb38:	b14b      	cbz	r3, 511cb4e <__ascii_mbtowc+0x1e>
 511cb3a:	7813      	ldrb	r3, [r2, #0]
 511cb3c:	600b      	str	r3, [r1, #0]
 511cb3e:	7812      	ldrb	r2, [r2, #0]
 511cb40:	1e10      	subs	r0, r2, #0
 511cb42:	bf18      	it	ne
 511cb44:	2001      	movne	r0, #1
 511cb46:	b002      	add	sp, #8
 511cb48:	4770      	bx	lr
 511cb4a:	4610      	mov	r0, r2
 511cb4c:	e7fb      	b.n	511cb46 <__ascii_mbtowc+0x16>
 511cb4e:	f06f 0001 	mvn.w	r0, #1
 511cb52:	e7f8      	b.n	511cb46 <__ascii_mbtowc+0x16>

0511cb54 <memmove>:
 511cb54:	b510      	push	{r4, lr}
 511cb56:	4288      	cmp	r0, r1
 511cb58:	eb01 0402 	add.w	r4, r1, r2
 511cb5c:	d902      	bls.n	511cb64 <memmove+0x10>
 511cb5e:	4623      	mov	r3, r4
 511cb60:	4284      	cmp	r4, r0
 511cb62:	d807      	bhi.n	511cb74 <memmove+0x20>
 511cb64:	1e43      	subs	r3, r0, #1
 511cb66:	42a1      	cmp	r1, r4
 511cb68:	d008      	beq.n	511cb7c <memmove+0x28>
 511cb6a:	f811 2b01 	ldrb.w	r2, [r1], #1
 511cb6e:	f803 2f01 	strb.w	r2, [r3, #1]!
 511cb72:	e7f8      	b.n	511cb66 <memmove+0x12>
 511cb74:	4402      	add	r2, r0
 511cb76:	4601      	mov	r1, r0
 511cb78:	428a      	cmp	r2, r1
 511cb7a:	d100      	bne.n	511cb7e <memmove+0x2a>
 511cb7c:	bd10      	pop	{r4, pc}
 511cb7e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 511cb82:	f802 4d01 	strb.w	r4, [r2, #-1]!
 511cb86:	e7f7      	b.n	511cb78 <memmove+0x24>

0511cb88 <__malloc_lock>:
 511cb88:	4801      	ldr	r0, [pc, #4]	; (511cb90 <__malloc_lock+0x8>)
 511cb8a:	f7fe bf62 	b.w	511ba52 <__retarget_lock_acquire_recursive>
 511cb8e:	bf00      	nop
 511cb90:	051386fc 	.word	0x051386fc

0511cb94 <__malloc_unlock>:
 511cb94:	4801      	ldr	r0, [pc, #4]	; (511cb9c <__malloc_unlock+0x8>)
 511cb96:	f7fe bf5d 	b.w	511ba54 <__retarget_lock_release_recursive>
 511cb9a:	bf00      	nop
 511cb9c:	051386fc 	.word	0x051386fc

0511cba0 <_realloc_r>:
 511cba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 511cba2:	4607      	mov	r7, r0
 511cba4:	4614      	mov	r4, r2
 511cba6:	460e      	mov	r6, r1
 511cba8:	b921      	cbnz	r1, 511cbb4 <_realloc_r+0x14>
 511cbaa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 511cbae:	4611      	mov	r1, r2
 511cbb0:	f7ff bba2 	b.w	511c2f8 <_malloc_r>
 511cbb4:	b922      	cbnz	r2, 511cbc0 <_realloc_r+0x20>
 511cbb6:	4625      	mov	r5, r4
 511cbb8:	f7ff fb52 	bl	511c260 <_free_r>
 511cbbc:	4628      	mov	r0, r5
 511cbbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 511cbc0:	f000 f83a 	bl	511cc38 <_malloc_usable_size_r>
 511cbc4:	42a0      	cmp	r0, r4
 511cbc6:	d20f      	bcs.n	511cbe8 <_realloc_r+0x48>
 511cbc8:	4621      	mov	r1, r4
 511cbca:	4638      	mov	r0, r7
 511cbcc:	f7ff fb94 	bl	511c2f8 <_malloc_r>
 511cbd0:	4605      	mov	r5, r0
 511cbd2:	2800      	cmp	r0, #0
 511cbd4:	d0f2      	beq.n	511cbbc <_realloc_r+0x1c>
 511cbd6:	4631      	mov	r1, r6
 511cbd8:	4622      	mov	r2, r4
 511cbda:	f7fd f861 	bl	5119ca0 <memcpy>
 511cbde:	4631      	mov	r1, r6
 511cbe0:	4638      	mov	r0, r7
 511cbe2:	f7ff fb3d 	bl	511c260 <_free_r>
 511cbe6:	e7e9      	b.n	511cbbc <_realloc_r+0x1c>
 511cbe8:	4635      	mov	r5, r6
 511cbea:	e7e7      	b.n	511cbbc <_realloc_r+0x1c>

0511cbec <_read_r>:
 511cbec:	b538      	push	{r3, r4, r5, lr}
 511cbee:	4604      	mov	r4, r0
 511cbf0:	4d06      	ldr	r5, [pc, #24]	; (511cc0c <_read_r+0x20>)
 511cbf2:	4608      	mov	r0, r1
 511cbf4:	4611      	mov	r1, r2
 511cbf6:	2200      	movs	r2, #0
 511cbf8:	602a      	str	r2, [r5, #0]
 511cbfa:	461a      	mov	r2, r3
 511cbfc:	f000 f85e 	bl	511ccbc <_read>
 511cc00:	1c43      	adds	r3, r0, #1
 511cc02:	d102      	bne.n	511cc0a <_read_r+0x1e>
 511cc04:	682b      	ldr	r3, [r5, #0]
 511cc06:	b103      	cbz	r3, 511cc0a <_read_r+0x1e>
 511cc08:	6023      	str	r3, [r4, #0]
 511cc0a:	bd38      	pop	{r3, r4, r5, pc}
 511cc0c:	05138708 	.word	0x05138708

0511cc10 <__ascii_wctomb>:
 511cc10:	b149      	cbz	r1, 511cc26 <__ascii_wctomb+0x16>
 511cc12:	2aff      	cmp	r2, #255	; 0xff
 511cc14:	bf95      	itete	ls
 511cc16:	700a      	strbls	r2, [r1, #0]
 511cc18:	238a      	movhi	r3, #138	; 0x8a
 511cc1a:	2001      	movls	r0, #1
 511cc1c:	6003      	strhi	r3, [r0, #0]
 511cc1e:	bf88      	it	hi
 511cc20:	f04f 30ff 	movhi.w	r0, #4294967295	; 0xffffffff
 511cc24:	4770      	bx	lr
 511cc26:	4608      	mov	r0, r1
 511cc28:	4770      	bx	lr

0511cc2a <abort>:
 511cc2a:	2006      	movs	r0, #6
 511cc2c:	b508      	push	{r3, lr}
 511cc2e:	f7ff feab 	bl	511c988 <raise>
 511cc32:	2001      	movs	r0, #1
 511cc34:	f000 f85c 	bl	511ccf0 <_exit>

0511cc38 <_malloc_usable_size_r>:
 511cc38:	f851 3c04 	ldr.w	r3, [r1, #-4]
 511cc3c:	1f18      	subs	r0, r3, #4
 511cc3e:	2b00      	cmp	r3, #0
 511cc40:	bfbc      	itt	lt
 511cc42:	580b      	ldrlt	r3, [r1, r0]
 511cc44:	18c0      	addlt	r0, r0, r3
 511cc46:	4770      	bx	lr

0511cc48 <_close>:
 511cc48:	f248 7308 	movw	r3, #34568	; 0x8708
 511cc4c:	f2c0 5313 	movt	r3, #1299	; 0x513
 511cc50:	2258      	movs	r2, #88	; 0x58
 511cc52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511cc56:	601a      	str	r2, [r3, #0]
 511cc58:	4770      	bx	lr
 511cc5a:	bf00      	nop

0511cc5c <_fstat>:
 511cc5c:	f248 7308 	movw	r3, #34568	; 0x8708
 511cc60:	f2c0 5313 	movt	r3, #1299	; 0x513
 511cc64:	2258      	movs	r2, #88	; 0x58
 511cc66:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511cc6a:	601a      	str	r2, [r3, #0]
 511cc6c:	4770      	bx	lr
 511cc6e:	bf00      	nop

0511cc70 <_getpid>:
 511cc70:	f248 7308 	movw	r3, #34568	; 0x8708
 511cc74:	f2c0 5313 	movt	r3, #1299	; 0x513
 511cc78:	2258      	movs	r2, #88	; 0x58
 511cc7a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511cc7e:	601a      	str	r2, [r3, #0]
 511cc80:	4770      	bx	lr
 511cc82:	bf00      	nop

0511cc84 <_isatty>:
 511cc84:	f248 7308 	movw	r3, #34568	; 0x8708
 511cc88:	f2c0 5313 	movt	r3, #1299	; 0x513
 511cc8c:	2258      	movs	r2, #88	; 0x58
 511cc8e:	2000      	movs	r0, #0
 511cc90:	601a      	str	r2, [r3, #0]
 511cc92:	4770      	bx	lr

0511cc94 <_kill>:
 511cc94:	f248 7308 	movw	r3, #34568	; 0x8708
 511cc98:	f2c0 5313 	movt	r3, #1299	; 0x513
 511cc9c:	2258      	movs	r2, #88	; 0x58
 511cc9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511cca2:	601a      	str	r2, [r3, #0]
 511cca4:	4770      	bx	lr
 511cca6:	bf00      	nop

0511cca8 <_lseek>:
 511cca8:	f248 7308 	movw	r3, #34568	; 0x8708
 511ccac:	f2c0 5313 	movt	r3, #1299	; 0x513
 511ccb0:	2258      	movs	r2, #88	; 0x58
 511ccb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511ccb6:	601a      	str	r2, [r3, #0]
 511ccb8:	4770      	bx	lr
 511ccba:	bf00      	nop

0511ccbc <_read>:
 511ccbc:	f248 7308 	movw	r3, #34568	; 0x8708
 511ccc0:	f2c0 5313 	movt	r3, #1299	; 0x513
 511ccc4:	2258      	movs	r2, #88	; 0x58
 511ccc6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 511ccca:	601a      	str	r2, [r3, #0]
 511cccc:	4770      	bx	lr
 511ccce:	bf00      	nop

0511ccd0 <_sbrk>:
 511ccd0:	f248 720c 	movw	r2, #34572	; 0x870c
 511ccd4:	f2c0 5213 	movt	r2, #1299	; 0x513
 511ccd8:	f248 7110 	movw	r1, #34576	; 0x8710
 511ccdc:	f2c0 5113 	movt	r1, #1299	; 0x513
 511cce0:	6813      	ldr	r3, [r2, #0]
 511cce2:	2b00      	cmp	r3, #0
 511cce4:	bf08      	it	eq
 511cce6:	460b      	moveq	r3, r1
 511cce8:	1819      	adds	r1, r3, r0
 511ccea:	4618      	mov	r0, r3
 511ccec:	6011      	str	r1, [r2, #0]
 511ccee:	4770      	bx	lr

0511ccf0 <_exit>:
 511ccf0:	e7fe      	b.n	511ccf0 <_exit>
 511ccf2:	bf00      	nop
